<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>kudu on hackfox</title>
    <link>https://xsoer.github.io/tags/kudu/</link>
    <description>Recent content in kudu on hackfox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Fri, 12 Jul 2019 10:13:23 +0000</lastBuildDate>
    
	<atom:link href="https://xsoer.github.io/tags/kudu/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kudu简介</title>
      <link>https://xsoer.github.io/posts/2019/07-12-kudu%E7%AE%80%E4%BB%8B/</link>
      <pubDate>Fri, 12 Jul 2019 10:13:23 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2019/07-12-kudu%E7%AE%80%E4%BB%8B/</guid>
      <description>总体概览 设计模式 存储结构 读写流程 impala结合 限制条件 文档资源   0x00、总体概览  1.历史发展  2012年10月由Cloudera公司发起创建,2015年10月对外公布，2015年12月进入apache基金会进行孵化，后续进入快速发展轨道。  2.产品定位  Fast Analytics on Fast Data。 在快速修改的数据上进行快速分析  3.产生之前 在有kudu之前，数据分类为： * 静态数据 * 以HDFS引擎作为存储引擎，适⽤用于⾼吞吐量的离线大数据分析场景 * 这类存储的局限性是数据无法进行行随机的读写 * 动态数据 * 以HBase、Cassandra 作为存储引擎，适⽤用于⼤大数据随机读写场景 * 这类存储的局限性是批量量读取吞吐量量远不不如 HDFS，不不适⽤用于批量量数据分 析的场景
而既要满足随机读写和大数据分析的解决方案如下：
而以上的方案问题是：
 架构复杂  流转涉及环节太多，运维成本很高 每个环节需要保证高可用，需要维护多个副本，存储空间也有一定的浪费 数据在多个系统上，对数据安全策略、监控等都提出了挑战  时效性低  从 HBase 导出成静态文件是周期性  难以应对后续的更新  已经从 HBase 导出到 HDFS，新到的变更数据就难以处理   所以产生了新的解决方案，那就是kudu，其定位如下： 而其gap了hdfs和hbase之间的 4.架构图 kudu的整体架构图如下 5.基本概念 下面了解一些kudu里的一些基本概念。 * Table * 数据存储，没有库的概念 * 有对应的schema结构 * 字段是强类型 * 需要设置主键 * 分隔为N个tablets * Tablet * Table按照行切分后存储的位置 * 一个tablet会多副本到其他server上，并且有一个会是leader * 如果leader失效，会用raft一致性协议重新选举 * 任何一组副本内的tablet都可以读，但是只能从leader写入 * Mater * 持续追踪所有的tablet、tablet server、catalog table、其他的集群meta信息 * 可以部署多个master，但只有一个是active * 如果active时效了，用raft协议在选举出一个 * Master信息也会存储在一个tablet上，并且被复制同步到其他master机器上 * Tablet servers会发送心跳包到master机器(默认是一秒一次) * Tablet Server * 用来存储tablet数据并且向client提供服务 * 一个tablet会在多个tablet server上 * 一个tablet server会有多个tablet * Catelog table * 是kudu元数据的中心，存储了关于table和tablet的信息 * 不允许被直接读写 * table * table schemas, * Locations * states * tablet * Tablet list * Tablet server上有哪些tablet * States * Start and end keys * Raft一致性协议算法 * 分布式服务高可用性进行多副本 * 通过raft来选举出leader * 多副本数据都可以读，但只有leader可以写 * 写入时只有当大多数follower确认成功，才算写入成功 * 在一组副本中(通常是3或5个)，允许有(N-1)/2的失败</description>
    </item>
    
  </channel>
</rss>