<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 3.9.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xsoer.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="建模是数据架构的基础">
<meta name="keywords" content="数据库">
<meta property="og:type" content="article">
<meta property="og:title" content="数据建模">
<meta property="og:url" content="https://xsoer.github.io/posts/storage/数据建模/index.html">
<meta property="og:site_name" content="hackfox">
<meta property="og:description" content="建模是数据架构的基础">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2020-06-13T02:06:31.516Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数据建模">
<meta name="twitter:description" content="建模是数据架构的基础">

<link rel="canonical" href="https://xsoer.github.io/posts/storage/数据建模/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>数据建模 | hackfox</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-114671402-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-duotone-dark.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hackfox</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注 慎思 博学</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-man">

    <a href="/man/" rel="section"><i class="fa fa-server fa-fw"></i>手册</a>

  </li>
        <li class="menu-item menu-item-algorithms">

    <a href="/algorithms/" rel="section"><i class="fa fa-cogs fa-fw"></i>算法</a>

  </li>
        <li class="menu-item menu-item-interview">

    <a href="/interview/" rel="section"><i class="fa fa-code fa-fw"></i>面试</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-gavel fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>书籍</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://xsoer.github.io/posts/storage/数据建模/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="hackfox">
      <meta itemprop="description" content="架构、AI、python、rust">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hackfox">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          数据建模
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-08-12 12:12:23" itemprop="dateCreated datePublished" datetime="2018-08-12T12:12:23+08:00">2018-08-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-06-13 10:06:31" itemprop="dateModified" datetime="2020-06-13T10:06:31+08:00">2020-06-13</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/storage/" itemprop="url" rel="index"><span itemprop="name">storage</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span><br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>22k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>20 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <center>
建模是数据架构的基础
</center>

<a id="more"></a>

<h2 id="0x00、数据模型"><a href="#0x00、数据模型" class="headerlink" title="0x00、数据模型"></a>0x00、数据模型</h2><ul>
<li><p>为什么要建模</p>
<ul>
<li>定义如何存储信息，如何操作信息，以及信息的完整性等约束功能</li>
<li>影响了数据的形态和使用方式</li>
<li>需要满足不同的业务场景需要<ul>
<li>联机事务处理(OLTP):满足业务线需要，频繁的维护更新数据，强一致性</li>
<li>联机分析处理(OLAP):满足决策层需要，更多纬度的视角查询，满足统计决策</li>
</ul>
</li>
</ul>
</li>
<li><p><img data-src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%BD%9C%E7%94%A8.png" alt="数据模型作用"></p>
</li>
<li><p>定义数据如何存储</p>
</li>
<li><p>数据模型是定义数据如何输入和输出的一种模型。其主要作用是为信息系统提供数据的定义和格式。</p>
</li>
<li><p>数据模型是数据库系统的核心和基础，现有的数据库系统都是基于某种数据模型而建立起来的。</p>
</li>
<li><p>三要素</p>
<ul>
<li>数据结构：储存在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。<ul>
<li>比如结构化存储、非结构化存储</li>
<li>关联关系型，KV型</li>
</ul>
</li>
<li>数据操作：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。<ul>
<li>关系操作的select及其join、 group by、order by,insert,update, delete等</li>
<li>关系型数据库：oracle,SQLServer,DB2,Mysql。面向对象化</li>
<li>键值数据库：redis,mongodb,hbase等。存储非结构化，缓存等</li>
<li>时间序列数据库:InfluxDB，confluenceDB，Elasticsearch等。 存储日志类型，便于分析</li>
<li>流式数据库:MQ，Spark，Kafka。存储消息类型，不做永久性存储。发布-订阅型、消息队列、消息中间件</li>
</ul>
</li>
<li>数据完整性约束条件：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。[1]</li>
</ul>
</li>
</ul>
<h2 id="0x01、数据建模"><a href="#0x01、数据建模" class="headerlink" title="0x01、数据建模"></a>0x01、数据建模</h2><ul>
<li>建模过程中的主要活动包括：<ul>
<li>确定数据及其相关过程（如实地销售人员需要查看在线产品目录并提交新客户订单）。</li>
<li>定义数据（如数据类型、大小和默认值）。</li>
<li>确保数据的完整性（使用业务规则和验证检查）。</li>
<li>定义操作过程（如安全检查和备份）。</li>
<li>选择数据存储技术（如关系、分层或索引存储技术）。</li>
</ul>
</li>
<li>数据建模大致分为三个阶段，概念建模阶段，逻辑建模阶段和物理建模阶段。其中概念建模和逻辑建模阶段与数据库厂商毫无关系，换言之，与MySQL，SQL Server，Oracle没有关系。物理建模阶段和数据库厂商存在很大的联系，因为不同厂商对同一功能的支持方式不同，如高可用性，读写分离，甚至是索引，分区等。</li>
</ul>
<h2 id="0x02、数据存储历史"><a href="#0x02、数据存储历史" class="headerlink" title="0x02、数据存储历史"></a>0x02、数据存储历史</h2><ul>
<li>无库时代 ：没有专门的数据库，数据大多以文件形式存放</li>
<li>层次状数据库 ：使用层次状模型进行数据库设计和存放</li>
<li>网状数据库 ：使用网状模型进行数据库设计和存放</li>
<li>关系型数据库 ：使用关系型模型进行数据库设计和存放</li>
<li>非关系型数据库：为适应水平扩展性和处理超大量的数据环境，近几年发展非常迅速的发展，衍生类型非常多。</li>
<li>数据集市</li>
<li>数据仓库</li>
</ul>
<h2 id="0x03、层次模型"><a href="#0x03、层次模型" class="headerlink" title="0x03、层次模型"></a>0x03、层次模型</h2><ul>
<li><img data-src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.jpg" alt="层次数据模型"></li>
<li>一种用树形结构描述实体及其之间关系的数据模型。在这种结构中，每一个记录类型都是用节点表示，记录类型之间的联系则用结点之间的有向线段来表示。每一个双亲结点可以有多个子节点但是每一个子节点只能有一个双亲结点。这种结构决定了采用层次模型作为数系组织方式的层次数据库系统只能处理一对多的实体联系。</li>
<li>层次模型是最早用于商品数据库管理系统的数据模型。</li>
<li>层次数据模型中最基本的数据关系是基本层次关系，它代表两个记录型之间一对多的关系，也叫做双亲子女关系（PCR）。</li>
<li>举例<ul>
<li><img data-src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.gif" alt="层次结构举例"></li>
<li>一个教师学生层次模型。该层次模型有4个记录类型，即实体。分别是：<ul>
<li>（1）记录型（实体）系是根结点，由系编号、系名、地点3个属性（字段）组成。它有两个子结点，分别是教研室实体和学生实体。</li>
<li>（2）记录型（实体）教研室是系的子结点，同时又是教师实体的双亲结点。它由教研室编号和教研室名两个属性（字段）组成。</li>
<li>（3）记录型（实体）学生由学号、姓名、成绩3个属性（字段）组成。</li>
<li>（4）记录型（实体）教师由教师号、姓名、研究方向3个属性（字段）组成。学生与教师是叶子结点，他们没有子结点。由系到教研室、教研室到教师、系到学生都是一对多的联系。</li>
</ul>
</li>
</ul>
</li>
<li>特征。在一个层次模型中的限制条件是：<ul>
<li>（1）有且仅有一个节点，无父节点，它为树的根；（有且仅有一个结点没有双亲，该节点就是根结点。）</li>
<li>（2）其他节点有且仅有一个父节点。（根以外的其他结点有且仅有一个双亲结点 ）这就使得层次数据库系统只能直接处理一对多的实体关系。</li>
<li>（3）任何一个给定的记录值只有按照其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离双亲记录值而独立存在。</li>
<li>因而层次模型只能表示“1一M”关系，而不能直接表示“M—M”关系。在层次模型中，一个结点称为一个记录型，用来描述实体集。每个记录型可以有一个或多个记录值，上层一个记录值对应下层一个或多个记录值，而下层每个记录值只能对应上层一个记录值。例如，系记录型有：计算机系、电信系等记录值。而计算机系的下层记录值有软件、结构、应用等研究室和数据结构、操作系统、数据库等课程，软件研究室下层又有员工和项目记录值，如图所示:</li>
<li><img data-src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E8%AE%B0%E5%BD%95%E5%80%BC%E7%A4%BA%E4%BE%8B.gif" alt="层次模型记录值示例"></li>
<li>关于层次模型中实体集之间多对多的联系的处理，解决的方法是引入冗余结点。例如，学生和课程之间的多对多的联系，引入学生和课程的冗余结点，转换为两棵树：一棵树的根是学生，子结点是课程，它表现了一个学生可以选多门课程；一棵树的根是课程，子结点是学生，它反映了一门课程可以被多个学生选。至于冗余结点可以用虚拟结点实现：在冗余结点处仅存放一个指针，指向实际结点。</li>
</ul>
</li>
<li>数据完整性约束。层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。具体如下：<ul>
<li>（1）进行插入数据时，如果没有相应的双亲结点值就不能插入它的子结点值。例如，在上图层次数据库中，如果新调入一名教师，但尚未分配到某个教研室，这时就不能将新的教师插入到数据库中。</li>
<li>（2）进行删除数据时，如果删除双亲结点值，则相应的子结点值也被同时删除。例如，在上图中的层次数据库中，如果删除网络教研室，则该教研室的所有教师的数据将全部丢失。</li>
<li>（3）进行修改数据时，进行更新操作时，应更新所有相应记录，以保证数据的一致性。 [2]</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点:<ul>
<li>层次模型的数据结构比较简单，只需要几条命令就能操纵数据库，比较容易使用。</li>
<li>结构清晰，结点间联系简单，只要知道每个结点的双亲结点，就可以知道整个模型结构。现实世界中许多实体间联系本来就是呈现出一种很自然的层次关系，如表示行政层次，家族关系很关系</li>
</ul>
</li>
<li>缺点:<ul>
<li>（1）现实世界中很多联系是非层次性的，如多对多联系、一个结点具有多个双亲等。层次模型表示这类联系的方法很不灵活，不能直接表示两个以上的实体型间的的复杂的联系和实体型间的多对多联系。只能通过引入冗余数据或建非自然的数据组织如创建虚拟节点的方法来解决，易产生不一致性。</li>
<li>（2）对数据的插入和删除的操作限制太多。</li>
<li>（3）查询子女结点必须通过双亲结点，因为层次模型对任一结点的所有子树都规定了先后次序，这一限制隐含了对数据库存取路径的控制。树中父子结点之间只存在一种联系，因此，对树中的任一结点，只有一条自根结点到达它的路径。</li>
<li>（4）树结点中任何记录的属性只能是不可再分的简单数据类型。</li>
<li>（5）由于结构严密，层次命令趋于程序化。</li>
</ul>
</li>
</ul>
</li>
<li>层次模型的物理存储有两种实现方法：<ul>
<li>顺序法：按照层次顺序把所有的记录邻接存放，即通过物理空间的位置相邻来实现层次顺序。</li>
<li>指针法：各个记录存放时不是按层次顺序，而是用指针按层次顺序把它们链接起来。</li>
</ul>
</li>
<li>1969由IBM公司的IMS（Information Management System），这是IBM公司研制的最早的大型数据库系统程序产品</li>
</ul>
<h2 id="0x04、网状模型"><a href="#0x04、网状模型" class="headerlink" title="0x04、网状模型"></a>0x04、网状模型</h2><ul>
<li>定义<ul>
<li>用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型（Network Model）。</li>
<li>网状模型取消了层次模型的不能表示非树状结构的限制，两个或两个以上的结点都可以有多个双亲结点，则此时有向树变成了有向图，该有向图描述了网状模型。</li>
</ul>
</li>
<li>特征。网状模型的数据结构主要有以下两个特征:<ul>
<li>(1)允许有一个以上的节点无双亲。</li>
<li>(2)至少有一个节点可以有多于一个的双亲。</li>
<li>网状模型中每个结点表示一个记录型（实体），每个记录型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）间的父子关系。</li>
</ul>
</li>
<li>示例<ul>
<li><img data-src="/assets/images/2018/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.png" alt="网状模型示例"></li>
<li>课程（实体）的父节点由专业、教研室、学生。以课程和学生之间的关系来说，他们是一种m:n的关系，也就是说一个学生能够选修多门课程，一门课程也可以被多个学生同时选修。</li>
</ul>
</li>
<li>网状与层级数据库的区别<ul>
<li>层次模型中子结点与双亲结点的联系是唯一的，在网状模型中这种联系可以不唯一。</li>
<li>层次模型可以看作网状模型的特例</li>
<li>因此，在网状模型中要为每个联系命名，并指出与该联系有关的双亲记录和子记录。</li>
</ul>
</li>
<li>数据操作与完整性约束<ul>
<li>网状模型的数据操作主要包括查询、插入、删除和更新。具体如下：<ul>
<li>(1)进行插入操作时，允许插入尚未确定双亲结点值的子结点值。如可增加一名尚未分配到某个教研室的新老师，也可增加一些刚来报到还未分配宿舍的学生。</li>
<li>(2)进行删除操作时，只允许删除双亲结点值。如可删除一个教研室，而该科研室所有教师的信息仍保留在数据库中。</li>
<li>(3)修改数据时，可直接表示非树状结构，而无须像层次模型那样增加冗余结点，因此修改操作时只需要指定更新记录即可。</li>
</ul>
</li>
<li>进行更新操作时只需更新指定记录即可。因此，一般来说，网状模型没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统(如DBTG)对数据操作都加了一些限制，提供了一定的完整性约束。 [3]</li>
<li>DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句，主要有：<ul>
<li>(1)支持记录码的概念，码是唯一标识记录的数据项的集合。</li>
<li>(2)保证一个联系中双亲记录和子记录之间是一对多的联系。</li>
<li>(3)可以支持双亲记录和子记录之间某些约束条件。如有些子记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。</li>
</ul>
</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点<ul>
<li>能够更为直接地描述现实客观世界。可表示实体间的多种复杂联系。</li>
<li>修改网状数据模型时，没有层次状数据模型的那么多的严格限制，可以删除一个节点的父节点而依旧保留该节点；也允许插入一个没有任何父节点的节点，这样的插入在层次状数据模型中是不被允许的，除非是首先插入的是根节点；</li>
<li>实体之间的关系在底层中可以借由指针指针实现。具有良好的性能，存取效率较高。</li>
</ul>
</li>
<li>缺点<ul>
<li>结构比较复杂，其数据定义语言(DDL)、数据操作语言(DML)复杂，用户不容易使用。而且应用环境越大，数据库的结构就变得越复杂，不利于最终用户掌握。</li>
<li>数据独立性差，由于实体间的联系本质上是通过存取路径表示的，因此应用程序在访问数据时要指定存取路径。</li>
<li>网状数据模型数据之间的彼此关联比较大，该模型其实一种导航式的数据模型结构，不仅要说明要对数据做些什么，还说明操作的记录的路径；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x05、关系模型"><a href="#0x05、关系模型" class="headerlink" title="0x05、关系模型"></a>0x05、关系模型</h2><ul>
<li>网状数据库和层次数据库已经很好地解决了数据的集中和共享问题</li>
<li>但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。</li>
<li>1970年，IBM的研究员E.F.Codd博士发表《大型共享数据银行的关系模型》一文提出了关系模型的概念，论述了范式理论和衡量关系系统的12条标准，如定义了某些关系代数运算，研究了数据的函数相关，定义了关系的第三范式，从而开创了数据库的关系方法和数据规范化理论的研究，他为此获得了1981年的图灵奖。</li>
<li>关系模型有严格的数学基础，抽象级别比较高，而且简单清晰，便于理解和使用。但是当时也有人认为关系模型是理想化的数据模型，用来实现DBMS是不现实的，尤其担心关系数据库的性能难以接受，更有人视其为当时正在进行中的网状数据库规范化工作的严重威胁。</li>
</ul>
<h2 id="0x06、面向对象模型"><a href="#0x06、面向对象模型" class="headerlink" title="0x06、面向对象模型"></a>0x06、面向对象模型</h2><ul>
<li>电脑辅助设计</li>
<li>嵌套记录、多值属性、继承</li>
</ul>
<blockquote>
<p>实体-关系模型(ER模型)</p>
</blockquote>
<ul>
<li>实体集、关系集、属性</li>
<li>ER图</li>
<li>原子域和第一范式：name:first_name,last_name;address:address1,address2,address3</li>
<li>约束：唯一性约束、外键约束</li>
</ul>
<h2 id="0x07、数据仓库与操作型数据库的区别"><a href="#0x07、数据仓库与操作型数据库的区别" class="headerlink" title="0x07、数据仓库与操作型数据库的区别"></a>0x07、数据仓库与操作型数据库的区别</h2><ul>
<li>操作型数据库主要是用来支撑即时操作，对数据库的性能和质量要求都比较高。通常设计操作型数据库的都要遵循几个范式的约束，除非少数情况下为了性能进行妥协，才可能出现冗余</li>
<li>数据仓库的数据是来源于即时操作产生的数据，而不是直接来源于即时操作，所以它的数据质量是由操作型系统来保证的，而不是由几个范式来保证的。而且为了更好的跟踪历史信息，以及更快的产生报表，数据仓库的物理模型中存在着大量冗余字段</li>
</ul>
<h2 id="0x08、数据仓库简介"><a href="#0x08、数据仓库简介" class="headerlink" title="0x08、数据仓库简介"></a>0x08、数据仓库简介</h2><ul>
<li>数据模型是抽象描述现实世界的一种工具和方法，是通过抽象的实体及实体之间联系的形式，来表示现实世界中事务的相互关系的一种映射</li>
<li>数据模型表现的抽象的是实体和实体之间的关系，通过对实体和实体之间关系的定义和描述，来表达实际的业务中具体的业务关系。</li>
<li>数据库与数据仓库区别<ul>
<li>数据库：<ul>
<li>传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</li>
<li>涉及到增删改查，都是小数据量的操作</li>
<li>业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。</li>
<li>业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>
<li>业务性数据库</li>
<li>是3NF设计</li>
<li>比较流行的有：MySQL, Oracle, SqlServer</li>
</ul>
</li>
<li>数据仓库<ul>
<li>数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</li>
<li>数据结构为了分析和查询的便利；查询为主，分析的基数很大</li>
<li>只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</li>
<li>分析性数据库</li>
<li>星行设计</li>
<li>比较流行的有：AWS Redshift, Greenplum, Hive</li>
</ul>
</li>
</ul>
</li>
<li>数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的 ETL 工作</li>
</ul>
<p><img data-src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B.jpg" alt="数据仓库模型"></p>
<ul>
<li>数据仓库模型<ul>
<li>业务建模，生成业务模型，主要解决业务层面的分解和程序化。</li>
<li>领域建模，生成领域模型，主要是对业务模型进行抽象处理，生成领域概念模型。</li>
<li>逻辑建模，生成逻辑模型，主要是将领域模型的概念实体以及实体之间的关系进行数据库层次的逻辑化。</li>
<li>物理建模，生成物理模型，主要解决，逻辑模型针对不同关系型数据库的物理化以及性能等一些具体的技术问题</li>
</ul>
</li>
<li>在整个数据仓库的模型的设计和架构中，既涉及到业务知识，也涉及到了具体的技术，我们既需要了解丰富的行业经验，同时，也需要一定的信息技术来帮助我们实现我们的数据模型，最重要的是，我们还需要一个非常适用的方法论，来指导我们自己针对我们的业务进行抽象，处理，生成各个阶段的模型</li>
</ul>
<p><img data-src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.jpg" alt="数据仓库架构"></p>
<ul>
<li>从上图我们可以看出，整个数据仓库的数据模型可以分为大概 5 大部分：<ul>
<li>系统记录域（System of Record）：这部分是主要的数据仓库业务数据存储区，数据模型在这里保证了数据的一致性。</li>
<li>内部管理域（Housekeeping）：这部分主要存储数据仓库用于内部管理的元数据，数据模型在这里能够帮助进行统一的元数据的管理。</li>
<li>汇总域（Summary of Area）：这部分数据来自于系统记录域的汇总，数据模型在这里保证了分析域的主题分析的性能，满足了部分的报表查询。</li>
<li>分析域（Analysis Area）：这部分数据模型主要用于各个业务部分的具体的主题业务分析。这部分数据模型可以单独存储在相应的数据集市中。</li>
<li>反馈域（Feedback Area）：可选项，这部分数据模型主要用于相应前端的反馈数据，数据仓库可以视业务的需要设置这一区域。</li>
</ul>
</li>
<li>通过对整个数据仓库模型的数据区域的划分，我们可以了解到，一个好的数据模型，不仅仅是对业务进行抽象划分，而且对实现技术也进行具体的指导，它应该涵盖了从业务到实现技术的各个部分。</li>
</ul>
<h2 id="0x09、ETL"><a href="#0x09、ETL" class="headerlink" title="0x09、ETL"></a>0x09、ETL</h2><ul>
<li>ETL，是英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过抽取（extract）、交互转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。</li>
<li>ETL的质量问题具体表现为正确性、完整性、一致性、完备性、有效性、时效性和可获取性等几个特性</li>
<li>实现ETL，首先要实现ETL转换的过程。体现为以下几个方面：<ul>
<li>1、空值处理：可捕获字段空值，进行加载或替换为其他含义数据，并可根据字段空值实现分流加载到不同目标库。</li>
<li>2、规范化数据格式：可实现字段格式约束定义，对于数据源中时间、数值、字符等数据，可自定义加载格式。</li>
<li>3、拆分数据：依据业务需求对字段可进行分解。例，主叫号 861082585313-8148，可进行区域码和电话号码分解。</li>
<li>4、验证数据正确性：可利用Lookup及拆分功能进行数据验证。例如，主叫号861082585313-8148，进行区域码和电话号码分解后，可利用Lookup返回主叫网关或交换机记载的主叫地区，进行数据验证。</li>
<li>5、数据替换：对于因业务因素，可实现无效数据、缺失数据的替换。</li>
<li>6、Lookup：查获丢失数据 Lookup实现子查询，并返回用其他手段获取的缺失字段，保证字段完整性。</li>
<li>7、建立ETL过程的主外键约束：对无依赖性的非法数据，可替换或导出到错误数据文件中，保证主键唯一记录的加载。</li>
</ul>
</li>
</ul>
<h2 id="0x10、仓库建模阶段解析"><a href="#0x10、仓库建模阶段解析" class="headerlink" title="0x10、仓库建模阶段解析"></a>0x10、仓库建模阶段解析</h2><ul>
<li>业务建模：<ul>
<li>划分整个单位的业务，一般按照业务部门的划分，进行各个部分之间业务工作的界定，理清各业务部门之间的关系。</li>
<li>深入了解各个业务部门的内具体业务流程并将其程序化。</li>
<li>提出修改和改进业务部门工作流程的方法并程序化。</li>
<li>数据建模的范围界定，整个数据仓库项目的目标和阶段划分。</li>
</ul>
</li>
<li>领域概念建模<ul>
<li>抽取关键业务概念，并将之抽象化。</li>
<li>将业务概念分组，按照业务主线聚合类似的分组概念。</li>
<li>细化分组概念，理清分组概念内的业务流程并抽象化。</li>
<li>理清分组概念之间的关联，形成完整的领域概念模型。</li>
</ul>
</li>
<li>逻辑建模：<ul>
<li>业务概念实体化，并考虑其具体的属性</li>
<li>事件实体化，并考虑其属性内容</li>
<li>说明实体化，并考虑其属性内容</li>
</ul>
</li>
<li>物理建模：<ul>
<li>针对特定物理化平台，做出相应的技术调整</li>
<li>针对模型的性能考虑，对特定平台作出相应的调整</li>
<li>针对管理的需要，结合特定的平台，做出相应的调整</li>
<li>生成最后的执行脚本，并完善之。</li>
</ul>
</li>
</ul>
<h2 id="0x11、数据仓库建模方法"><a href="#0x11、数据仓库建模方法" class="headerlink" title="0x11、数据仓库建模方法"></a>0x11、数据仓库建模方法</h2><ul>
<li><p>数据仓库得建模方法同样也有很多种，每一种建模方法其实代表了哲学上的一个观点，代表了一种归纳，概括世界的一种方法</p>
</li>
<li><p>主要介绍:实体模型(范式模型、ER模型)，维度建模法，Data Vault模型，Anchor模型</p>
</li>
<li><p>1.实体关系(ER)模型: 范式建模法（Third Normal Form，3NF）</p>
<ul>
<li><img data-src="/assets/images/2018/%E6%A0%B7%E4%BE%8BER%E5%9B%BE.png" alt="样例ER图"></li>
<li>范式模型由数据仓库之父 Inmon 提倡</li>
<li>实体联系模型、实体关系模型或实体联系模式图</li>
<li>范式是数据库逻辑模型设计的基本理论，一个关系模型可以从第一范式到第五范式进行无损分解，这个过程也可称为规范化。在数据仓库的模型设计中目前一般采用第三范式，它有着严格的数学定义</li>
<li>实体类型可以分为强实体类型（Strong）和弱实体类型（Weak）两种。强实体类型又可称为独立型实体类型（Indepent），是指其每一个实体实例都能自己识别，而不需要依赖其他实体类型的实例的实体类型。弱实体类型也可称为依赖型实体类型（Depend），是指其每一个实体实例必须依赖其他实体类型的某个实例才能识别的实体类型。</li>
<li>第三范式<ul>
<li>每个属性值唯一，不具有多义性 ;</li>
<li>每个非主属性必须完全依赖于整个主键，而非主键的一部分 ;</li>
<li>每个非主属性不能依赖于其他关系中的属性，因为这样的话，这种属性应该归到其他关系中去。</li>
</ul>
</li>
<li>特点<ul>
<li>需要全面了解企业业务和数据。</li>
<li>实施周期非常长。</li>
<li>对建模人员的能力要求非常高。</li>
</ul>
</li>
<li>优点<ul>
<li>用E-R图表示的概念模型独立于具体的DBMS所支持的数据模型，它是各种数据模型的共同基础，因而比数据模型更一般、更抽象、更接近现实世界。</li>
</ul>
</li>
<li>缺点<ul>
<li>在E-R建模中，数据和应用相分离，E-R图仅仅着眼于数据，不能给我们提供更多关于业务流程的信息</li>
<li>表达方式比较弱，抽象能力比较低</li>
</ul>
</li>
</ul>
</li>
<li><p>2.维度建模法</p>
<ul>
<li><img data-src="/assets/images/2018/%E7%BA%AC%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%B3%95.jpg" alt="维度建模法"></li>
<li>数据仓库领域另一位大师 Ralph Kimball</li>
<li>其最简单的描述就是，按照事实表，维表来构建数据仓库，数据集市。</li>
<li>维度建模(dimensional modeling)是专门用于分析型数据库、数据仓库、数据集市建模的方法</li>
<li>维度模型是将关系模型的层次结构展开平铺而成。</li>
<li>这种方法的最被人广泛知晓的名字就是星型模式（Star-schema），雪花建模，星座建模</li>
<li>优点<ul>
<li>星型模式之所以广泛被使用，在于针对各个维作了大量的预处理，如按照维进行预先的统计、分类、排序等。通过这些预处理，能够极大的提升数据仓库的处理能力。特别是针对 3NF 的建模方法，星型模式在性能上占据明显的优势。</li>
<li>维度建模非常直观，紧紧围绕着业务模型，可以直观的反映出业务模型中的业务问题。不需要经过特别的抽象处理，即可以完成维度建模。这一点也是维度建模的优势。</li>
</ul>
</li>
<li>缺点<ul>
<li>缺点也是非常明显的，由于在构建星型模式之前需要进行大量的数据预处理，因此会导致大量的数据处理工作。而且，当业务发生变化，需要重新进行维度的定义时，往往需要重新进行维度数据的预处理。而在这些与处理过程中，往往会导致大量的数据冗余。</li>
<li>如果只是依靠单纯的维度建模，不能保证数据来源的一致性和准确性，而且在数据仓库的底层，不是特别适用于维度建模的方法</li>
</ul>
</li>
<li>维度建模的领域主要适用与数据集市层，它的最大的作用其实是为了解决数据仓库建模中的性能问题。维度建模很难能够提供一个完整地描述真实业务实体之间的复杂关系的抽象方法。</li>
</ul>
</li>
<li><p>3.Data Valut</p>
<ul>
<li>Data Vault是面向细节的，可追踪历史的，它是一组有连接关系的规范化的表的集合。这些表可以支持一个或多个业务功能，它是一种综合了第三范式（3NF）和星型模型优点的建模方法。其设计理念是要满足企业对灵活性、可扩展性、一致性和对需求的适应性要求，它是一种专为企业级数据仓库量身定制的建模方式。</li>
<li>可以看出Data Vault既是一种数据建模的方法论，又是构建企业数据仓库的一种具体方法。</li>
<li>Data Vault模型由三个模块组成，中心表、链接表、附属表。</li>
<li>建模方法论里定义了Data Vault的组成部分和组成部分之间的交互方式。Data Vault的建模方法中还包括了最佳实践，来指导构建企业数据仓库。例如，业务规则应该在数据的下游实现，就是说Data Vault只按照业务数据的原样保存数据，不做任何解释、过滤、清洗、转换。即使从不同数据源来的数据是自行矛盾的（例如同一个客户有不同的地址），Data Vault模型不会遵照任何业务的规则，如“系统A的地址为准”。Data Vault模型会保存两个不同版本的数据，对数据的解释将推迟到整个架构的后一个阶段（数据集市）。</li>
<li>中心表：中心表主要是存储一些日常用的一些业务关键码，比如客户号，发票号，流水号等等。它包括三个要素：<ul>
<li>代理键：这就是一些操作性的组件，包括客户号，发票号等等</li>
<li>装载时间戳：这里可以理解为ETL进行日加载的时间。</li>
<li>数据源：就是可以追索到的原系统，比如，CRM，ERP等</li>
</ul>
</li>
<li>链接表：是3NF的多对多关系的物理表现形式，它表现的是多个业务键之间的关系。它和范式模型的最大区别是将关系作为一个独立单元抽象出来，可以提升模型的扩展性。它主要包含以下特征:<ul>
<li>代理键</li>
<li>代理键间的映射关系</li>
<li>装载时间戳：这里可以理解为ETL进行日加载的时间。</li>
<li>数据源：就是可以追索到的原系统，比如，CRM，ERP等</li>
</ul>
</li>
<li>卫星表：<ul>
<li>业务领域中的其余信息可能随着时间而变化，所以卫星表必须有能力存储新的或者变化的各种粒度的数据，他们将被存储在卫星表内。卫星表是中心表的详细描述内容，一个中心表会有多个卫星表。它由中心表的代理键、装载时间、来源类型、详细的中心表描述信息等组成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x12、范式模型-ER模型、实体模型"><a href="#0x12、范式模型-ER模型、实体模型" class="headerlink" title="0x12、范式模型(ER模型、实体模型)"></a>0x12、范式模型(ER模型、实体模型)</h2><p>-</p>
<h2 id="0x13、维度建模"><a href="#0x13、维度建模" class="headerlink" title="0x13、维度建模"></a>0x13、维度建模</h2><ul>
<li><p>数据仓库领域另一位大师 Ralph Kimball提出</p>
</li>
<li><p>维度建模以分析决策的需求出发构建模型。重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。</p>
</li>
<li><p>并不要求维度模型必须满足第3范式。</p>
</li>
<li><p>维度模型的部件是从需求定义的信息包中演化而来。</p>
</li>
<li><p>事实表包含了商业指标;维表包含了商业维度。每个维表中的层次结构用于下钻到更低级别的数据。</p>
</li>
<li><p>星形模式的优势包括:用户易于理解;优化浏览;提高查询处理速度;可以使用特别的提高性能的模式。</p>
</li>
<li><p>由事实表、纬度表、聚合表</p>
<ul>
<li>事实表：发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，反之亦然。比如投资事件、媒体报道等</li>
<li>纬度表：每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，当然，维度表行的描述环境应与事实表行完全对应。 维度表通常比较宽，是扁平型非规范表，包含大量的低粒度的文本属性。比如：公司、机构、基金、GP、个人等</li>
<li>聚合表：数据是按照最详细的格式存储在事实表中，各种报表可以充分利用这些数据。一般的查询语句在查询事实表时，一次操作经常涉及成千上万条记录，但是通过使用汇总、平均、极值等聚合技术可以大大降低数据的查询数量。因此，来自事实表中的底层数据应该事先经过聚合存储在中间表中。中间表存储了聚合信息，所以被称为聚合表，这种处理过程被称为聚合过程。</li>
</ul>
</li>
<li><p>事实表</p>
<ul>
<li>连接的事实表键。数据颗粒。完全的加和的指标。半加和的指标。大量的记录。只有一些属性。稀疏的数据。退化的维度。</li>
<li>连接的事实表主键。 事实表中的一行记录与所有维表中的相应记录相关。在这个事实表例子中，你可以发现订单的数量作为一个属性。假如维表是产品，时间，客户，以及销售代表。对这些维表，假 设维的层次结构中最低的层次分别是单独的产品，日历中的一天，一个特定的客户，以及一 个单独的销售代表。那么事实表中的一行就必须与特种特定的产品，一个特定的日期，一个 特定的客户，以及一个单独的销售代表相关。这意味着事实表中的记录必须可以由四个维表中的主键所唯一确定。由此，事实表中的主键必须是所有维表主键连接起来的组合键。</li>
<li>数据颗粒。 这是事实表的一个重要的特征。正如我们所知道的，数据粒度是指标的细节程度。在这个例子中，指标是在最细节的层次的。订单数量与以下的特征相关:一个单独的订单中某种 特定产品的数量，某个特定的日期，一个特定的客户，以及一位特定的销售代表。如果我们 只保留每个月中某种特定产品的销售量，那么数据颗粒就会与现在不同，而处在一个更高的 级别。</li>
<li>完全加和指标。让我们看看这些属性:order_dollars, extended_cost, quantiti_ordered。每一个都与一个特定的产品，一个特定的日期，一位特定的客户以及一位特定的销售代表相关。在一个查询当 中，我们假设用户希望得到某一个特定日期中某个州的客户对一个特定产品的订单总和。注 意，不是一个特定的客户，而是一个特定州中的所有客户。然后，我们需要找到事实表中所 有与这个州相关的所有客户，将 order_dollars, extended_cost, quantiti_ordered 这三个字段的 数值加和。这些属性的数值可以简单的汇总。这样的指标称为完全加和指标。完全加和指标 可以通过简单的加法进行汇总。当我们运行汇总事实表中指标的查询时，我们将不得不确认 这些指标是完全加和的。否则，将可能的不到正确的汇总数据。</li>
<li>半加和的指标。考虑事实表中的 margin_dollars 属性。举例来说，如果 order_dollars 时 120，extended_cost时 100，那么 margin_percentage 就是 20。这是通过计算 order_dollars 和 extended_cost 之后 得到的指标。如果你汇总事实表中某个州中所有客户的数值，你不能够将这些记录中的 margin_percentages 加起来就得到汇总数据。类似于 margin_percentage 这种衍生指标是非加 和的。它们称为半加和的指标。在执行汇总查询的时候，应当将半加和的指标和完全加和指 标区分开来。</li>
<li>表很长，但是不宽。通常一个事实表的属性要比一个维表少。一般来说只有 10 个甚至更少的属性。但是比较之下，事实表中的记录的数量是相当巨大的。我们举一个简单的例子，如果维表中有 3 种产品，5 个客户，30 天，10 个销售代表。那么，在这么少的维表记录数量下，事实表中 的记录数量将会有 4500 条。相对于维表的记录数量来说，这个数字是相当大的。如果你将 事实表展开成 2 位的表格，你会发现，维表只有很少的几列，但是有相当多的记录。</li>
<li>稀疏的数据。 我们讨论过事实表中的每一行都与一个特定的产品，一个特定的日期，一位特定的客户以及一个独立的销售代表相关。换句话说，对一个特定的产品，一个特定的日期，一位特定 的客户以及一个独立的销售代表，事实表中都由一个相应的记录。如果在一个临近假日的日 子里没有接到订单或者没有订单被处理，哪会发生什么呢?在这种日子中，事实表不会有相 关的记录。而且，其它维表也可能会导致事实表中出现空的指标值。那么，我们是否需要将 这些空的指标值放在事实表中呢?没有必要。因此，很重的一点就是要意识到这一类的稀疏 数据，并理解事实表中可能会存在数据隔断。</li>
<li>退化的维度。仔细的观察例子中的事实表。你会发现有 order_number 和 order_line 属性。这些属性不是指标，也不是事实。那么为什么这些属性会在事实表中呢?当你从操作形系统中获取维表 以及事实表的属性时，你会发现操作型系统中某些数据元素既不是事实也不是严格的维属 性。例如，这些属性是参考数字，例如订单数量，发票金额，订单流水号，等等。这些属性 在某些类型的分析中是有用的。例如，你可能在寻找每个订单中某种产品的平均数量。然后 你就需要将产品与订单中的数量联系起来，计算平均值。诸如例子中 order_number 和 order_line 的属性称为退化的维度，它们依然作为属性保留在事实表中。</li>
<li>不允许有空文本</li>
<li>用来存储事实的度量（measure）及指向各个维的外键值。</li>
<li>事实数据表的主要特点是包含数字数据（事实），并且这些数字信息可以汇总，以提供有关单位作为历史的数据，每个事实数据表包含一个由多个部分组成的索引，该索引包含作为外键的相关性纬度表的主键，而维度表包含事实记录的特性。</li>
<li>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与纬度表中对应项的相关索引字段之外的任何数据。</li>
<li>包含在事实数据表中的“度量值”有两种：一种是可以累计的度量值，另一种是非累计的度量值</li>
<li>最有用的度量值是可累计的度量值，其累计起来的数字是非常有意义的。用户可以通过累计度量值获得汇总信息，例如可以汇总具体时间段内一组商店的特定商品的销售情况。非累计的度量值也可以用于事实数据表，单汇总结果一般是没有意义的，例如，在一座大厦的不同位置测量温度时，如果将大厦中所有不同位置的温度累加是没有意义的，但是求平均值是有意义的。</li>
<li>一般来说，一个事实数据表都要和一个或多个纬度表相关联，用户在利用事实数据表创建多维数据集时，可以使用一个或多个维度表</li>
</ul>
</li>
<li><p>纬度表</p>
<ul>
<li>维表用来保存该维的元数据，即维的描述信息，包括维的层次及成员类别等</li>
<li>维度表可以看作是用户来分析数据的窗口，纬度表中包含事实数据表中事实记录的特性，有些特性提供描述性信息，有些特性指定如何汇总事实数据表数据，以便为分析者提供有用的信息，维度表包含帮助汇总数据的特性的层次结构。例如，包含产品信息的维度表通常包含将产品分为食品、饮料、非消费品等若干类的层次结构，这些产品中的每一类进一步多次细分，直到各产品达到最低级别。</li>
<li>大数值的数字属性 文本属性 非直接相关属性 非规范化的， 具有上钻/下钻的能力 多级层次结构 相对少的记录</li>
<li>在维度表中，每个表都包含独立于其他维度表的事实特性，例如，客户维度表包含有关客户的数据。维度表中的列字段可以将信息分为不同层次的结构级。</li>
<li>维表键。维表的主键，可以维一的确定每一条记录</li>
<li>维表很宽。一般来说，一个维表会有相当多的属性/字段。有一些维表有 50 个以上的属性并 非是不寻常的。所以，我们说维表很宽。如果你将表格的列排列一下，维表将会水平展开。</li>
<li>非直接相关属性。维表中的某一些属性经常不会与其中的其它属性直接相关。例如，包裹的 大小与商品的品牌不是直接相关的;然而，包裹的大小与产品的品牌可能都是产品维度的属 性。</li>
<li>非规范化。维表是扁平的，而不是规范化的</li>
<li>文本属性。在维表中，很难找到任何用于计算的数值数据。维表中的属性一般是文本格式的。 这些属性表示商业维度中的部件的文本描述。用户可以采用这些描述构造它们的查询</li>
<li>上钻/下钻。维表中的属性提供了获取从高层次的汇总信息到低层次细节信息的能力。例如， 一个层次结构中有三个属性，邮政编码，城市，以及州。你可以得到按州为单位销售总量， 然后从下钻到以城市为单位的，以及以邮政编码为单位的销售总量。另一方面，你可以首先 得到以邮政编码为单位的销售总量，然后上钻到城市，以及州。</li>
<li>多级层次结构。以客户维举例，该维表存在一个包括客户所在邮政编码号，城市以及州的单 一的层次结构。但是，维表通常会有多级的层次结构，从而使钻取可以沿着这些层次结构中 的任何一个进行。以商店的产品维表为例。在这种情况下，市场营销部门可能自己制定将产 品分类到不同的产品目录以及产品部门的方法。另一方面，会计部门也许会用另外的方式将 产品归类到产品目录以及产品部门中。所以，在这个案例中，产品维表会有多套属性，包括 市场营销-产品-目录，市场营销-产品-部门，财务-产品-目录，财务-产品-部门。</li>
<li>相对少的记录。一个维表中的记录数通常会比事实表中的记录数量要少。一个汽车厂上的产 品维表可能只有 500 行。另一方面，事实表可能会有上百万行记录。</li>
</ul>
</li>
<li><p>事实表和维度表的设计原则</p>
<ul>
<li>事实表是用来存储主题的主干内容的。以日常的工作量为例，工作量可能具有如下属性：工作日期，人员，上班时长，加班时长，工作性质，是否外勤，工作内容，审核人。那么什么才是主干内容？很容易看出上班时长，加班时长是主干，也就是工作量主题的基本内容，那么工作日期，人员，工作性质，是否外勤，工作内容是否为主干信息呢？认真分析特征会发现，日期，人员，性质，是否外勤都是可以被分类的，例如日期有年-月-日的层次，人员也有上下级关系，外勤和正常上班也是两类上班考勤记录，而上班时长和加班时长则不具有此类意义。所以一般把能够分类的属性单独列出来，成为维度表，在事实表中维护事实与维度的引用关系。</li>
<li>总的来看，和其他建立主外键关系的表也都一样。但是维度表的建立是需要有层次的（虽然不是必须，但是也是典型特征），而事实表的建立是针对已经发生的事实的，是历史数据的存档，也就是说是不应该修改的。以测试部测试软件的Bug为例。每个Bug都是一个事实。这个Bug的状态在数据字典里可能设计成新建，转派，修复，拒绝等等。那么在事实表中Bug表中有一个字段为Status。当测试员或者开发人员改变了这个状态的值，事实表中该如何更新呢？是直接更新Status还是什么其他的方式？显然，为了能够追踪这个Bug的历史信息，应该是重新插入一条新的记录。那么这和以往的数据库设计有什么区别呢？可以看出对于原始记录和新插入的记录，其他字段全部是相同的，也就是全部冗余的。如果以BugID作为主键，这时候会发现主键都是冗余的（当然，插入之前只能删除主键）。所以可以看出，事实表一般是没有主键的。数据的质量完全由业务系统来把握。</li>
<li>维度表一般是有主键的，代表该类物质的一个单一个体，其他的字段一般都是有层次关系的。例如2009年2月19日是主键，那么它会有年–月–日这样的层次，为了方便统计，年月日不会在做聚合的时候才计算出来，而是在维护记录时已经计算出来。那么这些字段的冗余是否值得呢？可以这样解释：维度表的数据一般是比较少的，这个少是指相对事实表来讲的。因为事实表是与日俱增，而维度表则增长缓慢，所以绝对数字也不会太大。假如要做一个group by Year(TimeKey),那么在事实表和维度表做连接查询的时候，会产生与事实表一样大的数据量；如果没有这些维度表的分层，那么其一是会增加计算（需要根据时间字段去取出年份)，其二是由于引入了计算，索引会失效。这个代价比引入冗余字段要大的多。</li>
<li>维度表的主键一般都取整型值的标志列类型,这样也是为了节省事实表的存储空间.</li>
</ul>
</li>
<li><p>纬度表优缺点：</p>
<ul>
<li>数据冗余小（因为很多具体的信息都存在相应的维度表中了，比如用户信息就只有一份）</li>
<li>结构清晰（表结构一目了然）</li>
<li>便于做OLAP分析（数据分析用起来会很开心）</li>
<li>增加使用成本，比如查询时要关联多张表</li>
<li>数据不一致，比如用户发起购买行为的时候的数据，和我们维度表里面存放的数据不一致</li>
</ul>
</li>
<li><p>大宽表的优缺点：</p>
<ul>
<li>业务直观，在做业务的时候，这种表特别方便，直接能对到业务中。</li>
<li>使用方便，写sql的时候很方便。</li>
<li>数据冗余巨大，真的很大，在几亿的用户规模下，他的订单行为会很恐怖</li>
<li>粒度僵硬，什么都写死了，这张表的可复用性太低</li>
</ul>
</li>
</ul>
<ul>
<li>星型建模<ul>
<li>星形模式的键<ul>
<li>一个维表的每行都可以维表中的主键所唯一的识别</li>
<li>第一个原则来自于产品被存放到另外一个 仓库的情况。换句话来说，操作型系统中的产品键是有内在含义的.避免维表中的键有内在的含义</li>
<li>第二条原则就是:不要适用生产系统中的主键作为维表的主键。</li>
<li>替代键就是简单的系统 生成的序列号码。</li>
<li>替代键可以映射为生产系统的键。但是， 它们之间是不同的。通常的做法是将生产系统的键作为维表的附加属性</li>
</ul>
</li>
<li>虽然星形模式是一个关系模型，但是它不是一个规范化模型。在星形模式中，维表被故 意的非范式化了。这是星形模式与 OLTP 系统中的关系模式的基本区别。<ul>
<li>用户容易理解<ul>
<li>决策支持系统(例如数据仓库)的用户就不一样了。他们需要自己构造查询语句。在使 用第三方工具与数据仓库进行交互的过程中，他们要知道自己究竟需要什么。他们必须对数 据仓库中的有什么数据非常的熟悉，必须理解数据的结构，以及在整个模式中这些结构之间 的相互关系。</li>
<li>星形模式确切的反映了用户是如何想的，他们在查询和分析时需要什么数据。他们从商 业的角度来考虑问题。维表包含了用户经常查询和分析的属性。</li>
</ul>
</li>
<li>优化浏览<ul>
<li>关系用于连接不同 的表，以得到你所需要的信息。关系提供了操作数据库的能力。使用连接路径，可以将表与表之间的数据联系起来。</li>
<li>星形模式的一个主要的优势在于它优化了对数据库的浏览。即使你要找到查询结果看上 去很复杂，但是查询的过程是简单而且清晰的。</li>
</ul>
</li>
<li>最适于查询处理<ul>
<li>如果不考虑查询中涉及的维的数量，也不考虑查询的复杂程度，实际上每一个查询都只 是简单的使用一些参数过滤维表，得到一些维表结果，然后从事实表中得到相应的结果集。 这都得益于简单、清晰的连接路径以及星形模式。没有其它的方式能够达到这种效果了。</li>
<li>数据仓库查询的另一个重要方面就是上钻和下钻。让我们看一个下钻的场景。假设我们 已经得到了所有加利福尼亚州的顾客的所有扩展成本。结果是通过事实表的记录得到的。接 下来我们希望按照邮政编码来下钻这些结果。这可以通过选择在事实表中和相应邮政编码范 围的相关的记录。相反的，上钻是通过扩展事实表的选择记录的过程。</li>
</ul>
</li>
<li>星形连接和星形索引<ul>
<li>星形模式允许查询处理软件使用更优化的执行计划。它使得查询有能够更高的效率。星 形模式尤其适用于应用类似于星型连接或者星型索引这类提高性能的技术。</li>
<li>星型连接是一种高速，并型的，单独操作的多表连接。它可以通过一个单独的操作连接 多个表。这种特别的模式能够显著的提高查询性能。</li>
<li>星型索引是一种独特的索引，它可以提高连接的性能。这些索引建立在事实表的一个或 者多个外键上面。这些索引可以提高维表与事实表中连接速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>雪花建模<ul>
<li>纬度表进行规范化，拆分成多个表</li>
</ul>
</li>
<li>星座建模</li>
</ul>
<h2 id="0x14、范式模型和纬度模型区别"><a href="#0x14、范式模型和纬度模型区别" class="headerlink" title="0x14、范式模型和纬度模型区别"></a>0x14、范式模型和纬度模型区别</h2><ul>
<li><p>一般常规的数据仓库层级结构可分为：ods、dw(默认为汇总数据层，也可在细分为dwd(明细)与dw(汇总)两层)、dm共三层：</p>
<ul>
<li>ods层：称为接口层或近源数据层，表结构与源系统表结构高度相似，通常在ods层主要会做字段的筛选，枚举值转换，编码统一，异常&amp;缺失数据处理等操作。</li>
<li>dw层：称为中间层，按主题建模（域-&gt;主题）的明细数据层，数据粒度与ods层一致。</li>
<li>dm层：称为数据集市层，集市层是按照业务主题、分主题构建出来的、面向特定部门或人员的数据集合。</li>
</ul>
</li>
<li><p>维度建模源于Kimball提出的总线式的自下而上（DM-DW）的数据仓库架构。</p>
</li>
<li><p>特点：</p>
<ul>
<li>1.模型结构简单，星型模型为主；</li>
<li>2.开发周期短，能够快速迭代；</li>
<li>3.维护成本较高；</li>
</ul>
</li>
<li><p>范式建模源于Inmon提出的集线器的自上而下（EDW-DM）的数据仓库架构。</p>
</li>
<li><p>特点：</p>
<ul>
<li>1.同一份数据只存放在一个地方，因此只能从一个地方获取，没有数据冗余，保证了数据一致性；</li>
<li>2.解耦（系统级与业务级），方便维护；</li>
<li>3.开发周期较长，开发成本较高；</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li>dw层通常会采用范式建模，并且可以根据实际情况允许存在一些冗余。</li>
<li>dm层通常会采用维度建模，因为采用维度建模构建出来的数据模型更加符合普通人的认知、易于被普通人所理解，从而有利于数据的推广使用。</li>
</ul>
</li>
<li><p>维度模型将ER模型的层次结构平铺开来了，整个数据结构是平面化、单一层次的，数据结构很简单，但是维度表的冗余也会较多，灵活性比较差；优势则是查询简单快速，比如对产品维度的大类汇总，ER建模需要关联产品再通过关系表关联产品大类，而维度模型直接在产品维度表中就有了</p>
</li>
<li><p>ER模型和维度模型应用场景有所不同，ER模型更偏向于基础数据仓库的建设，保证高度抽象、高度一致性，要求业务稳定；而维度模型更多应用于数据集市，偏向于直接面对业务，保证查询效率</p>
</li>
<li><p>为什么 E-R 建模适用于 OLTP 系统。</p>
<ul>
<li>OLTP系统捕捉事件或者交易的详细信息</li>
<li>OLTP系统关注独立的事件</li>
<li>一个OLTP系统是通向微观交易的窗口</li>
<li>反映运行业务所需要的细节信息</li>
<li>仅仅适用于回答交易级别的问题</li>
<li>数据一致性，非冗余性，以及高效的数据存储是最重要的</li>
<li>避免了数据冗余 确保数据一致 表达微观的关系</li>
</ul>
</li>
<li><p>数据仓库需要回答全局问题</p>
<ul>
<li>数据仓库关注经理如何管理业务问题</li>
<li>数据仓库反映商业趋势</li>
<li>信息是围绕商业流程来组织的</li>
<li>答案显示了业务是如何衡量流程的</li>
<li>通过几个商业维度，可以衡量业务情况</li>
<li>捕捉关键指标 通过维度显示 面向商业用户</li>
</ul>
</li>
</ul>
<h2 id="0x15、数据层"><a href="#0x15、数据层" class="headerlink" title="0x15、数据层"></a>0x15、数据层</h2><ul>
<li>数据规范定义<ul>
<li>个性化的数据指标进行规范定义，抽象成：原子指标、时间周期、其他修饰词等三个要素。</li>
</ul>
</li>
<li>ODL(操作数据层)+BDL(基础数据层)+IDL(接口数据层)+ADS(应用数据层)</li>
<li>ODS(操作数据)层、CDM(公共维度模型)层、ADS(应用数据)层<ul>
<li>ODS层主要功能<ul>
<li>同步：结构化数据增量或全量同步到ODPS;</li>
<li>结构化：非结构化(日志)结构化处理并存储到ODPS;</li>
<li>累积历史、清洗：根据数据业务需求及稽核和审计要求保存历史数据、数据清洗;</li>
</ul>
</li>
<li>CDM层主要功能<ul>
<li>CDM层又细分为DWD层和DWS层，分别是明细宽表层和公共汇总数据层，采取维度模型方法基础，更多采用一些维度退化手法，减少事实表和维度表的关联，容易维度到事实表强化明细事实表的易用性;</li>
<li>同时在汇总数据层，加强指标的维度退化，采取更多宽表化的手段构建公共指标数据层，提升公共指标的复用性，减少重复的加工。</li>
</ul>
</li>
<li>ADS层主要功能<ul>
<li>个性化指标加工：不公用性;复杂性(指数型、比值型、排名型指标)</li>
<li>基于应用的数据组装：大宽表集市、横表转纵表、趋势指标串</li>
</ul>
</li>
</ul>
</li>
<li>流式数据结构，数据分层处理</li>
</ul>
<h2 id="0x16、查询方式"><a href="#0x16、查询方式" class="headerlink" title="0x16、查询方式"></a>0x16、查询方式</h2><ul>
<li>分组查询</li>
<li>钻取查询</li>
</ul>
<h2 id="0x17、数据仓库"><a href="#0x17、数据仓库" class="headerlink" title="0x17、数据仓库"></a>0x17、数据仓库</h2><ul>
<li><p>这种新类型的系统环境的特点如下:</p>
<ul>
<li>为分析任务设计的数据库</li>
<li>从多种应用程序中的得到的数据</li>
<li>方便使用，有益于用户的长时间互动操作</li>
<li>深入读取的数据使用</li>
<li>不需要IT顾问，用户可以与系统直接互动</li>
<li>同时包含当前和历史数据</li>
<li>用户可以运行查询并在线得到结果</li>
<li>用户可以创建报表</li>
</ul>
</li>
<li><p>在操作型系统和数据仓库之间，存在一个数据准备区域。在这个区域中，操作型 数据被清洗，并转化成为适合数据仓库使用的格式。</p>
</li>
<li><p>数据仓库是一种信息化环境，它有以下特点:</p>
<ul>
<li>提供对企业的一个综合而且完整的观察</li>
<li>使企业决策所需要的无论是当前数据还是历史数据都方便易得</li>
<li>使决策支持的互动工作不再需要借助操作型系统</li>
<li>使企业的信息保持一致性</li>
<li>提供了一个灵活的和互动的战略信息来源</li>
</ul>
</li>
<li><p>数据仓库可以向用户提供对数据的直接接触， 提供一个单独的关于经营情况的指标，还可以准确地记录发生的情况，可以使客户能够从多 种不同的视角观察这些数据。简单地说，数据仓库可以支持决策型的处理工作。</p>
</li>
<li><p>给数据仓库下一个定义:使用所有已经存在的数据，通过清洗和转化，提供有用的决策 信息。</p>
</li>
<li><p>一个数据仓库不是一个你购买来提供战略信息的简单的软件或者是硬件产品，而是一个 用户可以发现战略信息的计算机系统。在这个环境里，用户可以通过与数据的直接接触来做 出更好的决策。它是一个以用户为中心的环境。</p>
</li>
<li><p>让我们来总结一下这种叫做数据仓库的新型计算机环境的特点:</p>
<ul>
<li>数据分析和决策支持的完美环境</li>
<li>不固定，灵活而且交互式</li>
<li>百分之百用户驱动</li>
<li>非常适合提问-回答-再提问的模式</li>
<li>提供回答复杂、不可预测的问题的能力</li>
</ul>
</li>
<li><p>让我们来重新看看关于数据仓库的定义。数据仓库的基本概念如下:</p>
<ul>
<li>从操作型系统中提取所有数据</li>
<li>在需要的时候，可以将外部相关数据包含其中，例如工业标准指标</li>
<li>将多种数据源的数据进行整合</li>
<li>清洗并转换数据</li>
<li>用适合决策的格式存储数据</li>
</ul>
</li>
<li><p>包含了几个不同的功能:数据抽取，数据装载的功能，数据转换，数据存储，以及提供用户接口。</p>
</li>
<li><p>完整的数据。解决数据中存在的矛盾;整合来自不同操作型应用中的数据。</p>
<ul>
<li>储蓄账户   数据仓库主题</li>
<li>支票账户    主题=账户</li>
<li>贷款账户</li>
</ul>
</li>
<li><p>这里有一些需要标准化的项目:</p>
<ul>
<li>命名规则</li>
<li>编码</li>
<li>数据属性</li>
<li>度量单位</li>
</ul>
</li>
<li><p>有时间特性。数据仓库中的数据是和时间变化有关的数据:</p>
<ul>
<li>可以对过去的数据进行分析</li>
<li>与当前的信息相关</li>
<li>可以对未来进行预测</li>
</ul>
</li>
<li><p>数据的不变性</p>
<ul>
<li>历史数据，不需要变更</li>
<li>可以一天一次，两天一次或者一星期一次</li>
<li>我们在每次交易发生的时候，从操作型系统中增加、改变或者删除数据， 而并不是直接在数据仓库中进行更新。你不能在数据仓库中实时的删除数据。一旦数据存入 了数据仓库，你就不能对这个数据进行修改。数据仓库中的数据不像操作型系统中的数据那 样，可以随时修改。数据仓库中的数据是用来查询和分析的。</li>
</ul>
</li>
<li><p>数据粒度</p>
<ul>
<li>在一个操作型系统中，数据存储通常非常的详细。</li>
<li>当用户需要查询数据仓库来进行分析工作的时候，他或者她通常开始看总和数据。然后 可能需要看某个地区分类的数据。下一步通常是检查每个商店的销售情况。一般说来，用户 是从一个高的层次向低层次的细节过渡。</li>
<li>在数据仓库中，你会发现可以很有效地进行不同层次的数据求和。根据查询的需 要，你能够得到不同程度的细节情况。数据仓库中的数据粒度就是指这种细节的程度。低层 次的细节程度，数据粒度越细。当然，如果你想得到更加细节的数据，必须要在数据仓库中 存储大量的数据。所以，必须根据数据类型和希望达到的系统查询性能的要求，决定数据粒 度级别</li>
<li>数据粒度是数据的细节程度。根据需求的不同，需要不同层次的数据细节。数据仓库一 般含有至少两层的数据粒度。</li>
</ul>
</li>
<li><p>数据仓库和数据集市</p>
<ul>
<li>在开始决定建立数据仓库之前，你需要考虑以下这些问题:<ul>
<li>采取自上而下还是自下而上的方法?</li>
<li>企业范围还是部门范围?</li>
<li>先建立数据仓库还是数据集市?</li>
<li>建立向导还是直接实施</li>
<li>是否依赖数据集市?</li>
</ul>
</li>
<li>自上而下方法<ul>
<li>优点是:<ul>
<li>可以从整个企业的角度来看数据</li>
<li>体系结构完整——不是由不同的数据集市组成的</li>
<li>对数据内容的唯一、集中的存储</li>
<li>中央控制和集中的规则</li>
<li>对反复的查询能够做出快速的反应</li>
</ul>
</li>
<li>缺点是:<ul>
<li>需要花更多的时间来建造</li>
<li>失败的风险很高</li>
<li>需要高水平的综合技能</li>
<li>费用很高</li>
</ul>
</li>
</ul>
</li>
<li>自下而上的方法的:<ul>
<li>优点是<ul>
<li>实施快速而方便</li>
<li>良好的投资回报</li>
<li>失败的风险较小</li>
<li>渐进的，可以先建立重要的数据集市</li>
<li>项目团队可以从中学习和成长</li>
</ul>
</li>
<li>缺点是:<ul>
<li>每一个数据集市对数据的视角都比较窄</li>
<li>每个数据集市都有多余数据</li>
<li>总是有矛盾和不一致的数据</li>
<li>增加无法管理的接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>这种实用方法的步骤是这样的:<ul>
<li>从整个公司的角度来计划和定义需求</li>
<li>为完整的仓库创造一个体系结构</li>
<li>使数据内容一致而且标准化</li>
<li>将数据仓库作为一组数据集市来实施，每次一个</li>
</ul>
</li>
</ul>
</li>
<li><p>数据仓库中的元数据主要分为三类:</p>
<ul>
<li>操作型元数据<ul>
<li>数据仓库中的数据来自于企业中多个操作型系统。这些数据源系统包含了很多不同的数据结构，字段长度和数据类型也有不同。在这些数据中，你要对 不同来源的文件进行合并，解决编码和字段长度不同的问题。当你将这些信息传递给最终用 户的时候，你必须能将这些数据与最初的数据源联系起来。操作型元数据包含了所有操作型 数据源的信息。</li>
</ul>
</li>
<li>抽取和转换元数据<ul>
<li>抽取和转换元数据包含了源数据系统的信息，例如，抽取频率、抽 取方法和数据抽取的商业规则。而且，这一类的元数据包含了数据准备阶段数据转换的所有 信息。</li>
</ul>
</li>
<li>最终用户元数据<ul>
<li>最终用户元数据是数据仓库的向导。它使最终用户可以从数据仓库中 找到自己需要的信息。最终用户元数据允许最终用户使用自己商业终端和自己的习惯来查询 数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>维表的更新</p>
<ul>
<li>事实表中的 数据却很少会改变。即便对以前的数字要作修改，这些修改的数据也会作为另外的修改行添 加到事实表中。</li>
<li>与事实表相比，维表要稳定的多。然而，与事实表只增加记录的 行数不一样的是，维表的变化不仅包括增加记录的行数，而且属性本身也会改变。</li>
</ul>
</li>
<li><p>慢速变化维</p>
<ul>
<li>通过考察修改维表的考虑因素，我们可以得出以下的原则:<ul>
<li>绝大部分的维都是不变的</li>
<li>很多维度虽然会变化，但是这种改变是缓慢的</li>
<li>源记录的产品键不会改变</li>
<li>产品描述以及其它的属性的改变都是缓慢的</li>
<li>在源OLTP系统中，新的值会覆盖旧的值</li>
<li>在数据仓库中，覆盖维表的属性并不总是适当的做法</li>
<li>修改维表的方法依赖于改变的方式，以及数据仓库中什么信息必须被保存。</li>
</ul>
</li>
<li>数据仓库的实践者对不同类型的修改采 用不同的技术。他们还为这 3 种修改维表的方式起了名字，分别称为第一类修改，第 2 类修 改，和第 3 类修改。<ul>
<li>第1类修改:改正错误。这些修改通常与修正源系统中的错误相关<ul>
<li>名称修改</li>
<li>通用原则:<ul>
<li>通常，这些修改与源系统中的改错有关;</li>
<li>这种修改在源系统中有时没有意义;</li>
<li>源系统中的旧的数值不能保留;</li>
<li>源系统中的修改不需要在数据仓库中保存。</li>
</ul>
</li>
<li>修改的方法是:<ul>
<li>用新的值覆盖维表中的旧数值</li>
<li>属性的旧数值不需要保留</li>
<li>对维表没有其它修改</li>
<li>维表中的键值不受影响</li>
<li>这类修改是最容易实施的</li>
</ul>
</li>
</ul>
</li>
<li>第2类修改:保存历史数据<ul>
<li>婚姻状态，住址迁移</li>
<li>以下是这一类修改 的原则:<ul>
<li>他们通常与源系统中的修改相关;</li>
<li>需要在数据仓库中保留历史数据</li>
<li>这一类修改将数据仓库中的历史数据分区</li>
<li>对属性的每一个修改都要保留</li>
</ul>
</li>
<li>修改方法是：<ul>
<li>在维表中增加一条新的记录，该记录存有修改后的数值</li>
<li>维表中可能会有一个有效日期字段</li>
<li>对原来维表中的原始记录没有作修改</li>
<li>原来的键不受影响</li>
<li>新的记录插入，该记录有一个新的替代键</li>
</ul>
</li>
</ul>
</li>
<li>第3类修改:暂时的(软性的)修改<ul>
<li>第3类修改的一些通用的原则:<ul>
<li>它们通常与源系统的临时修改相关</li>
<li>需要跟踪新旧两个属性值</li>
<li>新旧两个值用于比较改变所带来的效果</li>
<li>它们提供了前向和后向的跟踪能力</li>
</ul>
</li>
<li>第3类修改的方法如下:<ul>
<li>对受影响的属性，在维表中加入“旧的”字段</li>
<li>将“现有” 字段值赋值给“旧的”字段</li>
<li>将新的值赋给“现有”字段</li>
<li>加入一个“现有”有效日期</li>
<li>记录的键不受影响</li>
<li>不需要新的维表记录</li>
<li>现有的查询可以无缝的转换到“现有”的值</li>
<li>所有使用到“旧的”值的查询需要作相应的修改</li>
<li>这种技术对某段时期的临时修改最为适用</li>
<li>如果还有后续的修改，则需要使用更为复杂的技术</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>大维表。特别宽又特别深的维表</p>
<ul>
<li>多层次结构<ul>
<li>将大维度表分解成多个较为简单的小维度表</li>
<li>应该将快速变化的属性放到另一个维表中，而将缓慢变化的属性放在原来的表里面。</li>
</ul>
</li>
<li>废弃维度</li>
</ul>
</li>
<li><p>雪花模型</p>
<ul>
<li>使用雪花型结构的原因是明显的。通过减少维表中的所有长文本字段，你将节省存储空 间。</li>
<li>优势<ul>
<li>减少(很少的)存储空间</li>
<li>规范化的结构更容易更新和维护</li>
</ul>
</li>
<li>劣势<ul>
<li>模式比较复杂，用户不容易理解</li>
<li>浏览内容更为困难</li>
<li>额外的连接将使查询性能下降</li>
</ul>
</li>
<li>在数据仓库中，通常不推荐雪花化。在数据仓库中，查询性能极为重要，而雪花化将降低性能。</li>
<li>雪花化的原则是将维表中的低级的 属性移出，构建新的表。类似的，在一些情况下可以将一组属性分离，形成子维度。两个属 性集的粒度是不一样的。这个过程与雪花化技术很相像。</li>
</ul>
</li>
<li><p>事实表分层</p>
<ul>
<li>基础事实表</li>
<li>聚集事实表</li>
</ul>
</li>
<li><p>聚集事实表</p>
<ul>
<li>聚集是从最低粒度的事实表中衍生出来的预先计算的汇总数据。这些汇总数据形成了一 组独立的聚集事实表。你可以为一个特定的汇总构建一个聚集事实表</li>
<li>聚集事实表将最低粒度的数据通过维度层次结构汇总成更高层次的数据。</li>
<li>时间维度的层次结构最低的是天，最高的是年。商店维度的最低层次是城市，而产品维度的最低层次是产品。</li>
<li>多路聚集事实表<ul>
<li>如果从一个维度中的一个层次升到一个更高的层次，而在其它维度保持最低粒度，就生 成了一个单路聚集表</li>
</ul>
</li>
<li>你的汇总层次越高，稀疏程度比例就越高。</li>
<li>聚集策略的目标。除了提高数据仓库性能这个一般的目标之外，聚集还包括以下几个更实际的特定目标:<ul>
<li>不要陷在过多的聚集之中。记住，要支持聚集，需要额外的衍生维表。</li>
<li>尝试满足大多数用户的需求。尤其是你的高级用户。</li>
<li>建立聚集不能过多的增加存储容量。对具有较低稀疏比例的那些大型聚集要注意。</li>
<li>保持聚集对最终用户是不可见的。就是说，聚集必须对用户的查询是透明的。查询工具必须能够意识到聚集的存在，并正确的使用它。</li>
<li>尽量减少对数据缓存处理的影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>星型模式族中的事实表共享维表。</p>
<ul>
<li>时间维表被族中的大多数事实表共享</li>
</ul>
</li>
<li><p>快照表和实务表</p>
<ul>
<li>财务数据仓库同样需要快照和事实表，这是由其分析特点决定的。这些数据仓库中，有 一类问题与“单独事务在一段特定时期中，如何影响某个特定账户”有关。而另一类问题则 关注特定时期期末特定账户的余额。事务表回答第一类问题;而快照则处理第 2 类问题。</li>
</ul>
</li>
<li><p>核心表和定制表</p>
</li>
<li><p>将事实标准化</p>
<ul>
<li>除了使维度一致之外，将事实标准化也是一个基本需求。我们知道，事实表可以跨越多 个星型模式。回顾一下的与事实表属性标准化相关的问题:<ul>
<li>保证在数据集市中的定义和术语是相同的</li>
<li>解决同名问题</li>
<li>需要标准化的类型包括利润，价格，成本，边际利润</li>
<li>保证每个事实表中所有的衍生单元使用同样的算法</li>
<li>保证每一个事实都使用正确的指标单位</li>
</ul>
</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        <div class="reward-container">
  <div></div>
  <button onclick="var qr = document.getElementById('qr'); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">
      
      <div style="display: inline-block;">
        <img src="/images/wechat.png" alt="hackfox 微信支付">
        <p>微信支付</p>
      </div>
      
      <div style="display: inline-block;">
        <img src="/images/alipay.png" alt="hackfox 支付宝">
        <p>支付宝</p>
      </div>

  </div>
</div>

        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>hackfox
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://xsoer.github.io/posts/storage/数据建模/" title="数据建模">https://xsoer.github.io/posts/storage/数据建模/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/数据库/" rel="tag"># 数据库</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/storage/行与列式数据库/" rel="prev" title="行与列式数据库">
      <i class="fa fa-chevron-left"></i> 行与列式数据库
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/python/python的format使用/" rel="next" title="python的format使用">
      python的format使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#0x00、数据模型"><span class="nav-text">0x00、数据模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x01、数据建模"><span class="nav-text">0x01、数据建模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x02、数据存储历史"><span class="nav-text">0x02、数据存储历史</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x03、层次模型"><span class="nav-text">0x03、层次模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x04、网状模型"><span class="nav-text">0x04、网状模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x05、关系模型"><span class="nav-text">0x05、关系模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x06、面向对象模型"><span class="nav-text">0x06、面向对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x07、数据仓库与操作型数据库的区别"><span class="nav-text">0x07、数据仓库与操作型数据库的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x08、数据仓库简介"><span class="nav-text">0x08、数据仓库简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x09、ETL"><span class="nav-text">0x09、ETL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x10、仓库建模阶段解析"><span class="nav-text">0x10、仓库建模阶段解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x11、数据仓库建模方法"><span class="nav-text">0x11、数据仓库建模方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x12、范式模型-ER模型、实体模型"><span class="nav-text">0x12、范式模型(ER模型、实体模型)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x13、维度建模"><span class="nav-text">0x13、维度建模</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x14、范式模型和纬度模型区别"><span class="nav-text">0x14、范式模型和纬度模型区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x15、数据层"><span class="nav-text">0x15、数据层</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x16、查询方式"><span class="nav-text">0x16、查询方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#0x17、数据仓库"><span class="nav-text">0x17、数据仓库</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hackfox</p>
  <div class="site-description" itemprop="description">架构、AI、python、rust</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">23</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xsoer" title="GitHub → https://github.com/xsoer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:codehackfox@gmail.com" title="E-Mail → mailto:codehackfox@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/5746784/hackfox-code" title="StackOverflow → https://stackoverflow.com/users/5746784/hackfox-code" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://hackfox.vip" title="http://hackfox.vip" rel="noopener" target="_blank">hackfox</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hackfox</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">117k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:47</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/pisces.js"></script>
<script src="/js/next-boot.js"></script>
  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  <script src="/js/local-search.js"></script>












    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7c7b02623259a39014a0',
      clientSecret: '07c01a3277dab0956ad91bad7d24b91a7e773990',
      repo        : 'xsoer.github.io',
      owner       : 'xsoer',
      admin       : ['xsoer'],
      id          : 'e86977b19a421e0969f1e13b1af348e4',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
