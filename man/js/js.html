<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/pace-js@1/themes/blue/pace-theme-minimal.css">
  <script src="//cdn.jsdelivr.net/npm/pace-js@1/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"xsoer.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":true,"lazyload":true,"pangu":true,"comments":{"style":"buttons","active":"gitalk","storage":true,"lazyload":false,"nav":null,"activeClass":"gitalk"},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="2017.11.01 1.js到异步请求，需要用then和catch来执行，这些函数还可以在接着返回值吗？应该是可以返回true或false，但是返回到promise没有执行，这个如何让then和catch在返回一个promise进行执行？  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1.对于数据的操作方法的算法积累是很有用处的  基本数据类型：字符串，数字，数组，对象">
<meta property="og:type" content="website">
<meta property="og:title" content="hackfox">
<meta property="og:url" content="https://xsoer.github.io/man/js/js.html">
<meta property="og:site_name" content="hackfox">
<meta property="og:description" content="2017.11.01 1.js到异步请求，需要用then和catch来执行，这些函数还可以在接着返回值吗？应该是可以返回true或false，但是返回到promise没有执行，这个如何让then和catch在返回一个promise进行执行？  &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;1.对于数据的操作方法的算法积累是很有用处的  基本数据类型：字符串，数字，数组，对象">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-02-21T11:24:38.807Z">
<meta property="article:modified_time" content="2022-02-21T11:24:38.806Z">
<meta property="article:author" content="hackfox">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://xsoer.github.io/man/js/js">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title> | hackfox
</title>
  
    <script>
      function sendPageView() {
        if (CONFIG.hostname !== location.hostname) return;
        var uid = localStorage.getItem('uid') || (Math.random() + '.' + Math.random());
        localStorage.setItem('uid', uid);
        navigator.sendBeacon('https://www.google-analytics.com/collect', new URLSearchParams({
          v  : 1,
          tid: 'UA-114671402-1',
          cid: uid,
          t  : 'pageview',
          dp : encodeURIComponent(location.pathname)
        }));
      }
      document.addEventListener('pjax:complete', sendPageView);
      sendPageView();
    </script>






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism-duotone-dark.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hackfox</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">专注 慎思 博学</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-man">

    <a href="/man/" rel="section"><i class="fa fa-server fa-fw"></i>手册</a>

  </li>
        <li class="menu-item menu-item-architecture">

    <a href="/architecture/" rel="section"><i class="fa fa-server fa-fw"></i>架构</a>

  </li>
        <li class="menu-item menu-item-algorithms">

    <a href="/algorithms/" rel="section"><i class="fa fa-cogs fa-fw"></i>算法</a>

  </li>
        <li class="menu-item menu-item-interview">

    <a href="/interview/" rel="section"><i class="fa fa-code fa-fw"></i>面试</a>

  </li>
        <li class="menu-item menu-item-tools">

    <a href="/tools/" rel="section"><i class="fa fa-gavel fa-fw"></i>工具</a>

  </li>
        <li class="menu-item menu-item-resource">

    <a href="/resource/" rel="section"><i class="fa fa-folder fa-fw"></i>资源</a>

  </li>
        <li class="menu-item menu-item-books">

    <a href="/books/" rel="section"><i class="fa fa-book fa-fw"></i>读书</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
  
  

          <div class="content page posts-expand">
            

    
    
    
    <div class="post-block" lang="zh-CN">
      <header class="post-header">

<h1 class="post-title" itemprop="name headline">
</h1>

<div class="post-meta">
  
  <ul class="breadcrumb">
          
            <li><a href="/man/">MAN</a></li>
            <li><a href="/man/js/">JS</a></li>
            <li>JS</li>
          
  </ul>

</div>

</header>

      
      
      
      <div class="post-body">
          <h2 id="2017-11-01"><a href="#2017-11-01" class="headerlink" title="2017.11.01"></a>2017.11.01</h2><ul>
<li>1.js到异步请求，需要用then和catch来执行，这些函数还可以在接着返回值吗？应该是可以返回true或false，但是返回到promise没有执行，这个如何让then和catch在返回一个promise进行执行？</li>
</ul>
<p>=================================<br>1.对于数据的操作方法的算法积累是很有用处的<br>  基本数据类型：字符串，数字，数组，对象<br>  复合数据类型：队列，堆栈，</p>
<p>方法：遍历、排序、取值、过滤、修改、查询</p>
<p>遍历：forEach    for(in)     for(of)    each    invoke<br>排序：sort    sortBy    shuffle<br>取值：keys    values    entites    value    pluck    max    min    first    last    initial    rest    pairs<br>过滤：filter    reject    some    every    intersection    difference    uniq<br>修改：map    invert<br>查询：contains    indexOf    find    where  lastIndexOf    has<br>分组：groupBy    countBy    indexBy    partition<br>抽样：sample<br>转换：toArray<br>长度：size    length<br>拷贝：clone<br>判断：isEqual    isEmpty    isArray    isObject    isElement    isString    isNumber    isNaN    isDate    isBoolean    isNull</p>
<p> Javascript 的保留关键字不可以用作变量、标签或者函数名。有些保留关键字是作为 Javascript 以后扩展使用。</p>
<p>abstract<br>arguments<br>boolean<br>break<br>byte<br>case<br>catch<br>char<br>class*<br>const<br>continue<br>debugger<br>default<br>delete<br>do<br>double<br>else<br>enum*<br>eval<br>export*<br>extends*<br>false<br>final<br>finally<br>float<br>for<br>function<br>goto<br>if<br>implements<br>import*<br>in<br>instanceof<br>int<br>interface<br>let<br>long<br>native<br>new<br>null<br>package<br>private<br>protected<br>public<br>return<br>short<br>static<br>super*<br>switch<br>synchronized<br>this<br>throw<br>throws<br>transient<br>true<br>try<br>typeof<br>var<br>void<br>volatile<br>while<br>with<br>yield</p>
<pre><code>JavaScript 内置的对象、属性和方法的名称作为 Javascript 的变量或函数名：</code></pre><p>Array<br>Date<br>eval<br>function<br>hasOwnProperty<br>Infinity<br>isFinite<br>isNaN<br>isPrototypeOf<br>length<br>Math<br>NaN<br>name<br>Number<br>Object<br>prototype<br>String<br>toString<br>undefined<br>valueOf</p>
<p>  JavaScript 可以在 HTML 外部使用。它可在许多其他应用程序中作为编程语言使用。<br>    在 HTML 中，您必须（为了可移植性，您也应该这么做）避免使用 HTML 和 Windows 对象和属性的名称作为 Javascript 的变量及函数名：</p>
<p>alert<br>all<br>anchor<br>anchors<br>area<br>assign<br>blur<br>button<br>checkbox<br>clearInterval<br>clearTimeout<br>clientInformation<br>close<br>closed<br>confirm<br>constructor<br>crypto<br>decodeURI<br>decodeURIComponent<br>defaultStatus<br>document<br>element<br>elements<br>embed<br>embeds<br>encodeURI<br>encodeURIComponent<br>escape<br>event<br>fileUpload<br>focus<br>form<br>forms<br>frame<br>innerHeight<br>innerWidth<br>layer<br>layers<br>link<br>location<br>mimeTypes<br>navigate<br>navigator<br>frames<br>frameRate<br>hidden<br>history<br>image<br>images<br>offscreenBuffering<br>open<br>opener<br>option<br>outerHeight<br>outerWidth<br>packages<br>pageXOffset<br>pageYOffset<br>parent<br>parseFloat<br>parseInt<br>password<br>pkcs11<br>plugin<br>prompt<br>propertyIsEnum<br>radio<br>reset<br>screenX<br>screenY<br>scroll<br>secure<br>select<br>self<br>setInterval<br>setTimeout<br>status<br>submit<br>taint<br>text<br>textarea<br>top<br>unescape<br>untaint<br>window</p>
<p>JS基本知识</p>
<p>一.导论<br>   1.脚本语言<br>   2.基本语法和标准库<br>       各种宿主提供操作：<br>       浏览器:浏览器控制类、DOM类、Web类)<br>       服务器:操作系统API(文件操作、网络通信)<br>二、语法<br>1.基本语法<br>1.1语句<br>执行单位为一行，可不添加<br>1.2变量<br>基本：</p>
<blockquote>
<p>.组成有$、_、字母、数字，且不能数字开头<br>.声明形式：var、let(ES6,不存在变量提升)、const(ES6,不能被修改)<br>.原始类型值：字符串、数字、布尔值、null 、undefined 六种<br>.组合类型：数组、对象<br>.变量提示<br>1.3标示符<br>1.4注释<br>.//:单行注释<br>./* */:多行注释<br>1.5区块<br>1.用大括号表示一个区块<br>1.6条件语句<br>.if<br>.if else<br>.switch<br>.三元运算符(? :)<br>1.7循环语句<br>1.for 2.while 3.do while 4.break;continue 5.标签(慎用)<br>2.数据类型转换<br>强制转换：<br>1.数字类型转换：Number、String、Boolean<br>2.parseInt()、parseFloat()<br>Number<br>1.自动过滤前后空格，字符串如果是数字则转为数字、否则为NaN、空字符串为0<br>2.布尔值ture为1、false为0<br>3.undefined为NaN、null为0<br>转换对象：转换为NaN<br>1.调用对象自身的valueOf方法。如果返回原始类型的值，则直接对该值使用Number函数，不再进行后续步骤。<br>2.如果valueOf方法返回的还是对象，则改为调用对象自身的toString方法。如果返回原始类型的值，则对该值使用Number函数，不再进行后续步骤。<br>3.如果toString方法返回的是对象，就报错。<br>【String】:可以将任何类型转化为字符串<br>原始类型转换：<br>1&gt; 数值：转为相应的字符串。<br>2&gt; 字符串：转换后还是原来的值。<br>3&gt; 布尔值：true转为”true”，false转为”false”。<br>4&gt; undefined：转为”undefined”。<br>5&gt; null：转为”null”。<br>对象转换规则：<br>对象，返回一个类型字符串；<br>如果是数组，返回该数组的字符串形式<br>规则：<br>1.先调用对象自身的toString方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。<br>2.如果toString方法返回的是对象，再调用valueOf方法。如果返回原始类型的值，则对该值使用String函数，不再进行以下步骤。<br>3.如果valueOf方法返回的是对象，就报错。<br>【布尔值】：将任意类型的变量转为布尔值<br>除了以下值外，都是true：<br>undefined、null、-0、0或+0、NaN、’’（空字符串）<br>自动转换：</p>
<ol>
<li>不同类型的数据互相运算</li>
<li>对非布尔值类型的数据求布尔值</li>
<li>对非数值类型的数据使用一元运算符（即“+”和“-”）<br>规则：自动转换的规则是这样的：预期什么类型的值，就调用该类型的转换函数。<br>比如，某个位置预期为字符串，就调用String函数进行转换。如果该位置即可以是字符串，也可能是数值，那么默认转为数值。<br>【数值】:所有数字都是64位浮点存储(1与1.0相同)<br>组成：<br>第1位：符号位，0表示正数，1表示负数<br>第2位到第12位：储存指数部分<br>第13位到第64位：储存小数部分（即有效数字）<br>数字范围：2的1024次方到2的-1023次方（开区间）<br>Infinity(正无穷), -Infinity(负无穷)<br>数字表示方法：<br>十进制：没有前导0的数值。<br>八进制：有前缀0o或0O的数值，或者有前导0、且只用到0-7的七个阿拉伯数字的数值。<br>十六进制：有前缀0x或0X的数值。<br>二进制：有前缀0b或0B的数值。<br>科学计数法：123e3<br>注：进制中包含不该有的数值，会报错<br>特殊数值：</li>
<li>正负零：-0 === +0 // true；0 === -0 // true；0 === +0 // true</li>
<li>(1 / +0) 不等于 (1 / -0) //是因为除以正零得到+Infinity，除以负零得到-Infinity，这两者是不相等.</li>
<li>NaN<br>【字符串】:零个或多个排在一起的字符，放在单引号或双引号之中</li>
<li>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号</li>
<li>单引号字符串的内部，使用单引号（或者在双引号字符串的内部，使用双引号），就必须在内部的单引号（或者双引号）前面加上反斜杠，用来转义。</li>
<li>字符串默认只能写在一行内，分成多行将会报错.分行需要用反斜杠<br>需要用反斜杠转义的特殊字符</li>
<li>\0 null（\u0000）</li>
<li>\b 后退键（\u0008）</li>
<li>\f 换页符（\u000C）</li>
<li>\n 换行符（\u000A）</li>
<li>\r 回车键（\u000D）</li>
<li>\t 制表符（\u0009）</li>
<li>\v 垂直制表符（\u000B）</li>
<li>&#39; 单引号（\u0027）</li>
<li>&quot; 双引号（\u0022）</li>
<li>\ 反斜杠（\u005C）<br>反斜杠还有三种特殊用法。<br>（1）\HHH<br>反斜杠后面紧跟三个八进制数（000到377），代表一个字符。HHH对应该字符的Unicode码点，比如\251表示版权符号。显然，这种方法只能输出256种字符。<br>（2）\xHH<br>\x后面紧跟两个十六进制数（00到FF），代表一个字符。HH对应该字符的Unicode码点，比如\xA9表示版权符号。这种方法也只能输出256种字符。<br>（3）\uXXXX<br>\u后面紧跟四个十六进制数（0000到FFFF），代表一个字符。HHHH对应该字符的Unicode码点，比如\u00A9表示版权符号<br>字符串与数组：</li>
<li>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始)</li>
<li>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回undefined</li>
<li>字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</li>
<li>字符串也无法直接使用数组的方法，必须通过call方法间接使用。<br>length属性返回字符串的长度，该属性也是无法改变的。<br>字符集：Unicode<br>base64转码<br>【对象】:JS中所有数据都可以视为对象</li>
<li>就是一种无序的数据集合，由若干个“键值对”（key-value）构成。<br>键名：</li>
<li>都是字符串，加不加引号都可以。 2.如何不合法，则需要添加引号</li>
<li>属性: 每一个键名也称为属性</li>
<li>键值: 可以是任一种类型，如果是函数，则称之为方法。</li>
<li>属性之间用逗号分隔开</li>
<li>属性可以动态创建<br>对象应用：</li>
<li>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</li>
<li>种引用只局限于对象，对于原始类型的数据则是传值引用，也就是说，都是值的拷贝<br>表达式或语句？<br>问：如果行首是一个大括号，它到底是表达式还是语句？ 1.JavaScript规定，如果行首是大括号，一律解释为语句（即代码块）。如果要解释为表达式（即对象），必须在大括号前加上圆括号。<br>属性操作： 1.添加：Object.assign(); 2.删除：delete 3.查询：in 4.取键：Object.keys(o) 5.读取和赋值：点运算法或[]运算符 6.遍历：for in 7.with语句<br>【数组】:按次序排列的一组值,用方括号表示</li>
<li>任何类型的数据都可以放入</li>
<li>一种特殊的对象：键名按次序排列</li>
<li>数组只能用 []符号来取值</li>
<li>length属性等于最大的数字键加1</li>
<li>遍历：for in 、 forEach<br>【函数】:一段可以反复调用的代码块<br>函数声明：</li>
<li>function关键字</li>
<li>函数表达式(匿名函数赋值给变量)</li>
<li>Function构造函数</li>
<li>如果重复声明，后边的会覆盖掉前边的</li>
<li>不可在条件语句中声明函数(if和try语句)，但可以调用</li>
<li>圆括号运算法，表示调用</li>
<li>递归：函数自身调用自身</li>
<li>凡是可以使用值的地方，就能使用函数(一等公民)<br>属性：<br>1&gt;name:跟在function关键字后边<br>2&gt;length:参数个数<br>3&gt;toString:函数源码<br>作用域：(全局作用域和函数作用域，块作用域ES6)<br>参数：</li>
<li>值传递</li>
<li>设置默认值</li>
<li>arguments对象<br>其他知识点：</li>
<li>闭包</li>
<li>立即调用表达式</li>
<li>eval命令：把字符串转换为命令执行<br>运算符<br> JavaScript 算术运算符</li>
</ol>
</blockquote>
<pre><code>运算符</code></pre><p>描述<br>例子<br>结果<br>+<br>加<br>x=y+2<br>x=7<br>-<br>减<br>x=y-2<br>x=3<br>*<br>乘<br>x=y*2<br>x=10<br>/<br>除<br>x=y/2<br>x=2.5<br>%<br>求余数 (保留整数)<br>x=y%2<br>x=1<br>++<br>累加<br>x=++y</p>
<h2 id="x-6"><a href="#x-6" class="headerlink" title="x=6"></a>x=6</h2><p>递减<br>x=–y<br>x=4</p>
<pre><code>JavaScript 赋值运算符</code></pre><p>运算符<br>例子<br>等价于<br>结果<br>=<br>x=y</p>
<p>x=5<br>+=<br>x+=y<br>x=x+y</p>
<h1 id="x-15"><a href="#x-15" class="headerlink" title="x=15"></a>x=15</h1><p>x-=y<br>x=x-y<br>x=5<br><em>=<br>x</em>=y<br>x=x*y<br>x=50<br>/=<br>x/=y<br>x=x/y<br>x=2<br>%=<br>x%=y<br>x=x%y<br>x=0</p>
<p>  比较运算符</p>
<p>运算符<br>描述</p>
<h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>等于</p>
<h1 id="x-8-为-false"><a href="#x-8-为-false" class="headerlink" title="x==8 为 false"></a>x==8 为 false</h1><p>全等（值和类型）<br>x===5 为 true；x===”5” 为 false<br>!=<br>不等于<br>x!=8 为 true</p>
<blockquote>
</blockquote>
<p>大于<br>x&gt;8 为 false<br>&lt;<br>小于<br>x&lt;8 为 true</p>
<blockquote>
<p>=<br>大于或等于<br>x&gt;=8 为 false<br>&lt;=<br>小于或等于<br>x&lt;=8 为 true</p>
</blockquote>
<pre><code>逻辑运算符</code></pre><p>运算符<br>描述<br>例子<br>&amp;&amp;<br>and<br>(x &lt; 10 &amp;&amp; y &gt; 1) 为 true<br>||<br>or<br>(x==5 || y==5) 为 false<br>!<br>not<br>!(x==y) 为 true</p>
<p>加法运算符<br>算术运算符<br>赋值运算符<br>比较运算符<br>布尔运算符<br>位运算符<br>其他运算符<br>运算顺序<br>数据类型<br>typeof<br>instanceof<br>错误类型处理机制<br>Error对象<br>    1.原生提供Error构造函数，所有抛出的错误都是此函数的实例</p>
<ol>
<li>var err = new Error(‘出错了’);   //接受一个参数，表示错误提示</li>
<li>err.message // “出错了”<br> 2.所具有的属性<br> message：错误提示信息<br> name：错误名称（非标准属性）<br> stack：错误的堆栈（非标准属性）<br>原生错误类型<br>自定义错误<br>throw语句<br>try…catch<br>finally<br>编程风格<br>标准库<br>Object对象</li>
<li>提供一个对象及构造函数：Object.</li>
<li>var o = new Object();</li>
<li>Object作为构造函数使用时，可以接受一个参数。如果该参数是一个对象，则直接返回这个对象；如果是一个原始类型的值，则返回该值对应的包装对象。</li>
<li>var o1 = {a: 1};</li>
<li>var o2 = new Object(o1);</li>
<li>o1 === o2 // true</li>
<li>new Object(123) instanceof Number</li>
<li>// true</li>
<li>注：通过new Object()的写法生成新对象，与字面量的写法o = {}是等价的。<br> 3.部署方法有两种<pre><code>a.部署在Object本身</code></pre></li>
<li>Object.print = function(o){ console.log(o) };</li>
<li>var o = new Object();</li>
<li>Object.print(o)</li>
<li>// Object<pre><code>b.部署在Object.prototype对象上
    所有构造函数都有一个prototype属性，指向一个原型对象。凡是定义在Object.prototype对象上面的属性和方法，将被所有实例对象共享</code></pre></li>
<li>Object.prototype.print = function(){ console.log(this)};</li>
<li>var o = new Object();</li>
<li>o.print() // Object<br> 4.自身当作方法，用来转换值为对象</li>
<li>Object() // 返回一个空对象</li>
<li>Object() instanceof Object // true</li>
<li>Object(undefined) // 返回一个空对象</li>
<li>Object(undefined) instanceof Object // true</li>
<li>Object(null) // 返回一个空对象</li>
<li>Object(null) instanceof Object // true</li>
<li>Object(1) // 等同于 new Number(1)</li>
<li>Object(1) instanceof Object // true</li>
<li>Object(1) instanceof Number // true</li>
<li>Object(‘foo’) // 等同于 new String(‘foo’)</li>
<li>Object(‘foo’) instanceof Object // true</li>
<li>Object(‘foo’) instanceof String // true</li>
<li>Object(true) // 等同于 new Boolean(true)</li>
<li>Object(true) instanceof Object // true</li>
<li>Object(true) instanceof Boolean // true<pre><code>如果Object方法的参数是一个对象，它总是返回原对象</code></pre></li>
<li>var arr = [];</li>
<li>Object(arr) // 返回原数组</li>
<li>Object(arr) === arr // true</li>
<li>var obj = {};</li>
<li>Object(obj) // 返回原对象</li>
<li>Object(obj) === obj // true</li>
<li>var fn = function () {};</li>
<li>Object(fn) // 返回原函数</li>
<li>Object(fn) === fn // true<br> 利用这一点，来判断值是否为对象</li>
<li>function isObject(value) {</li>
<li>return value === Object(value);</li>
<li>}</li>
<li>isObject([]) // true</li>
<li>isObject(true) // false<br> 5.静态方法：部署在Object对象上的方法<blockquote>
<p>Object.keys()，Object.getOwnPropertyNames():获取对象属性方法，前者只返回可枚举属性，后者还返回不可枚举属性</p>
</blockquote>
</li>
<li>var o = {</li>
<li>p1: 123,</li>
<li>p2: 456</li>
<li>};</li>
<li>Object.keys(o)</li>
<li>// [“p1”, “p2”]</li>
<li>Object.getOwnPropertyNames(o)</li>
<li>// [“p1”, “p2”]</li>
<li>var a = [“Hello”, “World”];</li>
<li>Object.keys(a)</li>
<li>// [“0”, “1”]</li>
<li>Object.getOwnPropertyNames(a)</li>
<li>// [“0”, “1”, “length”]</li>
<li>//计算对象属性个数</li>
<li>Object.keys(o).length //常用</li>
<li>Object.getOwnPropertyNames(o).length<br>a.对象属性模型方法<blockquote>
<p>Object.getOwnPropertyDescriptor()：获取某个属性的attributes对象。<br>Object.defineProperty()：通过attributes对象，定义某个属性。<br>Object.defineProperties()：通过attributes对象，定义多个属性。<br>Object.getOwnPropertyNames()：返回直接定义在某个对象上面的全部属性的名称。<br>b.控制对象状态的方法<br>Object.preventExtensions()：防止对象扩展。<br>Object.isExtensible()：判断对象是否可扩展。<br>Object.seal()：禁止对象配置。<br>Object.isSealed()：判断一个对象是否可配置。<br>Object.freeze()：冻结一个对象。<br>Object.isFrozen()：判断一个对象是否被冻结。<br>c.原型链相关方法<br>Object.create()：生成一个新对象，并该对象的原型。<br>Object.getPrototypeOf()：获取对象的Prototype对象。<br>6.对象实例方法(部署在prototype上)<br>Object实例对象的方法，主要有以下六个。<br>valueOf()：返回当前对象对应的值。<br>toString()：返回当前对象对应的字符串形式。<br>toLocaleString()：返回当前对象对应的本地字符串形式。<br>hasOwnProperty()：判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。<br>isPrototypeOf()：判断当前对象是否为另一个对象的原型。<br>propertyIsEnumerable()：判断某个属性是否可枚举。<br>a.valueOf：返回对象一个值，默认返回对象本身。主要用途在自动转换类型时调用</p>
</blockquote>
</li>
<li>var o = new Object();</li>
<li>1 + o // “1[object Object]”</li>
<li>var o = new Object();</li>
<li>o.valueOf = function (){</li>
<li>return 2;</li>
<li>};</li>
<li>1 + o // 3<br>  b.toString:  返回对象的字符串形式</li>
<li>var o1 = new Object();</li>
<li>o1.toString() // “[object Object]”</li>
<li>var o2 = {a:1};</li>
<li>o2.toString() // “[object Object]”    //第二个Object表示该值的构造函数<br>数组、字符串、函数、Date对象都分别部署了自己版本的toString方法，覆盖了Object.prototype.toString方法。</li>
<li>[1, 2, 3].toString() // “1,2,3”</li>
<li>‘123’.toString() // “123”</li>
<li>(function () {</li>
<li>return 123;</li>
<li>}).toString()</li>
<li>// “function () {</li>
<li>// return 123;</li>
<li>// }”</li>
<li>(new Date()).toString()</li>
<li>// “Tue May 10 2016 09:11:31 GMT+0800 (CST)”<br>判断数据类型: 通过函数的call方法，可以在任意值上调用Object.prototype.toString方法，帮助我们判断这个值的类型<br>不同数据类型的Object.prototype.toString方法返回值如下。<blockquote>
<p>数值：返回[object Number]。<br>字符串：返回[object String]。<br>布尔值：返回[object Boolean]。<br>undefined：返回[object Undefined]。<br>null：返回[object Null]。<br>数组：返回[object Array]。<br>arguments对象：返回[object Arguments]。<br>函数：返回[object Function]。<br>Error对象：返回[object Error]。<br>Date对象：返回[object Date]。<br>RegExp对象：返回[object RegExp]。<br>其他对象：返回[object Object]。</p>
</blockquote>
</li>
</ol>
<h4 id="Array对象"><a href="#Array对象" class="headerlink" title="Array对象"></a>Array对象</h4><p>1.内置对象和构造函数。其构造函数存在问题，不同的参数产生不一样的结果</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无参数时，返回一个空数组</span></span><br><span class="line"> <span class="keyword">new</span> <span class="built_in">Array</span>() <span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个正整数参数，表示返回的新数组的长度</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>) <span class="comment">// [ undefined ]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">2</span>) <span class="comment">// [ undefined x 2 ]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非正整数的数值作为参数，会报错</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3.2</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">-3</span>) <span class="comment">// RangeError: Invalid array length</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单个非正整数参数（比如字符串、布尔值、对象等），</span></span><br><span class="line"><span class="comment">// 则该参数是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'abc'</span>) <span class="comment">// ['abc']</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>([<span class="number">1</span>]) <span class="comment">// [Array[1]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多参数时，所有参数都是返回的新数组的成员</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>) <span class="comment">// ['a', 'b', 'c']</span></span><br><span class="line"><span class="comment">// 故最好的做法是：</span></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br></pre></td></tr></table></figure>

<p>2.对象方法：isArray()。用来判断一个值是否为数组</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">typeof</span> a <span class="comment">// "object"</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(a) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>3.实例方法：</p>
<p>方法<br>描述<br>concat()<br>连接两个或更多的数组，并返回结果。<br>every()<br>检测数值元素的每个元素是否都符合条件。<br>filter()<br>检测数值元素，并返回符合条件所有元素的数组。<br>indexOf()<br>搜索数组中的元素，并返回它所在的位置。<br>join()<br>把数组的所有元素放入一个字符串。<br>lastIndexOf()<br>返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。<br>map()<br>通过指定函数处理数组的每个元素，并返回处理后的数组。<br>pop()<br>删除数组的最后一个元素并返回删除的元素。<br>push()<br>向数组的末尾添加一个或更多元素，并返回新的长度。<br>reverse()<br>反转数组的元素顺序。<br>shift()<br>删除并返回数组的第一个元素。<br>slice()<br>选取数组的的一部分，并返回一个新数组。<br>some()<br>检测数组元素中是否有元素符合指定条件。<br>sort()<br>对数组的元素进行排序。<br>splice()<br>从数组中添加或删除元素。<br>toString()<br>把数组转换为字符串，并返回结果。<br>unshift()<br>向数组的开头添加一个或更多元素，并返回新的长度。<br>valueOf()<br>返回数组对象的原始值。</p>
<p>包装对象和Boolean对象<br>    1.所谓包装对象就是把原始值转换为对象。用意在于一切结对象。<br>    2.Boolean值判断</p>
<ol>
<li>Boolean(undefined) // false</li>
<li>Boolean(null) // false</li>
<li>Boolean(0) // false</li>
<li>Boolean(‘’) // false</li>
<li>Boolean(NaN) // false</li>
<li>Boolean(1) // true</li>
<li>Boolean(‘false’) // true</li>
<li>Boolean([]) // true</li>
<li>Boolean({}) // true</li>
<li>Boolean(function () {}) // true</li>
<li>Boolean(/foo/) // true<br>加双！</li>
<li>!!undefined // false</li>
<li>!!null // false</li>
<li>!!0 // false</li>
<li>!!’’ // false</li>
<li>!!NaN // false</li>
<li>!!1 // true</li>
<li>!!’false’ // true</li>
<li>!![] // true</li>
<li>!!{} // true</li>
<li>!!function(){} // true</li>
<li>!!/foo/ // true<br>对于一些特殊值，Boolean对象前面加不加new，会得到完全相反的结果，必须小心。</li>
<li>if (Boolean(false)) {</li>
<li>console.log(‘true’);</li>
<li>} // 无输出</li>
<li>if (new Boolean(false)) {</li>
<li>console.log(‘true’);</li>
<li>} // true</li>
<li>if (Boolean(null)) {</li>
<li>console.log(‘true’);</li>
<li>} // 无输出</li>
<li>if (new Boolean(null)) {</li>
<li>console.log(‘true’);</li>
<li>} // true</li>
</ol>
<h4 id="Number对象"><a href="#Number对象" class="headerlink" title="Number对象"></a>Number对象</h4><p>1.Number对象是数值对应的包装对象，可以作为构造函数使用，也可以作为工具函数使用。<br>2.Number对象拥有以下一些属性。</p>
<ul>
<li>Number.POSITIVE_INFINITY：正的无限，指向Infinity。</li>
<li>Number.NEGATIVE_INFINITY：负的无限，指向-Infinity。<br>Number.NaN：表示非数值，指向NaN。<blockquote>
<p>Number.MAX_VALUE：表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。<br>Number.MIN_VALUE：表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324），相应的，最接近0的负数为-Number.MIN_VALUE。<br>Number.MAX_SAFE_INTEGER：表示能够精确表示的最大整数，即9007199254740991。<br>Number.MIN_SAFE_INTEGER：表示能够精确表示的最小整数，即-9007199254740991。</p>
</blockquote>
</li>
</ul>
<ol>
<li>Number.POSITIVE_INFINITY // Infinity</li>
<li>Number.NEGATIVE_INFINITY // -Infinity</li>
<li>Number.NaN // NaN</li>
<li>Number.MAX_VALUE</li>
<li>// 1.7976931348623157e+308</li>
<li>Number.MAX_VALUE &lt; Infinity</li>
<li>// true</li>
<li>Number.MIN_VALUE</li>
<li>// 5e-324</li>
<li>Number.MIN_VALUE &gt; 0</li>
<li>// true</li>
<li>Number.MAX_SAFE_INTEGER // 9007199254740991</li>
<li>Number.MIN_SAFE_INTEGER // -9007199254740991<br>3.实例方法<blockquote>
<p>toString()<br>toFixed方法用于将一个数转为指定位数的小数，返回这个小数对应的字符串。<br>toExponential方法用于将一个数转为科学计数法形式。<br>toPrecision方法用于将一个数转为指定位数的有效数字。</p>
</blockquote>
</li>
</ol>
<h4 id="String对象"><a href="#String对象" class="headerlink" title="String对象"></a>String对象</h4><p> 字符串方法</p>
<p>Method<br>描述<br>charAt()<br>返回指定索引位置的字符<br>charCodeAt()<br>返回指定索引位置字符的 Unicode 值<br>concat()<br>连接两个或多个字符串，返回连接后的字符串<br>fromCharCode()<br>将字符转换为 Unicode 值<br>indexOf()<br>返回字符串中检索指定字符第一次出现的位置<br>lastIndexOf()<br>返回字符串中检索指定字符最后一次出现的位置<br>localeCompare()<br>用本地特定的顺序来比较两个字符串<br>match()<br>找到一个或多个正则表达式的匹配<br>replace()<br>替换与正则表达式匹配的子串<br>search()<br>检索与正则表达式相匹配的值<br>slice()<br>提取字符串的片断，并在新的字符串中返回被提取的部分<br>split()<br>把字符串分割为子字符串数组<br>substr()<br>从起始索引号提取字符串中指定数目的字符<br>substring()<br>提取字符串中两个指定的索引号之间的字符<br>toLocaleLowerCase()<br>根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br>toLocaleUpperCase()<br>根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射<br>toLowerCase()<br>把字符串转换为小写<br>toString()<br>返回字符串对象值<br>toUpperCase()<br>把字符串转换为大写<br>trim()<br>移除字符串首尾空白<br>valueOf()<br>返回某个字符串对象的原始值</p>
<p>Math对象<br>    1.为内置对象，但不是构造函数(即不能用new来创建对象)<br>    2.属性<br>     &gt;Math.E：常数e。<br>     &gt;Math.LN2：2的自然对数。<br>     &gt;Math.LN10：10的自然对数。<br>     &gt;Math.LOG2E：以2为底的e的对数。<br>     &gt;Math.LOG10E：以10为底的e的对数。<br>     &gt;Math.PI：常数Pi。<br>     &gt;Math.SQRT1_2：0.5的平方根。<br>     &gt;Math.SQRT2：2的平方根。<br>    3.Math对象提供以下一些数学方法。<br>    &gt;Math.abs()：绝对值<br>    &gt;Math.ceil()：向上取整<br>    &gt;Math.floor()：向下取整<br>    &gt;Math.max()：最大值<br>    &gt;Math.min()：最小值<br>    &gt;Math.pow()：指数运算<br>    &gt;Math.sqrt()：平方根<br>    &gt;Math.log()：自然对数<br>    &gt;Math.exp()：e的指数<br>    &gt;Math.round()：四舍五入<br>    &gt;Math.random()：随机数<br>    4.Math对象还提供一系列三角函数方法。<br>    &gt;Math.sin()：返回参数的正弦<br>    &gt;Math.cos()：返回参数的余弦<br>    &gt;Math.tan()：返回参数的正切<br>    &gt;Math.asin()：返回参数的反正弦（弧度值）<br>    &gt;Math.acos()：返回参数的反余弦（弧度值）<br>    &gt;Math.atan()：返回参数的反正切（弧度值）</p>
<p>Date对象<br>    1. 构造函数<br>    new Date(millisecondes);Date对象接受从1970年1月1日00:00:00 UTC开始计算的毫秒数作为参数。这意味着如果将Unix时间戳（单位为秒）作为参数，必须将Unix时间戳乘以1000</p>
<ol>
<li><p>new Date(1378218728000)</p>
</li>
<li><p>// Tue Sep 03 2013 22:32:08 GMT+0800 (CST)</p>
</li>
<li><p>// 1970年1月2日的零时</p>
</li>
<li><p>var Jan02_1970 = new Date(3600 * 24 * 1000);</p>
</li>
<li><p>// Fri Jan 02 1970 08:00:00 GMT+0800 (CST)</p>
</li>
<li><p>// 1969年12月31日的零时</p>
</li>
<li><p>var Dec31_1969 = new Date(-3600 * 24 * 1000);</p>
</li>
<li><p>// Wed Dec 31 1969 08:00:00 GMT+0800 (CST)<br> 2.new Date(datestring)</p>
</li>
<li><p>new Date(‘2013-2-15’)</p>
</li>
<li><p>new Date(‘2013/2/15’)</p>
</li>
<li><p>new Date(‘02/15/2013’)</p>
</li>
<li><p>new Date(‘2013-FEB-15’)</p>
</li>
<li><p>new Date(‘FEB, 15, 2013’)</p>
</li>
<li><p>new Date(‘FEB 15, 2013’)</p>
</li>
<li><p>new Date(‘Feberuary, 15, 2013’)</p>
</li>
<li><p>new Date(‘Feberuary 15, 2013’)</p>
</li>
<li><p>new Date(‘15 Feb 2013’)</p>
</li>
<li><p>new Date(‘15, Feberuary, 2013’)</p>
</li>
<li><p>// Fri Feb 15 2013 00:00:00 GMT+0800 (CST)<br>3.new Date(year, month [, day, hours, minutes, seconds, ms])</p>
<blockquote>
<p>year：四位年份，如果写成两位数，则加上1900<br>month：表示月份，0表示一月，11表示12月<br>date：表示日期，1到31<br>hour：表示小时，0到23<br>minute：表示分钟，0到59<br>second：表示秒钟，0到59<br>ms：表示毫秒，0到999<br>注：这些参数如果超出了正常范围，会被自动折算。比如，如果月设为15，就折算为下一年的4月。<br>4.运算<br>两个日期对象进行减法运算，返回的就是它们间隔的毫秒数；进行加法运算，返回的就是连接后的两个字符串。<br>5.对象方法<br>Date.now()    返回当前距离1970年1月1日 00:00:00 UTC的毫秒数（Unix时间戳乘以1000）<br>Date.parse()    用来解析日期字符串，返回距离1970年1月1日 00:00:00的毫秒数。<br>Date.UTC()    Date对象返回的都是当前时区的时间。Date.UTC方法可以返回UTC时间（世界标准时间）。该方法接受年、月、日等变量作为参数，返回当前距离1970年1月1日 00:00:00 UTC的毫秒数。<br>6.实例方法<br>分三大类：to类、get类、set类<br>a.to类<br>toString方法返回一个完整的日期字符串。<br>toUTCString方法返回对应的UTC时间，也就是比北京时间晚8个小时。<br>toISOString方法返回对应时间的ISO8601写法。<br>toJSON方法返回一个符合JSON格式的ISO格式的日期字符串，与toISOString方法的返回结果完全相同。<br>toDateString方法返回日期字符串。<br>toTimeString方法返回时间字符串。<br>toLocaleDateString方法返回一个字符串，代表日期的当地写法。<br>toLocaleTimeString方法返回一个字符串，代表时间的当地写法。</p>
</blockquote>
<p>b.get类</p>
</li>
</ol>
<p>方法<br>描述<br>getDate()<br>从 Date 对象返回一个月中的某一天 (1 ~ 31)。<br>getDay()<br>从 Date 对象返回一周中的某一天 (0 ~ 6)。<br>getFullYear()<br>从 Date 对象以四位数字返回年份。<br>getHours()<br>返回 Date 对象的小时 (0 ~ 23)。<br>getMilliseconds()<br>返回 Date 对象的毫秒(0 ~ 999)。<br>getMinutes()<br>返回 Date 对象的分钟 (0 ~ 59)。<br>getMonth()<br>从 Date 对象返回月份 (0 ~ 11)。<br>getSeconds()<br>返回 Date 对象的秒数 (0 ~ 59)。<br>getTime()<br>返回 1970 年 1 月 1 日至今的毫秒数。</p>
<p>c.set类<br>    setDate(date)：设置实例对象对应的每个月的几号（1-31），返回改变后毫秒时间戳。<br>    setYear(year): 设置距离1900年的年数。<br>    setFullYear(year [, month, date])：设置四位年份。<br>    setHours(hour [, min, sec, ms])：设置小时（0-23）。<br>    setMilliseconds()：设置毫秒（0-999）。<br>    setMinutes(min [, sec, ms])：设置分钟（0-59）。<br>    setMonth(month [, date])：设置月份（0-11）。<br>    setSeconds(sec [, ms])：设置秒（0-59）。<br>    setTime(milliseconds)：设置毫秒时间戳。</p>
<p>RegExp对象<br>1.正则表达式：一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用作按照“给定模式”匹配文本的工具。<br>2.参照Perl5建立起来的<br>3.两种方法来建立正则表达式：<br>    a.使用字面量，以斜杠表示开始和结束</p>
<ol>
<li>var regex = /xyz/;<br> b.使用RegExp构造函数</li>
<li>var regex = new RegExp(‘xyz’);<br> 注：它们的主要区别是，第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。<br> 4.RegExp构造函数还可以接受第二个参数，表示修饰符</li>
<li>var regex = new RegExp(‘xyz’, “i”);</li>
<li>// 等价于</li>
<li>var regex = /xyz/i;<br> 5.正则对象生成以后，有两种使用方式：<blockquote>
<p>正则对象的方法：将字符串作为参数，比如regex.test(string)。<br>字符串对象的方法：将正则对象作为参数，比如string.match(regex)。<br> 6.属性：正则对象的属性分成两类。<br>  a.一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置<br>ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。<br>global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。<br>multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。</p>
</blockquote>
</li>
<li>var r = /abc/igm;</li>
<li>r.ignoreCase // true</li>
<li>r.global // true</li>
<li>r.multiline // true<br> b.修饰符无关的属性，主要是下面两个。<blockquote>
<p>lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。<br>source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</p>
</blockquote>
</li>
<li>var r = /abc/igm;</li>
<li>r.lastIndex // 0</li>
<li>r.source // “abc”<br>7.方法<br> a.test():返回一个布尔值，表示当前模式是否能匹配参数字符串</li>
<li>/cat/.test(‘cats and dogs’) // true<br> 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。</li>
<li>var r = /x/g;</li>
<li>var s = ‘<em>x</em>x’;</li>
<li>r.lastIndex // 0</li>
<li>r.test(s) // true</li>
<li>r.lastIndex // 2</li>
<li>r.test(s) // true</li>
<li>r.lastIndex // 4</li>
<li>r.test(s) // false<br> 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。</li>
<li>var r = /x/g;</li>
<li>var s = ‘<em>x</em>x’;</li>
<li>r.lastIndex = 4;</li>
<li>r.test(s) // false<br> 如果正则模式是一个空字符串，则匹配所有字符串。</li>
<li>new RegExp(‘’).test(‘abc’)</li>
<li>// true<br> b.exec():可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。</li>
<li>var s = ‘<em>x</em>x’;</li>
<li>var r1 = /x/;</li>
<li>var r2 = /y/;</li>
<li>r1.exec(s) // 成功：[“x”]</li>
<li>r2.exec(s) // 失败：null<br> 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。</li>
<li>var s = ‘<em>x</em>x’;</li>
<li>var r = /_(x)/;</li>
<li>r.exec(s) // [“_x”, “x”]</li>
<li>//第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。<pre><code>返回数组还包含以下两个属性：
 &gt;input：整个原字符串。
 &gt;index：整个模式匹配成功的开始位置（从0开始计数）。</code></pre></li>
<li>var r = /a(b+)a/;</li>
<li>var arr = r.exec(‘<em>abbba_aba</em>‘);</li>
<li>arr // [“abbba”, “bbb”]</li>
<li>arr.index // 1</li>
<li>arr.input // “<em>abbba_aba</em>“<pre><code>如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</code></pre></li>
<li>var r = /a(b+)a/g;</li>
<li>var a1 = r.exec(‘<em>abbba_aba</em>‘);</li>
<li>a1 // [‘abbba’, ‘bbb’]</li>
<li>a1.index // 1</li>
<li>r.lastIndex // 6</li>
<li>var a2 = r.exec(‘<em>abbba_aba</em>‘);</li>
<li>a2 // [‘aba’, ‘b’]</li>
<li>a2.index // 7</li>
<li>r.lastIndex // 10</li>
<li>var a3 = r.exec(‘<em>abbba_aba</em>‘);</li>
<li>a3 // null</li>
<li>a3.index // TypeError: Cannot read property ‘index’ of null</li>
<li>r.lastIndex // 0</li>
<li>var a4 = r.exec(‘<em>abbba_aba</em>‘);</li>
<li>a4 // [‘abbba’, ‘bbb’]</li>
<li>a4.index // 1</li>
<li>r.lastIndex // 6<br>8.字符串方法<pre><code>字符串对象的方法之中，有4种与正则对象有关。
 &gt;match()：返回一个数组，成员是所有匹配的子字符串。
 &gt;search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。
 &gt;replace()：按照给定的正则表达式进行替换，返回替换后的字符串。
 &gt;split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。
a.match():对字符串进行正则匹配，返回匹配结果。</code></pre></li>
<li>var s = ‘<em>x</em>x’;</li>
<li>var r1 = /x/;</li>
<li>var r2 = /y/;</li>
<li>s.match(r1) // [“x”]</li>
<li>s.match(r2) // null<pre><code>字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。</code></pre></li>
<li>var s = ‘abba’;</li>
<li>var r = /a/g;</li>
<li>s.match(r) // [“a”, “a”]</li>
<li>r.exec(s) // [“a”]<pre><code>设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。</code></pre></li>
<li>var r = /a|b/g;</li>
<li>r.lastIndex = 7;</li>
<li>‘xaxb’.match(r) // [‘a’, ‘b’]</li>
<li>r.lastIndex // 0<br> b.search():返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。</li>
<li>‘<em>x</em>x’.search(/x/)</li>
<li>// 1<br> 该方法会忽略g修饰符。</li>
<li>var r = /x/g;</li>
<li>r.lastIndex = 2; // 无效</li>
<li>‘<em>x</em>x’.search(r) // 1<br> c.replace():可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。<pre><code>搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</code></pre></li>
<li>‘aaa’.replace(‘a’, ‘b’) // “baa”</li>
<li>‘aaa’.replace(/a/, ‘b’) // “baa”</li>
<li>‘aaa’.replace(/a/g, ‘b’) // “bbb”<pre><code>消除字符串首尾两端的空格。</code></pre></li>
<li>var str = ‘ #id div.class ‘;</li>
<li>str.replace(/^\s+|\s+$/g, ‘’)</li>
<li>// “#id div.class”<pre><code>replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。
 &gt;$&amp; 指代匹配的子字符串。
 &gt;$` 指代匹配结果前面的文本。
 &gt;$&apos; 指代匹配结果后面的文本。
 &gt;$n 指代匹配成功的第n组内容，n是从1开始的自然数。
 &gt;$$ 指代美元符号$。</code></pre></li>
<li>‘hello world’.replace(/(\w+)\s(\w+)/, ‘$2 $1’)</li>
<li>// “world hello”</li>
<li>‘abc’.replace(‘b’, ‘[$`-$&amp;-$&#39;]’)</li>
<li>// “a[a-b-c]c”<pre><code>replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。</code></pre></li>
<li>‘3 and 5’.replace(/[0-9]+/g, function(match){</li>
<li>return 2 * match;</li>
<li>})</li>
<li>// “6 and 10”</li>
<li>var a = ‘The quick brown fox jumped over the lazy dog.’;</li>
<li>var pattern = /quick|brown|lazy/ig;</li>
<li>a.replace(pattern, function replacer(match) {</li>
<li>return match.toUpperCase();</li>
<li>});</li>
<li>// The QUICK BROWN fox jumped over the LAZY dog.<pre><code>作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</code></pre></li>
<li>var prices = {</li>
<li>‘pr_1’: ‘$1.99’,</li>
<li>‘pr_2’: ‘$9.99’,</li>
<li>‘pr_3’: ‘$5.00’</li>
<li>};</li>
<li>var template = ‘/* … */‘; // 这里可以放网页模块字符串</li>
<li>template.replace(</li>
<li>/(<span id=")(.*?)(">)(&lt;/span&gt;)/g,</li>
<li>function(match, $1, $2, $3, $4){</li>
<li>return $1 + $2 + $3 + prices[$2] + $4;</li>
<li>}</li>
<li>);<pre><code>d.split():按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组    str.split(separator, [limit])
该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。</code></pre></li>
<li>// 非正则分隔</li>
<li>‘a, b,c, d’.split(‘,’)</li>
<li>// [ ‘a’, ‘ b’, ‘c’, ‘ d’ ]</li>
<li>// 正则分隔，去除多余的空格</li>
<li>‘a, b,c, d’.split(/, */)</li>
<li>// [ ‘a’, ‘b’, ‘c’, ‘d’ ]</li>
<li>// 指定返回数组的最大成员</li>
<li>‘a, b,c, d’.split(/, */, 2)</li>
<li>[ ‘a’, ‘b’ ]<pre><code>上面代码使用正则表达式，去除了子字符串的逗号后面的空格。</code></pre></li>
<li>// 例一</li>
<li>‘aaa<em>a</em>‘.split(/a*/)</li>
<li>// [ ‘’, ‘<em>‘, ‘</em>‘ ]</li>
<li>// 例二</li>
<li>‘aaa<em>*a</em>‘.split(/a*/)</li>
<li>// [“”, “*”, “*”, “*”]<br> 9.匹配规则<pre><code>9.1字面量字符和元字符
 a.点符号：点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。
 b.位置字符: 位置字符用来提示字符所处的位置，主要有两个字符。
  &gt;^ 表示字符串的开始位置
  &gt;$ 表示字符串的结束位置</code></pre></li>
<li>// test必须出现在开始位置</li>
<li>/^test/.test(‘test123’) // true</li>
<li>// test必须出现在结束位置</li>
<li>/test$/.test(‘new test’) // true</li>
<li>// 从开始位置到结束位置只有test</li>
<li>/^test$/.test(‘test’) // true</li>
<li>/^test$/.test(‘test test’) // false<pre><code>c.选择符（|）:在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。</code></pre></li>
<li>/11|22/.test(‘911’) // true<pre><code>选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。</code></pre></li>
<li>/a( |\t)b/.test(‘a\tb’) // true<br> 9.2转义符<pre><code>正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</code></pre> 9.3特殊字符<pre><code>正则表达式对一些不能打印的特殊字符，提供了表达方法。
  &gt;\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。
  &gt;[\b] 匹配退格键(U+0008)，不要与\b混淆。
  &gt;\n 匹配换行键。
  &gt;\r 匹配回车键。
  &gt;\t 匹配制表符tab（U+0009）。
  &gt;\v 匹配垂直制表符（U+000B）。
  &gt;\f 匹配换页符（U+000C）。
  &gt;\0 匹配null字符（U+0000）。
  &gt;\xhh 匹配一个以两位十六进制数（\x00-\xFF）表示的字符。
  &gt;\uhhhh 匹配一个以四位十六进制数（\u0000-\uFFFF）表示的unicode字符。</code></pre> 9.4字符类（class）<pre><code>表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</code></pre></li>
<li>/[abc]/.test(‘hello world’) // false</li>
<li>/[abc]/.test(‘apple’) // true<br> 有两个字符在字符类中有特殊含义。<br>（1）脱字符（^）<pre><code>如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。</code></pre></li>
<li>/[^abc]/.test(‘hello world’) // true</li>
<li>/[^abc]/.test(‘bbc’) // false<pre><code>如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。</code></pre></li>
<li>var s = ‘Please yes\nmake my day!’;</li>
<li>s.match(/yes.*day/) // null</li>
<li>s.match(/yes[^]*day/) // [ ‘yes\nmake my day’]<pre><code>注：注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</code></pre> （2）连字符（-）<pre><code>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</code></pre></li>
<li>/a-z/.test(‘b’) // false</li>
<li>/[a-z]/.test(‘b’) // true<pre><code>当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列。</code></pre></li>
<li>以下都是合法的字符类简写形式。</li>
<li>[0-9.,]</li>
<li>[0-9a-fA-F]</li>
<li>[a-zA-Z0-9-]</li>
<li>[1-31]    //不代表1到31，只代表1到3。<pre><code>注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。
不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母，但是由于在ASCII编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。</code></pre></li>
<li>/[A-z]/.test(‘\‘) // true<br> 9.5预定义模式<pre><code>预定义模式指的是某些常见模式的简写方式。
&gt;\d 匹配0-9之间的任一数字，相当于[0-9]。
&gt;\D 匹配所有0-9以外的字符，相当于[^0-9]。
&gt;\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。
&gt;\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。
&gt;\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。
&gt;\S 匹配非空格的字符，相当于[^\t\r\n\v\f]。
&gt;\b 匹配词的边界。
&gt;\B 匹配非词边界，即在词的内部。</code></pre></li>
<li>// \s的例子</li>
<li>/\s\w*/.exec(‘hello world’) // [“ world”]</li>
<li>// \b的例子</li>
<li>/\bworld/.test(‘hello world’) // true</li>
<li>/\bworld/.test(‘hello-world’) // true</li>
<li>/\bworld/.test(‘helloworld’) // false</li>
<li>// \B的例子</li>
<li>/\Bworld/.test(‘hello-world’) // false</li>
<li>/\Bworld/.test(‘helloworld’) // true<pre><code>通常，正则表达式遇到换行符（\n）就会停止匹配。</code></pre></li>
<li>var html = “<b>Hello</b>\n<i>world!</i>“;</li>
<li>/.*/.exec(html)[0]</li>
<li>// “<b>Hello</b>“<pre><code>上面代码中，字符串html包含一个换行符，结果点字符（.）不匹配换行符，导致匹配结果可能不符合原意。这时使用\s字符类，就能包括换行符。</code></pre></li>
<li>var html = “<b>Hello</b>\n<i>world!</i>“;</li>
<li>/[\S\s]*/.exec(html)[0]</li>
<li>// “<b>Hello</b>\n<i>world!</i>“</li>
<li>// 另一种写法（用到了非捕获组）</li>
<li>/(?:.|\s)*/.exec(html)[0]</li>
<li>// “<b>Hello</b>\n<i>world!</i>“<pre><code>上面代码中，[\S\s]指代一切字符。</code></pre> 9.6重复类<pre><code>模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</code></pre></li>
<li>/lo{2}k/.test(‘look’) // true</li>
<li>/lo{2, 5}k/.test(‘looook’) // true<br> 9.7量词符<pre><code>量词符用来设定某个模式出现的次数。
  &gt;? 问号表示某个模式出现0次或1次，等同于{0, 1}。
  &gt;* 星号表示某个模式出现0次或多次，等同于{0,}。
  &gt;+ 加号表示某个模式出现1次或多次，等同于{1,}。</code></pre></li>
<li>// t出现0次或1次</li>
<li>/t?est/.test(‘test’) // true</li>
<li>/t?est/.test(‘est’) // true</li>
<li>// t出现1次或多次</li>
<li>/t+est/.test(‘test”) // true</li>
<li>/t+est/.test(‘ttest’) // true</li>
<li>/t+est/.test(‘est’) // false</li>
<li>// t出现0次或多次</li>
<li>/t*est/.test(‘test’) // true</li>
<li>/t*est/.test(‘ttest’) // true</li>
<li>/t*est/.test(‘tttest’) // true</li>
<li>/t*est/.test(‘est’) // true<br>9.8贪婪模式<br>   上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。</li>
<li>var s = ‘aaa’;</li>
<li>s.match(/a+/) // [“aaa”]<pre><code>模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。</code></pre></li>
<li>var s = ‘aaa’;</li>
<li>s.match(/a+?/) // [“a”]<pre><code> 模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。
除了非贪婪模式的加号，还有非贪婪模式的星号（*）。
  &gt;*?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。
  &gt;+?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。</code></pre> 9.9修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。<pre><code>修饰符可以单个使用，也可以多个一起使用。</code></pre>  （1）g修饰符<pre><code>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</code></pre></li>
<li>var regex = /b/;</li>
<li>var str = ‘abba’;</li>
<li>regex.test(str); // true</li>
<li>regex.test(str); // true</li>
<li>regex.test(str); // true<pre><code>上面代码中，正则模式不含g修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。</code></pre></li>
<li>var regex = /b/g;</li>
<li>var str = ‘abba’;</li>
<li>regex.test(str); // true</li>
<li>regex.test(str); // true</li>
<li>regex.test(str); // false<pre><code>（2）i修饰符    默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。</code></pre></li>
<li>/abc/.test(‘ABC’) // false</li>
<li>/abc/i.test(‘ABC’) // true<pre><code>（3）m修饰符
   m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\n）。</code></pre></li>
<li>/world$/.test(‘hello world\n’) // false</li>
<li>/world$/m.test(‘hello world\n’) // true<br> 9.10组匹配<br>（1）概述<pre><code>正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。</code></pre></li>
<li>/fred+/.test(‘fredd’) // true</li>
<li>/(fred)+/.test(‘fredfred’) // true<pre><code>第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配“fred”这个词。</code></pre> （2）非捕获组<pre><code>(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。
非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。</code></pre></li>
<li>var m = ‘abc’.match(/(?:.)b(.)/);</li>
<li>m // [“abc”, “c”]<pre><code>下面是用来分解网址的正则表达式。</code></pre></li>
<li>// 正常匹配</li>
<li>var url = /(http|ftp)://([^/\r\n]+)(/[^\r\n]*)?/;</li>
<li>url.exec(‘<a href="http://google.com/&#39;" target="_blank" rel="noopener">http://google.com/&#39;</a>);</li>
<li>// [“<a href="http://google.com/&quot;" target="_blank" rel="noopener">http://google.com/&quot;</a>, “http”, “google.com”, “/“]</li>
<li>// 非捕获组匹配</li>
<li>var url = /(?:http|ftp)://([^/\r\n]+)(/[^\r\n]*)?/;</li>
<li>url.exec(‘<a href="http://google.com/&#39;" target="_blank" rel="noopener">http://google.com/&#39;</a>);</li>
<li>// [“<a href="http://google.com/&quot;" target="_blank" rel="noopener">http://google.com/&quot;</a>, “google.com”, “/“]<pre><code>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</code></pre> （3）先行断言<pre><code>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\d+(?=%)/。
“先行断言”中，括号里的部分是不会返回的。</code></pre></li>
<li>var m = ‘abc’.match(/b(?=c)/);</li>
<li>m // [“b”]<br> （4）先行否定断言<pre><code>x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\d+(?!%)/。</code></pre></li>
<li>/\d+(?!.)/.exec(‘3.14’)</li>
<li>// [“14”]<pre><code>“先行否定断言”中，括号里的部分是不会返回的。</code></pre></li>
<li>var m = ‘abd’.match(/b(?!c)/);</li>
<li>m // [‘b’]</li>
</ol>
<p>*</p>
<p>修饰符<br>描述<br>i<br>执行对大小写不敏感的匹配。<br>g<br>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。<br>m<br>执行多行匹配。</p>
<p>方括号用于查找某个范围内的字符：</p>
<p>表达式<br>描述<br>[abc]<br>查找方括号之间的任何字符。<br>[0-9]<br>查找任何从 0 至 9 的数字。<br>(x|y)<br>查找任何以 | 分隔的选项。</p>
<p>元字符是拥有特殊含义的字符</p>
<p>元字符<br>描述<br>\d<br>查找数字。<br>\s<br>查找空白字符。<br>\b<br>匹配单词边界。<br>\uxxxx<br>查找以十六进制数 xxxx 规定的 Unicode 字符。</p>
<p>量词</p>
<p>量词<br>描述<br>n+<br>匹配任何包含至少一个 n 的字符串。<br>n*<br>匹配任何包含零个或多个 n 的字符串。<br>n?<br>匹配任何包含零个或一个 n 的字符串。</p>
<p>Json对象<br>    1.JSON对值的类型和格式有严格的规定。<br>     &gt;复合类型的值只能是数组或对象，不能是函数、正则表达式对象、日期对象。<br>     &gt;简单类型的值只有四种：字符串、数值（必须以十进制表示）、布尔值和null（不能使用NaN, Infinity, -Infinity和undefined）。<br>     &gt;字符串必须使用双引号表示，不能使用单引号。<br>     &gt;对象的键名必须放在双引号里面。<br>     &gt;数组或对象最后一个成员的后面，不能加逗号。<br>            JSON 语法规则<br>    数据为 键/值 对。<br>    数据由逗号分隔。<br>    大括号保存对象<br>    方括号保存数组<br>     2.JSON.stringify()<br>         2.1基本用法<br>           JSON.stringify方法用于将一个值转为字符串。该字符串符合 JSON 格式，并且可以被JSON.parse方法还原。</p>
<ol>
<li>JSON.stringify(‘abc’) // “”abc””</li>
<li>JSON.stringify(1) // “1”</li>
<li>JSON.stringify(false) // “false”</li>
<li>JSON.stringify([]) // “[]”</li>
<li>JSON.stringify({}) // “{}”</li>
<li>JSON.stringify([1, “false”, false])</li>
<li>// ‘[1,”false”,false]’</li>
<li>JSON.stringify({ name: “张三” })</li>
<li>// ‘{“name”:”张三”}’<pre><code>需要注意的是，对于原始类型的字符串，转换结果会带双引号。</code></pre></li>
<li>JSON.stringify(‘foo’) === “foo” // false</li>
<li>JSON.stringify(‘foo’) === “&quot;foo&quot;“ // true<pre><code>如果原始对象中，有一个成员的值是undefined、函数或 XML 对象，这个成员会被过滤。</code></pre></li>
<li>var obj = {</li>
<li>a: undefined,</li>
<li>b: function () {}</li>
<li>};</li>
<li>JSON.stringify(obj) // “{}”<pre><code>如果数组的成员是undefined、函数或 XML 对象，则这些值被转成null。</code></pre></li>
<li>var arr = [undefined, function () {}];</li>
<li>JSON.stringify(arr) // “[null,null]”<pre><code>正则对象会被转成空对象。</code></pre></li>
<li>JSON.stringify(/foo/) // “{}”<pre><code>JSON.stringify方法会忽略对象的不可遍历属性。</code></pre></li>
<li>var obj = {};</li>
<li>Object.defineProperties(obj, {</li>
<li>‘foo’: {</li>
<li>value: 1,</li>
<li>enumerable: true</li>
<li>},</li>
<li>‘bar’: {</li>
<li>value: 2,</li>
<li>enumerable: false</li>
<li>}</li>
<li>});</li>
<li>JSON.stringify(obj); // “{“foo”:1}”<pre><code>2.2第二个参数</code></pre>   JSON.stringify方法还可以接受一个数组，作为第二个参数，指定需要转成字符串的属性。</li>
<li>var obj = {</li>
<li>‘prop1’: ‘value1’,</li>
<li>‘prop2’: ‘value2’,</li>
<li>‘prop3’: ‘value3’</li>
<li>};</li>
<li>var selectedProperties = [‘prop1’, ‘prop2’];</li>
<li>JSON.stringify(obj, selectedProperties)</li>
<li>// “{“prop1”:”value1”,”prop2”:”value2”}”<pre><code>这个类似“白名单”的数组，只对对象的属性有效，对数组无效。</code></pre></li>
<li>JSON.stringify([‘a’, ‘b’], [‘0’])</li>
<li>// “[“a”,”b”]”</li>
<li>JSON.stringify({0: ‘a’, 1: ‘b’}, [‘0’])</li>
<li>// “{“0”:”a”}”<pre><code>第二个参数还可以是一个函数，用来更改JSON.stringify的默认行为。</code></pre></li>
<li>function f(key, value) {</li>
<li>if (typeof value === “number”) {</li>
<li>value = 2 * value;</li>
<li>}</li>
<li>return value;</li>
<li>}</li>
<li>JSON.stringify({ a: 1, b: 2 }, f)</li>
<li>// ‘{“a”: 2,”b”: 4}’<pre><code>2.3第三个参数
   JSON.stringify还可以接受第三个参数，用于增加返回的JSON字符串的可读性。如果是数字，表示每个属性前面添加的空格（最多不超过10个）；如果是字符串（不超过10个字符），则该字符串会添加在每行前面。</code></pre></li>
<li>JSON.stringify({ p1: 1, p2: 2 }, null, 2);</li>
<li>/*</li>
<li>“{</li>
<li>“p1”: 1,</li>
<li>“p2”: 2</li>
<li>}”</li>
<li>*/</li>
<li>JSON.stringify({ p1:1, p2:2 }, null, ‘|-‘);</li>
<li>/*</li>
<li>“{</li>
<li>|-“p1”: 1,</li>
<li>|-“p2”: 2</li>
<li>}”</li>
<li>*/<pre><code>2.4toJSON 方法
   如果JSON.stringify的参数对象有自定义的toJSON方法，那么JSON.stringify会使用这个方法的返回值作为参数，而忽略原对象的其他属性。</code></pre></li>
<li>var user = {</li>
<li>firstName: ‘三’,</li>
<li>lastName: ‘张’,</li>
<li>get fullName(){</li>
<li>return this.lastName + this.firstName;</li>
<li>}</li>
<li>};</li>
<li>JSON.stringify(user)</li>
<li>// “{“firstName”:”三”,”lastName”:”张”,”fullName”:”三张”}”<pre><code>现在，为这个对象加上toJSON方法。</code></pre></li>
<li>var user = {</li>
<li>firstName: ‘三’,</li>
<li>lastName: ‘张’,</li>
<li>get fullName(){</li>
<li>return this.lastName + this.firstName;</li>
<li>},</li>
<li>toJSON: function () {</li>
<li>var data = {</li>
<li>firstName: this.firstName,</li>
<li>lastName: this.lastName</li>
<li>};</li>
<li>return data;</li>
<li>}</li>
<li>};</li>
<li>JSON.stringify(user)</li>
<li>// “{“firstName”:”三”,”lastName”:”张”}”<pre><code>toJSON方法的一个应用是，将正则对象自动转为字符串。因为JSON.stringify默认不能转换正则对象，但是设置了toJSON方法以后，就可以转换正则对象了。</code></pre></li>
<li>var obj = {</li>
<li>reg: /foo/</li>
<li>};</li>
<li>// 不设置 toJSON 方法时</li>
<li>JSON.stringify(obj) // “{“reg”:{}}”</li>
<li>// 设置 toJSON 方法时</li>
<li>RegExp.prototype.toJSON = RegExp.prototype.toString;</li>
<li>JSON.stringify(/foo/) // “”/foo/“”<br> 3.JSON.parse方法用于将JSON字符串转化成对象。</li>
<li>JSON.parse(‘{}’) // {}</li>
<li>JSON.parse(‘true’) // true</li>
<li>JSON.parse(‘“foo”‘) // “foo”</li>
<li>JSON.parse(‘[1, 5, “false”]’) // [1, 5, “false”]</li>
<li>JSON.parse(‘null’) // null</li>
<li>var o = JSON.parse(‘{“name”: “张三”}’);</li>
<li>o.name // 张三<pre><code>如果传入的字符串不是有效的JSON格式，JSON.parse方法将报错</code></pre></li>
<li>JSON.parse(“‘String’”) // illegal single quotes</li>
<li>// SyntaxError: Unexpected token ILLEGAL<pre><code>为了处理解析错误，可以将JSON.parse方法放在try...catch代码块中。JSON.parse方法可以接受一个处理函数，用法与JSON.stringify方法类似。</code></pre></li>
<li>function f(key, value) {</li>
<li>if (key === ‘’){</li>
<li>return value;</li>
<li>}</li>
<li>if (key === ‘a’) {</li>
<li>return value + 10;</li>
<li>}</li>
<li>}</li>
<li>var o = JSON.parse(‘{“a”:1,”b”:2}’, f);</li>
<li>o.a // 11</li>
<li>o.b // undefined</li>
</ol>
<h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><ol>
<li>概述</li>
</ol>
<p>1.1对象的概念<br>“对象”是单个实物的抽象。<br>“对象”是一个容器，封装了“属性”（property）和“方法”（method）。</p>
<p>1.2构造函数<br>a.所谓“构造函数”，就是专门用来生成“对象”的函数。它提供模板，描述对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。<br>            b.构造函数的特点有两个。<br>             &gt;函数体内部使用了this关键字，代表了所要生成的对象实例。<br>             &gt;生成对象的时候，必需用new命令，调用Vehicle函数。</p>
<ol>
<li>var Vehicle = function () {</li>
<li>this.price = 1000;</li>
<li>};<pre><code>1.3new命令
    a.new命令的作用，就是执行构造函数，返回一个实例对象。</code></pre></li>
<li>var Vehicle = function (){</li>
<li>this.price = 1000;</li>
<li>};</li>
<li>var v = new Vehicle();</li>
<li>v.price // 1000<pre><code>使用new命令时，根据需要，构造函数也可以接受参数。</code></pre></li>
<li>var Vehicle = function (p) {</li>
<li>this.price = p;</li>
<li>};</li>
<li>var v = new Vehicle(500);<pre><code> 一个很自然的问题是，如果忘了使用new命令，直接调用构造函数会发生什么事？
这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，this这时代表全局对象，将造成一些意想不到的结果。</code></pre></li>
<li>var Vehicle = function (){</li>
<li>this.price = 1000;</li>
<li>};</li>
<li>var v = Vehicle();</li>
<li>v.price</li>
<li>// Uncaught TypeError: Cannot read property ‘price’ of undefined</li>
<li>price</li>
<li>// 1000<pre><code>为了保证构造函数必须与new命令一起使用，
&gt;一个解决办法是，在构造函数内部使用严格模式，即第一行加上use strict。</code></pre></li>
<li>function Fubar(foo, bar){</li>
<li>‘use strict’;</li>
<li>this._foo = foo;</li>
<li>this._bar = bar;</li>
<li>}</li>
<li>Fubar()</li>
<li>// TypeError: Cannot set property ‘_foo’ of undefined<pre><code>&gt;另一个解决办法，是在构造函数内部判断是否使用new命令，如果发现没有使用，则直接返回一个实例对象。</code></pre></li>
<li>function Fubar(foo, bar){</li>
<li>if (!(this instanceof Fubar)) {</li>
<li>return new Fubar(foo, bar);</li>
<li>}</li>
<li>this._foo = foo;</li>
<li>this._bar = bar;</li>
<li>}</li>
<li>Fubar(1, 2)._foo // 1</li>
<li>(new Fubar(1, 2))._foo // 1<pre><code>b.new命令的原理
    使用new命令时，它后面的函数调用就不是正常的调用，而是依次执行下面的步骤。
     &gt;1创建一个空对象，作为将要返回的对象实例
     &gt;2将这个空对象的原型，指向构造函数的prototype属性
     &gt;3将这个空对象赋值给函数内部的this关键字
     &gt;4开始执行构造函数内部的代码
如果构造函数内部有return语句，而且return后面跟着一个对象，new命令会返回return语句指定的对象；否则，就会不管return语句，返回this对象。</code></pre></li>
<li>var Vehicle = function () {</li>
<li>this.price = 1000;</li>
<li>return 1000;</li>
<li>};</li>
<li>(new Vehicle()) === 1000</li>
<li>// false<pre><code>但是，如果return语句返回的是一个跟this无关的新对象，new命令会返回这个新对象，而不是this对象。这一点需要特别引起注意。</code></pre></li>
<li>var Vehicle = function (){</li>
<li>this.price = 1000;</li>
<li>return { price: 2000 };</li>
<li>};</li>
<li>(new Vehicle()).price</li>
<li>// 2000<pre><code>另一方面，如果对普通函数（内部没有this关键字的函数）使用new命令，则会返回一个空对象。</code></pre></li>
<li>function getMessage() {</li>
<li>return ‘this is a message’;</li>
<li>}</li>
<li>var msg = new getMessage();</li>
<li>msg // {}</li>
<li>typeof msg // “Object”<pre><code>new命令简化的内部流程，可以用下面的代码表示。</code></pre></li>
<li>function _new(/* 构造函数 <em>/ constructor, /</em> 构造函数参数 */ param1) {</li>
<li>// 将 arguments 对象转为数组</li>
<li>var args = [].slice.call(arguments);</li>
<li>// 取出构造函数</li>
<li>var constructor = args.shift();</li>
<li>// 创建一个空对象，继承构造函数的 prototype 属性</li>
<li>var context = Object.create(constructor.prototype);</li>
<li>// 执行构造函数</li>
<li>var result = constructor.apply(context, args);</li>
<li>// 如果返回结果是对象，就直接返回，则返回 context 对象</li>
<li>return (typeof result === ‘object’ &amp;&amp; result != null) ? result : context;</li>
<li>}</li>
<li>// 实例</li>
<li>var actor = _new(Person, ‘张三’, 28);<pre><code>c.new.target
   函数内部可以使用new.target属性。如果当前函数是new命令调用，new.target指向当前函数，否则为undefined。</code></pre></li>
<li>function f() {</li>
<li>console.log(new.target === f);</li>
<li>}</li>
<li>f() // false</li>
<li>new f() // true</li>
<li>this 关键字<pre><code>a.this总是返回一个对象，简单说，就是返回属性或方法“当前”所在的对象.this就代表property属性当前所在的对象。
   由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即this的指向是可变的。</code></pre></li>
<li>var A = {</li>
<li>name: ‘张三’,</li>
<li>describe: function () {</li>
<li>return ‘姓名：’+ this.name;</li>
<li>}</li>
<li>};</li>
<li>var B = {</li>
<li>name: ‘李四’</li>
<li>};</li>
<li>B.describe = A.describe;</li>
<li>B.describe()</li>
<li>// “姓名：李四”</li>
<li>function f() {</li>
<li>return ‘姓名：’+ this.name;</li>
<li>}</li>
<li>var A = {</li>
<li>name: ‘张三’,</li>
<li>describe: f</li>
<li>};</li>
<li>var B = {</li>
<li>name: ‘李四’,</li>
<li>describe: f</li>
<li>};</li>
<li>A.describe() // “姓名：张三”</li>
<li>B.describe() // “姓名：李四”</li>
<li>var A = {</li>
<li>name: ‘张三’,</li>
<li>describe: function () {</li>
<li>return ‘姓名：’+ this.name;</li>
<li>}</li>
<li>};</li>
<li>var name = ‘李四’;</li>
<li>var f = A.describe;    //顶层对象</li>
<li>f() // “姓名：李四”<pre><code>如果一个函数在全局环境中运行，那么this就是指顶层对象</code></pre> b.使用场合<pre><code>b.1全局环境：在全局环境使用this，它指的就是顶层对象window。
b.2构造函数中的this，指的是实例对象。
b.3 对象的方法
   当A对象的方法被赋予B对象，该方法中的this就从指向A对象变成了指向B对象。所以要特别小心，将某个对象的方法赋值给另一个对象，会改变this的指向。
b.4 Node
   在Node中，this的指向又分成两种情况。全局环境中，this指向全局对象global；模块环境中，this指向module.exports。</code></pre> c.使用注意到<pre><code>c.1 避免多层this
   由于this的指向是不确定的，所以切勿在函数中包含多层的this。</code></pre></li>
<li>var o = {</li>
<li>f1: function () {</li>
<li>console.log(this);</li>
<li>var f2 = function () {</li>
<li>console.log(this);</li>
<li>}();</li>
<li>}</li>
<li>}</li>
<li>o.f1()</li>
<li>// Object</li>
<li>// Window<pre><code>一个解决方法是在第二层改用一个指向外层this的变量。</code></pre></li>
<li>var o = {</li>
<li>f1: function() {</li>
<li>console.log(this);</li>
<li>var that = this;</li>
<li>var f2 = function() {</li>
<li>console.log(that);</li>
<li>}();</li>
<li>}</li>
<li>}</li>
<li>o.f1()</li>
<li>// Object</li>
<li>// Object</li>
</ol>
<p>prototype 对象<br>Object 对象与继承<br>面向对象编程的模式<br>语法专题<br>单线程模型<br>定时器<br>Promise<br>严格模式<br>DOM模型<br>Document节点<br>Element节点<br>属性的操作<br>Text节点和DocumentFragment节点<br>事件模型<br>事件类型<br>CSS操作<br>Mutation Observer</p>
<p>浏览器环境</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.writeln(<span class="string">'ceshi'</span>);</span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">"&lt;h1&gt;This is a heading&lt;/h1&gt;"</span>);</span><br><span class="line">&lt;button type=<span class="string">"button"</span> onclick=<span class="string">"alert('Welcome!')"</span>&gt;点击这里&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">x=document.getElementById("demo") /</span><span class="regexp">/查找元素</span></span><br><span class="line"><span class="regexp">x.innerHTML="Hello JavaScript"; /</span><span class="regexp">/改变内容</span></span><br><span class="line"><span class="regexp">x=document.getElementById("demo") /</span><span class="regexp">/找到元素</span></span><br><span class="line"><span class="regexp">x.style.color="#ff0000"; /</span><span class="regexp">/改变样式</span></span><br><span class="line"><span class="regexp">if isNaN(x) &#123;alert("Not Numeric")&#125;; /</span><span class="regexp">/验证输入</span></span><br><span class="line"><span class="regexp">function myFunction()&#123;</span></span><br><span class="line"><span class="regexp">    document.getElementById("demo").innerHTML="My First JavaScript Function";</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>window对象<br>History对象<br>Cookie<br>Web Storage：浏览器端数据储存机制</p>
<ul>
<li>同源策略<br>同源策略需要同时满足以下三点要求：<br>1）协议相同<br>2）域名相同<br>3）端口相同</li>
</ul>
<p>Ajax<br>CORS<br>IndexedDB：浏览器端数据库<br>Web Notification API<br>Performance API<br>移动设备API<br>事件<br>    onmousedown 和 onmouseup<br>    onload<br>    onfocus<br>网页api<br>Canvas<br>SVG图像<br>表单<br>文件与二进制数据的操作<br>Web Worker<br>SSE：服务器发送事件<br>Page Visiblity<br>FullScreen API：全屏操作<br>Web Speech<br>requestAnimationFrame<br>WebSocket<br>WebRTC<br>Web Components<br>前端工程<br>Node.js</p>

      </div>
      
      
      
    </div>
    
  <ul class="breadcrumb">
          
            <li><a href="/man/">MAN</a></li>
            <li><a href="/man/js/">JS</a></li>
            <li>JS</li>
          
  </ul>

    
    
    


          </div>
          
    <div class="comments" id="gitalk-container"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#2017-11-01"><span class="nav-text">2017.11.01</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#x-6"><span class="nav-text">x&#x3D;6</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#x-15"><span class="nav-text">x&#x3D;15</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BE%8B%E5%AD%90"><span class="nav-text">例子</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#x-8-%E4%B8%BA-false"><span class="nav-text">x&#x3D;&#x3D;8 为 false</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Array%E5%AF%B9%E8%B1%A1"><span class="nav-text">Array对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Number%E5%AF%B9%E8%B1%A1"><span class="nav-text">Number对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#String%E5%AF%B9%E8%B1%A1"><span class="nav-text">String对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B"><span class="nav-text">面向对象编程</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">hackfox</p>
  <div class="site-description" itemprop="description">架构、AI、python、rust</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">28</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
        <span class="site-state-item-count">24</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xsoer" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xsoer" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:codehackfox@gmail.com" title="E-Mail → mailto:codehackfox@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://stackoverflow.com/users/5746784/hackfox-code" title="StackOverflow → https:&#x2F;&#x2F;stackoverflow.com&#x2F;users&#x2F;5746784&#x2F;hackfox-code" rel="noopener" target="_blank"><i class="fab fa-stack-overflow fa-fw"></i>StackOverflow</a>
      </span>
  </div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" class="cc-opacity" rel="noopener" target="_blank"><img src="/undefined/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://hackfox.vip/" title="http:&#x2F;&#x2F;hackfox.vip" rel="noopener" target="_blank">hackfox</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">hackfox</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">126k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">1:54</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/theme-next/theme-next-pjax@0/pjax.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/medium-zoom@1/dist/medium-zoom.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/lozad@1/dist/lozad.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/pangu@4/dist/browser/pangu.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  




  
<script src="/js/local-search.js"></script>













    <div id="pjax">
  

  

<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css">

<script>
NexT.utils.loadComments(document.querySelector('#gitalk-container'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js', () => {
    var gitalk = new Gitalk({
      clientID    : '7c7b02623259a39014a0',
      clientSecret: '07c01a3277dab0956ad91bad7d24b91a7e773990',
      repo        : 'xsoer.github.io',
      owner       : 'xsoer',
      admin       : ['xsoer'],
      id          : '552a13081d1ebaa446b1f145841a2483',
        language: 'zh-CN',
      distractionFreeMode: true
    });
    gitalk.render('gitalk-container');
  }, window.Gitalk);
});
</script>

    </div>
</body>
</html>
