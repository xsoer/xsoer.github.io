<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>mysql数据库主从同步</title>
    <url>/2019/03/10/2015/03-10-mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<h2 id="一、同步配置"><a href="#一、同步配置" class="headerlink" title="一、同步配置"></a>一、同步配置</h2><ul>
<li><p>1.主库和从库创建同步账户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; grant replication slave, replication client on *.* to repl@<span class="string">'192.168.1.%'</span> identified by <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.主库配置/etc/my.cnf</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server-id=130	<span class="comment">#保证唯一值</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">binlog-do-db=test2</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="built_in">log</span>-error=/var/lib/mysql/mysql.err</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.重启主库</p>
</li>
<li><p>4.查看主库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt;show master status;</span><br><span class="line">+-------------------------+-----------------+--------------------+-------------------------+</span><br><span class="line">| File            |	 Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+-------------------------+----------------+--------------------+--------------------------+</span><br><span class="line">| mysql-bin.000002 |      120 |   test2      |   mysql        |</span><br><span class="line">+-------------------------+----------------+---------------------+------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.从库配置 /etc/my.cnf</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">server-id=131 #保证唯一值</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">replicate-do-db=test2</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">relay_log=/var/lib/mysql/mysql-relay-bin</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.重启从库</p>
</li>
<li><p>7.指向主库操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash"> change master to master_host=<span class="string">'192.168.1.201'</span>,</span></span><br><span class="line">master_user='repl',</span><br><span class="line">master_password='123456',</span><br><span class="line">master_log_file='mysql-bin.000002',</span><br><span class="line">master_log_pos=120;</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.开始同步</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash">start slave;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>9.查看状态</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">mysql&gt;</span><span class="bash">show slave status;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>10.双向主从的话，把主库按照从库在配置一遍即可</p>
</li>
</ul>
<h2 id="二、常见问题"><a href="#二、常见问题" class="headerlink" title="二、常见问题"></a>二、常见问题</h2><ul>
<li>1.两个数据库版本尽量一致，如果不一致，高版本做从库，此时不可双向主从</li>
<li>2.主库和从库的数据库名必须相同；</li>
<li>3.主库和从库的复制可以精确到表，但是在需要更改主库或从库的数据结构时需要立刻重启slave；</li>
<li>4.不能在mysql配置文件里直接写入master的配置信息，需要用change master命令来完成；</li>
<li>5.指定replicate_do_db必须在my.ini里配置，不能用change master命令来完成；</li>
<li>6.如果不及时清理，日积月累二进制日志文件可能会把磁盘空间占满，可以在配置文件里加上expire_logs_days=7，只保留最近7天的日志，建议当slave不再使用时，通过reset slave来取消relaylog；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构</title>
    <url>/2015/03/10/2015/03-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h2 id="0x00、基本结构：集合、线性结构、树形结构、图状结构"><a href="#0x00、基本结构：集合、线性结构、树形结构、图状结构" class="headerlink" title="0x00、基本结构：集合、线性结构、树形结构、图状结构"></a>0x00、基本结构：集合、线性结构、树形结构、图状结构</h2><ul>
<li>数据结构往往同高效的检索算法和索引技术有关，是介于数学、计算机硬件和计算机软件三者之间的一门核心课程</li>
<li>集合结构:除了同属于一种类型外，别无其它关系</li>
<li>线性结构:元素之间存在一对一关系常见类型有:数组,链表,队列,栈,它们之间在操作上有所区别。例如:链表可在任意位置插入或删除元素,而队列在队尾插入元素,队头删除元素,栈只能在栈顶进行插入,删除操作.</li>
<li>树形结构:元素之间存在一对多的关系,常见类型有:树(有许多特例:二叉树、平衡二叉树、查找树等)</li>
<li>图形结构:元素之间存在多对多的关系,图形结构中每个结点的前驱结点数和后续结点多个数可以任意</li>
</ul>
<h2 id="0x01、常用数据结构"><a href="#0x01、常用数据结构" class="headerlink" title="0x01、常用数据结构"></a>0x01、常用数据结构</h2><ul>
<li>数组（静态数组、动态数组）</li>
<li>线性表</li>
<li>链表（单向链表、双向链表、循环链表）</li>
<li>队栈</li>
<li>散列表</li>
<li>树（二叉树、查找树、平衡树、线索、堆）</li>
<li>图等的定义、存储和操作</li>
</ul>
<h2 id="0x02、数组"><a href="#0x02、数组" class="headerlink" title="0x02、数组"></a>0x02、数组</h2><ul>
<li>PHP的数组和其他语言不同之处是键可以为字符串，而且语言都是整型值</li>
<li>关于数组的问题及解法<ul>
<li>数组的循环移动</li>
<li>最长递增子序列</li>
<li>和最大的子数组</li>
<li>寻找最大的前K个元素</li>
<li>数组分裂</li>
<li>乘积最大的子数组</li>
<li>最快速度求两个数组之交集算法</li>
<li>查找第二大数的算法</li>
<li>蛇形输出数组</li>
</ul>
</li>
</ul>
<h2 id="0x03、线性表"><a href="#0x03、线性表" class="headerlink" title="0x03、线性表"></a>0x03、线性表</h2><ul>
<li>list</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP数组函数</title>
    <url>/2015/07/05/2015/07-05-php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li><p>1.生成数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">array</span>()  []</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.判断该值是否存在</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">isset</span>($arr[$i])</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.判断是否是数组、</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">is_array($arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.从尾部往数组内添加值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_push($arr,$a)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.从头部往数组内插入</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_unshift</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.弹出数组最后一个</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_pop</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.弹出数组第一个</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_shift</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.产生一个从0到6的数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">range(<span class="number">0</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.检验是否在数组内</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">in_array($a,$arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.返回数组的所有键值</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_keys()</span><br></pre></td></tr></table></figure>
</li>
<li><p>11.改变键值为大写 或者CASE_LOWER 小写</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_change_key_case($arr1,CASE_UPPER)</span><br></pre></td></tr></table></figure>
</li>
<li><p>12.合并两个或多个数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_merge()</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.给数组排序，升序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">sort($arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.查询数组内元素的个数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">count()</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.用一个函数过滤数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">array_filter($arr,$fun)</span><br></pre></td></tr></table></figure>
</li>
<li><p>16.输出数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">print_r()</span><br></pre></td></tr></table></figure>
</li>
<li><p>17.遍历数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($arr <span class="keyword">as</span> $k)</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.list遍历数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">list</span>($key,$value)==each($arr))</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.去除字符串中的逗号，转为数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">explode(<span class="string">','</span>,$arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>20.将数组转为字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">implode(<span class="string">','</span>,$arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>21.按键排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">ksort()</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.按值排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">asort()</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.降序排序</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">rsort($arr)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP字符串操作</title>
    <url>/2015/06/12/2015/06-12-php%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<ul>
<li><p>1.打印输出</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//有返回值、只能输出一个、可以用在表达式中</span></span><br><span class="line"><span class="keyword">print</span>()</span><br><span class="line"><span class="comment">//无返回值、能输出多个、不能用于表达式中</span></span><br><span class="line"><span class="keyword">echo</span>()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.去除两边的空格</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">trim($strs)</span><br><span class="line"><span class="comment">//去除右边的空格</span></span><br><span class="line">rtrim($strs)</span><br><span class="line"><span class="comment">//去除左边的空格</span></span><br><span class="line">ltrim($strs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.点链接字符串(.)</p>
</li>
<li><p>4.求字符串长度</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strlen($strs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.分割字符串为数组</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">explode(<span class="string">','</span>,$strs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.分割数组为字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">implode(<span class="string">','</span>,$arr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.转换字符串大小写</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strtoupper($strs),strtolower($strs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.比较两个对象是否相等</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">!=、==</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.比较两个对象及值是否相等</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">!== 、===</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.区分大小写比较字符串，前者大于后者返回大于零的数，小于返回小于零的数，相等则返回零</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strcmp($str1,$str2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>11.不区分大小写比较字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strcasecmp($str1,$str2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>12.区分大小写比较前n个字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strncmp($str1,$str2,n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.不区分大小写比较前n个字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strncasecmp($str1,$str2,n)</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.区分大小写替换字符串内的字符</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">str_replace($oldstr,$newstr,$strs)</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.字符串查找</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strstr($strs,$findstr)</span><br></pre></td></tr></table></figure>
</li>
<li><p>16.将字符串内特殊的字符转换为html内的字符</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">htmlspecialchars($str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>17.md5加密</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">md5($str)</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.反转字符串</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strrev($str)</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>运维技能</title>
    <url>/2015/10/01/2015/10-01-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/</url>
    <content><![CDATA[<h2 id="0x00、初级运维"><a href="#0x00、初级运维" class="headerlink" title="0x00、初级运维"></a>0x00、初级运维</h2><ul>
<li>1.CPU、内存、磁盘、IO、文件系统</li>
<li>2.系统安装：设备选择、规划磁盘分区、定制化安装</li>
<li>3.基础知识：基本命令、文本编辑器、用户与组、权限管理</li>
<li>4.磁盘管理：磁盘分区和文件系统、磁盘阵列管理、逻辑卷管理</li>
<li>5.软件管理：软件安装、服务管理、进程管理</li>
</ul>
<h2 id="0x01、中级运维"><a href="#0x01、中级运维" class="headerlink" title="0x01、中级运维"></a>0x01、中级运维</h2><ul>
<li>1.开源、GNU、GPL、POSIX、Linux内核、RAID、RAID等级、磁盘、磁盘原理、块、超级块、文件系统、i节点</li>
<li>2.shell<ul>
<li>1.基础入门<ul>
<li>1)shell的基本组成与参数</li>
<li>2)执行跟踪和调优排错</li>
</ul>
</li>
<li>2.shell脚本<ul>
<li>1)输入输出重定向</li>
<li>2)分割和管道</li>
<li>3)增强管道能力：find、grep等</li>
<li>4)shell变量和返回值</li>
<li>5)字符串操作</li>
<li>6)条件判断、循环</li>
<li>7)分支、函数、块输入</li>
<li>8)shell文件处理</li>
</ul>
</li>
<li>3.正则表达式<ul>
<li>1)基本概念</li>
<li>2)基本元字符</li>
<li>3)正则表达式总的分组</li>
</ul>
</li>
<li>4.sed与awk<ul>
<li>1)sed与awk的概念</li>
<li>2)sed工作模式</li>
<li>3)sed中的正则</li>
<li>4)awk中的模式与动作</li>
<li>5)awk的域和记录</li>
<li>6)awk中的正则</li>
<li>7)awk管道与重定向</li>
<li>8)awk格式化输出</li>
<li>9)awk变量与函数</li>
</ul>
</li>
</ul>
</li>
<li>3.LAMP<ul>
<li>1.APACHE<ul>
<li>1)APACHE安装与配置</li>
<li>2)profork与workert</li>
<li>3)apache模块</li>
</ul>
</li>
<li>2.mysql<ul>
<li>1)mysql安装与配置</li>
<li>2)SQL语句与管理工具</li>
<li>3)存储引擎与索引</li>
<li>4)单机运行多实例</li>
<li>5)mysql主从复制</li>
<li>6)mysql cluster</li>
</ul>
</li>
<li>3.php<ul>
<li>1)php安装与配置</li>
<li>2)phpize</li>
<li>3)session与cookie</li>
<li>4)php操作数据库</li>
</ul>
</li>
<li>4.lamp整合<ul>
<li>1)编译整合</li>
<li>2)FASTCGI</li>
</ul>
</li>
<li>5.性能测试<ul>
<li>1)性能测试原则</li>
<li>2)apache自带工具：ab</li>
<li>3)吞吐量与负载测试工具：http_load</li>
<li>4)使用curl进行更细致的测试</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x02、高级运维"><a href="#0x02、高级运维" class="headerlink" title="0x02、高级运维"></a>0x02、高级运维</h2><ul>
<li>1.大数据<ul>
<li>1)Hadoop</li>
<li>2)HDFS</li>
<li>3)Hbase</li>
</ul>
</li>
<li>2.云计算<ul>
<li>1)Saas、PaaS、Iaas</li>
<li>2)OpenStack的组件</li>
<li>3)部署管理OpenStack的私有云</li>
</ul>
</li>
<li>3.优化<ul>
<li>1)系统调用</li>
<li>2)应用优化</li>
<li>3)数据库优化</li>
<li>4)分布式缓存</li>
</ul>
</li>
<li>4.运维平台<ul>
<li>1)监控：Nagios、Cacti、Zabbix</li>
<li>2)自动化：cobbier、Puppet、SaltStack</li>
<li>3)自动化平台编写：python、html</li>
</ul>
</li>
<li>5.负载均衡<ul>
<li>1)DNS负载均衡</li>
<li>2)Nginx负载均衡</li>
<li>3)Haproxy负载均衡</li>
<li>4)LVS负载均衡</li>
</ul>
</li>
<li>6.反向代理<ul>
<li>1)squid反向代理</li>
<li>2)varish反向代理</li>
<li>3)DNS视图和CND实现</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>运维</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql性能优化建议</title>
    <url>/2015/12/28/2015/12-28-mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</url>
    <content><![CDATA[<ul>
<li>1.为查询缓存优化你的查询(curdata(),rand(),no()无法进行优化)；</li>
<li>2.explain你的查询；</li>
<li>3.当只要一行数据时使用limit 1；</li>
<li>4.为搜索字段建立索引；</li>
<li>5.在join表的时候使用相当类型的列，并将其索引</li>
<li>6.千万不要order by rand();</li>
<li>7.避免select *；</li>
<li>8.用于为每张表设置一个id，尽量为unsigned int类型；</li>
<li>9.使用enum而不是varchar;</li>
<li>10.从procedure  analyse()取得建议；</li>
<li>11.尽可能的使用not null;</li>
<li>12.Prepared  Statements;</li>
<li>13.把ip地址存成UNSIGNED INT</li>
<li>14.固定长度表会更快；</li>
<li>15.垂直分割；</li>
<li>16.拆分大的delete或insert语句；</li>
<li>17.越小的列会越快；</li>
<li>18.选择正确的存储引擎；</li>
<li>19.使用一个对象关系映射器（ORM）；</li>
<li>20.小心“永久链接”；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>VIM使用文档总结</title>
    <url>/2017/03/02/2017/03-12-vim%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><p>向下添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+f</span><br></pre></td></tr></table></figure>
</li>
<li><p>向上翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+b</span><br></pre></td></tr></table></figure>
</li>
<li><p>下一个词</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure>
</li>
<li><p>行尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个字符行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^</span><br></pre></td></tr></table></figure>
</li>
<li><p>行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gg</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">G</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+h</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+m</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+l</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>VIM</category>
      </categories>
      <tags>
        <tag>VIM</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql常用语句</title>
    <url>/2019/03/10/2016/03-10-mysql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<ul>
<li><p>1.授权用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'zxc'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'ydp#2015$Z!!!'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.远程连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -h127.0.0.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.导出数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysqldump -h127.0.0.1 -P3306 -uroot -p sqsx &gt; sqsx.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.导入数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p sqsx &lt; sqsx.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.分析查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from user;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.查询所有的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show procelist;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.建数据库语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database dbname default character <span class="built_in">set</span> utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.创建数据表语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table dbname.tablename () engine=Innodb charset=utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.删除数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop database dbname;</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.查看数据库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; use dbname;</span><br><span class="line">mysql&gt; status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>11.查看参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like “%sql%”;</span><br></pre></td></tr></table></figure>
</li>
<li><p>12.查看事件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show events;</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.查看触发器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show triggers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.查看所有参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.查看打开表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show open tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>16.查看表状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show table status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>17.查看主数据状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.查看从数据库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.查看函数状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">function</span> status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>20.查看插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show plugins;</span><br></pre></td></tr></table></figure>
</li>
<li><p>21.查看某用户的授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show grants <span class="keyword">for</span> username;</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.查看错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show errors;</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.查看创建表语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table tablename;</span><br></pre></td></tr></table></figure>
</li>
<li><p>24.查看表头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show columns from tablename;</span><br></pre></td></tr></table></figure>
</li>
<li><p>25.查看存储引擎</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>
</li>
<li><p>26.查看表状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show table status;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2016/12/24/2016/12-24-git%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<ul>
<li><strong><code>git init</code></strong>                                #git 初始化仓库</li>
<li><strong><code>git clone remote_url</code></strong>                    #git 克隆远程库</li>
<li><strong><code>git add .</code></strong>                               #git  添加所有文件</li>
<li><strong><code>git commit -m &quot;批注&quot;</code></strong>                     #git 提交</li>
<li><strong><code>git push &lt;remoteName&gt; &lt;localName&gt;</code></strong>       #git推送至远程</li>
<li><strong><code>git remote add origin &lt;server&gt;</code></strong>          #远程没有创建仓库，将本地推送到远程仓库</li>
<li><strong><code>git checkout -b branch_name</code></strong>             #创建分支，并切换到分支</li>
<li><strong><code>git checkout master</code></strong>                     #切换到主分支</li>
<li><strong><code>git branch -d &lt;branch_name&gt;</code></strong>             #删除分支</li>
<li><strong><code>git pull &lt;remoteName&gt; &lt;localName&gt;</code></strong>        #将本地仓库更新至最新</li>
<li><strong><code>git merge branch_name</code></strong>                    #将其他分支合并到本地主分支</li>
<li><strong><code>git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</code></strong> #比对分支</li>
<li><strong><code>git tag &lt;tag_name&gt;</code></strong>                      #创建标签</li>
<li><strong><code>git show</code></strong></li>
<li><strong><code>git status</code></strong>                              #查看当前状态</li>
<li><strong><code>git fetch</code></strong>                               #合并</li>
<li><strong><code>git config --list</code></strong>                       #查看配置信息</li>
<li><strong><code>git rm &lt;file_name&gt;</code></strong>                      #删除文件</li>
<li><strong><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code></strong>            #重命名文件</li>
<li><strong><code>git log</code></strong>                                 #查看日志</li>
<li><strong><code>git rebase HEAD &lt;file_name&gt;</code></strong>             #重置</li>
<li><strong><code>git remote -v</code></strong>                           #查看远程仓库</li>
<li><strong><code>git remote rm &lt;file_name&gt;</code></strong>               #删除远程仓库</li>
<li><strong><code>git branch</code></strong>                              #查看本地分支</li>
<li><strong><code>git branch -r</code></strong>                           #查看远程分支</li>
<li><strong><code>git branch &lt;branch_name&gt;</code></strong>                #创建本地分支</li>
<li><strong><code>git config --global user.name NEWNAME</code></strong>   #修改用户名</li>
<li><strong><code>git config --global user.email NEWEMAIL</code></strong> #修改用户邮箱</li>
</ul>
]]></content>
      <categories>
        <category>GIT</category>
      </categories>
      <tags>
        <tag>GIT</tag>
      </tags>
  </entry>
  <entry>
    <title>docker常用命令</title>
    <url>/2018/05/18/2018/05-18-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="0x00、常用命令"><a href="#0x00、常用命令" class="headerlink" title="0x00、常用命令"></a>0x00、常用命令</h2><ul>
<li>查看容器重启次数<ul>
<li>docker inspect -f “ .RestartCount “ container_id</li>
</ul>
</li>
<li>查看容器最后一次的启动时间<ul>
<li>docker inspect -f “ .State.StartedAt ” container_id</li>
</ul>
</li>
<li>commit一个镜像<ul>
<li>docker run –name=”python_env_l” -it image_name /bin/bash</li>
<li>docker commit -m=”msg” -a=”user_name” 4631e1627784 image_name:2.1</li>
<li>docker tag  image_name:2.1 image_name:latest</li>
<li>docker push image_name</li>
</ul>
</li>
<li>Docker构建镜像<ul>
<li>docker build -t imageName .</li>
</ul>
</li>
<li>打标签<ul>
<li>Docker tag image user/newName:tag</li>
</ul>
</li>
<li>批量删除无用镜像<ul>
<li>docker image rm <code>docker images|grep none|awk {&#39;print $3&#39;}</code></li>
</ul>
</li>
<li>批量删除无用容器<ul>
<li>sudo docker rm <code>sudo docker ps -a |grep Exited| awk {&#39;print $1&#39;}</code></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>crontab表示法</title>
    <url>/2017/07/20/2017/07-20-crontab%E8%A1%A8%E7%A4%BA%E6%B3%95/</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>crontab是linux上的定时任务工具，用来做定时管理服务。其常用的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l <span class="comment"># 罗列出当前用户的所有定时任务列表</span></span><br><span class="line">crontab -e <span class="comment"># 编辑定时任务</span></span><br><span class="line">crontab -r <span class="comment"># 删除定时任务</span></span><br></pre></td></tr></table></figure>

<p>当然，最重要的还是如何使用cron来表示什么时候什么频次来执行任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*  *  * *  *   <span class="built_in">command</span></span><br><span class="line">分 时 日 月 周   命令</span><br></pre></td></tr></table></figure>

<p>如上表示，有5个位置符来表示，后边跟需要执行的命令。</p>
<ul>
<li>第一列：分(0-59)</li>
<li>第二列：时(0-23)</li>
<li>第三列：日(1-31)</li>
<li>第四列：月(1-12)</li>
<li>第五列：周(0-6,0为星期天)</li>
</ul>
<p>除了以上的表示方法，还可以结合一些特殊的符号来表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* ：   表示任何时刻</span><br><span class="line">, ：   表示在这几个选项内</span><br><span class="line">－ ：  表示一个范围，如第二列里： 3-5，就表示3到5点</span><br><span class="line">/n ：  表示每个n的单位执行一次，如第二列里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.</span><br></pre></td></tr></table></figure>

<h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * *                           每分钟执行一次</span><br><span class="line">0 */1 * * *                         每分钟执行一次</span><br><span class="line">43 21 * * *                         21:43 执行</span><br><span class="line">15 05 * * *                         05:15 执行</span><br><span class="line">0 17 * * *                          17:00 执行</span><br><span class="line">0 17 * * 1                          每周一的 17:00 执行</span><br><span class="line">0,10 17 * * 0,2,3                   每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="line">0-10 17 1 * *                       毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="line">0 0 1,15 * 1                        毎月1日和 15日和 一日的 0:00 执行</span><br><span class="line">42 4 1 * *                          毎月1日的 4:42分 执行</span><br><span class="line">0 21 * * 1-6                        周一到周六 21:00 执行</span><br><span class="line">0,10,20,30,40,50 * * * *            每隔10分 执行</span><br><span class="line">*/10 * * * *                        每隔10分 执行</span><br><span class="line">* 1 * * *                           从1:0到1:59 每隔1分钟 执行</span><br><span class="line">0 1 * * *                           1:00 执行</span><br><span class="line">0 * * * *                           毎时0分 每隔1小时 执行</span><br><span class="line">2 8-20/3 * * *                      8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="line">30 5 1,15 * *                       1日 和 15日的 5:30 执行</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>行与列式数据库</title>
    <url>/2018/08/10/2018/08-10-%E8%A1%8C%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    <content><![CDATA[<h1 id="行与列式数据库"><a href="#行与列式数据库" class="headerlink" title="行与列式数据库"></a>行与列式数据库</h1><ul>
<li>作者：<a href="mailto:codehackfox@gmail.com" target="_blank" rel="noopener">codehackfox@gmail.com</a></li>
<li>时间：2018-08-10 13:23:49</li>
</ul>
<h2 id="0x00、简介"><a href="#0x00、简介" class="headerlink" title="0x00、简介"></a>0x00、简介</h2><h5 id="行式数据库"><a href="#行式数据库" class="headerlink" title="行式数据库"></a>行式数据库</h5><ul>
<li>平常用的结构化关系型数据库，比如mysql、sqlserver等</li>
<li>一行为一条数据，进行记录存储</li>
<li>可以进行join查询，可以进行笛卡尔积运算</li>
</ul>
<h5 id="列式数据库"><a href="#列式数据库" class="headerlink" title="列式数据库"></a>列式数据库</h5><ul>
<li>列式数据库是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。</li>
<li>特点<ul>
<li>因为硬盘寻址时间相较于计算机上其他部件的运行速度来说不是一般的慢，所以常用相同工作负载下的硬盘访问性能来比较行数据库和列数据库。通常，顺序读取数据要比随机访问更快。而且，硬盘寻址时间的提升比起CPU速度的进步要慢得多 (参看 摩尔定律)，在使用硬盘作为存储媒介的系统上这种情况很可能还会持续一段时间。下面简单罗列了一些选择行数据库还是列数据库的权衡依据。当然，如果能够把数据全放在内存中，那么使用内存数据库性能会更好。<ul>
<li>1.在只需要根据某几列来聚合数据的时候按列的数据组织方式更有效。因为这样只需要读取一部分数据，要比读取全部数据更快。</li>
<li>2.当只需要修改某一列值的时候按列的数据组织方式更有效。因为可以直接找到某列数据并修改，而与行中的其他列无关。</li>
<li>3.当需要某行的多列数据的时候按行的数据组织方式更有效。当行中数据不是太多的情况下一次硬盘寻址就可以获得该行的所有数据。</li>
<li>4.在新增行数据的时候，如果各列都有值，那么按行的数据组织方式会更有效，因为只需要一次硬盘寻址就可以写入整行的全部数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ul>
<li>面向行的数据存储架构更适用于OLTP-频繁交互事务的场景。</li>
<li>面向列的数据存储架构更适用于OLAP-(如数据仓库)这样在海量数据（(可能达到 terabyte规模)）中进行有限复杂查询的场景。</li>
</ul>
<h2 id="0x01、比较"><a href="#0x01、比较" class="headerlink" title="0x01、比较"></a>0x01、比较</h2><ul>
<li><img src="/assets/images/2018/13022AD3-DD16-4B84-9099-C03E4F10533D.png" alt="13022AD3-DD16-4B84-9099-C03E4F10533D.png"></li>
<li><img src="/assets/images/2018/0CD4C6E1-CAB6-44A4-8875-DA4F1C6FCF57.png" alt="0CD4C6E1-CAB6-44A4-8875-DA4F1C6FCF57.png"></li>
<li>底层存储实例<ul>
<li><img src="/assets/images/2018/773CBA88-4945-40CA-8628-78BE4CF97B5C.jpg" alt="773CBA88-4945-40CA-8628-78BE4CF97B5C.jpg"></li>
<li><img src="/assets/images/2018/FA6212EF-26D1-4AB7-B52C-343F8105A3D6.jpg" alt="FA6212EF-26D1-4AB7-B52C-343F8105A3D6.jpg"></li>
<li><img src="/assets/images/2018/2D9E6EC3-D366-4087-A92F-C9CF9A2BC238.jpg" alt="2D9E6EC3-D366-4087-A92F-C9CF9A2BC238.jpg"></li>
</ul>
</li>
<li>随机读与顺序读<ul>
<li><img src="/assets/images/2018/CA0D0CF0-F150-47DD-A98F-8BAB0D9B0A02.jpg" alt="CA0D0CF0-F150-47DD-A98F-8BAB0D9B0A02.jpg"></li>
</ul>
</li>
</ul>
<h2 id="0x02、优缺点"><a href="#0x02、优缺点" class="headerlink" title="0x02、优缺点"></a>0x02、优缺点</h2><h5 id="列数据库"><a href="#列数据库" class="headerlink" title="列数据库"></a>列数据库</h5><ul>
<li>优点：<ul>
<li>极高的装载速度（最高可以等于所有硬盘IO 的总和，基本是极限了）</li>
<li>适合大量的数据而不是小数据</li>
<li>实时加载数据仅限于增加（删除和更新需要解压缩Block 然后计算然后重新压缩储存</li>
<li>高效的压缩率，不仅节省储存空间也节省计算内存和CPU。</li>
<li>非常适合做聚合操作。</li>
</ul>
</li>
<li>缺点：<ul>
<li>不适合扫描小量数据</li>
<li>不适合随机的更新</li>
<li>批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。</li>
<li>不适合做含有删除和更新的实时操作</li>
</ul>
</li>
</ul>
<h5 id="行数据库"><a href="#行数据库" class="headerlink" title="行数据库"></a>行数据库</h5><ul>
<li>优点<ul>
<li>适合频繁的增删改数据</li>
<li>小量数据的频繁维护和简单统计</li>
</ul>
</li>
<li>缺点<ul>
<li>不适合做统计类操作</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>系统开机自检</title>
    <url>/2017/09/28/2017/09-28-%E5%BC%80%E6%9C%BA%E8%87%AA%E6%A3%80/</url>
    <content><![CDATA[<h2 id="0x00、关于开机自动检测硬盘的原因"><a href="#0x00、关于开机自动检测硬盘的原因" class="headerlink" title="0x00、关于开机自动检测硬盘的原因"></a>0x00、关于开机自动检测硬盘的原因</h2><ul>
<li>第一种：是你非法关机造成的，比如直接断电的情况。</li>
<li>第二种：是和硬盘的分区格式有关，FAT32格式在非法关机后会在开机时要求检测硬盘，而且必须检测完毕才不会在下次启动时重新检测。系统有一个文件中记录了检测是否结束的信息，有时即使检测完成了也会因为这个文件没有更新而在下次开机时重新检测。</li>
<li>第三种：当硬盘出现坏道也会出现开机自动检测硬盘。</li>
</ul>
<h2 id="0x01、关于取消开机自动检测硬盘的方法"><a href="#0x01、关于取消开机自动检测硬盘的方法" class="headerlink" title="0x01、关于取消开机自动检测硬盘的方法"></a>0x01、关于取消开机自动检测硬盘的方法</h2><ul>
<li>方法一： 如果分区是FAT32格式，将其转换成NTFS，方法是在命令提示符下输入：convert X: /fs:ntfs</li>
<li>方法二： 如果是非正常的关机，然后开机检测时又跳过了，每一次都会运行的。如果不是这个原因的话，您就要检查一下D盘状态是否正常，修正一下硬盘的错误。方法为 “开始”→”运行”，在窗口中输入”chkdskX:/f”(x为盘符)，这个命令可以检查文件系统中的逻辑错误，并进行修复；然后启动”磁盘碎片整理” 对相应的磁盘进行碎片整理，可以消除再次的磁盘扫描。如果还是不行，就可能是硬盘出现了坏道，最简单的方法是把D盘的数据备份一下，然后格式化D盘，就可 以正常使用了。</li>
<li>方法三：打开”我的电脑”－右键点击X盘选择”属性”－选择”工具”－”查错”中点”开始检查”－选中”自动修复文件系统错误”和”扫描并试图恢复坏扇区”，然后点”开始”。</li>
<li>方法四：我们知道系统之所以要对磁盘进行扫描是因为在注册表中设置了”脏”字节。在注册表中找到以下分支:</li>
<li>方法五：如果是硬盘出现坏道，请使用磁盘修复工具进行修复，如使用HDDRegenerate等。</li>
<li>方法六：一定是你在BIOS设置中选择了每次开机都要检测硬盘,所以才这样,和你的电脑配置是没有关系的。解决方法在开机后按DEL进入BIOS选 择Quick Power On Self Test（快速加电自检测），你的一定设为了Enabled了,选择Disabled，将其关闭就行了。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>iterm2配置lzrz</title>
    <url>/2019/03/09/2019/03-09-iterm2%E9%85%8D%E7%BD%AElzrz/</url>
    <content><![CDATA[<h2 id="0x00、安装lzrz"><a href="#0x00、安装lzrz" class="headerlink" title="0x00、安装lzrz"></a>0x00、安装lzrz</h2><ul>
<li><p>1.远程连接的服务器端必须要有sz、rz这两个工具，如果没有，可以执行安装。如在CentOS上安装的命令为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install lrzsz</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.本地安装lzrz工具。</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure>

<h2 id="0x01、本地下载脚本"><a href="#0x01、本地下载脚本" class="headerlink" title="0x01、本地下载脚本"></a>0x01、本地下载脚本</h2><ul>
<li>1.由于sz,rz是基于ZMODEM/YMODEM/XMODEM协议的，所以安装iterm2-zmodem<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/bin</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-send-zmodem.sh</span><br><span class="line">sudo wget https://raw.github.com/mmastrac/iterm2-zmodem/master/iterm2-recv-zmodem.sh</span><br><span class="line">sudo chmod 777 /usr/<span class="built_in">local</span>/bin/iterm2-*</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="0x02、配置iterm2"><a href="#0x02、配置iterm2" class="headerlink" title="0x02、配置iterm2"></a>0x02、配置iterm2</h2><ul>
<li><p>1.打开Item2，点击preferences → profiles，选择某个profile，如Default，之后继续选择advanced → triggers，添加编辑添加如下triggers：<br>(Profiles -&gt; Open Profiles -&gt; Edit Profies -&gt; Advanced -&gt; Triggers -&gt; Edit )</p>
</li>
<li><p>2.rz配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Regular Expression: \*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/<span class="built_in">local</span>/bin/iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.sz配置</p>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Regular Expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: /usr/<span class="built_in">local</span>/bin/iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure>

<h2 id="0x03、配置完毕，进行尝试。"><a href="#0x03、配置完毕，进行尝试。" class="headerlink" title="0x03、配置完毕，进行尝试。"></a>0x03、配置完毕，进行尝试。</h2>]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>python总结</title>
    <url>/2018/12/02/2018/12-02-python%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="0x00、基本概念"><a href="#0x00、基本概念" class="headerlink" title="0x00、基本概念"></a>0x00、基本概念</h2><h2 id="0x01、基本类型"><a href="#0x01、基本类型" class="headerlink" title="0x01、基本类型"></a>0x01、基本类型</h2><ul>
<li>1.数字:numbers<ul>
<li>int,double,float,bool,complex</li>
<li>1)可同时为多个变量赋值</li>
<li>2)一个变量可以通过赋值指向不同类型的对象</li>
<li>3)数值的除法(/)总时返回浮点数，要获得整数用(//)</li>
</ul>
</li>
<li>2.字符串:string<ul>
<li>1)可以用’’或””</li>
<li>2)可以使用()转义</li>
<li>3)不想转义需要字符串前加r</li>
<li>4)可以使用(+)号连接，用(*)可以重复</li>
<li>5)可以使用()连接上下行，也可以用’’’…’’’或”””…”””</li>
<li>6)没有单独的字符，一个字符就是长度为1的字符串</li>
<li>7)可对字符串切片，用冒号切割，形式为：变量[头下标:尾下标]，从左向右以0开始，从右向左以-1开始</li>
<li>8)字符串不能改变</li>
</ul>
</li>
<li>3.列表:list-&gt;[]<ul>
<li>1)写在方括号内，并用逗号隔开</li>
<li>2)元素类型可以不同</li>
<li>3)可以被索引和切片</li>
<li>4)支持串联操作，用(+)操作符</li>
<li>5)列表元素可以改变</li>
<li>6)内置很多方法：如append(i),pop(i),len(),insert(i,x),remove(x),index(i),count(i),sort(),reverse(),copy()</li>
</ul>
</li>
<li>4.元组:tuple-&gt;()<ul>
<li>1)写在圆括号内，用逗号隔开</li>
<li>2)元素类型可以不同</li>
<li>3)可以被索引和切片</li>
<li>4)支持串联操作，用(+)操作符</li>
<li>5)元素不可改变</li>
</ul>
</li>
<li>5.集合：set-&gt;{}<ul>
<li>1)无序不重复元素集</li>
<li>2)基本功能是进行成员关系测试和消除重复元素</li>
<li>3)可以使用大括号或set()函数创建集合；但创建空集合必须用set()函数，因为{}是用来创建字典的</li>
</ul>
</li>
<li>6.字典：Dictionary-&gt;{‘’:’’,…}<ul>
<li>1)一种映射类型，一个无序的键:值对的集合</li>
<li>2)dict()函数直接从键值对序列中构造，也可以进行推导</li>
<li>3)内置很多方法：如clear(),keys(),values()等</li>
<li>4)字典的关键字必须是不可变类型，且不能重复</li>
</ul>
</li>
<li>list,string和tuple都属于sequence(序列)</li>
</ul>
<h2 id="0x02、注释"><a href="#0x02、注释" class="headerlink" title="0x02、注释"></a>0x02、注释</h2><ul>
<li>1.#号单行注释</li>
<li>2.’’’或”””多行注释</li>
</ul>
<h2 id="0x03、格式"><a href="#0x03、格式" class="headerlink" title="0x03、格式"></a>0x03、格式</h2><ul>
<li>1.使用缩进来划分语句，相同缩进数的语句在一起组成一个语句块</li>
<li>2.没有switch-case语句</li>
<li>3.每个条件后都要是用(:)，表示接下来满足条件后要执行的语句</li>
</ul>
<h2 id="0x04、关键字"><a href="#0x04、关键字" class="headerlink" title="0x04、关键字"></a>0x04、关键字</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while,if,else,elif,pass,True,False,None,for,in,do</span><br><span class="line">break,continue,as,del,from,global,import,is,lambda,not,or</span><br><span class="line">class,def,self,return,with,yield,nonlocal</span><br><span class="line">try,except,raise,finally</span><br></pre></td></tr></table></figure>

<h2 id="0x05、操作符"><a href="#0x05、操作符" class="headerlink" title="0x05、操作符"></a>0x05、操作符</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;,&gt;,&lt;=,&gt;=,==,!=</span><br></pre></td></tr></table></figure>

<h2 id="0x06、函数"><a href="#0x06、函数" class="headerlink" title="0x06、函数"></a>0x06、函数</h2><ul>
<li>1.range(begin,end,step):</li>
<li>2.input(“some word”):</li>
<li>3.len()</li>
<li>4.dir()</li>
<li>5.format()</li>
<li>6.open()<ul>
<li>1)f.read()</li>
<li>2)f.write()</li>
<li>3)f.readlines()</li>
<li>4)f.tell()</li>
<li>5)f.feek()</li>
<li>6)f.close()</li>
</ul>
</li>
<li>7.<strong>str</strong></li>
<li>8.<strong>init</strong></li>
<li>9.<strong>del</strong></li>
<li>10.<strong>repr</strong></li>
<li>11.<strong>setitem</strong></li>
<li>12.<strong>getitem</strong></li>
<li>13.<strong>len</strong></li>
<li>14.<strong>cmp</strong></li>
<li>15.<strong>call</strong></li>
<li>16.<strong>add</strong></li>
<li>17.<strong>sub</strong></li>
<li>18.<strong>mul</strong></li>
<li>19.<strong>div</strong></li>
<li>20.<strong>mod</strong></li>
<li>21.<strong>pow</strong></li>
</ul>
<h2 id="0x07、模块"><a href="#0x07、模块" class="headerlink" title="0x07、模块"></a>0x07、模块</h2><ul>
<li>1.conllections<ul>
<li>1)deque</li>
</ul>
</li>
<li>2.sys</li>
<li>3.fibo</li>
<li>4.math</li>
<li>5.os<ul>
<li>1)getcwd()</li>
<li>2)get_exec_path()</li>
<li>3)getenv(‘varname’)</li>
</ul>
</li>
<li>6.re</li>
<li>7.glob</li>
<li>8.urllib</li>
<li>9.smtplib</li>
<li>10.datetime</li>
<li>11.zlib</li>
<li>12.timeit</li>
<li>13.doctest</li>
<li>14.unittest</li>
<li>15.keyword<ul>
<li>1)kwlist</li>
<li>2)iskeyword(‘word’)</li>
</ul>
</li>
<li><strong>name</strong>属性</li>
</ul>
<h2 id="0x08、包"><a href="#0x08、包" class="headerlink" title="0x08、包"></a>0x08、包</h2><h2 id="0x09、特性"><a href="#0x09、特性" class="headerlink" title="0x09、特性"></a>0x09、特性</h2><ul>
<li>1.自动检测递归深度，如果无限太深，会自动停止并抛出异常。</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>python的format使用</title>
    <url>/2018/10/26/2018/10-26-python%E7%9A%84format%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h3 id="0x00、介绍"><a href="#0x00、介绍" class="headerlink" title="0x00、介绍"></a>0x00、介绍</h3><ul>
<li>format优点<ul>
<li>1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型</li>
<li>2.单个参数可以多次输出，参数顺序可以不相同</li>
<li>3.填充方式十分灵活，对齐方式十分强大</li>
<li>4.官方推荐用的方式，%方式将会在后面的版本被淘汰</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(<span class="string">'hello &#123;0&#125;'</span>.format(<span class="string">'world'</span>))</span><br><span class="line"></span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure>

<ul>
<li><p>format格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#format的格式</span></span><br><span class="line">replacement_field ::= <span class="string">"&#123;"</span> [field_name] [<span class="string">"!"</span> conversion] [<span class="string">":"</span> format_spec] <span class="string">"&#125;"</span></span><br><span class="line">field_name ::= arg_name (<span class="string">"."</span> attribute_name | <span class="string">"["</span> element_index <span class="string">"]"</span>)*</span><br><span class="line">arg_name ::= [identifier | integer]</span><br><span class="line">attribute_name ::= identifier</span><br><span class="line">element_index ::= integer | index_string</span><br><span class="line">index_string ::= &lt;any source character <span class="keyword">except</span> <span class="string">"]"</span>&gt; +</span><br><span class="line">conversion ::= <span class="string">"r"</span> | <span class="string">"s"</span> | <span class="string">"a"</span></span><br><span class="line">format_spec ::= &lt;described <span class="keyword">in</span> the next section&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>format_spec 的格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">format_spec 　　::= 　　[[fill]align][sign][<span class="comment">#][0][width][,][.precision][type]</span></span><br><span class="line">fill 　　　　　::= 　　&lt;any character&gt;</span><br><span class="line">align 　　　　::= 　　<span class="string">"&lt;"</span> | <span class="string">"&gt;"</span> | <span class="string">"="</span> | <span class="string">"^"</span></span><br><span class="line">sign 　　　　 ::= 　　<span class="string">"+"</span> | <span class="string">"-"</span> | <span class="string">" "</span></span><br><span class="line">width 　　　　 ::= 　　 integer</span><br><span class="line">precision 　　　　::= 　　 integer</span><br><span class="line">type 　　　　::= 　　<span class="string">"b"</span> | <span class="string">"c"</span> | <span class="string">"d"</span> | <span class="string">"e"</span> | <span class="string">"E"</span> | <span class="string">"f"</span> | <span class="string">"F"</span> | <span class="string">"g"</span> | <span class="string">"G"</span> | <span class="string">"n"</span> | <span class="string">"o"</span> | <span class="string">"s"</span> | <span class="string">"x"</span> | <span class="string">"X"</span> | <span class="string">"%"</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="0x01、应用"><a href="#0x01、应用" class="headerlink" title="0x01、应用"></a>0x01、应用</h3><h4 id="一、填充"><a href="#一、填充" class="headerlink" title="一、填充"></a>一、填充</h4><ul>
<li>1.通过位置来填充字符串</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(<span class="string">'hello &#123;0&#125; i am &#123;1&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))                  <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;&#125; i am &#123;&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))                <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;0&#125; i am &#123;1&#125; . my name is &#123;0&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>)) <span class="comment"># hello Kevin i am Tom . my name is Kevin</span></span><br></pre></td></tr></table></figure>

<ul>
<li>2.通过key来填充</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">print(<span class="string">'hello &#123;name1&#125; i am &#123;name2&#125;'</span>.format(name1=<span class="string">'Kevin'</span>,name2=<span class="string">'Tom'</span>) )    <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>3.通过下标填充</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">names=[<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>]</span><br><span class="line">print(<span class="string">'hello &#123;names[0]&#125; i am &#123;names[1]&#125;'</span>.format(names=names))                  <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;0[0]&#125; i am &#123;0[1]&#125;'</span>.format(names))                                <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>4..通过字典的key    注意访问字典的key，不用引号的</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">names=&#123;<span class="string">'name'</span>:<span class="string">'Kevin'</span>,<span class="string">'name2'</span>:<span class="string">'Tom'</span>&#125;</span><br><span class="line">print(<span class="string">'hello &#123;names[name]&#125; i am &#123;names[name2]&#125;'</span>.format(names=names))    <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>5.通过对象的属性</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Names</span><span class="params">()</span>:</span></span><br><span class="line">    name1=<span class="string">'Kevin'</span></span><br><span class="line">    name2=<span class="string">'Tom'</span></span><br><span class="line">print(<span class="string">'hello &#123;names.name1&#125; i am &#123;names.name2&#125;'</span>.format(names=Names))                  <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure>

<ul>
<li>6.使用魔法参数</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">args=[<span class="string">'lu'</span>]</span><br><span class="line">kwargs = &#123;<span class="string">'name1'</span>: <span class="string">'Kevin'</span>, <span class="string">'name2'</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line">print(<span class="string">'hello &#123;name1&#125; &#123;&#125; i am &#123;name2&#125;'</span>.format(*args, **kwargs))  <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure>

<h4 id="二、格式转换"><a href="#二、格式转换" class="headerlink" title="二、格式转换"></a>二、格式转换</h4><ul>
<li>b、d、o、x分别是二进制、十进制、八进制、十六进制。</li>
</ul>
<table>
<thead>
<tr>
<th>数字</th>
<th>格式</th>
<th>输出</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>3.1415926</td>
<td>{:.2f}</td>
<td>3.14</td>
<td>保留小数点后两位</td>
</tr>
<tr>
<td>3.1415926</td>
<td>{:+.2f}</td>
<td>3.14</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>-1</td>
<td>{:+.2f}</td>
<td>-1</td>
<td>带符号保留小数点后两位</td>
</tr>
<tr>
<td>2.71828</td>
<td>{:.0f}</td>
<td>3</td>
<td>不带小数</td>
</tr>
<tr>
<td>1000000</td>
<td>{:,}</td>
<td>1,000,000</td>
<td>以逗号分隔的数字格式</td>
</tr>
<tr>
<td>0.25</td>
<td>{:.2%}</td>
<td>25.00%</td>
<td>百分比格式</td>
</tr>
<tr>
<td>1000000000</td>
<td>{:.2e}</td>
<td>1.00E+09</td>
<td>指数记法</td>
</tr>
<tr>
<td>25</td>
<td>{0:b}</td>
<td>11001</td>
<td>转换成二进制</td>
</tr>
<tr>
<td>25</td>
<td>{0:d}</td>
<td>25</td>
<td>转换成十进制</td>
</tr>
<tr>
<td>25</td>
<td>{0:o}</td>
<td>31</td>
<td>转换成八进制</td>
</tr>
<tr>
<td>25</td>
<td>{0:x}</td>
<td>19</td>
<td>转换成十六进制</td>
</tr>
</tbody></table>
<h4 id="三、对齐与填充"><a href="#三、对齐与填充" class="headerlink" title="三、对齐与填充"></a>三、对齐与填充</h4><p>|数字|    格式|    输出|    描述|<br>| — | — | — | — | — |<br>|5    |{:0&gt;2}    |05    |数字补零 (填充左边, 宽度为2)|<br>|5    |{:x&lt;4}|5xxx|    数字补x (填充右边, 宽度为4)|<br>|10|{:x^4}|x10x|    数字补x (填充右边, 宽度为4)|<br>|13    |{:10}|13|    右对齐 (默认, 宽度为10)|<br>|13    |{:&lt;10}|13|    左对齐 (宽度为10)|<br>|13    |{:^10}|13|    中间对齐 (宽度为10)|</p>
<h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><ul>
<li><p>1.转义{和}符号</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"\&#123;\&#123; hello &#123;0&#125; \&#125;\&#125;"</span>.format(<span class="string">'Kevin'</span>))</span><br><span class="line"><span class="comment"># 跟%中%%转义%一样，formate中用两个大括号来转义</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.format作为函数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">f = <span class="string">'hello &#123;0&#125; i am &#123;1&#125;'</span>.format</span><br><span class="line">print(f(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.格式化datetime</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">now=datetime.now()</span><br><span class="line">print(<span class="string">'&#123;:%Y-%m-%d %X&#125;'</span>.format(now))</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.{}内嵌{}</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">'hello &#123;0:&gt;&#123;1&#125;&#125; '</span>.format(<span class="string">'Kevin'</span>,<span class="number">50</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.叹号的用法</p>
<ul>
<li>！后面可以加s r a 分别对应str() repr() ascii()</li>
<li>作用是在填充前先用对应的函数来处理参数</li>
<li>差别就是repr带有引号，str()是面向用户的，目的是可读性，repr()是面向python解析器的，返回值表示在python内部的含义<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"&#123;!s&#125;"</span>.format(<span class="string">'2'</span>))  <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"&#123;!r&#125;"</span>.format(<span class="string">'2'</span>))   <span class="comment"># '2'</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6标准概览</title>
    <url>/2019/03/10/2019/03-10-ES6%E6%A0%87%E5%87%86%E6%A6%82%E8%A7%88/</url>
    <content><![CDATA[<h2 id="0x00、变量"><a href="#0x00、变量" class="headerlink" title="0x00、变量"></a>0x00、变量</h2><blockquote>
<p>新增两个关键字：let、const</p>
</blockquote>
<ul>
<li><p>let与var的区别</p>
<ul>
<li>作用域不同()</li>
<li>变量是否可以提升不</li>
</ul>
</li>
<li><p>contst：只读不可改，声明即赋值 其所声明的对象的属性是可以改变的。</p>
</li>
</ul>
<h2 id="0x01、箭头函数"><a href="#0x01、箭头函数" class="headerlink" title="0x01、箭头函数"></a>0x01、箭头函数</h2><p>()-&gt;{</p>
<p>}</p>
<h2 id="0x02、字符串"><a href="#0x02、字符串" class="headerlink" title="0x02、字符串"></a>0x02、字符串</h2><ul>
<li>模版字符串(``)</li>
<li>新增几个方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">'my string'</span>.startsWith(<span class="string">'my'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="string">'my string'</span>.endsWith(<span class="string">'my'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">'my string'</span>.includes(<span class="string">'str'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">'my '</span>.repeat(<span class="number">3</span>); <span class="comment">// 'my my my '</span></span><br></pre></td></tr></table></figure>

<h2 id="0x03、数组"><a href="#0x03、数组" class="headerlink" title="0x03、数组"></a>0x03、数组</h2><blockquote>
<p>Array 对象增加了一些新的静态方法，Array 原型上也增加了一些新方法</p>
</blockquote>
<ul>
<li>from 从类数组和可遍历对象中创建 Array 的实例</li>
<li>find 返回回调返回 true 的第一个元素。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">9</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">8</span>].find(<span class="function"><span class="params">n</span> =&gt;</span> n === <span class="number">10</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>

<ul>
<li>findIndex 返回回调函数返回 true的第一个元素的下标。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">5</span>, <span class="number">1</span>, <span class="number">10</span>, <span class="number">8</span>].findIndex(<span class="function"><span class="params">n</span> =&gt;</span> n === <span class="number">10</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<ul>
<li>fill 用所给参数”覆盖”数组的元素。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>) <span class="comment">// [7, 7, 7]</span></span><br><span class="line">[<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">3</span>) <span class="comment">// [0, 7, 7, 7, 0]</span></span><br></pre></td></tr></table></figure>

<h2 id="0x04、新增Map和Set结构"><a href="#0x04、新增Map和Set结构" class="headerlink" title="0x04、新增Map和Set结构"></a>0x04、新增Map和Set结构</h2><h2 id="0x05、Math新增几个方法"><a href="#0x05、Math新增几个方法" class="headerlink" title="0x05、Math新增几个方法"></a>0x05、Math新增几个方法</h2><ul>
<li>Math.sign 返回数字的符号，结果为 1、-1 或 0。</li>
<li>Math.trunc 返回无小数位的数字</li>
<li>Math.cbrt 返回数字的立方根。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-9</span>); <span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">5.9</span>); <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="number">5.123</span>); <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="number">64</span>); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<h2 id="0x06、扩展运算符-…"><a href="#0x06、扩展运算符-…" class="headerlink" title="0x06、扩展运算符(…)"></a>0x06、扩展运算符(…)</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="keyword">let</span> some = [...values, <span class="number">8</span>]; <span class="comment">// [1, 2, 4, 8]</span></span><br><span class="line"><span class="keyword">let</span> more = [...values, <span class="number">8</span>, ...values]; <span class="comment">// [1, 2, 4, 8, 1, 2, 4]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// Iterate, push, sweat, repeat...</span></span><br><span class="line"><span class="comment">// Iterate, push, sweat, repeat...</span></span><br></pre></td></tr></table></figure>

<p>扩展语法在传参数调用函数时也非常有用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">doSomething(...values);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">   <span class="comment">// x = 1, y = 2, z = 4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line">doSomething.apply(<span class="literal">null</span>, values);</span><br></pre></td></tr></table></figure>

<h2 id="0x07、解构赋值"><a href="#0x07、解构赋值" class="headerlink" title="0x07、解构赋值"></a>0x07、解构赋值</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>]; <span class="comment">// x = 1, y = 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5 equivalent:</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">var</span> x = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> y = arr[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用这个语法，可以一次性给多个变量赋值。一个很好的附加用处是可以很简单地交换变量值：</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>,</span><br><span class="line">    y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x]; <span class="comment">// x = 2, y = 1</span></span><br><span class="line"><span class="comment">//解构也可以用于对象。注意对象中必须存在对应的键：</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;x, y&#125; = obj; <span class="comment">// x = 1, y = 2</span></span><br><span class="line"><span class="comment">//你也可以使用该机制来修改变量名：</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;<span class="attr">x</span>: a, <span class="attr">y</span>: b&#125; = obj; <span class="comment">// a = 1, b = 2</span></span><br><span class="line"><span class="comment">//另一个有趣的模式是模拟多个返回值：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y] = doSomething(); <span class="comment">// x = 1, y = 2</span></span><br><span class="line"><span class="comment">//解构可以用来为参数对象赋默认值。通过对象字面量，可以模拟命名参数：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">&#123;y = <span class="number">1</span>, z = <span class="number">0</span>&#125;</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.log(y, z);</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&#123;<span class="attr">y</span>: <span class="number">2</span>&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="0x08、参数"><a href="#0x08、参数" class="headerlink" title="0x08、参数"></a>0x08、参数</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//可以设置默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x, y = <span class="number">2</span></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(<span class="number">5</span>); <span class="comment">// 10</span></span><br><span class="line">doSomething(<span class="number">5</span>, <span class="literal">undefined</span>); <span class="comment">// 10</span></span><br><span class="line">doSomething(<span class="number">5</span>, <span class="number">3</span>); <span class="comment">// 15</span></span><br><span class="line"><span class="comment">//看起来很简洁，对吧？ 我肯定你之前在 ES5 中曾经需要给某些参数赋默认值：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">   y = y === <span class="literal">undefined</span> ? <span class="number">2</span> : y;</span><br><span class="line">   <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x09、模块"><a href="#0x09、模块" class="headerlink" title="0x09、模块"></a>0x09、模块</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">类的创建围绕 <span class="class"><span class="keyword">class</span> 和 <span class="title">constructor</span> 关键词。以下是个简短的示例：</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">this</span>.name = name;</span><br><span class="line">      <span class="keyword">this</span>.kind = <span class="string">'vehicle'</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   getName() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create an instance</span></span><br><span class="line"><span class="keyword">let</span> myVehicle = <span class="keyword">new</span> Vehicle(<span class="string">'rocky'</span>);</span><br></pre></td></tr></table></figure>

<p>注意类的定义不是一般的对象，因此，类的成员间没有逗号。 创造一个类的对象时，需要使用 new 关键词。继承一个基类时，使用 extends：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">extends</span> <span class="title">Vehicle</span> </span>&#123;</span><br><span class="line">   <span class="keyword">constructor</span>(name) &#123;</span><br><span class="line">      <span class="keyword">super</span>(name);</span><br><span class="line">      <span class="keyword">this</span>.kind = <span class="string">'car'</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCar = <span class="keyword">new</span> Car(<span class="string">'bumpy'</span>);</span><br><span class="line"></span><br><span class="line">myCar.getName(); <span class="comment">// 'bumpy'</span></span><br><span class="line">myCar <span class="keyword">instanceof</span> Car; <span class="comment">// true</span></span><br><span class="line">myCar <span class="keyword">instanceof</span> Vehicle; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>

<p>从衍生类中，你可以使用从任何构造函数或方法中使用 super 来获取它的基类：</p>
<blockquote>
<p>使用 super() 调用父类构造函数。 调用其它成员，举个例子，使用 super.getName() 。</p>
</blockquote>
<h2 id="0x10、记号"><a href="#0x10、记号" class="headerlink" title="0x10、记号"></a>0x10、记号</h2><blockquote>
<p>记号是一个新的原生数据类型，像 Number 和 String 一样。你可以使用记号为对象属性创建唯一标识或创建唯一的常量。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> MY_CONSTANT = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line">obj[MY_CONSTANT] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记号与 const 配合很合适，因为它们都有不可改变的特性。</span></span><br><span class="line"><span class="keyword">const</span> CHINESE = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> ENGLISH = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> SPANISH = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(language) &#123;</span><br><span class="line">   <span class="keyword">case</span> CHINESE:</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> ENGLISH:</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> SPANISH:</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">default</span>:</span><br><span class="line">      <span class="comment">//</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//你可以为 symbol 添加描述。虽然不可以通过描述获取 symbol，但是可用于代码调试。</span></span><br><span class="line"><span class="keyword">const</span> CONST_1 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"><span class="keyword">const</span> CONST_2 = <span class="built_in">Symbol</span>(<span class="string">'my symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> CONST_1 === <span class="string">'symbol'</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">CONST_1 === CONST_2; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>python资源汇总</title>
    <url>/2019/03/10/2019/03-10-python%E8%B5%84%E6%BA%90%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="0x00、图书链接"><a href="#0x00、图书链接" class="headerlink" title="0x00、图书链接"></a>0x00、图书链接</h2><ul>
<li><a href="https://github.com/xsoer/learn-files/tree/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python" target="_blank" rel="noopener">各种图书资源</a></li>
</ul>
<h2 id="0x01、常用库"><a href="#0x01、常用库" class="headerlink" title="0x01、常用库"></a>0x01、常用库</h2><h3 id="01、通用库"><a href="#01、通用库" class="headerlink" title="01、通用库"></a>01、通用库</h3><ul>
<li>urllib<ul>
<li>allows you access websites via your program</li>
<li><a href="https://docs.python.org/3/library/urllib.html" target="_blank" rel="noopener">文档</a></li>
</ul>
</li>
<li>requests -网络库</li>
<li>grab – 网络库（基于pycurl）。</li>
<li>pycurl – 网络库（绑定libcurl）。</li>
<li>urllib3 – Python HTTP库，安全连接池、支持文件post、可用性高。</li>
<li>httplib2 – 网络库。</li>
<li>RoboBrowser – 一个简单的、极具Python风格的Python库，无需独立的浏览器即可浏览网页。</li>
<li>MechanicalSoup -一个与网站自动交互Python库。</li>
<li>mechanize -有状态、可编程的Web浏览库。</li>
<li>socket – 底层网络接口(stdlib)。</li>
<li>Unirest for Python – Unirest是一套可用于多种语言的轻量级的HTTP库。</li>
<li>hyper – Python的HTTP/2客户端。</li>
<li>PySocks – SocksiPy更新并积极维护的版本，包括错误修复和一些其他的特征。作为socket模块的直接替换。</li>
</ul>
<h3 id="02、爬虫库"><a href="#02、爬虫库" class="headerlink" title="02、爬虫库"></a>02、爬虫库</h3><ul>
<li>scrapy – 网络爬虫框架（基于twisted），不支持Python3。</li>
<li>pyspider – 一个强大的爬虫系统。</li>
<li>cola – 一个分布式爬虫框架</li>
<li>portia – 基于Scrapy的可视化爬虫。</li>
<li>restkit – Python的HTTP资源工具包。它可以让你轻松地访问HTTP资源，并围绕它建立的对象。</li>
<li>demiurge – 基于PyQuery的爬虫微框架。</li>
</ul>
<h3 id="03、HTML-XML解析器"><a href="#03、HTML-XML解析器" class="headerlink" title="03、HTML/XML解析器"></a>03、HTML/XML解析器</h3><ul>
<li>lxml – C语言编写高效HTML/ XML处理库。支持XPath。</li>
<li>cssselect – 解析DOM树和CSS选择器。</li>
<li>pyquery – 解析DOM树和jQuery选择器。</li>
<li>BeautifulSoup – 低效HTML/ XML处理库，纯Python实现。</li>
<li>html5lib – 根据WHATWG规范生成HTML/ XML文档的DOM。该规范被用在现在所有的浏览器上。</li>
<li>feedparser – 解析RSS/ATOM feeds。</li>
<li>MarkupSafe – 为XML/HTML/XHTML提供了安全转义的字符串。</li>
<li>xmltodict – 一个可以让你在处理XML时感觉像在处理JSON一样的Python模块。</li>
<li>xhtml2pdf – 将HTML/CSS转换为PDF。</li>
<li>untangle – 轻松实现将XML文件转换为Python对象。</li>
<li>Bleach – 清理HTML（需要html5lib）。</li>
<li>sanitize – 为混乱的数据世界带来清明。</li>
</ul>
<h3 id="04、文本处理"><a href="#04、文本处理" class="headerlink" title="04、文本处理"></a>04、文本处理</h3><ul>
<li>difflib – （Python标准库）帮助进行差异化比较。</li>
<li>Levenshtein – 快速计算Levenshtein距离和字符串相似度。</li>
<li>fuzzywuzzy – 模糊字符串匹配。</li>
<li>esmre – 正则表达式加速器。</li>
<li>ftfy – 自动整理Unicode文本，减少碎片化。</li>
</ul>
<h3 id="05、自然语言处理"><a href="#05、自然语言处理" class="headerlink" title="05、自然语言处理"></a>05、自然语言处理</h3><ul>
<li>NLTK -编写Python程序来处理人类语言数据的最好平台。</li>
<li>Pattern – Python的网络挖掘模块。他有自然语言处理工具，机器学习以及其它。</li>
<li>TextBlob – 为深入自然语言处理任务提供了一致的API。是基于NLTK以及Pattern的巨人之肩上发展的。</li>
<li>jieba – 中文分词工具。</li>
<li>SnowNLP – 中文文本处理库。</li>
<li>loso – 另一个中文分词库。</li>
<li>scikit-learn</li>
<li>tensorflow</li>
<li>kera</li>
</ul>
<h3 id="06、图像处理库"><a href="#06、图像处理库" class="headerlink" title="06、图像处理库"></a>06、图像处理库</h3><ul>
<li>matplotlib<ul>
<li><a href="https://matplotlib.org/" target="_blank" rel="noopener">官网</a></li>
<li><a href="https://matplotlib.org/contents.html" target="_blank" rel="noopener">文档地址</a></li>
<li><a href="https://matplotlib.org/Matplotlib.pdf" target="_blank" rel="noopener">文档pdf版本</a></li>
<li><a href="https://www.matplotlib.org.cn/index.html" target="_blank" rel="noopener">中文文档</a></li>
<li><a href="https://github.com/xsoer/interview/blob/master/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/python/libaray/matplotlib.md" target="_blank" rel="noopener">总结说明</a></li>
</ul>
</li>
</ul>
<h3 id="07、浏览器自动化与仿真"><a href="#07、浏览器自动化与仿真" class="headerlink" title="07、浏览器自动化与仿真"></a>07、浏览器自动化与仿真</h3><ul>
<li>selenium – 自动化真正的浏览器（Chrome浏览器，火狐浏览器，Opera浏览器，IE浏览器）。</li>
<li>Ghost.py – 对PyQt的webkit的封装（需要PyQT）。</li>
<li>Spynner – 对PyQt的webkit的封装（需要PyQT）。</li>
<li>Splinter – 通用API浏览器模拟器（selenium web驱动，Django客户端，Zope）。</li>
</ul>
<h3 id="08、多重处理"><a href="#08、多重处理" class="headerlink" title="08、多重处理"></a>08、多重处理</h3><ul>
<li>threading – Python标准库的线程运行。对于I/O密集型任务很有效。对于CPU绑定的任务没用，因为python GIL。</li>
<li>multiprocessing – 标准的Python库运行多进程。</li>
<li>celery – 基于分布式消息传递的异步任务队列/作业队列。</li>
<li>concurrent-futures – concurrent-futures 模块为调用异步执行提供了一个高层次的接口。</li>
</ul>
<h3 id="09、异步"><a href="#09、异步" class="headerlink" title="09、异步"></a>09、异步</h3><ul>
<li>asyncio – （在Python 3.4 +版本以上的 Python标准库）异步I/O，时间循环，协同程序和任务。</li>
<li>Twisted – 基于事件驱动的网络引擎框架。</li>
<li>Tornado – 一个网络框架和异步网络库。</li>
<li>pulsar – Python事件驱动的并发框架。</li>
<li>diesel – Python的基于绿色事件的I/O框架。</li>
<li>gevent – 一个使用greenlet 的基于协程的Python网络库。</li>
<li>eventlet – 有WSGI支持的异步框架。</li>
<li>Tomorrow – 异步代码的奇妙的修饰语法。</li>
</ul>
<h3 id="10、队列"><a href="#10、队列" class="headerlink" title="10、队列"></a>10、队列</h3><ul>
<li>celery – 基于分布式消息传递的异步任务队列/作业队列。</li>
<li>huey – 小型多线程任务队列。</li>
<li>mrq – Mr. Queue – 使用redis &amp; Gevent 的Python分布式工作任务队列。</li>
<li>RQ – 基于Redis的轻量级任务队列管理器。</li>
<li>simpleq – 一个简单的，可无限扩展，基于Amazon SQS的队列。</li>
<li>python-gearman – Gearman的Python API</li>
</ul>
<h3 id="11、云计算"><a href="#11、云计算" class="headerlink" title="11、云计算"></a>11、云计算</h3><ul>
<li>picloud – 云端执行Python代码。</li>
<li>dominoup.com – 云端执行R，Python和matlab代码</li>
</ul>
<h3 id="12、网页内容提取"><a href="#12、网页内容提取" class="headerlink" title="12、网页内容提取"></a>12、网页内容提取</h3><ul>
<li>newspaper – 用Python进行新闻提取、文章提取和内容策展。</li>
<li>html2text – 将HTML转为Markdown格式文本。</li>
<li>python-goose – HTML内容/文章提取器。</li>
<li>lassie – 人性化的网页内容检索工具</li>
</ul>
<h3 id="13、WebSocket"><a href="#13、WebSocket" class="headerlink" title="13、WebSocket"></a>13、WebSocket</h3><ul>
<li>Crossbar – 开源的应用消息传递路由器（Python实现的用于Autobahn的WebSocket和WAMP）。</li>
<li>AutobahnPython – 提供了WebSocket协议和WAMP协议的Python实现并且开源。</li>
<li>WebSocket-for-Python – Python 2和3以及PyPy的WebSocket客户端和服务器库。</li>
</ul>
<h3 id="14、DNS解析"><a href="#14、DNS解析" class="headerlink" title="14、DNS解析"></a>14、DNS解析</h3><ul>
<li>dnsyo – 在全球超过1500个的DNS服务器上检查你的DNS。</li>
<li>pycares – c-ares的接口。c-ares是进行DNS请求和异步名称决议的C语言库。</li>
</ul>
<h3 id="15、计算机视觉"><a href="#15、计算机视觉" class="headerlink" title="15、计算机视觉"></a>15、计算机视觉</h3><ul>
<li>OpenCV – 开源计算机视觉库。</li>
<li>SimpleCV – 用于照相机、图像处理、特征提取、格式转换的简介，可读性强的接口（基于OpenCV）。</li>
<li>mahotas – 快速计算机图像处理算法（完全使用 C++ 实现），完全基于 numpy 的数组作为它的数据类型。</li>
</ul>
<h3 id="16、web框架"><a href="#16、web框架" class="headerlink" title="16、web框架"></a>16、web框架</h3><ul>
<li>Django</li>
<li>Flask</li>
<li>Web2py</li>
<li>Tornado</li>
<li>CherryPy</li>
</ul>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库基础</title>
    <url>/2019/03/10/2019/03-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？"><a href="#1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？" class="headerlink" title="1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？"></a>1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？</h3><ul>
<li>数据库事务<ul>
<li>将一组相关操作组合为一个要么全部成功要么全部失败的单元</li>
<li>具有ACID（原子性、一致性、隔离性和持久性）属性<ul>
<li>原子性(Atomicity)：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li>
<li>一致性(Consistent)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须于一致性状态</li>
<li>隔离性(Isolation)：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所扰，多个并发事务之间要相互隔离。</li>
<li>持久性(Duration)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
</li>
</ul>
</li>
<li>事物隔离级别<ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
</li>
<li>脏读、幻读、不可重复读<ul>
<li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</li>
<li>不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li>
<li>幻读：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li>
</ul>
</li>
<li>备注：<ul>
<li>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</li>
<li>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</li>
<li>当前事务的隔离级别：select @@tx_isolation;</li>
</ul>
</li>
</ul>
<h3 id="2-优化数据库的方法。说说-SQL-优化之道"><a href="#2-优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="2.优化数据库的方法。说说 SQL 优化之道"></a>2.优化数据库的方法。说说 SQL 优化之道</h3><ul>
<li>主机性能</li>
<li>内存使用性能</li>
<li>网络传输性能</li>
<li>SQL语句执行性能</li>
</ul>
<h3 id="3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别"><a href="#3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别" class="headerlink" title="3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别"></a>3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</h3><h3 id="为什么要用-B-tree-作为-MySql-索引的数据结构"><a href="#为什么要用-B-tree-作为-MySql-索引的数据结构" class="headerlink" title="为什么要用 B+tree 作为 MySql 索引的数据结构"></a>为什么要用 B+tree 作为 MySql 索引的数据结构</h3><h3 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h3><h3 id="Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？"><a href="#Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？"></a>Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？</h3><h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><h3 id="DDL、DML、DCL-分别指什么"><a href="#DDL、DML、DCL-分别指什么" class="headerlink" title="DDL、DML、DCL 分别指什么"></a>DDL、DML、DCL 分别指什么</h3><h3 id="explain-命令"><a href="#explain-命令" class="headerlink" title="explain 命令"></a>explain 命令</h3><h3 id="数据库的几大范式"><a href="#数据库的几大范式" class="headerlink" title="数据库的几大范式"></a>数据库的几大范式</h3><h3 id="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"><a href="#说说分库与分表设计，分库与分表带来的分布式困境与对应之策" class="headerlink" title="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"></a>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</h3><h3 id="什么是自适应哈希索引（AHI）"><a href="#什么是自适应哈希索引（AHI）" class="headerlink" title="什么是自适应哈希索引（AHI）"></a>什么是自适应哈希索引（AHI）</h3><h3 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h3><h3 id="常见的几种分布式-ID-的设计方案"><a href="#常见的几种分布式-ID-的设计方案" class="headerlink" title="常见的几种分布式 ID 的设计方案"></a>常见的几种分布式 ID 的设计方案</h3>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>终端命令工具集</title>
    <url>/2019/04/22/2019/04-22-%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<h2 id="0x00、工具"><a href="#0x00、工具" class="headerlink" title="0x00、工具"></a>0x00、工具</h2><ul>
<li>autojump<ul>
<li>自动跳转文件夹，不用cd</li>
</ul>
</li>
<li>tree<ul>
<li>以树状图列出当前目录结构</li>
</ul>
</li>
<li>you-get<ul>
<li>视频下载</li>
</ul>
</li>
<li>tldr<ul>
<li>命令示例文档</li>
</ul>
</li>
<li>htop<ul>
<li>更强大的top</li>
</ul>
</li>
<li>git<ul>
<li>版本控制工具</li>
</ul>
</li>
<li>vim<ul>
<li>编辑器</li>
</ul>
</li>
<li>tmux<ul>
<li>终端复用神器</li>
</ul>
</li>
<li>thefuck<ul>
<li>命令出错自动完善</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Impala操作手册</title>
    <url>/2019/04/22/2019/04-22-Impala%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ul>
<li>支持的查询存储<ul>
<li>关系型数据库</li>
<li>数据仓库</li>
<li>Kudu</li>
<li>Hive</li>
<li>Hbase</li>
<li>HDFS</li>
</ul>
</li>
<li>可以单独部署一个集群，读取远程数据源。</li>
<li>支持的操作<ul>
<li>运行impala-shell进入交互模式<ul>
<li><code>/usr/bin/impala-shell</code></li>
</ul>
</li>
<li>ODBC、JDBC</li>
<li>Hue web-based user interface.</li>
</ul>
</li>
</ul>
<h2 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h2><ul>
<li>分为外部表和内部表</li>
<li>内部表<ul>
<li>通过impala创建的表都是内部表(internal)</li>
<li>修改表结构对应的底层表也会进行变动</li>
</ul>
</li>
<li>外部表<ul>
<li>不同过impala创建的表都是外部表(external)</li>
<li>要操作这些表，需要在impala建立表的映射关系</li>
<li>通过sql修改表结构或者删除表不会删除底层表，删除的只是表的映射关系</li>
</ul>
</li>
</ul>
<h2 id="SQL语法"><a href="#SQL语法" class="headerlink" title="SQL语法"></a>SQL语法</h2><ul>
<li>sql示例</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- This line is a comment about a table.</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> ...;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">This is a multi-line comment about a query.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">select</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="comment">/* This is an embedded comment about a query. */</span> <span class="keyword">where</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t <span class="comment">-- This is a trailing comment within a multi-line command.</span></span><br><span class="line"><span class="keyword">where</span> ...;</span><br></pre></td></tr></table></figure>

<ul>
<li>外部表映射</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">EXTERNAL</span> <span class="keyword">TABLE</span> my_mapping_table</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU</span><br><span class="line">TBLPROPERTIES (</span><br><span class="line">  <span class="string">'kudu.table_name'</span> = <span class="string">'my_kudu_table'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建内部表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_first_table</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="keyword">name</span> <span class="keyword">STRING</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span>(<span class="keyword">id</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> <span class="keyword">PARTITIONS</span> <span class="number">16</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU;</span><br></pre></td></tr></table></figure>
</li>
<li><p>用select来建表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table</span><br><span class="line">PRIMARY <span class="keyword">KEY</span> (ts, <span class="keyword">name</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span>(<span class="keyword">name</span>) <span class="keyword">PARTITIONS</span> <span class="number">8</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> ts, <span class="keyword">name</span>, <span class="keyword">value</span> <span class="keyword">FROM</span> old_table;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复杂点的partition</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cust_behavior (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  sku <span class="keyword">STRING</span>,</span><br><span class="line">  salary <span class="keyword">STRING</span>,</span><br><span class="line">  edu_level <span class="built_in">INT</span>,</span><br><span class="line">  usergender <span class="keyword">STRING</span>,</span><br><span class="line">  <span class="string">`group`</span> <span class="keyword">STRING</span>,</span><br><span class="line">  city <span class="keyword">STRING</span>,</span><br><span class="line">  postcode <span class="keyword">STRING</span>,</span><br><span class="line">  last_purchase_price <span class="built_in">FLOAT</span>,</span><br><span class="line">  last_purchase_date <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="keyword">category</span> <span class="keyword">STRING</span>,</span><br><span class="line">  rating <span class="built_in">INT</span>,</span><br><span class="line">  fulfilled_date <span class="built_in">BIGINT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>, sku)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> (<span class="keyword">id</span>) <span class="keyword">PARTITIONS</span> <span class="number">4</span>,</span><br><span class="line"><span class="keyword">RANGE</span> (sku)</span><br><span class="line">(</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUES</span> &lt; <span class="string">'g'</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="string">'g'</span> &lt;= <span class="keyword">VALUES</span> &lt; <span class="string">'o'</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="string">'o'</span> &lt;= <span class="keyword">VALUES</span> &lt; <span class="string">'u'</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="string">'u'</span> &lt;= <span class="keyword">VALUES</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个hash分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cust_behavior (</span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">BIGINT</span>,</span><br><span class="line">  sku <span class="keyword">STRING</span>,</span><br><span class="line">  salary <span class="keyword">STRING</span>,</span><br><span class="line">  edu_level <span class="built_in">INT</span>,</span><br><span class="line">  usergender <span class="keyword">STRING</span>,</span><br><span class="line">  <span class="string">`group`</span> <span class="keyword">STRING</span>,</span><br><span class="line">  city <span class="keyword">STRING</span>,</span><br><span class="line">  postcode <span class="keyword">STRING</span>,</span><br><span class="line">  last_purchase_price <span class="built_in">FLOAT</span>,</span><br><span class="line">  last_purchase_date <span class="built_in">BIGINT</span>,</span><br><span class="line">  <span class="keyword">category</span> <span class="keyword">STRING</span>,</span><br><span class="line">  rating <span class="built_in">INT</span>,</span><br><span class="line">  fulfilled_date <span class="built_in">BIGINT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>, sku)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">HASH</span> (<span class="keyword">id</span>) <span class="keyword">PARTITIONS</span> <span class="number">4</span>,</span><br><span class="line">             <span class="keyword">HASH</span> (sku) <span class="keyword">PARTITIONS</span> <span class="number">4</span></span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU;</span><br></pre></td></tr></table></figure>
</li>
<li><p>多个range分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> sales_by_year (</span><br><span class="line">  <span class="keyword">year</span> <span class="built_in">INT</span>, sale_id <span class="built_in">INT</span>, amount <span class="built_in">INT</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (sale_id, <span class="keyword">year</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> <span class="keyword">RANGE</span> (<span class="keyword">year</span>) (</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2012</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2013</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2014</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2015</span>,</span><br><span class="line">  <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2016</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">STORED</span> <span class="keyword">AS</span> KUDU;</span><br></pre></td></tr></table></figure>
</li>
<li><p>添加ragne分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales_by_year <span class="keyword">ADD</span> <span class="keyword">RANGE</span> <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2017</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除一个range分区</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> sales_by_year <span class="keyword">DROP</span> <span class="keyword">RANGE</span> <span class="keyword">PARTITION</span> <span class="keyword">VALUE</span> = <span class="number">2012</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>操作元</p>
<ul>
<li>Arithmetic Operators</li>
<li>BETWEEN Operator</li>
<li>Comparison Operators</li>
<li>EXISTS Operator</li>
<li>ILIKE Operator</li>
<li>IN Operator</li>
<li>IREGEXP Operator</li>
<li>IS DISTINCT FROM Operator</li>
<li>IS NULL Operator</li>
<li>IS TRUE Operator</li>
<li>LIKE Operator</li>
<li>Logical Operators</li>
<li>REGEXP Operator</li>
<li>RLIKE Operator</li>
</ul>
</li>
</ul>
<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul>
<li>ARRAY Complex Type (CDH 5.5 or higher only)</li>
<li>BIGINT</li>
<li>BOOLEAN</li>
<li>CHAR</li>
<li>DECIMAL</li>
<li>DOUBLE</li>
<li>FLOAT</li>
<li>INT</li>
<li>MAP Complex Type (CDH 5.5 or higher only)</li>
<li>REAL</li>
<li>SMALLINT</li>
<li>STRING</li>
<li>STRUCT Complex Type (CDH 5.5 or higher only)</li>
<li>TIMESTAMP</li>
<li>TINYINT</li>
<li>VARCHAR</li>
<li>Complex Types (CDH 5.5 or higher only)</li>
<li><code>PS:注意</code><ul>
<li>Currently, the data types CHAR, VARCHAR, ARRAY, MAP, and STRUCT cannot be used with Kudu tables.</li>
</ul>
</li>
</ul>
<h2 id="SQL-Statements"><a href="#SQL-Statements" class="headerlink" title="SQL Statements"></a>SQL Statements</h2><ul>
<li>DDL Statements</li>
<li>DML Statements</li>
<li>ALTER DATABASE</li>
<li>ALTER TABLE</li>
<li>ALTER VIEW</li>
<li>COMMENT</li>
<li>COMPUTE STATS</li>
<li>CREATE DATABASE</li>
<li>CREATE FUNCTION</li>
<li>CREATE ROLE</li>
<li>CREATE TABLE</li>
<li>CREATE VIEW</li>
<li>DELETE</li>
<li>DESCRIBE</li>
<li>DROP DATABASE</li>
<li>DROP FUNCTION</li>
<li>DROP ROLE</li>
<li>DROP STATS</li>
<li>DROP TABLE</li>
<li>DROP VIEW</li>
<li>EXPLAIN</li>
<li>GRANT</li>
<li>INSERT<ul>
<li>VALUES Clause</li>
<li>Inserting Into Partitioned Tables with PARTITION Clause<ul>
<li>Static Partition Inserts</li>
<li>Dynamic Partition Inserts</li>
</ul>
</li>
</ul>
</li>
<li>INVALIDATE METADATA</li>
<li>LOAD DATA</li>
<li>REFRESH</li>
<li>REFRESH AUTHORIZATION</li>
<li>REFRESH FUNCTIONS</li>
<li>REVOKE</li>
<li>SELECT<ul>
<li>Joins</li>
<li>ORDER BY Clause</li>
<li>GROUP BY Clause</li>
<li>HAVING Clause</li>
<li>LIMIT Clause</li>
<li>OFFSET Clause</li>
<li>UNION Clause</li>
<li>Subqueries</li>
<li>TABLESAMPLE Clause</li>
<li>WITH Clause</li>
<li>DISTINCT Operator</li>
</ul>
</li>
<li>SET<ul>
<li>ABORT_ON_ERROR</li>
<li>ALLOW_ERASURE_CODED_FILES</li>
<li>ALLOW_UNSUPPORTED_FORMATS</li>
<li>APPX_COUNT_DISTINCT</li>
<li>BATCH_SIZE</li>
<li>BUFFER_POOL_LIMIT</li>
<li>COMPRESSION_CODEC</li>
<li>COMPUTE_STATS_MIN_SAMPLE_SIZE</li>
<li>DEBUG_ACTION</li>
<li>DECIMAL_V2</li>
<li>DEFAULT_FILE_FORMAT</li>
<li>DEFAULT_JOIN_DISTRIBUTION_MODE</li>
<li>DEFAULT_SPILLABLE_BUFFER_SIZE</li>
<li>DISABLE_CODEGEN</li>
<li>DISABLE_CODEGEN_ROWS_THRESHOLD</li>
<li>DISABLE_ROW_RUNTIME_FILTERING</li>
<li>DISABLE_STREAMING_PREAGGREGATIONS</li>
<li>DISABLE_UNSAFE_SPILLS</li>
<li>ENABLE_EXPR_REWRITES</li>
<li>EXEC_SINGLE_NODE_ROWS_THRESHOLD</li>
<li>EXEC_TIME_LIMIT_S</li>
<li>EXPLAIN_LEVEL</li>
<li>HBASE_CACHE_BLOCKS</li>
<li>HBASE_CACHING</li>
<li>IDLE_SESSION_TIMEOUT</li>
<li>KUDU_READ_MODE</li>
<li>LIVE_PROGRESS</li>
<li>LIVE_SUMMARY</li>
<li>MAX_ERRORS</li>
<li>MAX_MEM_ESTIMATE_FOR_ADMISSION</li>
<li>MAX_NUM_RUNTIME_FILTERS</li>
<li>MAX_ROW_SIZE</li>
<li>MAX_SCAN_RANGE_LENGTH</li>
<li>MEM_LIMIT</li>
<li>MIN_SPILLABLE_BUFFER_SIZE</li>
<li>MT_DOP</li>
<li>NUM_NODES</li>
<li>NUM_ROWS_PRODUCED_LIMIT</li>
<li>NUM_SCANNER_THREADS</li>
<li>OPTIMIZE_PARTITION_KEY_SCANS</li>
<li>PARQUET_COMPRESSION_CODEC</li>
<li>PARQUET_ANNOTATE_STRINGS_UTF8</li>
<li>PARQUET_ARRAY_RESOLUTION</li>
<li>PARQUET_DICTIONARY_FILTERING</li>
<li>PARQUET_FALLBACK_SCHEMA_RESOLUTION</li>
<li>PARQUET_FILE_SIZE</li>
<li>PARQUET_READ_STATISTICS</li>
<li>PREFETCH_MODE</li>
<li>QUERY_TIMEOUT_S</li>
<li>REPLICA_PREFERENCE</li>
<li>REQUEST_POOL</li>
<li>RESOURCE_TRACE_RATIO</li>
<li>RUNTIME_BLOOM_FILTER_SIZE</li>
<li>RUNTIME_FILTER_MAX_SIZE</li>
<li>RUNTIME_FILTER_MIN_SIZE</li>
<li>RUNTIME_FILTER_MODE</li>
<li>RUNTIME_FILTER_WAIT_TIME_MS</li>
<li>S3_SKIP_INSERT_STAGING</li>
<li>SCAN_BYTES_LIMIT</li>
<li>SCHEDULE_RANDOM_REPLICA</li>
<li>SCRATCH_LIMIT</li>
<li>SHUFFLE_DISTINCT_EXPRS</li>
<li>SUPPORT_START_OVER</li>
<li>SYNC_DDL</li>
<li>THREAD_RESERVATION_AGGREGATE_LIMIT</li>
<li>THREAD_RESERVATION_LIMIT</li>
<li>TIMEZONE</li>
<li>TOPN_BYTES_LIMIT</li>
</ul>
</li>
<li>SHOW<ul>
<li>SHOW FILES Statement</li>
<li>SHOW ROLES Statement</li>
<li>SHOW CURRENT ROLE</li>
<li>SHOW ROLE GRANT Statement</li>
<li>SHOW GRANT ROLE Statement</li>
<li>SHOW GRANT USER Statement</li>
<li>SHOW DATABASES</li>
<li>SHOW TABLES Statement</li>
<li>SHOW CREATE TABLE Statement</li>
<li>SHOW CREATE VIEW Statement</li>
<li>SHOW TABLE STATS Statement</li>
<li>SHOW COLUMN STATS Statement</li>
<li>SHOW PARTITIONS Statement</li>
<li>SHOW FUNCTIONS Statement</li>
</ul>
</li>
<li>SHUTDOWN</li>
<li>TRUNCATE TABLE</li>
<li>UPDATE</li>
<li>UPSERT</li>
<li>USE</li>
<li>Optimizer Hints</li>
</ul>
<h2 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器工具集</title>
    <url>/2019/04/23/2019/04-23-%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E5%85%B7%E9%9B%86/</url>
    <content><![CDATA[<h3 id="0x00、插件"><a href="#0x00、插件" class="headerlink" title="0x00、插件"></a>0x00、插件</h3><ul>
<li>github<ul>
<li>sourcegraph</li>
<li>octotree</li>
</ul>
</li>
<li>剪切网页<ul>
<li>evernote</li>
</ul>
</li>
<li>调试接口<ul>
<li>JSONview</li>
</ul>
</li>
<li>词典<ul>
<li>沙拉查词</li>
</ul>
</li>
<li>广告<ul>
<li>广告终结者</li>
</ul>
</li>
<li>产品原型<ul>
<li>axure</li>
</ul>
</li>
<li>多tab管理<ul>
<li>Toby</li>
</ul>
</li>
</ul>
<h3 id="0x01、工具网站"><a href="#0x01、工具网站" class="headerlink" title="0x01、工具网站"></a>0x01、工具网站</h3><ul>
<li>json格式化<ul>
<li><a href="https://json.cn" target="_blank" rel="noopener">https://json.cn</a></li>
<li><a href="http://json.parser.online.fr" target="_blank" rel="noopener">http://json.parser.online.fr</a></li>
</ul>
</li>
<li>随机密码生成<ul>
<li><a href="https://www.sexauth.com/" target="_blank" rel="noopener">https://www.sexauth.com/</a></li>
<li><a href="https://suijimimashengcheng.51240.com/" target="_blank" rel="noopener">https://suijimimashengcheng.51240.com/</a></li>
<li><a href="https://www.dashlane.com/zh/features/password-generator" target="_blank" rel="noopener">https://www.dashlane.com/zh/features/password-generator</a></li>
</ul>
</li>
<li>正则表达式<ul>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></li>
<li><a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">http://wangwl.net/static/projects/visualRegex</a></li>
</ul>
</li>
<li>问题讨论<ul>
<li><a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li>
<li><a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></li>
</ul>
</li>
</ul>
<h3 id="0x02、前沿科技网站"><a href="#0x02、前沿科技网站" class="headerlink" title="0x02、前沿科技网站"></a>0x02、前沿科技网站</h3><ul>
<li>论文<ul>
<li><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></li>
<li><a href="https://www.nature.com/" target="_blank" rel="noopener">https://www.nature.com/</a></li>
</ul>
</li>
</ul>
<h3 id="0x03、github系列"><a href="#0x03、github系列" class="headerlink" title="0x03、github系列"></a>0x03、github系列</h3><ul>
<li><p>图书</p>
<ul>
<li><a href="https://github.com/royeo/free-programming-books.pdf" target="_blank" rel="noopener">https://github.com/royeo/free-programming-books.pdf</a></li>
<li><a href="https://github.com/threerocks/studyFiles" target="_blank" rel="noopener">https://github.com/threerocks/studyFiles</a></li>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></li>
<li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="noopener">https://github.com/it-ebooks/it-ebooks-archive</a></li>
<li><a href="https://github.com/shivam-jha/DockerBooks" target="_blank" rel="noopener">https://github.com/shivam-jha/DockerBooks</a></li>
<li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md</a></li>
<li><a href="https://github.com/zhiwoeryi/eBook-3" target="_blank" rel="noopener">https://github.com/zhiwoeryi/eBook-3</a></li>
</ul>
</li>
<li><p>awesome系列</p>
<ul>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">https://github.com/sindresorhus/awesome</a></li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">https://github.com/linyiqun/DataMiningAlgorithm</a></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac开发环境配置</title>
    <url>/2019/09/05/2019/09-05-mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="0X00、Mac软件"><a href="#0X00、Mac软件" class="headerlink" title="0X00、Mac软件"></a>0X00、Mac软件</h2><ul>
<li>1.vscode</li>
<li>2.omyzsh</li>
<li>3.tmux</li>
<li>4.vim</li>
<li>5.Chrome</li>
<li>6.输入法</li>
</ul>
<h2 id="0x01、vscode"><a href="#0x01、vscode" class="headerlink" title="0x01、vscode"></a>0x01、vscode</h2><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><ul>
<li>Dash</li>
<li>clock in status bar</li>
<li>Docker</li>
<li>ESlint</li>
<li>File Utils</li>
<li>filesize</li>
<li>GitLens</li>
<li>Go</li>
<li>python</li>
<li>IntelliJ IDEA keybingdings</li>
<li>LaTex Workshop</li>
<li>leetCode</li>
<li>open in browser</li>
<li>Path Intelligence</li>
<li>Remote - Container</li>
<li>Remote - SSH</li>
<li>Remote - SSH:Editing Configuration</li>
<li>Remote - SSH:Explore</li>
<li>Remote - WSL</li>
<li>Remote Development</li>
<li>Settings Sync</li>
<li>Shades of Purple</li>
<li>SQLTools</li>
<li>Stackoverflow Instant Search</li>
<li>TabNine</li>
<li>Vetur</li>
<li>YAML</li>
</ul>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"workbench.activityBar.visible"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"editor.scrollBeyondLastLine"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"files.autoSave"</span>: <span class="string">"onFocusChange"</span>,</span><br><span class="line">    <span class="attr">"workbench.colorTheme"</span>: <span class="string">"Shades of Purple"</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.cursorStyle"</span>: <span class="string">"line"</span>,</span><br><span class="line">    <span class="attr">"workbench.statusBar.feedback.visible"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"clock.dateFormat"</span>: <span class="string">"yyyy-mm-dd HH:MM:ss"</span>,</span><br><span class="line">    <span class="attr">"extensions.ignoreRecommendations"</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"files.exclude"</span>: &#123;</span><br><span class="line">        <span class="attr">"**/__pycache__"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">"**/*.pyc"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">"breadcrumbs.enabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"editor.fontSize"</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="attr">"editor.fontFamily"</span>: <span class="string">"'Source Code Pro',Menlo, Monaco, 'Courier New', monospace"</span>,</span><br><span class="line">    <span class="attr">"terminal.external.osxExec"</span>: <span class="string">"iterm.app"</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.copyOnSelection"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.fontSize"</span>: <span class="number">15</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.fontFamily"</span>: <span class="string">"'Source Code Pro'"</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.scrollback"</span>: <span class="number">3000</span>,</span><br><span class="line">    <span class="attr">"terminal.integrated.shell.osx"</span>: <span class="string">"/bin/zsh"</span>,</span><br><span class="line">    <span class="attr">"python.pythonPath"</span>: <span class="string">"~/anaconda3/bin/python"</span>,</span><br><span class="line">    <span class="attr">"python.linting.pylintEnabled"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"leetcode.defaultLanguage"</span>: <span class="string">"python3"</span>,</span><br><span class="line">    <span class="attr">"leetcode.outputFolder"</span>: <span class="string">"leecode"</span>,</span><br><span class="line">    <span class="attr">"leetcode.hideSolved"</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">"breadcrumbs.symbolSortOrder"</span>: <span class="string">"name"</span>,</span><br><span class="line">    // Theme Setup.</span><br><span class="line">    // "workbench.iconTheme": "vscode-icons",</span><br><span class="line">    "editor.lineHeight": 24.65,</span><br><span class="line">    "editor.letterSpacing": 0.5,</span><br><span class="line">    "editor.fontWeight": "400",</span><br><span class="line">    "editor.fontLigatures": true,</span><br><span class="line">    "editor.cursorStyle": "line",</span><br><span class="line">    // "editor.cursorWidth": 1,</span><br><span class="line">    "editor.cursorBlinking": "solid",</span><br><span class="line">    "editor.renderWhitespace": "all",</span><br><span class="line">    "editor.snippetSuggestions": "top",</span><br><span class="line">    "editor.glyphMargin": true,</span><br><span class="line">    "workbench.editor.enablePreview": false,</span><br><span class="line">    "explorer.confirmDragAndDrop": false,</span><br><span class="line">    "files.trimTrailingWhitespace": true,</span><br><span class="line">    "files.trimFinalNewlines": true,</span><br><span class="line">    // Formatting Optional.</span><br><span class="line">    // "editor.formatOnSave": true,</span><br><span class="line">    "eslint.run": "onType",</span><br><span class="line">    "eslint.autoFixOnSave": true,</span><br><span class="line">    // MacOS Only Settings.</span><br><span class="line">    "workbench.fontAliasing": "auto",</span><br><span class="line">    "terminal.integrated.macOptionIsMeta": true,</span><br><span class="line">    // SOP's highlight matching tag setting.</span><br><span class="line">    "workbench.statusBar.visible": true,</span><br><span class="line">    "python.dataScience.sendSelectionToInteractiveWindow": true,</span><br><span class="line">    "terminal.integrated.rendererType": "dom",</span><br><span class="line">    "git.ignoreLegacyWarning": true,</span><br><span class="line">    "GithubGistExplorer.explorer.gistSortBy": "Last Updated",</span><br><span class="line">    "GithubGistExplorer.explorer.gistAscending": false,</span><br><span class="line">    "GithubGistExplorer.explorer.subscriptionSortBy": "Last Updated",</span><br><span class="line">    "GithubGistExplorer.explorer.subscriptionAscending": false,</span><br><span class="line">    "GithubGistExplorer.github.token": "b70cb2a4a71195fab3c47a8ae0a1209441a46075",</span><br><span class="line">    "GithubGistExplorer.github.username": "xsoer",</span><br><span class="line">    "sync.gist": "20a9cb9d32319e38ded959f092109cd5",</span><br><span class="line">    "window.zoomLevel": 0,</span><br><span class="line">    "go.formatTool": "goimports",</span><br><span class="line">    "go.useLanguageServer": true,</span><br><span class="line">    "http.proxy": "http://127.0.0.1:1087"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="0x02、omyzsh"><a href="#0x02、omyzsh" class="headerlink" title="0x02、omyzsh"></a>0x02、omyzsh</h2><h4 id="插件-1"><a href="#插件-1" class="headerlink" title="插件"></a>插件</h4><ul>
<li>git</li>
<li>autojump</li>
<li>zsh-syntax-highlighting</li>
<li>zsh-autosuggestions</li>
</ul>
<h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(git zsh-autosuggestions zsh-syntax-highlighting)</span><br><span class="line"></span><br><span class="line">[ -f /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh ] &amp;&amp; . /usr/<span class="built_in">local</span>/etc/profile.d/autojump.sh</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">"<span class="variable">$TMUX</span>"</span> ]; <span class="keyword">then</span></span><br><span class="line">    tmux attach -t default || tmux new -s default</span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure>

<h2 id="0x03、tmux"><a href="#0x03、tmux" class="headerlink" title="0x03、tmux"></a>0x03、tmux</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install tmux</span><br></pre></td></tr></table></figure>

<h4 id="配置文件-1"><a href="#配置文件-1" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#设置前缀为Ctrl + a</span><br><span class="line">set -g prefix C-a</span><br><span class="line"></span><br><span class="line">#解除Ctrl+b 与前缀的对应关系</span><br><span class="line">unbind C-b</span><br><span class="line">bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀</span><br><span class="line"></span><br><span class="line"># 设置序号从1开始</span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br><span class="line"></span><br><span class="line">#将r 设置为加载配置文件，并显示&quot;reloaded!&quot;信息</span><br><span class="line">bind r source-file ~/.tmux.conf \; display &quot;Reloaded!&quot;</span><br><span class="line"></span><br><span class="line">bind-key k select-pane -U # up</span><br><span class="line">bind-key j select-pane -D # down</span><br><span class="line">bind-key h select-pane -L # left</span><br><span class="line">bind-key l select-pane -R # right</span><br><span class="line"></span><br><span class="line">set -g mouse on # 支持鼠标选取文本等</span><br><span class="line"></span><br><span class="line">set -g status-interval 2 # 状态栏刷新时间</span><br><span class="line">set -g status-justify left # 状态栏列表左对齐</span><br><span class="line">setw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知</span><br><span class="line"></span><br><span class="line">set -g status-bg black # 设置状态栏背景黑色</span><br><span class="line">set -g status-fg yellow # 设置状态栏前景黄色</span><br><span class="line">set -g status-style &quot;bg=black, fg=yellow&quot; # 状态栏前景背景色</span><br><span class="line"></span><br><span class="line">set -g status-left &quot;#[bg=#FF661D] ❐ #S &quot; # 状态栏左侧内容</span><br><span class="line">set -g status-right &quot;#S #[fg=green,bg=black]#(tmux-mem-cpu-load --colors --interval 2)#[default]&quot;</span><br><span class="line">set -g status-left-length 300 # 状态栏左边长度300</span><br><span class="line">set -g status-right-length 500 # 状态栏右边长度500</span><br><span class="line"></span><br><span class="line">set -wg window-status-format &quot; #I #W &quot; # 状态栏窗口名称格式</span><br><span class="line">set -wg window-status-current-format &quot; #I:#W#F &quot; # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span><br><span class="line">set -wg window-status-separator &quot;&quot; # 状态栏窗口名称之间的间隔</span><br><span class="line">set -wg window-status-current-style &quot;bg=red&quot; # 状态栏当前窗口名称的样式</span><br><span class="line">set -wg window-status-last-style &quot;fg=yellow&quot; # 状态栏最后一个窗口名称的样式</span><br><span class="line"></span><br><span class="line">set -g message-style &quot;bg=#202529, fg=#91A8BA&quot; # 指定消息通知的前景、后景色</span><br></pre></td></tr></table></figure>

<h2 id="0x04、vim"><a href="#0x04、vim" class="headerlink" title="0x04、vim"></a>0x04、vim</h2><h4 id="配置文件-2"><a href="#配置文件-2" class="headerlink" title="配置文件"></a>配置文件</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set nocompatible</span><br><span class="line">syntax on</span><br><span class="line">filetype plugin indent on</span><br><span class="line">set ic</span><br><span class="line">set hlsearch</span><br><span class="line">set encoding=utf-8</span><br><span class="line">set fileencodings=utf-8,ucs-bom,GB2312,big5</span><br><span class="line">set cursorline</span><br><span class="line">set autoindent</span><br><span class="line">set smartindent</span><br><span class="line">set scrolloff=4</span><br><span class="line">set showmatch</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">let python_highlight_all=1</span><br><span class="line">au Filetype python set tabstop=4</span><br><span class="line">au Filetype python set softtabstop=4</span><br><span class="line">au Filetype python set shiftwidth=4</span><br><span class="line">au Filetype python set textwidth=79</span><br><span class="line">au Filetype python set expandtab</span><br><span class="line">au Filetype python set autoindent</span><br><span class="line">au Filetype python set fileformat=unix</span><br><span class="line">autocmd Filetype python set foldmethod=indent</span><br><span class="line">autocmd Filetype python set foldlevel=99</span><br></pre></td></tr></table></figure>

<h2 id="0x05、chrome"><a href="#0x05、chrome" class="headerlink" title="0x05、chrome"></a>0x05、chrome</h2><h4 id="插件-2"><a href="#插件-2" class="headerlink" title="插件"></a>插件</h4><ul>
<li>vimium</li>
<li>Evernote web Clipper</li>
<li>JSONview</li>
<li>OctTree</li>
<li>Sourcegraph</li>
<li>沙拉查词</li>
</ul>
<h2 id="0x06、输入法"><a href="#0x06、输入法" class="headerlink" title="0x06、输入法"></a>0x06、输入法</h2><ul>
<li>RIME</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络类型</title>
    <url>/2019/09/02/2019/09-02-%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="0x00、大体类型"><a href="#0x00、大体类型" class="headerlink" title="0x00、大体类型"></a>0x00、大体类型</h2><ul>
<li>1.卷积神经网络</li>
<li>2.循环神经网络</li>
<li>3.深度信念网络</li>
<li>4.生成对抗网络</li>
<li>5.深度强化学习</li>
</ul>
<h2 id="0x01、卷积神经网络"><a href="#0x01、卷积神经网络" class="headerlink" title="0x01、卷积神经网络"></a>0x01、卷积神经网络</h2><ul>
<li>卷积神经网络属于前面介绍的前馈神经网络之一，它对于图形图像的处理有着独特的效果，在结构上至少包括卷积层和池化层</li>
<li>目前卷积神经网络主要应用于影像中物体检测和识别、视频理解，除此之外，卷积神经网络还被应用于自然语言处理</li>
<li>代表性的卷积神经网络包括LeNet-5、VGG、AlexNet 等</li>
</ul>
<h2 id="0x02、循环神经网络"><a href="#0x02、循环神经网络" class="headerlink" title="0x02、循环神经网络"></a>0x02、循环神经网络</h2><ul>
<li>不同于卷积神经网络，循环神经网络更擅长于对语言文本的处理。文本的分析处理，更看重时序上的输入与上下文的联系。循环神经网络的内部记忆结构，刚好满足这样的需求场景，因此在文本处理方面循环神经网络更胜一筹。</li>
<li>目前循环神经网络的主要落地场景在机器翻译、情感分析等NLP 领域。特别是近几年媒体曝光较多的新闻写稿机器人，也是基于循环神经网络的一个应用。除此之外，循环神经网络还可以实现自动作诗、自动写歌词，甚至自动写代码。</li>
</ul>
<h2 id="0x03、深度信念网络"><a href="#0x03、深度信念网络" class="headerlink" title="0x03、深度信念网络"></a>0x03、深度信念网络</h2><ul>
<li>是一种生成模型，由多个受限玻尔兹曼机组成，采用逐层的方式进行训练，其结构可以理解为由多层简单学习模型组合而成的复合模型。深度信念网络是一个可以对训练的数据样本进行深层次表达的图形模型。</li>
</ul>
<h2 id="0x04、生成对抗网络"><a href="#0x04、生成对抗网络" class="headerlink" title="0x04、生成对抗网络"></a>0x04、生成对抗网络</h2><ul>
<li>生成对抗网络将对抗的思想引入机器学习领域，对抗的双方为判别模型和生成模型</li>
<li>判别模型的职责是准确区分真实数据和生成数据，而生成模型负责生成符合真实数据概率分布的新数据</li>
<li>生成对抗网络主要用于样本数据概率分布的建模，并生成与训练数据相同分布的新数据<ul>
<li>目前，GAN 主要应用于图像与视觉领域，以及自然语言处理领域，例如，提升图像分辨率、还原遮挡或破损图像、基于文本描述生成图像等。</li>
</ul>
</li>
</ul>
<h2 id="0x05、深度强化学习"><a href="#0x05、深度强化学习" class="headerlink" title="0x05、深度强化学习"></a>0x05、深度强化学习</h2><ul>
<li>与其他机器学习的差异在于，深度强化学习更加注重基于环境的改变而调整自身的行为</li>
<li>深度强化学习的运行机制由四个基本组件组成：环境、代理、动作、反馈。通过四者的关系，强调代理如何在环境给予的奖励或者惩罚的刺激下，逐渐改变自己的行为动作，使得尽可能使用环境，从而达到环境给予的奖励值最大，逐步形成符合最大利益的惯性行为。</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>python性能分析工具cProfile</title>
    <url>/2019/10/08/2019/10-08-python%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="0x00、cProfile简介"><a href="#0x00、cProfile简介" class="headerlink" title="0x00、cProfile简介"></a>0x00、cProfile简介</h2><ul>
<li>cProfile是python自带的模块，对运行的代码做性能分析。可以输出运行时长，</li>
</ul>
<h2 id="0x01、分析示例"><a href="#0x01、分析示例" class="headerlink" title="0x01、分析示例"></a>0x01、分析示例</h2><ul>
<li>1.直接加载cProfile模块来运行代码进行输出分析。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># 方式一</span></span><br><span class="line"><span class="comment"># 直接输出调用的函数、运行时长、cpu占用等情况</span></span><br><span class="line">python -m cProfile main.py</span><br><span class="line"><span class="comment"># 如果调用链路太长，则可以指定输出到文件内，如下所示。不过输出内容为二进制，不可以直接查看。</span></span><br><span class="line">python -m cProfile -o profile.out main.py</span><br><span class="line"></span><br><span class="line"><span class="comment"># 方式二</span></span><br><span class="line"><span class="keyword">import</span> cProfile</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    cProfile.run(<span class="string">"test()"</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>2.为了解决分析内容格式是二进制的，python自带了可以分析的工具pstats。示例代码如下</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Stats对象</span></span><br><span class="line">p = pstats.Stats(<span class="string">"profile/profile.out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></span><br><span class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></span><br><span class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行,也可以指定小数，为百分比，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></span><br><span class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"test"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></span><br><span class="line">p.print_callees(<span class="string">"test"</span>)</span><br></pre></td></tr></table></figure>

<h2 id="0x03、可视化分析"><a href="#0x03、可视化分析" class="headerlink" title="0x03、可视化分析"></a>0x03、可视化分析</h2><p>上面的分析只能做初步的统计查看，并不能有直观的查看和分析。所有一下提供了函数堆栈调用图及每步所花费的时间占比等。</p>
<ul>
<li>1.安装gprof2dot</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">pip install gprof2dot</span><br></pre></td></tr></table></figure>

<ul>
<li>2.安装graphviz包。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> mac下</span></span><br><span class="line">brew install graphviz</span><br></pre></td></tr></table></figure>

<ul>
<li>3.对输出的out文件进行分析</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">gprof2dot -f pstats profile.out | dot -Tpng -o profile.png</span><br></pre></td></tr></table></figure>

<p>其效果如下图<br><img src="/assets/images/2019/10-08-profile.png" alt="cprofile分析图"></p>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>tmux配置</title>
    <url>/2019/09/05/2019/09-05-tmux%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h2 id="0x00、简介"><a href="#0x00、简介" class="headerlink" title="0x00、简介"></a>0x00、简介</h2><ul>
<li>终端复用神器</li>
</ul>
<h2 id="0x01、快捷键"><a href="#0x01、快捷键" class="headerlink" title="0x01、快捷键"></a>0x01、快捷键</h2><h3 id="1-tmux命令"><a href="#1-tmux命令" class="headerlink" title="1.tmux命令"></a>1.tmux命令</h3><ul>
<li>启动新会话</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux [new -s 会话名 -n 窗口名]</span><br></pre></td></tr></table></figure>

<ul>
<li>恢复会话：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux at [-t 会话名]</span><br></pre></td></tr></table></figure>

<ul>
<li>列出所有会话：</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure>

<ul>
<li>关闭会话</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tmux kill-session -t 会话名</span><br></pre></td></tr></table></figure>

<h3 id="2-tmux内快捷键"><a href="#2-tmux内快捷键" class="headerlink" title="2.tmux内快捷键"></a>2.tmux内快捷键</h3><ul>
<li>会话</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:new&lt;回车&gt;  启动新会话</span><br><span class="line">s           列出所有会话</span><br><span class="line"><span class="meta">$</span><span class="bash">           重命名当前会话</span></span><br></pre></td></tr></table></figure>

<ul>
<li>窗口 (标签页)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">c 创建一个新窗口</span><br><span class="line">, 重命名当前窗口</span><br><span class="line">w 列出所有窗口</span><br><span class="line"><span class="meta">%</span><span class="bash"> 水平分割窗口</span></span><br><span class="line">" 竖直分割窗口</span><br><span class="line">n 选择下一个窗口</span><br><span class="line">p 选择上一个窗口</span><br><span class="line">0~9 选择0~9对应的窗口</span><br><span class="line">h 将光标移入左侧的窗格*</span><br><span class="line">j 将光标移入下方的窗格*</span><br><span class="line">l 将光标移入右侧的窗格*</span><br><span class="line">k 将光标移入上方的窗格*</span><br><span class="line">q 显示窗格的编号</span><br><span class="line">o 在窗格间切换</span><br><span class="line">&#125; 与下一个窗格交换位置</span><br><span class="line">&#123; 与上一个窗格交换位置</span><br><span class="line">! 在新窗口中显示当前窗格</span><br><span class="line">x 关闭当前窗格</span><br></pre></td></tr></table></figure>

<ul>
<li>调整窗口排序</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swap-window -s 3 -t 1  交换 3 号和 1 号窗口</span><br><span class="line">swap-window -t 1       交换当前和 1 号窗口</span><br><span class="line">move-window -t 1       移动当前窗口到 1 号</span><br></pre></td></tr></table></figure>

<ul>
<li>窗格（分割窗口）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">  垂直分割</span></span><br><span class="line">"  水平分割</span><br><span class="line">o  交换窗格</span><br><span class="line">x  关闭窗格</span><br><span class="line">⍽  左边这个符号代表空格键 - 切换布局</span><br><span class="line">q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格</span><br><span class="line">&#123; 与上一个窗格交换位置</span><br><span class="line">&#125; 与下一个窗格交换位置</span><br><span class="line">z 切换窗格最大化/最小化</span><br></pre></td></tr></table></figure>

<ul>
<li>杂项</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">d  退出 tmux（tmux 仍在后台运行）</span><br><span class="line">t  窗口中央显示一个数字时钟</span><br><span class="line">?  列出所有快捷键</span><br><span class="line">:  命令提示符</span><br></pre></td></tr></table></figure>

<h2 id="0x02、配置文件"><a href="#0x02、配置文件" class="headerlink" title="0x02、配置文件"></a>0x02、配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置前缀为Ctrl + a</span></span><br><span class="line">set -g prefix C-a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解除Ctrl+b 与前缀的对应关系</span></span><br><span class="line">unbind C-b</span><br><span class="line">bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置序号从1开始</span></span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将r 设置为加载配置文件，并显示<span class="string">"reloaded!"</span>信息</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display "Reloaded!"</span><br><span class="line"></span><br><span class="line">bind-key k select-pane -U # up</span><br><span class="line">bind-key j select-pane -D # down</span><br><span class="line">bind-key h select-pane -L # left</span><br><span class="line">bind-key l select-pane -R # right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set -g mouse on # 支持鼠标选取文本等</span><br><span class="line"></span><br><span class="line">set -g status-interval 2 # 状态栏刷新时间</span><br><span class="line">set -g status-justify left # 状态栏列表左对齐</span><br><span class="line">setw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知</span><br><span class="line"></span><br><span class="line">set -g status-bg black # 设置状态栏背景黑色</span><br><span class="line">set -g status-fg yellow # 设置状态栏前景黄色</span><br><span class="line">set -g status-style "bg=black, fg=yellow" # 状态栏前景背景色</span><br><span class="line"></span><br><span class="line">set -g status-left "#[bg=#FF661D] " # 状态栏左侧内容</span><br><span class="line">set -g status-right "#S #[fg=green,bg=black]#(tmux-mem-cpu-load --colors --interval 2)#[default]"</span><br><span class="line">set -g status-left-length 300 # 状态栏左边长度300</span><br><span class="line">set -g status-right-length 500 # 状态栏右边长度500</span><br><span class="line"></span><br><span class="line">set -wg window-status-format " #I #W " # 状态栏窗口名称格式</span><br><span class="line">set -wg window-status-current-format " #I:#W#F " # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span><br><span class="line">set -wg window-status-separator "" # 状态栏窗口名称之间的间隔</span><br><span class="line">set -wg window-status-current-style "bg=red" # 状态栏当前窗口名称的样式</span><br><span class="line">set -wg window-status-last-style "fg=yellow" # 状态栏最后一个窗口名称的样式</span><br><span class="line"></span><br><span class="line">set -g message-style "bg=#202529, fg=#91A8BA" # 指定消息通知的前景、后景色</span><br></pre></td></tr></table></figure>

<h2 id="0x03、复制到系统"><a href="#0x03、复制到系统" class="headerlink" title="0x03、复制到系统"></a>0x03、复制到系统</h2><p>在 Mac 下使用 tmux，希望能够复制到系统粘贴板，可以通过下面的方式实现：</p>
<ul>
<li>1.安装 rettach-to-user-namespace</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install reattach-to-user-namespace</span><br></pre></td></tr></table></figure>

<ul>
<li>2.修改 ~/.tmux.conf</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set-option -g default-command "reattach-to-user-namespace -l zsh"</span><br><span class="line"><span class="meta">#</span><span class="bash"> buffer缓存复制到Mac系统粘贴板</span></span><br><span class="line">bind y run "tmux save-buffer - | reattach-to-user-namespace pbcopy" \; display-message "Copied tmux buffer to system clipboard"</span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac系统粘贴板内容复制到会话</span></span><br><span class="line">bind C-v run "reattach-to-user-namespace pbpaste | tmux load-buffer - \; paste-buffer -d"</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3.使用<br>在 tmux 中复制之后，按 prefix + y 就可以把 tmux 内复制的内容放到系统粘贴板了</p>
</li>
<li><p>4.复制模式<br>tmux中操作文本，自然离不开复制模式，通常使用复制模式的步骤如下：</p>
<ul>
<li><ol>
<li>输入 `+[ 进入复制模式</li>
</ol>
</li>
<li><ol start="2">
<li>按下 空格键 开始复制，移动光标选择复制区域</li>
</ol>
</li>
<li><ol start="3">
<li>按下 回车键 复制选中文本并退出复制模式</li>
</ol>
</li>
<li><ol start="4">
<li>按下 `+] 粘贴文本</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>数据同步工具</title>
    <url>/2019/09/06/2019/09-06-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<h2 id="0x00、总览"><a href="#0x00、总览" class="headerlink" title="0x00、总览"></a>0x00、总览</h2><ul>
<li>1.定时任务</li>
<li>2.canal/otter</li>
<li>3.Datax</li>
<li>4.Sqoop</li>
<li>5.NiFi</li>
<li>6.mongoshake</li>
</ul>
<h2 id="0x02、定时任务"><a href="#0x02、定时任务" class="headerlink" title="0x02、定时任务"></a>0x02、定时任务</h2><p>定时任务工具是作为数据同步的最基本也是最常用的工具。其不但用于定时的数据同步，而且作为定时的处理其他任务，比如爬虫等。</p>
<h3 id="1-Airflow"><a href="#1-Airflow" class="headerlink" title="1.Airflow"></a>1.<a href="https://airflow.apache.org/" target="_blank" rel="noopener">Airflow</a></h3><h3 id="2-gocron"><a href="#2-gocron" class="headerlink" title="2.gocron"></a>2.<a href="https://github.com/ouqiang/gocron" target="_blank" rel="noopener">gocron</a></h3><h2 id="0x03、cannel-otter"><a href="#0x03、cannel-otter" class="headerlink" title="0x03、cannel/otter"></a>0x03、cannel/otter</h2><ul>
<li>阿里巴巴分布式数据库同步系统</li>
<li><a href="https://github.com/alibaba/otter" target="_blank" rel="noopener">官网</a></li>
<li>主要同步mysql数据，读取解析mysql binlog，然后同步导入到新的mysql库内</li>
</ul>
<h2 id="0x04、Datax"><a href="#0x04、Datax" class="headerlink" title="0x04、Datax"></a>0x04、Datax</h2><ul>
<li>阿里巴巴开源离线同步Datax</li>
<li><a href="https://github.com/alibaba/DataX" target="_blank" rel="noopener">官网</a></li>
<li>抽象为读取的reader源和写入的write源，支持开发新插件</li>
<li>直接读取写入，用json格式来描述，不支持中间做转换</li>
</ul>
<h2 id="0x05、Sqoop"><a href="#0x05、Sqoop" class="headerlink" title="0x05、Sqoop"></a>0x05、Sqoop</h2><ul>
<li><a href="https://sqoop.apache.org/" target="_blank" rel="noopener">https://sqoop.apache.org/</a></li>
<li><a href="https://github.com/apache/sqoop" target="_blank" rel="noopener">https://github.com/apache/sqoop</a></li>
<li>定位是从hadoop与关系型数据库的同步。</li>
<li>Sqoop 启用了一个 MapReduce 作业（极其容错的分布式并行计算）来执行任务</li>
<li>Sqoop 的另一大优势是其传输大量结构化或半结构化数据的过程是完全自动化的。</li>
<li><img src="/assets/images/2019/09-06-sqool.png" alt="架构图"></li>
</ul>
<h2 id="0x06、Nifi"><a href="#0x06、Nifi" class="headerlink" title="0x06、Nifi"></a>0x06、Nifi</h2><ul>
<li>NiFi 项目在创建过程中遵循了一些理念<ul>
<li>1）精细化管理信息流的能力；</li>
<li>2）跟踪数据相关事件和信息的能力，比如数据从哪里来，在路径中发生了什么；</li>
<li>3）保证控制和数据面的安全能力</li>
</ul>
</li>
<li>优势<ul>
<li>有保证的数据交付</li>
<li>支持背压（back-pressure）机制的数据缓冲</li>
<li>有优先级的队列</li>
<li>QoS</li>
<li>数据溯源（Data provenance）：NiFi 对数据流路径上的每次变化都会保留日志记录，从而保证结果的可追溯，以及数据的恢复、重播、审计和评估。</li>
<li>通过日志记录数据的历史细节</li>
<li>支持交互式命令和控制台，并对系统变化提供可视化的反馈</li>
<li>支持流模板（Flow templates）</li>
<li>支持插入式（Pluggable）/ 多角色（multi-role）的安全机制</li>
<li>支持对数据操作的扩展</li>
<li>支持集群管理</li>
</ul>
</li>
</ul>
<h2 id="0x07、mongoshake"><a href="#0x07、mongoshake" class="headerlink" title="0x07、mongoshake"></a>0x07、mongoshake</h2><ul>
<li><a href="https://github.com/alibaba/MongoShake" target="_blank" rel="noopener">https://github.com/alibaba/MongoShake</a></li>
<li>alibaba开源的同步mogndb的服务</li>
<li><img src="/assets/images/2019/09-06-mongoshake.png" alt="架构图"></li>
</ul>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>docker基础文档</title>
    <url>/2019/03/10/2019/03-10-docker%E5%9F%BA%E7%A1%80%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h2 id="0x00、命令"><a href="#0x00、命令" class="headerlink" title="0x00、命令"></a>0x00、命令</h2><ul>
<li>Management Commands:<ul>
<li><strong><code>config</code></strong>      Manage Docker configs</li>
<li><strong><code>container</code></strong>   Manage containers</li>
<li><strong><code>image</code></strong>       Manage images</li>
<li><strong><code>network</code></strong>     Manage networks</li>
<li><strong><code>node</code></strong>        Manage Swarm nodes</li>
<li><strong><code>plugin</code></strong>      Manage plugins</li>
<li><strong><code>secret</code></strong>      Manage Docker secrets</li>
<li><strong><code>service</code></strong>     Manage services</li>
<li><strong><code>stack</code></strong>       Manage Docker stacks</li>
<li><strong><code>swarm</code></strong>       Manage Swarm</li>
<li><strong><code>system</code></strong>      Manage Docker</li>
<li><strong><code>volume</code></strong>      Manage volumes</li>
</ul>
</li>
</ul>
<br>

<ul>
<li>Commands:<ul>
<li><strong><code>attach</code></strong>      Attach local standard input, output, and error streams to a running container</li>
<li><strong><code>build</code></strong>       Build an image from a Dockerfile</li>
<li><strong><code>commit</code></strong>      Create a new image from a container’s changes</li>
<li><strong><code>cp</code></strong>          Copy files/folders between a container and the local filesystem</li>
<li><strong><code>create</code></strong>      Create a new container</li>
<li><strong><code>diff</code></strong>        Inspect changes to files or directories on a container’s filesystem</li>
<li><strong><code>events</code></strong>      Get real time events from the server</li>
<li><strong><code>exec</code></strong>        Run a command in a running container</li>
<li><strong><code>export</code></strong>      Export a container’s filesystem as a tar archive</li>
<li><strong><code>history</code></strong>     Show the history of an image</li>
<li><strong><code>images</code></strong>      List images</li>
<li><strong><code>import</code></strong>      Import the contents from a tarball to create a filesystem image</li>
<li><strong><code>info</code></strong>        Display system-wide information</li>
<li><strong><code>inspect</code></strong>     Return low-level information on Docker objects</li>
<li><strong><code>kill</code></strong>        Kill one or more running containers</li>
<li><strong><code>load</code></strong>        Load an image from a tar archive or STDIN</li>
<li><strong><code>login</code></strong>       Log in to a Docker registry</li>
<li><strong><code>logout</code></strong>      Log out from a Docker registry</li>
<li><strong><code>logs</code></strong>        Fetch the logs of a container</li>
<li><strong><code>pause</code></strong>       Pause all processes within one or more containers</li>
<li><strong><code>port</code></strong>        List port mappings or a specific mapping for the container</li>
<li><strong><code>ps</code></strong>          List containers</li>
<li><strong><code>pull</code></strong>        Pull an image or a repository from a registry</li>
<li><strong><code>push</code></strong>        Push an image or a repository to a registry</li>
<li><strong><code>rename</code></strong>      Rename a container</li>
<li><strong><code>restart</code></strong>     Restart one or more containers</li>
<li><strong><code>rm</code></strong>          Remove one or more containers</li>
<li><strong><code>rmi</code></strong>         Remove one or more images</li>
<li><strong><code>run</code></strong>         Run a command in a new container</li>
<li><strong><code>save</code></strong>        Save one or more images to a tar archive (streamed to STDOUT by default)</li>
<li><strong><code>search</code></strong>      Search the Docker Hub for images</li>
<li><strong><code>start</code></strong>       Start one or more stopped containers</li>
<li><strong><code>stats</code></strong>       Display a live stream of container(s) resource usage statistics</li>
<li><strong><code>stop</code></strong>        Stop one or more running containers</li>
<li><strong><code>tag</code></strong>         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</li>
<li><strong><code>top</code></strong>         Display the running processes of a container</li>
<li><strong><code>unpause</code></strong>     Unpause all processes within one or more containers</li>
<li><strong><code>update</code></strong>      Update configuration of one or more containers</li>
<li><strong><code>version</code></strong>     Show the Docker version information</li>
<li><strong><code>wait</code></strong>        Block until one or more containers stop, then print their exit codes</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><strong><code>docker images</code></strong>       // 查看存在多少镜像</li>
<li><strong><code>docker ps</code></strong>           // 查看镜像运行情况</li>
<li><strong><code>docker run -t -i</code></strong>    // 运行镜像。并进行交互模式。</li>
<li><strong><code>docker stop</code></strong>         // 停止运行镜像，后边跟镜像ID或name</li>
<li><strong><code>docker search</code></strong>       // 搜索镜像仓库</li>
<li><strong><code>docker pull</code></strong>         // 拉取镜像</li>
<li><strong><code>docker inspect</code></strong>      // 查看镜像的json文件，即全部详细信息</li>
<li><strong><code>docker port</code></strong>         // 查看docker与宿主机的端口映射关系</li>
<li><strong><code>docker commit</code></strong>       // 用来生成新的版本</li>
<li><strong><code>docker build</code></strong>        // 用docker file来创建镜像</li>
<li><strong><code>docker tag</code></strong>          // 设置镜像标签</li>
</ul>
<br>

<ul>
<li>容器生命周期管理<ul>
<li><strong><code>create</code></strong></li>
<li><strong><code>run</code></strong></li>
<li><strong><code>start/stop/restart</code></strong></li>
<li><strong><code>pause/unpause</code></strong></li>
<li><strong><code>exec</code></strong></li>
<li><strong><code>rm</code></strong></li>
<li><strong><code>kill</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li><p>容器操作</p>
<ul>
<li><strong><code>ps</code></strong></li>
<li><strong><code>inspect</code></strong></li>
<li><strong><code>top</code></strong></li>
<li><strong><code>attach</code></strong></li>
<li><strong><code>events</code></strong></li>
<li><strong><code>logs</code></strong></li>
<li><strong><code>wait</code></strong></li>
<li><strong><code>export</code></strong></li>
<li><strong><code>port</code></strong></li>
</ul>
</li>
<li><p>容器rootfs命令</p>
<ul>
<li><strong><code>commit</code></strong></li>
<li><strong><code>cp</code></strong></li>
<li><strong><code>diff</code></strong></li>
</ul>
</li>
<li><p>镜像仓库</p>
<ul>
<li><strong><code>login</code></strong></li>
<li><strong><code>pull</code></strong></li>
<li><strong><code>push</code></strong></li>
<li><strong><code>search</code></strong></li>
</ul>
</li>
<li><p>本地镜像管理</p>
<ul>
<li><strong><code>images</code></strong></li>
<li><strong><code>rmi</code></strong></li>
<li><strong><code>tag</code></strong></li>
<li><strong><code>build</code></strong></li>
<li><strong><code>history</code></strong></li>
<li><strong><code>save</code></strong></li>
<li><strong><code>import</code></strong></li>
</ul>
</li>
<li><p>信息</p>
<ul>
<li><strong><code>info</code></strong></li>
<li><strong><code>version</code></strong></li>
</ul>
</li>
</ul>
<h2 id="0x01、简介"><a href="#0x01、简介" class="headerlink" title="0x01、简介"></a>0x01、简介</h2><h3 id="1-链接映射"><a href="#1-链接映射" class="headerlink" title="1.链接映射"></a>1.链接映射</h3><p>docker有一个连接系统允许将多个容器连接在一起，共享连接信息。docker连接会创建一个父子关系，其中父容器可以看到子容器的信息。</p>
<h3 id="2-容器与虚拟机是互补的。"><a href="#2-容器与虚拟机是互补的。" class="headerlink" title="2.容器与虚拟机是互补的。"></a>2.容器与虚拟机是互补的。</h3><p>虚拟机是用来进行硬件资源划分的完美解决方案，它利用了硬件虚拟化技术，例如VT-x、AMD-V或者privilege level（权限等级）会同时通过一个hypervisor层来实现对资源的彻底隔离；而容器则是操作系统级别的虚拟化，利用的是内核的Cgroup和Namespace特性，此功能完全通过软件来实现，仅仅是进程本身就可以与其他进程隔离开，不需要任何辅助。</p>
<p>Docker容器与主机共享操作系统内核，不同的容器之间可以共享部分系统资源，因此容器更加轻量级，消耗的资源也更少。而虚拟机会独占分配给自己的资源，几乎不存在资源共享，各个虚拟机实例之间近乎完全隔离，因此虚拟机更加重量级，也会消耗更多的资源。\</p>
<h3 id="3-最小组成"><a href="#3-最小组成" class="headerlink" title="3.最小组成"></a>3.最小组成</h3><p>对于Linux容器的最小组成，可以由以下公式来表示：</p>
<ul>
<li>容器=cgroup+namespace+rootfs+容器引擎（用户态工具）</li>
</ul>
<p>其中各项的功能分别为：</p>
<ul>
<li>Cgroup：资源控制。</li>
<li>Namespace：访问隔离。</li>
<li>rootfs：文件系统隔离。</li>
<li>容器引擎：生命周期控制。</li>
</ul>
<p>目前市场上所有Linux容器项目都包含以上组件。</p>
<h2 id="0x02、Cgroups"><a href="#0x02、Cgroups" class="headerlink" title="0x02、Cgroups"></a>0x02、Cgroups</h2><p>Cgroup是control group的简写，属于Linux内核提供的一个特性，用于限制和隔离一组进程对系统资源的使用，也就是做资源QoS，这些资源主要包括CPU、内存、block I/O和网络带宽。</p>
<p>从实现的角度来看，Cgroup实现了一个通用的进程分组的框架，而不同资源的具体管理则是由各个Cgroup子系统实现的。</p>
<p>Cgroup中实现的子系统及其作用如下：</p>
<ul>
<li>devices：设备权限控制。</li>
<li>cpuset：分配指定的CPU和内存节点。</li>
<li>cpu：控制CPU占用率。</li>
<li>cpuacct：统计CPU使用情况。</li>
<li>memory：限制内存的使用上限。</li>
<li>freezer：冻结（暂停）Cgroup中的进程。</li>
<li>net_cls：配合tc（traffic controller）限制网络带宽。</li>
<li>net_prio：设置进程的网络流量优先级。</li>
<li>huge_tlb：限制HugeTLB的使用。</li>
<li>perf_event：允许Perf工具基于Cgroup分组</li>
<li>做性能监测。</li>
</ul>
<h4 id="Cgroups子系统"><a href="#Cgroups子系统" class="headerlink" title="Cgroups子系统"></a>Cgroups子系统</h4><h5 id="cpuset子系统"><a href="#cpuset子系统" class="headerlink" title="cpuset子系统"></a>cpuset子系统</h5><ul>
<li>cpuset可以为一组进程分配指定的CPU和内存节点。</li>
</ul>
<ul>
<li><p>cpu子系统</p>
<ul>
<li>子系统用于限制进程的CPU占用率。实际上它有三个功能，分别通过不同的接口来提供。<ul>
<li>CPU比重分配。这个特性使用的接口是cpu.shares。</li>
<li>CPU带宽限制。这个特性使用的接口是cpu.cfs_period_us和cpu.cfs_quota_us，这两个接口的单位是微秒</li>
<li>实时进程的CPU带宽限制。以上两个特性都只能限制普通进程，若要限制实时进程，就要使用cpu.rt_period_us和cpu.rt_runtime_us这两个接口了。使用方法和上面类似。</li>
</ul>
</li>
</ul>
</li>
<li><p>cpuacct子系统</p>
<ul>
<li>cpuacct子系统用来统计各个Cgroup的CPU使用情况</li>
</ul>
</li>
<li><p>memory子系统</p>
<ul>
<li>memory子系统用来限制Cgroup所能使用的内存上限</li>
</ul>
</li>
<li><p>blkio子系统</p>
<ul>
<li>blkio子系统用来限制Cgroup的block I/O带宽</li>
</ul>
</li>
<li><p>devices子系统</p>
<ul>
<li>devices子系统用来控制Cgroup的进程对哪些设备有访问权限</li>
</ul>
</li>
</ul>
<h2 id="0x03、Namespace"><a href="#0x03、Namespace" class="headerlink" title="0x03、Namespace"></a>0x03、Namespace</h2><p>Namespace是将内核的全局资源做封装，使得每个Namespace都有一份独立的资源，因此不同的进程在各自的Namespace内对同一种资源的使用不会互相干扰</p>
<p>目前Linux内核总共实现了6种Namespace：</p>
<ul>
<li>IPC：隔离System V IPC和POSIX消息队列。</li>
<li>Network：隔离网络资源。</li>
<li>Mount：隔离文件系统挂载点。</li>
<li>PID：隔离进程ID。</li>
<li>UTS：隔离主机名和域名。</li>
<li>User：隔离用户ID和组ID。</li>
</ul>
<p>对Namespace的操作，主要是通过clone、setns和unshare这3个系统调用来完成的。</p>
<h4 id="1-子命名空间"><a href="#1-子命名空间" class="headerlink" title="1.子命名空间"></a>1.子命名空间</h4><p>1.UTS Namespace</p>
<ul>
<li>UTS Namespace用于对主机名和域名进行隔离，也就是uname系统调用使用的结构体struct utsname里的nodename和domainname这两个字段，UTS这个名字也是由此而来的。</li>
</ul>
<p>2.IPC Namespace</p>
<ul>
<li>IPC是Inter-Process Communication的简写，也就是进程间通信。Linux提供了很多种进程间通信的机制，IPC Namespace针对的是SystemV IPC和Posix消息队列。</li>
</ul>
<p>3.PID Namespace</p>
<ul>
<li>PID Namespace用于隔离进程PID号，这样一来，不同的Namespace里的进程PID号就可以是一样的了。</li>
</ul>
<p>4.Mount Namespace</p>
<ul>
<li>Mount Namespace用来隔离文件系统挂载点，每个进程能看到的文件系统都记录在/proc/$$/mounts里。</li>
</ul>
<p>5.Network Namespace</p>
<ul>
<li>这个Namespace会对网络相关的系统资源进行隔离，每个Network Namespace都有自己的网络设备、IP地址、路由表、/proc/net目录、端口号等。</li>
</ul>
<p>6.User Namespace</p>
<ul>
<li>User Namespace用来隔离用户和组ID，也就是说一个进程在Namespace里的用户和组ID与它在host里的ID可以不一样，这样说可能读者还不理解有什么实际的用处。</li>
</ul>
<p>Namespace和Cgroup的使用是很灵活的，同时这里面又有不少需要注意的地方，因此直接操作Namespace和Cgroup并不是很容易。正是因为这些原因，Docker通过Libcontainer来处理这些底层的事情。这样一来，Docker只需要简单地调用Libcontainer的API，就能将完整的容器搭建起来</p>
<h2 id="0x04、Images"><a href="#0x04、Images" class="headerlink" title="0x04、Images"></a>0x04、Images</h2><ul>
<li>是启动融资的rootfs,只读模版</li>
</ul>
<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><h4 id="1-1-创建镜像"><a href="#1-1-创建镜像" class="headerlink" title="1.1 创建镜像"></a>1.1 创建镜像</h4><ul>
<li><p>1.直接下载镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.导入镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o centos.tar centos</span><br><span class="line">docker load -i centos.tar</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.制作新镜像</p>
<ul>
<li>docker import 用于导入包含根文件系统的归档，并将之变成docker镜像</li>
<li>docker commit 可以增量的生成镜像，可以把容器保存为一个镜像</li>
<li>docker build 可以用Dockerfile来制作镜像</li>
</ul>
</li>
</ul>
<h4 id="1-2-传输镜像"><a href="#1-2-传输镜像" class="headerlink" title="1.2 传输镜像"></a>1.2 传输镜像</h4><ul>
<li>1.用Docker镜像仓库做中转</li>
<li>2.docker export/docker save生成tar包</li>
<li>3.Dockerfile文件</li>
</ul>
<h4 id="1-3-运行镜像"><a href="#1-3-运行镜像" class="headerlink" title="1.3 运行镜像"></a>1.3 运行镜像</h4><ul>
<li>docker run 来运营一个镜像成为容器</li>
</ul>
<h3 id="2-组织结构"><a href="#2-组织结构" class="headerlink" title="2.组织结构"></a>2.组织结构</h3><h4 id="2-1-数据内容"><a href="#2-1-数据内容" class="headerlink" title="2.1 数据内容"></a>2.1 数据内容</h4><p>包含着数据和元数据。</p>
<ul>
<li>数据有一层一层的image layer组成，元数据则是一些JSON文件，用来描述数据之间的关系和容器配置信息。</li>
</ul>
<p>Docker对数据进行来完整性校验，这种完整性对凭证是有镜像仓库提供的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ll /var/lab/docker</span><br></pre></td></tr></table></figure>

<p>1.总体信息</p>
<ul>
<li>从repositories-overlay文件可以看到该存储目录下的所有image以及其对应的layer ID.</li>
</ul>
<p>2.数据和元数据</p>
<ul>
<li>graph和overlay目录包含本地镜像库中所有元数据和数据信息</li>
<li>对于不同的存储驱动，数据的存储位置和存储结构是不同的。</li>
<li>元数据包含json和layersize两个文件，其中json包含来必要的层次和配置信息，layersize文件包含来该层的大小。</li>
<li>先通过repositories-overlay获取image对应的layer ID；在根据layer对应的元数据梳理出image包含的所有层，以及层之间的关系；在使用联合挂载技术还原出容器启动所需要的rootfs和一些基本配置信息。</li>
</ul>
<p>3.数据组织</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect dockerID</span><br></pre></td></tr></table></figure>

<h4 id="2-2-扩展知识"><a href="#2-2-扩展知识" class="headerlink" title="2.2 扩展知识"></a>2.2 扩展知识</h4><p>docker引入的联合挂载(Union mount)使镜像分层成为可能；而git式管理，使基础镜像复用成为可能。<br>1.联合挂载</p>
<ul>
<li>把多个目录挂载到同一个目录，对外呈现这些目录的联合。·</li>
</ul>
<p>2.写时复制</p>
<h2 id="0x05、仓库进阶"><a href="#0x05、仓库进阶" class="headerlink" title="0x05、仓库进阶"></a>0x05、仓库进阶</h2><h3 id="1-什么是仓库"><a href="#1-什么是仓库" class="headerlink" title="1.什么是仓库"></a>1.什么是仓库</h3><h4 id="1-1-仓库的组成"><a href="#1-1-仓库的组成" class="headerlink" title="1.1 仓库的组成"></a>1.1 仓库的组成</h4><p>仓库的名字通常有两部分组成，中间以斜线分隔。前边是用户名，后边是镜像名。<br>仓库有镜像存储系统和账户管理系统</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login -u &lt;user_name&gt; -p &lt;password&gt; -e &lt;email&gt; &lt;registry domain&gt;</span><br></pre></td></tr></table></figure>

<h4 id="1-2-仓库镜像"><a href="#1-2-仓库镜像" class="headerlink" title="1.2 仓库镜像"></a>1.2 仓库镜像</h4><p>仓库下面包含一组镜像，彼此之间用标签(tag)区分。一个完整的镜像地址通常有 服务器地址、仓库名称和标签组成。</p>
<p>1.上传镜像：push</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 表示向本地私有仓库上传镜像。如果不写服务器地址，默认上传到官方Docker Hub。一般需要先登陆在上传。</span><br><span class="line">docker push localhost::5000/official/ubuntu:14.04</span><br></pre></td></tr></table></figure>

<p>2.下载镜像：pull</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull ubuntu:14.04</span><br></pre></td></tr></table></figure>

<ul>
<li><p>3.搜索镜像：search</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure>
</li>
<li><p>注：在上传、下载过程中是逐层进行的。下载和搜索不需要登陆</p>
</li>
</ul>
<h3 id="1-3-restfulApi介绍"><a href="#1-3-restfulApi介绍" class="headerlink" title="1.3 restfulApi介绍"></a>1.3 restfulApi介绍</h3><h3 id="1-4-上传、下载、鉴权原理"><a href="#1-4-上传、下载、鉴权原理" class="headerlink" title="1.4 上传、下载、鉴权原理"></a>1.4 上传、下载、鉴权原理</h3><h3 id="1-5-私有仓库搭建"><a href="#1-5-私有仓库搭建" class="headerlink" title="1.5 私有仓库搭建"></a>1.5 私有仓库搭建</h3><h2 id="0x06、docker网络"><a href="#0x06、docker网络" class="headerlink" title="0x06、docker网络"></a>0x06、docker网络</h2><h2 id="0x07、容器卷管理"><a href="#0x07、容器卷管理" class="headerlink" title="0x07、容器卷管理"></a>0x07、容器卷管理</h2><p>可以把本地文件目录挂载到容器内</p>
<h2 id="0x08、DockerAPI"><a href="#0x08、DockerAPI" class="headerlink" title="0x08、DockerAPI"></a>0x08、DockerAPI</h2><h3 id="1-Docker-Remote-API"><a href="#1-Docker-Remote-API" class="headerlink" title="1.Docker Remote API"></a>1.Docker Remote API</h3><h3 id="2-Docker-Registry-API"><a href="#2-Docker-Registry-API" class="headerlink" title="2.Docker Registry API"></a>2.Docker Registry API</h3><h3 id="3-Docker-Hub-API"><a href="#3-Docker-Hub-API" class="headerlink" title="3.Docker Hub API"></a>3.Docker Hub API</h3><h2 id="0x09、Docker安全"><a href="#0x09、Docker安全" class="headerlink" title="0x09、Docker安全"></a>0x09、Docker安全</h2><h3 id="1-包含内容"><a href="#1-包含内容" class="headerlink" title="1.包含内容"></a>1.包含内容</h3><ul>
<li>容器的安全性</li>
<li>镜像的安全性</li>
<li>Docker daemon的安全性</li>
</ul>
<h3 id="2-容器安全"><a href="#2-容器安全" class="headerlink" title="2.容器安全"></a>2.容器安全</h3><ul>
<li>Cgroup<ul>
<li>限制CPU：指定CPU权重、使用上限</li>
<li>限制内存</li>
<li>限制块设备I/O</li>
</ul>
</li>
<li>ulimit<ul>
<li>core dump文件大小</li>
<li>进程数据段大小</li>
<li>可创建文件大小</li>
<li>常驻内存集大小</li>
<li>打开文件数量</li>
<li>进程栈的大小</li>
<li>CPU时间</li>
<li>单个用户的最大进程数</li>
<li>进程的最大虚拟内存</li>
</ul>
</li>
<li>容器组网<ul>
<li>将容器隔离在不同的网络内</li>
</ul>
</li>
<li>容器+虚拟化</li>
<li>镜像签名</li>
<li>日志审计</li>
<li>监控</li>
<li>文件系统级保护</li>
<li>capability<ul>
<li>可以作用在进程上；也可以作用在程序文件上</li>
<li>与sudo不同，sudo可以配置某个用户可以执行某个命令或更改某个文件；而capablity则是让某个程序拥有某种能力</li>
<li>每个进程有三个和能力有关的位图：Inheritable(I)、Permitted(P)和Effective(E)</li>
</ul>
</li>
<li>SELinux</li>
<li>APPArmor</li>
<li>Seccomp</li>
<li>grsecurity</li>
</ul>
<h3 id="3-安全加固"><a href="#3-安全加固" class="headerlink" title="3.安全加固"></a>3.安全加固</h3><h3 id="4-安全遗留问题"><a href="#4-安全遗留问题" class="headerlink" title="4.安全遗留问题"></a>4.安全遗留问题</h3><h2 id="0x10、Libcontainer"><a href="#0x10、Libcontainer" class="headerlink" title="0x10、Libcontainer"></a>0x10、Libcontainer</h2><p>容器引擎：一种驱动和管理容器生命周期的runtime工具</p>
<h2 id="0x11、Docker实战"><a href="#0x11、Docker实战" class="headerlink" title="0x11、Docker实战"></a>0x11、Docker实战</h2><p>部署web服务</p>
<h2 id="0x12、Docker集群"><a href="#0x12、Docker集群" class="headerlink" title="0x12、Docker集群"></a>0x12、Docker集群</h2><ul>
<li>Compose</li>
<li>Machine</li>
<li>Swarm</li>
</ul>
<h2 id="0x13、Docker生态圈"><a href="#0x13、Docker生态圈" class="headerlink" title="0x13、Docker生态圈"></a>0x13、Docker生态圈</h2>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能学习路线</title>
    <url>/2019/03/10/2019/04-09-%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E5%AD%A6%E4%B9%A0%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h2 id="0x00、数学基础"><a href="#0x00、数学基础" class="headerlink" title="0x00、数学基础"></a>0x00、数学基础</h2><ul>
<li>线性代数：如何将研究对象形式化<ul>
<li>事实上，线性代数不仅仅是人工智能的基础，更是现代数学和以现代数学作为主要分析方法的众多学科的基础。从量子力学到图像处理都离不开向量和矩阵的使用。而在向量和矩阵背后，线性代数的核心意义在于提供了⼀种看待世界的抽象视角：万事万物都可以被抽象成某些特征的组合，并在由预置规则定义的框架之下以静态和动态的方式加以观察。</li>
<li>着重于抽象概念的解释而非具体的数学公式来看，线性代数要点如下：线性代数的本质在于将具体事物抽象为数学对象，并描述其静态和动态的特性；向量的实质是 n 维线性空间中的静止点；线性变换描述了向量或者作为参考系的坐标系的变化，可以用矩阵表示；矩阵的特征值和特征向量描述了变化的速度与方向。</li>
<li>总之，线性代数之于人工智能如同加法之于高等数学，是一个基础的工具集。</li>
</ul>
</li>
<li>概率论：如何描述统计规律？<ul>
<li>除了线性代数之外，概率论也是人工智能研究中必备的数学基础。随着连接主义学派的兴起，概率统计已经取代了数理逻辑，成为人工智能研究的主流工具。在数据爆炸式增长和计算力指数化增强的今天，概率论已经在机器学习中扮演了核心角色。</li>
<li>同线性代数一样，概率论也代表了一种看待世界的方式，其关注的焦点是无处不在的可能性。频率学派认为先验分布是固定的，模型参数要靠最大似然估计计算；贝叶斯学派认为先验分布是随机的，模型参数要靠后验概率最大化计算；正态分布是最重要的一种随机变量的分布。</li>
</ul>
</li>
<li>数理统计：如何以小见大？<ul>
<li>在人工智能的研究中，数理统计同样不可或缺。基础的统计理论有助于对机器学习的算法和数据挖掘的结果做出解释，只有做出合理的解读，数据的价值才能够体现。数理统计根据观察或实验得到的数据来研究随机现象，并对研究对象的客观规律做出合理的估计和判断。</li>
<li>虽然数理统计以概率论为理论基础，但两者之间存在方法上的本质区别。概率论作用的前提是随机变量的分布已知，根据已知的分布来分析随机变量的特征与规律；数理统计的研究对象则是未知分布的随机变量，研究方法是对随机变量进行独立重复的观察，根据得到的观察结果对原始分布做出推断。</li>
<li>用一句不严谨但直观的话讲：数理统计可以看成是逆向的概率论。 数理统计的任务是根据可观察的样本反过来推断总体的性质；推断的工具是统计量，统计量是样本的函数，是个随机变量；参数估计通过随机抽取的样本来估计总体分布的未知参数，包括点估计和区间估计；假设检验通过随机抽取的样本来接受或拒绝关于总体的某个判断，常用于估计机器学习模型的泛化错误率。</li>
</ul>
</li>
<li>最优化理论： 如何找到最优解？<ul>
<li>本质上讲，人工智能的目标就是最优化：在复杂环境与多体交互中做出最优决策。几乎所有的人工智能问题最后都会归结为一个优化问题的求解，因而最优化理论同样是人工智能必备的基础知识。最优化理论研究的问题是判定给定目标函数的最大值（最小值）是否存在，并找到令目标函数取到最大值 (最小值) 的数值。 如果把给定的目标函数看成一座山脉，最优化的过程就是判断顶峰的位置并找到到达顶峰路径的过程。</li>
<li>通常情况下，最优化问题是在无约束情况下求解给定目标函数的最小值；在线性搜索中，确定寻找最小值时的搜索方向需要使用目标函数的一阶导数和二阶导数；置信域算法的思想是先确定搜索步长，再确定搜索方向；以人工神经网络为代表的启发式算法是另外一类重要的优化方法。</li>
</ul>
</li>
<li>信息论：如何定量度量不确定性？<ul>
<li>近年来的科学研究不断证实，不确定性就是客观世界的本质属性。换句话说，上帝还真就掷骰子。不确定性的世界只能使用概率模型来描述，这促成了信息论的诞生。</li>
<li>信息论使用“信息熵”的概念，对单个信源的信息量和通信中传递信息的数量与效率等问题做出了解释，并在世界的不确定性和信息的可测量性之间搭建起一座桥梁。</li>
<li>总之，信息论处理的是客观世界中的不确定性；条件熵和信息增益是分类问题中的重要参数；KL 散度用于描述两个不同概率分布之间的差异；最大熵原理是分类问题汇总的常用准则。</li>
</ul>
</li>
<li>形式逻辑：如何实现抽象推理？<ul>
<li>1956 年召开的达特茅斯会议宣告了人工智能的诞生。在人工智能的襁褓期，各位奠基者们，包括约翰·麦卡锡、赫伯特·西蒙、马文·闵斯基等未来的图灵奖得主，他们的愿景是让“具备抽象思考能力的程序解释合成的物质如何能够拥有人类的心智。”通俗地说，理想的人工智能应该具有抽象意义上的学习、推理与归纳能力，其通用性将远远强于解决国际象棋或是围棋等具体问题的算法。</li>
<li>如果将认知过程定义为对符号的逻辑运算，人工智能的基础就是形式逻辑；谓词逻辑是知识表示的主要方法；基于谓词逻辑系统可以实现具有自动推理能力的人工智能；不完备性定理向“认知的本质是计算”这一人工智能的基本理念提出挑战。</li>
</ul>
</li>
</ul>
<h2 id="0x01、机器学习主要方法"><a href="#0x01、机器学习主要方法" class="headerlink" title="0x01、机器学习主要方法"></a>0x01、机器学习主要方法</h2><ul>
<li>机器学习概述：如何让计算机识别特征</li>
<li>线性回归：如何拟合线性模型？</li>
<li>朴素贝叶斯分类：如何利用后验概率</li>
<li>逻辑回归：如何利用似然函数</li>
<li>决策树方法：如何利用信息增益</li>
<li>支持向量机：如何在特征空间上分类</li>
<li>集成学习：如何整合优化</li>
<li>聚类：如何实现无监督学习</li>
<li>降维学习：如何抓大放小</li>
</ul>
<h2 id="0x02、人工神经网络"><a href="#0x02、人工神经网络" class="headerlink" title="0x02、人工神经网络"></a>0x02、人工神经网络</h2><ul>
<li>神经网络的生理学依据：如何模拟人类认知？</li>
<li>神经网络的基本单元：如何构造人工神经网络？</li>
<li>多层神经网络：如何解决复杂问题？</li>
<li>前馈与反向传播：如何用神经网络实现优化？</li>
<li>自组织神经网络：如何用神经网络实现无监督学习？</li>
<li>模糊神经网络：如何用神经网络实现逻辑功能？</li>
</ul>
<h2 id="0x03、深度学习"><a href="#0x03、深度学习" class="headerlink" title="0x03、深度学习"></a>0x03、深度学习</h2><ul>
<li>深度学习概述：如何让人工神经网络物尽其用？</li>
<li>深度前馈网络：如何实现最佳近似？</li>
<li>深度学习中的正则化：如何抑制过拟合？</li>
<li>深度模型优化：如何提升学习效率？</li>
<li>自动编码器：如何实现生成式建模？</li>
<li>深度强化学习：如何实现从数据到决策？</li>
<li></li>
<li>深度信念网络：如何充分利用隐藏单元？</li>
<li>卷积神经网络：如何高效处理网格化数据？</li>
<li>递归神经网络：如何高效处理序列数据？</li>
<li>生成式对抗网络：如何让神经网络自行优化？</li>
<li>长短期记忆神经网络：如何在神经网络中引入记忆？</li>
<li></li>
<li>贝叶斯网络：如何利用有向概率图？</li>
<li>马尔可夫随扌厼如何利用无向概率图？</li>
<li>迁移学习：如何基于小数据学习？</li>
<li>集群智能：如何让智能涌现？</li>
</ul>
<h2 id="0x04、应用场景"><a href="#0x04、应用场景" class="headerlink" title="0x04、应用场景"></a>0x04、应用场景</h2><ul>
<li>计算机视觉：如何让人工智能会“看”？</li>
<li>语音识别：如何让人工智能会“听”？</li>
<li>对话系统：如何让人工智能会“说”？</li>
<li>机器翻译：如何让人工智能会“想”？</li>
</ul>
<h2 id="0x05、基础算法："><a href="#0x05、基础算法：" class="headerlink" title="0x05、基础算法："></a>0x05、基础算法：</h2><ul>
<li>SVM简介；</li>
<li>带松弛变量的SVM模型: CSVM；</li>
<li>对偶问题；</li>
<li>核方法；</li>
<li>支持向量回归：SVR；</li>
<li>Scikit-Learn中的SVM；</li>
<li>SVM案例分析：Otto商品分类；</li>
<li>决策树；</li>
<li>Scikit-Learn中的决策树模型；</li>
<li>决策树案例分析：Otto商品分类；</li>
<li>Bagging和随机森林；</li>
<li>Scikit-Learn中的随机森林模型；</li>
<li>随机森林案例分析：Otto商品分类；</li>
<li>Adaboost；</li>
<li>GBM；</li>
<li>Scikit-Learn中的GBM；</li>
<li>XGBoost原理；</li>
<li>XGBoost工具包使用指南；</li>
<li>XGBoost的Scikit-Learn接口；</li>
<li>XGBoost案例分析：Otto商品分类；</li>
<li>LightGBM原理；</li>
<li>LightGBM使用指南；</li>
<li>LightGBM案例分析：Otto商品分析；</li>
<li>PCA降维原理；</li>
<li>Scikit-Learn中的PCA；</li>
<li>t-SNE；</li>
<li>Scikit-Learn中的 t-SNE；</li>
<li>降维案例分析：Otto商品数据降维分析；</li>
<li>聚类简介；</li>
<li>KMean聚类算法；</li>
<li>Scikit-Learn中的 KMean聚类；</li>
<li>聚类案例分析：Event聚类；</li>
<li>推荐系统简介；</li>
<li>基于内容的推荐；</li>
<li>基于用户的协同过滤；</li>
<li>基于物品的协同过滤；</li>
<li>基于矩阵分解的协同过滤；</li>
<li>协同过滤推荐案例分析：MovieLens电影推荐；</li>
<li>CTR预估简介；</li>
<li>FTRL模型；</li>
<li>FM与FFM；</li>
<li>GBDT；</li>
<li>Wide and Deep Learning模型；</li>
<li>CTR案例分析：Criteo CTR预估；</li>
</ul>
]]></content>
      <categories>
        <category>AI</category>
      </categories>
      <tags>
        <tag>AI</tag>
      </tags>
  </entry>
  <entry>
    <title>kudu简介</title>
    <url>/2019/07/12/2019/07-12-kudu%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h2 id="0x00、总体概览"><a href="#0x00、总体概览" class="headerlink" title="0x00、总体概览"></a>0x00、总体概览</h2><h3 id="1-历史发展"><a href="#1-历史发展" class="headerlink" title="1.历史发展"></a>1.历史发展</h3><ul>
<li>2012年10月由Cloudera公司发起创建,2015年10月对外公布，2015年12月进入apache基金会进行孵化，后续进入快速发展轨道。</li>
</ul>
<h3 id="2-产品定位"><a href="#2-产品定位" class="headerlink" title="2.产品定位"></a>2.产品定位</h3><ul>
<li>Fast Analytics on Fast Data。</li>
<li>在快速修改的数据上进行快速分析</li>
</ul>
<h3 id="3-产生之前"><a href="#3-产生之前" class="headerlink" title="3.产生之前"></a>3.产生之前</h3><p>在有kudu之前，数据分类为：</p>
<ul>
<li>静态数据<ul>
<li>以HDFS引擎作为存储引擎，适⽤用于⾼吞吐量的离线大数据分析场景</li>
<li>这类存储的局限性是数据无法进行行随机的读写</li>
</ul>
</li>
<li>动态数据<ul>
<li>以HBase、Cassandra 作为存储引擎，适⽤用于⼤大数据随机读写场景</li>
<li>这类存储的局限性是批量量读取吞吐量量远不不如 HDFS，不不适⽤用于批量量数据分 析的场景</li>
</ul>
</li>
</ul>
<p>而既要满足随机读写和大数据分析的解决方案如下：</p>
<p><img src="/assets/images/2019/07-12-hbase-hdfs.png" alt="解决方案图"></p>
<p>而以上的方案问题是：</p>
<ul>
<li>架构复杂<ul>
<li>流转涉及环节太多，运维成本很高</li>
<li>每个环节需要保证高可用，需要维护多个副本，存储空间也有一定的浪费</li>
<li>数据在多个系统上，对数据安全策略、监控等都提出了挑战</li>
</ul>
</li>
<li>时效性低<ul>
<li>从 HBase 导出成静态文件是周期性</li>
</ul>
</li>
<li>难以应对后续的更新<ul>
<li>已经从 HBase 导出到 HDFS，新到的变更数据就难以处理</li>
</ul>
</li>
</ul>
<p>所以产生了新的解决方案，那就是kudu，其定位如下：<br><img src="/assets/images/2019/07-12-kudu-position.png" alt="kudu定位"></p>
<p>而其gap了hdfs和hbase之间的<br><img src="/assets/images/2019/07-12-kudu-gap.png" alt="kudugap"></p>
<h3 id="4-架构图"><a href="#4-架构图" class="headerlink" title="4.架构图"></a>4.架构图</h3><p>kudu的整体架构图如下<br><img src="/assets/images/2019/07-12-kudu-architecture.png" alt="架构图"></p>
<h3 id="5-基本概念"><a href="#5-基本概念" class="headerlink" title="5.基本概念"></a>5.基本概念</h3><p>下面了解一些kudu里的一些基本概念。</p>
<ul>
<li>Table<ul>
<li>数据存储，没有库的概念</li>
<li>有对应的schema结构</li>
<li>字段是强类型</li>
<li>需要设置主键</li>
<li>分隔为N个tablets</li>
</ul>
</li>
<li>Tablet<ul>
<li>Table按照行切分后存储的位置</li>
<li>一个tablet会多副本到其他server上，并且有一个会是leader</li>
<li>如果leader失效，会用raft一致性协议重新选举</li>
<li>任何一组副本内的tablet都可以读，但是只能从leader写入</li>
</ul>
</li>
<li>Mater<ul>
<li>持续追踪所有的tablet、tablet server、catalog table、其他的集群meta信息</li>
<li>可以部署多个master，但只有一个是active</li>
<li>如果active时效了，用raft协议在选举出一个</li>
<li>Master信息也会存储在一个tablet上，并且被复制同步到其他master机器上</li>
<li>Tablet servers会发送心跳包到master机器(默认是一秒一次)</li>
</ul>
</li>
<li>Tablet Server<ul>
<li>用来存储tablet数据并且向client提供服务</li>
<li>一个tablet会在多个tablet server上</li>
<li>一个tablet server会有多个tablet</li>
</ul>
</li>
<li>Catelog table<ul>
<li>是kudu元数据的中心，存储了关于table和tablet的信息</li>
<li>不允许被直接读写</li>
<li>table<ul>
<li>table schemas,</li>
<li>Locations</li>
<li>states</li>
</ul>
</li>
<li>tablet<ul>
<li>Tablet list</li>
<li>Tablet server上有哪些tablet</li>
<li>States</li>
<li>Start and end keys</li>
</ul>
</li>
</ul>
</li>
<li>Raft一致性协议算法<ul>
<li>分布式服务高可用性进行多副本</li>
<li>通过raft来选举出leader</li>
<li>多副本数据都可以读，但只有leader可以写</li>
<li>写入时只有当大多数follower确认成功，才算写入成功</li>
<li>在一组副本中(通常是3或5个)，允许有(N-1)/2的失败</li>
</ul>
</li>
</ul>
<h3 id="6-使用场景"><a href="#6-使用场景" class="headerlink" title="6.使用场景"></a>6.使用场景</h3><ul>
<li>流式实时计算<ul>
<li>流式计算场景通常有持续不断地大量写入</li>
<li>与此同时这些数据还要支持近乎实时的读、写以及更新操作</li>
</ul>
</li>
<li>时间序列存储<ul>
<li>hash分片设计能够很好地避免TSDB类请求的局部热点问题</li>
<li>高效的Scan性能让Kudu能够比Hbase更好的支持查询操作</li>
</ul>
</li>
<li>历史数据共存<ul>
<li>Impala可以同时支持HDFS、Kudu等多个底层存储引擎</li>
<li>不必把所有的数据都迁移到Kudu</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="0x01、设计模式"><a href="#0x01、设计模式" class="headerlink" title="0x01、设计模式"></a>0x01、设计模式</h2></blockquote>
<h3 id="1-数据类型"><a href="#1-数据类型" class="headerlink" title="1.数据类型"></a>1.数据类型</h3><ul>
<li>boolean</li>
<li>8-bit signed integer</li>
<li>16-bit signed integer</li>
<li>32-bit signed integer</li>
<li>64-bit signed integer</li>
<li>unixtime_micros (64-bit microseconds since the Unix epoch)</li>
<li>single-precision (32-bit) IEEE-754 floating-point number</li>
<li>double-precision (64-bit) IEEE-754 floating-point number</li>
<li>decimal (see Decimal Type for details)</li>
<li>UTF-8 encoded string (up to 64KB uncompressed)</li>
<li>binary (up to 64KB uncompressed)</li>
</ul>
<h3 id="2-主键设计"><a href="#2-主键设计" class="headerlink" title="2.主键设计"></a>2.主键设计</h3><ul>
<li>单列或多列<ul>
<li>可以设置一列为主键，也同时设置多列为主键</li>
</ul>
</li>
<li>唯一性<ul>
<li>数据是全表唯一的</li>
</ul>
</li>
<li>不可被更改性<ul>
<li>在schema建成后，主键不能够修改</li>
<li>其值不能被更改，不同即新增</li>
</ul>
</li>
<li>主键索引<ul>
<li>为主键建立B+索引</li>
</ul>
</li>
</ul>
<h3 id="3-分区设计-Partition"><a href="#3-分区设计-Partition" class="headerlink" title="3.分区设计(Partition)"></a>3.分区设计(Partition)</h3><ul>
<li><p>表分区类型</p>
<ul>
<li>hash<ul>
<li>按照某一个或几个值的hash进行分区</li>
<li>可指定分区的个数</li>
</ul>
</li>
<li>range<ul>
<li>按照某一个字段值的范围分区</li>
<li>可以动态的增删</li>
</ul>
</li>
<li>multilevel<ul>
<li>可以同时按照hash、range结合来分区</li>
<li>既分散热点数据又可动态增删</li>
</ul>
</li>
</ul>
</li>
<li><p>比如建立如下一个表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> metrics (</span><br><span class="line">    host <span class="keyword">STRING</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    metric <span class="keyword">STRING</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="built_in">time</span> INT64 <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="keyword">value</span> <span class="keyword">DOUBLE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (host, metric, <span class="built_in">time</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
</li>
<li><p>按照range来分区如下<br><img src="/assets/images/2019/07-12-range.png" alt="range"></p>
</li>
<li><p>按照hash分区如下<br><img src="/assets/images/2019/07-12-hash.png" alt="hash"></p>
</li>
<li><p>同时按照range和hash来分区<br><img src="/assets/images/2019/07-12-hash-range.png" alt="rang-hash"></p>
</li>
<li><p>同时按照hash和hash来分区<br><img src="/assets/images/2019/07-12-hash-hash.png" alt="hash-hash"></p>
</li>
<li><p>那么hash与range的优缺点是<br><img src="/assets/images/2019/07-12-hash-range-good-bad.png" alt="hash-range-good-bad"></p>
</li>
</ul>
<h3 id="4-字段编码"><a href="#4-字段编码" class="headerlink" title="4.字段编码"></a>4.字段编码</h3><ul>
<li><p>编码的类型如下<br><img src="/assets/images/2019/07-12-encoding.png" alt="encoding"></p>
</li>
<li><p>每中字段适用及默认的编码类型如下<br><img src="/assets/images/2019/07-12-field-encoding.png" alt="field-encoding"></p>
</li>
</ul>
<h3 id="5-数据压缩"><a href="#5-数据压缩" class="headerlink" title="5.数据压缩"></a>5.数据压缩</h3><ul>
<li>编码类型有一下几种<ul>
<li>LZ4<ul>
<li>可以设置为默认</li>
</ul>
</li>
<li>zlib</li>
<li>snappy</li>
</ul>
</li>
</ul>
<blockquote>
<h2 id="0x02、存储结构"><a href="#0x02、存储结构" class="headerlink" title="0x02、存储结构"></a>0x02、存储结构</h2></blockquote>
<ul>
<li>逻辑结构图如下<br><img src="/assets/images/2019/07-12-store-tree.png" alt="store-tree"></li>
</ul>
<blockquote>
<h2 id="0x03、读写流程"><a href="#0x03、读写流程" class="headerlink" title="0x03、读写流程"></a>0x03、读写流程</h2></blockquote>
<h3 id="1-锁类型"><a href="#1-锁类型" class="headerlink" title="1.锁类型"></a>1.锁类型</h3><ul>
<li>共享锁(读锁)<ul>
<li>获得后只能够进行读操作</li>
<li>其他读可以，任何写等待</li>
</ul>
</li>
<li>互斥锁(写锁)<ul>
<li>只能获得锁的对象进行写</li>
<li>任何读等待，其他写等待</li>
</ul>
</li>
<li>MVCC(Multi-Version Concurrency Control)<ul>
<li>每一个写操作都会创建一个新版本的数据</li>
<li>读操作会从有限多个版本的数据中挑选一个最合适的结果直接返回</li>
<li>读写操作之间的冲突就不再需要被关注，而管理和快速挑选数据的版本就成了 MVCC 需要解决的主要问题。</li>
</ul>
</li>
</ul>
<h3 id="2-存储数据"><a href="#2-存储数据" class="headerlink" title="2.存储数据"></a>2.存储数据</h3><p><img src="/assets/images/2019/07-12-insert-data.png" alt="insert-data"><br><img src="/assets/images/2019/07-12-store-data.png" alt="store-data"><br>fluash示例如下<br><img src="/assets/images/2019/07-12-flush.png" alt="flush"></p>
<h3 id="3-compaction"><a href="#3-compaction" class="headerlink" title="3.compaction"></a>3.compaction</h3><p><img src="/assets/images/2019/07-12-compation.png" alt="compation"></p>
<h3 id="4-kudu-api"><a href="#4-kudu-api" class="headerlink" title="4.kudu api"></a>4.kudu api</h3><p><img src="/assets/images/2019/07-12-kuduapi.png" alt="kuduapi"></p>
<blockquote>
<h2 id="0x04、impala结合"><a href="#0x04、impala结合" class="headerlink" title="0x04、impala结合"></a>0x04、impala结合</h2></blockquote>
<h3 id="1-功能简介"><a href="#1-功能简介" class="headerlink" title="1.功能简介"></a>1.功能简介</h3><ul>
<li>支持存储<ul>
<li>HDFS、Hbase、Kudu、Hive</li>
<li>csv、file</li>
</ul>
</li>
<li>结构概念<ul>
<li>库、表、视图、角色</li>
<li>权限、函数</li>
</ul>
</li>
<li>多种类型<ul>
<li>array、bigint、boolean、char</li>
<li>map、struct</li>
</ul>
</li>
</ul>
<h3 id="2-表的概念"><a href="#2-表的概念" class="headerlink" title="2.表的概念"></a>2.表的概念</h3><ul>
<li>内部表<ul>
<li>通过impala创建的表都是内部表(internal)</li>
<li>修改表结构对应的底层表也会进行变动</li>
<li>删除表底层表也删除</li>
</ul>
</li>
<li>外部表<ul>
<li>不同过impala创建的表都是外部表(external)</li>
<li>要操作这些表，需要在impala建立表的映射关系</li>
<li>通过sql修改表结构或者删除表不会删除底层表，删除的只是表的映射关系</li>
</ul>
</li>
</ul>
<h3 id="3-建表示例"><a href="#3-建表示例" class="headerlink" title="3.建表示例"></a>3.建表示例</h3><p><img src="/assets/images/2019/07-12-impala-create.png" alt="impala-create"></p>
<h3 id="4-属性操作"><a href="#4-属性操作" class="headerlink" title="4.属性操作"></a>4.属性操作</h3><p><img src="/assets/images/2019/07-12-impala-property.png" alt="impala-property"></p>
<h3 id="5-常用操作"><a href="#5-常用操作" class="headerlink" title="5.常用操作"></a>5.常用操作</h3><p><img src="/assets/images/2019/07-12-impala-op.png" alt="impala-op"></p>
<h3 id="6-python-api"><a href="#6-python-api" class="headerlink" title="6.python api"></a>6.python api</h3><p><img src="/assets/images/2019/07-12-impalaapi.png" alt="api"></p>
<blockquote>
<h2 id="0x05、限制条件"><a href="#0x05、限制条件" class="headerlink" title="0x05、限制条件"></a>0x05、限制条件</h2></blockquote>
<h3 id="1-表限制"><a href="#1-表限制" class="headerlink" title="1.表限制"></a>1.表限制</h3><ul>
<li>表的备份数必须为奇数，最⼤大为7</li>
<li>备份数在设置后不不可修改</li>
<li>删除表后空间会⽴立⻢马释放</li>
<li>建表时partition总数限制为60个，后续可以添加</li>
</ul>
<h3 id="2-列限制"><a href="#2-列限制" class="headerlink" title="2.列限制"></a>2.列限制</h3><ul>
<li>部分数据类型不支持，如CHAR, VARCHAR, DATE, ARRAY等</li>
<li>数据类型以及是否可为空等列列属性不支持修改</li>
<li>一张表最多有300列列</li>
<li>删除列列的时候不会立马清除空间，需要执⾏Compaction操作，但是 Compaction操作不⽀持手动执行</li>
</ul>
<h3 id="3-主键限制"><a href="#3-主键限制" class="headerlink" title="3.主键限制"></a>3.主键限制</h3><ul>
<li>表创建后主键不不可更更改</li>
<li>主键字段必须在其他字段之前定义</li>
<li>⼀行对应的主键内容不可以被Update操作修改。要修改⼀行的主键值，需 要删除并新增⼀行新数据，并且该操作无法保持原子性</li>
<li>主键的类型不支持DOUBLE、FLOAT、BOOL，且必须是非空的(NOT NULL)</li>
<li>不支持⾃自动⽣生成主键</li>
<li>每行对应的主键存储单元(CELL)最⼤为16KB</li>
</ul>
<h3 id="4-单元限制"><a href="#4-单元限制" class="headerlink" title="4.单元限制"></a>4.单元限制</h3><ul>
<li>单元对应的数据最⼤大为64KB，并且是在压缩前</li>
</ul>
<h3 id="5-分片限制"><a href="#5-分片限制" class="headerlink" title="5.分片限制"></a>5.分片限制</h3><ul>
<li>分⽚只支持手动指定，⾃自动分⽚不支持</li>
<li>分片设定不不⽀支持修改，修改分⽚设定需要”建新表-导数据-删老表”操作;</li>
<li>丢掉多数备份的Tablets需要⼿手动修复。</li>
<li>Range⽀持删除或新增</li>
</ul>
<h3 id="6-容量建议"><a href="#6-容量建议" class="headerlink" title="6.容量建议"></a>6.容量建议</h3><ul>
<li>建议tablet servers的最⼤大数量量为100;</li>
<li>建议masters的最⼤大数量量为3;</li>
<li>建议每个tablet server存储的数据最大为8T</li>
<li>每个tablet server存储的tablets数量建议在1000以内;</li>
<li>每个表分片后的tablets存储在单个tablet server的最⼤大数量为60。</li>
</ul>
<h3 id="7-Impala集成限制"><a href="#7-Impala集成限制" class="headerlink" title="7.Impala集成限制"></a>7.Impala集成限制</h3><ul>
<li>不支持varchar、array、map、struct等类型</li>
<li>Impala⼤小写不不敏敏感，kudu是⼤小写敏敏感，所以表名及字段最好都是小写</li>
<li>!=和like查询是kudu把数据全部给impala，然后在过滤的，相⽐其他操作效率要低</li>
<li>Updates、inserts、deletes都是⾮非事务的</li>
<li>一条sql的并发执⾏行行数在于tablets的个数，所以推荐⾄至少有10个tablets</li>
</ul>
<h3 id="8-其他限制"><a href="#8-其他限制" class="headerlink" title="8.其他限制"></a>8.其他限制</h3><ul>
<li>主键有索引，不支持⼆级索引(Secondary indexes)</li>
<li>不支持多⾏行行的事务操作</li>
<li>关系型数据的一些功能，如外键，不支持;</li>
<li>列和表的名字强制为UTF-8编码，并且最大256字节</li>
</ul>
<blockquote>
<h2 id="0x06、文档资源"><a href="#0x06、文档资源" class="headerlink" title="0x06、文档资源"></a>0x06、文档资源</h2></blockquote>
<ul>
<li><a href="https://kudu.apache.org/kudu.pdf" target="_blank" rel="noopener">https://kudu.apache.org/kudu.pdf</a></li>
<li><a href="https://www.cloudera.com/documentation/enterprise/latest/PDF/cloudera-kudu.pdf" target="_blank" rel="noopener">https://www.cloudera.com/documentation/enterprise/latest/PDF/cloudera-kudu.pdf</a></li>
<li><a href="https://kudu.apache.org/docs/" target="_blank" rel="noopener">https://kudu.apache.org/docs/</a></li>
<li><a href="https://github.com/apache/kudu/blob/master/docs/design-docs/tablet.md" target="_blank" rel="noopener">https://github.com/apache/kudu/blob/master/docs/design-docs/tablet.md</a></li>
<li><a href="https://github.com/apache/kudu/blob/master/docs/design-docs/cfile.md" target="_blank" rel="noopener">https://github.com/apache/kudu/blob/master/docs/design-docs/cfile.md</a></li>
<li><a href="https://raft.github.io/raft.pdf" target="_blank" rel="noopener">https://raft.github.io/raft.pdf</a></li>
<li><a href="https://impala.apache.org/docs/build/impala-2.8.pdf" target="_blank" rel="noopener">https://impala.apache.org/docs/build/impala-2.8.pdf</a></li>
<li><a href="https://www.cloudera.com/documentation/enterprise/5-10-x/topics/impala_tutorial.html" target="_blank" rel="noopener">https://www.cloudera.com/documentation/enterprise/5-10-x/topics/impala_tutorial.html</a></li>
</ul>
]]></content>
      <categories>
        <category>kudu</category>
      </categories>
      <tags>
        <tag>kudu</tag>
      </tags>
  </entry>
  <entry>
    <title>排序算法汇总</title>
    <url>/2016/05/10/2016/05-10-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>本文是常见的排序算法的一个简单总结，也是算法导论第三版的一些摘要记录，以作备忘和查询。</p>
<h2 id="0X00、简介"><a href="#0X00、简介" class="headerlink" title="0X00、简介"></a>0X00、简介</h2><ul>
<li><p>1.排序的定义：</p>
<ul>
<li>输入：n个数的一个序列&lt;a1,a2,…,an&gt;</li>
<li>输出：序列的一个排列&lt;a1’,a2’,…,an’&gt;,满足a1’&lt;=a2’&lt;=…&lt;=an’</li>
</ul>
</li>
<li><p>2.排序算法复杂度概览</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(logn)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody></table>
<ul>
<li><p>3.术语解释</p>
<ul>
<li>稳定性：如果a=b，且a在b前面，排序后a仍然在b前面，则说算法是稳定的；否则就是不稳定的。</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度：一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul>
</li>
<li><p>4.关于时间复杂度的排序:</p>
<ul>
<li>(O(n^2))排序:各类简单排序：直接插入、直接选择和冒泡排序；</li>
<li>(O(nlog2n))排序:快速排序、堆排序和归并排序；</li>
<li>O(n1+§))排序，§是介于0和1之间的常数:希尔排序</li>
<li>(O(n))排序:基数排序、桶、箱排序。</li>
</ul>
</li>
<li><p>5.关于稳定性的排序：</p>
<ul>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li>
</ul>
</li>
</ul>
<h2 id="0X01、冒泡排序"><a href="#0X01、冒泡排序" class="headerlink" title="0X01、冒泡排序"></a>0X01、冒泡排序</h2><p>冒泡排序是一种流行但是低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>3.针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>4.重复步骤1~3，直到排序完成。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">1  for i = 1 to A.length - 1</span><br><span class="line">2    for j = A.length downto i+1</span><br><span class="line">3       if A[j] &lt; A[j-1]</span><br><span class="line">4           exchange A[j] with A[j-1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(n^2)</li>
<li>平均情况：T(n) = O(n^2)</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="3-代码实现如下"><a href="#3-代码实现如下" class="headerlink" title="3.代码实现如下"></a>3.代码实现如下</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, cnt<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>] , a[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#for i in range(cnt-2):</span></span><br><span class="line">    <span class="comment">#    for j in range(cnt-1, i, -1):</span></span><br><span class="line">    <span class="comment">#        if a[j] &lt; a[j-1]:</span></span><br><span class="line">    <span class="comment">#            a[j], a[j-1] = a[j-1], a[j]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bubble_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X02、插入排序"><a href="#0X02、插入排序" class="headerlink" title="0X02、插入排序"></a>0X02、插入排序</h2><p>插入排序(Insertion-Sort)是一种简单有效的排序方法。整体思想就是把后边一个待排的元素和前边已经排序好的元素做比较，如果比这元素大，就把前边的元素依次后移，直到找到一个比待排元素小的值，在其后边插入既可。然后在排序下一个待排元素。</p>
<h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.从第一个元素开始，该元素可以认为已经被排序；</li>
<li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>4.将新元素插入到该位置后；</li>
<li>5.重复步骤2~5。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">1  for j = 2 to A.length:</span><br><span class="line">2    key = A[j]</span><br><span class="line">3    i = j - 1</span><br><span class="line">4    while i &gt; 0 and A[i] &gt; key:</span><br><span class="line">5        A[i+1] = A[i]</span><br><span class="line">6        i = i - 1</span><br><span class="line">7    A[i+1] = key</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度：<ul>
<li>最佳情况：T(n) = O(n)。</li>
<li>最坏情况：T(n) = O(n^2)。</li>
<li>平均情况：T(n) = O(n^2)。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(1)。因为其要占用一个存储空间来放置key。</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt - <span class="number">1</span>):</span><br><span class="line">        value = a[i+<span class="number">1</span>]</span><br><span class="line">        pre_index = i</span><br><span class="line">        <span class="keyword">while</span> (pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; a[pre_index]):</span><br><span class="line">            a[pre_index + <span class="number">1</span>] = a[pre_index]</span><br><span class="line">            pre_index -= <span class="number">1</span></span><br><span class="line">        a[pre_index+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    insert_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X03、选择排序"><a href="#0X03、选择排序" class="headerlink" title="0X03、选择排序"></a>0X03、选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1.算法分析"></a>1.算法分析</h4><ul>
<li>1.初始状态：无序区为R[1..n]，有序区为空；</li>
<li>2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>3.n-1趟结束，数组有序化了。</li>
</ul>
<h4 id="2-算法复杂度-1"><a href="#2-算法复杂度-1" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cnt)[i:]:</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; a[minIndex]:</span><br><span class="line">                a[minIndex], a[j] = a[j], a[minIndex]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    selection_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X04、希尔排序"><a href="#0X04、希尔排序" class="headerlink" title="0X04、希尔排序"></a>0X04、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="2-算法复杂度-2"><a href="#2-算法复杂度-2" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog2n)　</li>
</ul>
<h4 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    算法思路：</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)，最好：O(n)，最坏：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    gap = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, cnt, <span class="number">1</span>):</span><br><span class="line">            tmp = a[i]</span><br><span class="line">            pre_index = i - gap</span><br><span class="line">            <span class="keyword">while</span> pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> a[pre_index] &gt; tmp:</span><br><span class="line">                a[pre_index+gap] = a[pre_index]</span><br><span class="line">                pre_index -= gap</span><br><span class="line">            a[pre_index+gap] = tmp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    shell_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X05、归并排序"><a href="#0X05、归并排序" class="headerlink" title="0X05、归并排序"></a>0X05、归并排序</h2><p>归并排序是分治思想的一种实现。这里分治模式的每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li>
<li>解决这些子问题，递归的求解各个子问题。然而，若小问题的规模足够小，则直接求解。</li>
<li>合并这些子问题的解成原问题的解。<br>这便是分治模式的思想。把大问题拆分成几个规模较小的子问题，把子问题在拆分成几个在小的问题，直至可以直接求解。然后把所有子问题的解合并就是原问题的解。</li>
</ul>
<h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>归并排序完全是分治思想的实现。</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>分解。分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li>
<li>解决。使用归并排序递归地排序两个子序列。</li>
<li>合并。合并两个已排序的子序列以产生已排序的答案。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MERGE(A,p,q,r)</span><br><span class="line">1  n1 = p - q + 1</span><br><span class="line">2  n2 = r - q</span><br><span class="line">3  let L[1..n1+1] and R[1..n2+1] to be new arrays</span><br><span class="line">4  for i = 1 to n1</span><br><span class="line">5    L[i] = A[p+i-1]</span><br><span class="line">6  for j = 1 to n2</span><br><span class="line">7    R[j] = A[q+j]</span><br><span class="line">8  L[n1+1] = ∞</span><br><span class="line">9  R[n2+1] = ∞</span><br><span class="line">10 i = 1</span><br><span class="line">11 j = 1</span><br><span class="line">12 for k = p to r</span><br><span class="line">13   if L[i] &lt;= R[j]</span><br><span class="line">14      A[k] = L[i]</span><br><span class="line">15      i = i+1</span><br><span class="line">16   else</span><br><span class="line">17      A[k] = R[j]</span><br><span class="line">18      j = j+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2     q = (p+r)/2</span><br><span class="line">3     MERGE-SORT(A,p,q)</span><br><span class="line">4     MERGE-SORT(A,q+1,r)</span><br><span class="line">5     MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-算法复杂度-3"><a href="#2-算法复杂度-3" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    mid = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(a[:mid]), merge_sort(a[mid:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left: list, right: list)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X06、快速排序"><a href="#0X06、快速排序" class="headerlink" title="0X06、快速排序"></a>0X06、快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="1-算法思路-2"><a href="#1-算法思路-2" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2    q = PARTITION(A,p,r)</span><br><span class="line">3    QUICKSORT(A,p,q-1)</span><br><span class="line">4    QUICKSORT(A,q+1,r)</span><br><span class="line"></span><br><span class="line">PARTITION(A,p,r)</span><br><span class="line">1  x = A[r]</span><br><span class="line">2  i = p-1</span><br><span class="line">3  for j = p to r-1</span><br><span class="line">4    if A[j] &lt;= x</span><br><span class="line">5        i = i+1</span><br><span class="line">6        exchange A[i] with A[j]</span><br><span class="line">7  exchange A[i+1] with A[r]</span><br><span class="line">8  return i+1</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度-4"><a href="#2-算法复杂度-4" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)　</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= array[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i+<span class="number">1</span>], array[r] = array[r], array[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[len(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    quick_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X07、计数排序"><a href="#0X07、计数排序" class="headerlink" title="0X07、计数排序"></a>0X07、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="1-算法思路-3"><a href="#1-算法思路-3" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h4 id="2-算法复杂度-5"><a href="#2-算法复杂度-5" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</p>
<h4 id="3-算法实现-5"><a href="#3-算法实现-5" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    leng = len(array)</span><br><span class="line">    c = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, leng):</span><br><span class="line">        c[array[i]] = c[array[i]]+<span class="number">1</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>]+c[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(leng<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res[c[array[i]]<span class="number">-1</span>] = array[i]</span><br><span class="line">        c[array[i]] = c[array[i]]<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(count_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X08、基数排序"><a href="#0X08、基数排序" class="headerlink" title="0X08、基数排序"></a>0X08、基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h4 id="1-算法思路-4"><a href="#1-算法思路-4" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ul>
<h4 id="2-算法复杂度-6"><a href="#2-算法复杂度-6" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)<br>基数排序有两种方法：<br>MSD 从高位开始进行排序 LSD 从低位开始进行排序<br>基数排序 vs 计数排序 vs 桶排序<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h4 id="3-算法实现-6"><a href="#3-算法实现-6" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j//(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    radix_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X09、桶排序"><a href="#0X09、桶排序" class="headerlink" title="0X09、桶排序"></a>0X09、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h4 id="1-算法思路-5"><a href="#1-算法思路-5" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li>
</ul>
<h4 id="2-算法复杂度-7"><a href="#2-算法复杂度-7" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)　</p>
<h4 id="3-算法实现-7"><a href="#3-算法实现-7" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(lista)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        h.append(node(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lista)):</span><br><span class="line">        tmp = node(lista[i])</span><br><span class="line">        map = lista[i]//<span class="number">10</span></span><br><span class="line">        p = h[map]</span><br><span class="line">        <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">            h[map].next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span>(p.next != <span class="literal">None</span> <span class="keyword">and</span> p.next.key &lt;= tmp.key):</span><br><span class="line">                p = p.next</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        q = h[i].next</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">None</span>):</span><br><span class="line">            lista[k] = q.key</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bucket_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X10、堆排序"><a href="#0X10、堆排序" class="headerlink" title="0X10、堆排序"></a>0X10、堆排序</h2><p>堆排序(heap-sort),和归并排序一样，不同于插入排序的是，堆排序的时间复杂度是O(nlogn)。与插入排序相同，不同于堆排序的是，堆排序具有空间原址性：任何时候都需要常数个额外的元素空间来存储临时数据。<br>其思想便是引用一种成为堆的数据结构。常见的有大根堆（最大堆）和小根堆（最小堆）。在排序中一般使用大根堆，小根堆通常构建优先队列。</p>
<ul>
<li>大根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&gt;=A[i]</li>
</ul>
</li>
<li>小根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&lt;=A[i]</li>
</ul>
</li>
</ul>
<h4 id="1-算法思路-6"><a href="#1-算法思路-6" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>伪代码描述</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用于维护最大根堆的性质</span><br><span class="line"># 对于树高为h的大根堆，其时间复杂度为O(h)</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">1  l = LEFT(i)</span><br><span class="line">2  r = RIGHT(i)</span><br><span class="line">3  if l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">4    largest = l</span><br><span class="line">5  else larget = r</span><br><span class="line">6  if r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">7    largest = r</span><br><span class="line">8  if largest != i</span><br><span class="line">9    exchange A[i] with A[largest]</span><br><span class="line">10   MAX-HEAPIFY(A,largest)</span><br><span class="line"></span><br><span class="line"># 建堆</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">1  A.heap-size = A.length</span><br><span class="line">2  for i = ⌊A.length/2⌋ downto 1</span><br><span class="line">3    MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">HEAP-SORT(A)</span><br><span class="line">1  BUILD-MAX-HEAP(A)</span><br><span class="line">2  for i = A.length downto 2</span><br><span class="line">3    exchange A[1] with A[i]</span><br><span class="line">4    MAX-HEAPIFY(A, 1)</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度-8"><a href="#2-算法复杂度-8" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-8"><a href="#3-算法实现-8" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_param</span><span class="params">(L, i, j)</span>:</span></span><br><span class="line">    L[i], L[j] = L[j], L[i]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    temp = L[start]</span><br><span class="line"></span><br><span class="line">    i = start</span><br><span class="line">    j = <span class="number">2</span> * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end) <span class="keyword">and</span> (L[j] &lt; L[j + <span class="number">1</span>]):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt; L[j]:</span><br><span class="line">            L[i] = L[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    L[i] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    L_length = len(L) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    first_sort_count = L_length // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first_sort_count):</span><br><span class="line">        heap_adjust(L, first_sort_count - i, L_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L_length - <span class="number">1</span>):</span><br><span class="line">        L = swap_param(L, <span class="number">1</span>, L_length - i)</span><br><span class="line">        heap_adjust(L, <span class="number">1</span>, L_length - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    L = deque(a)</span><br><span class="line">    L.appendleft(<span class="number">0</span>)</span><br><span class="line">    print(heap_sort(L))</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>PHP知识体系</title>
    <url>/2018/03/02/2018/03-02-PHP%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<h2 id="0x00、关键字"><a href="#0x00、关键字" class="headerlink" title="0x00、关键字"></a>0x00、关键字</h2><ul>
<li>$ 、echo、 print、null、global、GLOBALS[‘y’]、static、function、public、private、protected</li>
<li>对象(class)：String、Integer、Float、Boolean、Object、NULL、Resource、Closure()</li>
<li>函数(function)：<ul>
<li>通用：die()、var_dump()、for()、foreach()、define()、echo</li>
<li>函数：function_exists()</li>
<li>数组：array()、sort()、count()、 implode($arr,’,’)、is_array()、unset()、</li>
<li>字符串：strlen()、mb_substr()、strpos()、str_replace()、str_word_count()、sprintf()、explode(‘,’,$string)、substr()、iconv_substr</li>
<li>数据库：query()、mysql()、close()、</li>
<li>文件：file_exist()、is_file()、is_dir()</li>
<li>对象： serialize()、unserialize()</li>
<li>回话：session_start()、setcookie()、session_destroy()、session_unset()、</li>
<li>日期：date()、strtotime()、date_default_timezone_set()</li>
<li>socket：</li>
</ul>
</li>
<li>超级全局变量:<ul>
<li>$GLOBALS<ul>
<li>$_SERVER</li>
<li>$_REQUEST</li>
<li>$_POST</li>
<li>$_GET</li>
<li>$_FILES</li>
<li>$_ENV</li>
<li>$_COOKIE</li>
<li>$_SESSION</li>
</ul>
</li>
</ul>
</li>
<li>魔术方法：<ul>
<li><strong>contract()、</strong>decontract、<strong>get()、</strong>set()、 _invoke()</li>
</ul>
</li>
</ul>
<h2 id="0x01、字符串"><a href="#0x01、字符串" class="headerlink" title="0x01、字符串"></a>0x01、字符串</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="comment">//字符串定义方式</span></span><br><span class="line"><span class="comment">// ''只转译 ' / 但是“”转译的比较多</span></span><br><span class="line"><span class="comment">// ""可以解析变量</span></span><br><span class="line"><span class="comment">// ''速度比较快，不用分析变量，转译内用少。我们优先使用 ''</span></span><br><span class="line">$str1 = <span class="string">'hello'</span>;</span><br><span class="line">$str2 = <span class="string">"hello"</span>;</span><br><span class="line"><span class="comment">//写大段文本</span></span><br><span class="line"><span class="comment">//heredoc    &lt;&lt;&lt;HTML ......HTML; //类似于"" 可以解析文本中的变量</span></span><br><span class="line"><span class="comment">//nowdoc    &lt;&lt;&lt;'HTML'......HTML;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串函数</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">字符长度计算</span></span><br><span class="line"><span class="comment">查找字符位置</span></span><br><span class="line"><span class="comment">字符替换</span></span><br><span class="line"><span class="comment">提取字符</span></span><br><span class="line"><span class="comment">分割连接反转字符</span></span><br><span class="line"><span class="comment">去除增加空格</span></span><br><span class="line"><span class="comment">HTML代码/数据库安全处理字符</span></span><br><span class="line"><span class="comment">比较字符</span></span><br><span class="line"><span class="comment">字符大小写转换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">number_format(<span class="string">'123456789'</span>);<span class="comment">//123,456,789 使用科学计数法表示字符串</span></span><br><span class="line">str_repeat(<span class="string">' '</span>, <span class="number">10</span>); <span class="comment">//重复空格10次</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//计算字符串长度</span></span><br><span class="line">$t1 = <span class="string">'abcdefghijklmn abcdefg'</span>;</span><br><span class="line">$t2 = <span class="string">'我是中国人'</span>;</span><br><span class="line"><span class="keyword">echo</span> strlen($t1),<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//22    //计算字符长度</span></span><br><span class="line"><span class="keyword">echo</span> mb_strlen($t2,<span class="string">'utf-8'</span>), <span class="string">'&lt;br /&gt;'</span>; <span class="comment">//utf-8 必须加 '' //5 //计算字节长度</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//反转字符</span></span><br><span class="line"><span class="keyword">echo</span> strrev($t1).<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//gfedcba nmlkjihgfedcba 反转字符</span></span><br><span class="line"><span class="comment">//reverse 背面，反面 反转 同数组反转array_reverse 字符串是strrve</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找自字符串的位置</span></span><br><span class="line">$t1 = <span class="string">'abcdefghijklmn abcd.efg'</span>;</span><br><span class="line">$t3 = <span class="string">'d'</span>;</span><br><span class="line">$t4 = <span class="string">'bc'</span>;</span><br><span class="line"><span class="keyword">echo</span> strpos($t1, $t3), <span class="string">'&lt;br /&gt;'</span>; <span class="comment">//区分大小写，查找第一次出现的位置//返回值为int</span></span><br><span class="line"><span class="keyword">echo</span> stripos($t1, <span class="string">'c'</span>), <span class="string">'&lt;br /&gt;'</span>; <span class="comment">//不区分大小写，返回字符串在另一个字符串出现的位置</span></span><br><span class="line"><span class="keyword">echo</span> strrpos($t1, <span class="string">'.'</span>), <span class="string">'&lt;br /&gt;'</span>; <span class="comment">//区分大小写，最后一次出现的位置 //19</span></span><br><span class="line"><span class="keyword">echo</span> strrchr($t1, <span class="string">'.'</span>).<span class="string">'&lt;br /&gt;'</span>;    <span class="comment">//查找字符串最后出现的位置,并打印之后的 //.efg</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串替换</span></span><br><span class="line">$t1 = <span class="string">'abcdefghijklmn abcdefg'</span>;</span><br><span class="line">$t5 = <span class="string">'opqrsruvw'</span>;</span><br><span class="line"><span class="keyword">echo</span> str_replace(<span class="string">'Abc'</span>, <span class="string">'dEfg'</span>, $t1), <span class="string">'&lt;br /&gt;'</span>; <span class="comment">//区分大小写,如果不同不会进行替换，在$t1中，defg替换掉abc</span></span><br><span class="line"><span class="keyword">echo</span> str_ireplace(<span class="string">'ABC'</span>, <span class="string">'HAHAha'</span>, $t1), <span class="string">'&lt;BR /&gt;'</span>;<span class="comment">//进行替换 //不区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> strtr($t1, <span class="string">'aBCd'</span>, <span class="string">'HAHAHA'</span>),<span class="string">'&lt;bR /&gt;'</span>; <span class="comment">//HAHAHA只替换成HbcA,中间BC不被替换，只替换4位// 区分大小写，但是还是会进行替换 //只是截取等长部分，区分大小写，而且之替换相同的</span></span><br><span class="line"><span class="keyword">echo</span> substr_replace($t1, $t5, <span class="number">4</span>, <span class="number">3</span>),<span class="string">'&lt;br&gt;'</span>; <span class="comment">//$t5从$t1的第4位开始替换，$t1失去3字节的内容，如果没有写3，则默认替换掉$t1从第4位后的所有字节</span></span><br><span class="line"><span class="comment">//截取字符串</span></span><br><span class="line">$t1 = <span class="string">'abcdefghijklmn abcdefghijklmnopq'</span>;</span><br><span class="line">$t6 = <span class="string">'fg'</span>;</span><br><span class="line"><span class="keyword">echo</span> substr($t1, <span class="number">3</span>, <span class="number">5</span>),<span class="string">'&lt;bR /&gt;&lt;br /&gt;'</span>; <span class="comment">//defgh //从$t1的第3位开始，截取5字节内容，默认截取余下全部</span></span><br><span class="line"><span class="keyword">echo</span> mb_substr($t1, <span class="number">1</span>, <span class="number">10</span>, <span class="string">'UTF8'</span>); <span class="comment">//从第1位开始，长度为10，字符编码为 UTF-8 截取， 返回值string</span></span><br><span class="line"><span class="keyword">echo</span> strstr($t1, $t6),<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//从$t1中找到$t6，截取后半截，$t6必须完全存在于$t1中，且区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> stristr($t1, <span class="string">'FGH'</span>),<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//同上不区分大小写</span></span><br><span class="line"><span class="keyword">echo</span> strrchr($t1, $t6), <span class="string">'&lt;br /&gt;'</span>;<span class="comment">//$t6最后一次出现的位置截取到最后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分割， 连接， 反转字符串</span></span><br><span class="line">$t1 = <span class="string">'abcde fghijklmn abcde fgh ijklm nopq'</span>;</span><br><span class="line">var_dump(str_split($t1, <span class="number">5</span>)); <span class="comment">//返回数组类型, 把$t1按照5个字节分成数组</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'&lt;br /&gt;'</span>;</span><br><span class="line">        <span class="comment">/*    array (size=7)</span></span><br><span class="line"><span class="comment">                  0 =&gt; string 'abcde' (length=5)</span></span><br><span class="line"><span class="comment">                  1 =&gt; string 'fghij' (length=5)</span></span><br><span class="line"><span class="comment">                  2 =&gt; string 'klmn ' (length=5)</span></span><br><span class="line"><span class="comment">                  3 =&gt; string 'abcde' (length=5)</span></span><br><span class="line"><span class="comment">                  4 =&gt; string 'fghij' (length=5)</span></span><br><span class="line"><span class="comment">                  5 =&gt; string 'klmno' (length=5)</span></span><br><span class="line"><span class="comment">                  6 =&gt; string 'pq' (length=2)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">var_dump(split(<span class="string">'ij'</span>, $t1, <span class="number">5</span>)) ;<span class="comment">//将$t1以'ij'进行分割5次，如果后面还出现将不进行分割</span></span><br><span class="line">$t7 = explode(<span class="string">' '</span>, $t1); <span class="comment">//将$t1以空格分开，返回数组,</span></span><br><span class="line">    <span class="keyword">echo</span> $t7[<span class="number">0</span>], <span class="string">'&lt;br /&gt;'</span>, $t7[<span class="number">3</span>], <span class="string">'&lt;br /&gt;'</span>;<span class="comment">//abcde fgh</span></span><br><span class="line">    var_dump($t7);</span><br><span class="line">    <span class="comment">/*    array (size=6)</span></span><br><span class="line"><span class="comment">              0 =&gt; string 'abcde' (length=5)</span></span><br><span class="line"><span class="comment">              1 =&gt; string 'fghijklmn' (length=9)</span></span><br><span class="line"><span class="comment">              2 =&gt; string 'abcde' (length=5)</span></span><br><span class="line"><span class="comment">              3 =&gt; string 'fgh' (length=3)</span></span><br><span class="line"><span class="comment">              4 =&gt; string 'ijklm' (length=5)</span></span><br><span class="line"><span class="comment">              5 =&gt; string 'nopq' (length=4)</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="keyword">echo</span> implode($t7, <span class="string">'/'</span>), <span class="string">'&lt;br /&gt;'</span>;<span class="comment">//abcde/fghijklmn/abcde/fgh/ijklm/nopq //将$t7用 / 连接起来，并且以字符串的形式返回</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//空白处理字符串</span></span><br><span class="line">$t1 = <span class="string">'        abcde fghijklmn abcde fgh ijklm nopq         '</span>;</span><br><span class="line"><span class="keyword">echo</span> trim($t1), <span class="string">'&lt;br /&gt;'</span>;<span class="comment">//处理$t1 前后 的空白字符，包括 ""空格 "\t"制表符 "\n"换行符 "\r"回车符 "\0"空字节 "\x08"垂直制表符</span></span><br><span class="line"><span class="keyword">echo</span> ltrim($t1),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//处理$t1 前 的空白字符，同上//可查看网页源代码</span></span><br><span class="line"><span class="keyword">echo</span> rtrim($t1),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//处理$t1 后 的空白字符，同上</span></span><br><span class="line"><span class="keyword">ECHO</span> chunk_split(<span class="string">'abcdefghijklmnopq'</span>, <span class="number">3</span>, <span class="string">','</span>),<span class="string">'&lt;BR /&gt;'</span>;<span class="comment">//abc,def,ghi,jkl,mno,pq,//将字符串按照 3个字符+一个，分割开，并连起来</span></span><br><span class="line"><span class="keyword">echo</span> str_pad(<span class="string">'zxd'</span>, <span class="number">6</span>),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//将 zxd 填充到6个字节</span></span><br><span class="line"><span class="keyword">echo</span> str_pad(<span class="string">'zxd'</span>, <span class="number">6</span>, <span class="string">'_'</span>,STR_PAD_LEFT),<span class="string">'&lt;BR /&gt;'</span>; <span class="comment">//___zxd 以 _ 对 zxd 进行填充 // STR_PAD_LEFT STR_PAD_BOTH 或者不填则直接填到最后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符转义</span></span><br><span class="line">$t8 = <span class="string">"My name\id Xiaodong'ZHANG"</span>;</span><br><span class="line">$t9 = <span class="string">"My name\\id Xiaodong\'ZHANG"</span>;</span><br><span class="line"><span class="keyword">echo</span> addslashes($t8),<span class="string">'&lt;br/&gt;'</span>; <span class="comment">//My name\\id Xiaodong\'ZHANG 使用反斜线引入字符串 //为了向数据库中输入带有 " ' \ null 的数据的时候使用的,</span></span><br><span class="line"><span class="keyword">echo</span> stripslashes($t9),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//My nameid Xiaodong'ZHANG 反引用一个引用字符串 同上相反，从数据库中提取数据</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//没有搞懂，同以下几个都没搞懂 echo get_magic_quotes_gpc();</span></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars(<span class="string">'&lt;h1&gt;HEllp'</span>),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//将字符串中的一些字符转换成HTML实体，其中&lt; &gt;被翻译成&lt; &gt;</span></span><br><span class="line"><span class="keyword">echo</span> htmlspecialchars_decode(<span class="string">'&lt;h1&gt;HEllp'</span>),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//&lt;h1&gt;HEllp //同上相反，这个是在网页中显示效果，上则是在源代码中显示效果</span></span><br><span class="line"><span class="keyword">echo</span> htmlentities(<span class="string">'html&lt;h1&gt;&lt;p&gt;'</span>),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//把字符串中所有可以转换的字符换成HTML实体</span></span><br><span class="line"><span class="keyword">echo</span> html_entity_decode(<span class="string">'&lt; &gt; haha'</span>),<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//同上 相反</span></span><br><span class="line"><span class="comment">// echo '&lt;h1&gt;nihao&lt;h1&gt; &lt;br /&gt;';//直接在网页上输出大写的nihao 类似于网页效果</span></span><br><span class="line"><span class="comment">// echo '&lt;h1&gt; nihao&lt;h1&gt;','&lt;br /&gt;';//直接转译成&lt;h1&gt; nihao 并且自带效果</span></span><br><span class="line"><span class="keyword">echo</span> <span class="string">'heiadk&lt;br /&gt;'</span>;<span class="comment">//上两行必须屏蔽掉，否则之后的自带h1效果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="keyword">echo</span> strcmp(<span class="string">'abcd'</span>, <span class="string">'abcde'</span>).<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//-1 //str1大于str2是为正数，相等为0</span></span><br><span class="line"><span class="keyword">echo</span> strcasecmp(<span class="string">'ABcDe'</span>, <span class="string">'abcDE'</span>).<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符串转换大小</span></span><br><span class="line"><span class="keyword">ECHO</span> strtolower(<span class="string">'ABcDeFg'</span>).<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//abcdefg</span></span><br><span class="line"><span class="keyword">echo</span> strtoupper(<span class="string">'strinABcDeFg'</span>).<span class="string">'&lt;br /&gt;'</span>;<span class="comment">//STRINABCDEFG</span></span><br><span class="line"><span class="keyword">echo</span> ucfirst(<span class="string">'andjfJSUD'</span>).<span class="string">'&lt;BR /&gt;'</span>; <span class="comment">//AndjfJSUD 首字母为大写</span></span><br><span class="line"><span class="keyword">echo</span> ucwords(<span class="string">'my name Is zhang XAIO dong'</span>).<span class="string">'&lt;br /&gt;'</span>; <span class="comment">//My Name Is Zhang XAIO Dong 每个单词的首字母大写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将1234567890转换成1,234,567,8</span></span><br><span class="line">$str1 = <span class="string">'1234567890'</span>;</span><br><span class="line">$str4 = strrev($str1);</span><br><span class="line">$str2 = chunk_split($str4, <span class="number">3</span>, <span class="string">','</span>); <span class="comment">//098,765,432,1,</span></span><br><span class="line">$str3 = substr($str2, <span class="number">2</span>, <span class="number">11</span>);</span><br><span class="line"><span class="keyword">echo</span> strrev($str3);</span><br><span class="line"><span class="keyword">echo</span> number_format(<span class="string">'123456789'</span>);</span><br></pre></td></tr></table></figure>

<h2 id="0x02、数组"><a href="#0x02、数组" class="headerlink" title="0x02、数组"></a>0x02、数组</h2><h2 id="0x03、类"><a href="#0x03、类" class="headerlink" title="0x03、类"></a>0x03、类</h2><h2 id="0x04、函数"><a href="#0x04、函数" class="headerlink" title="0x04、函数"></a>0x04、函数</h2><h2 id="0x05、文件操作"><a href="#0x05、文件操作" class="headerlink" title="0x05、文件操作"></a>0x05、文件操作</h2><h2 id="0x06、应用"><a href="#0x06、应用" class="headerlink" title="0x06、应用"></a>0x06、应用</h2><ul>
<li><p>1.交换两个数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="number">123.456</span>;</span><br><span class="line">$b = \<span class="string">'abcDEF\';</span></span><br><span class="line"><span class="string">function swap (&amp;$arg1, &amp;$arg2)</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">   $w=$arg1;</span></span><br><span class="line"><span class="string">   $arg1=$arg2;</span></span><br><span class="line"><span class="string">   $arg2=$w;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">swap(&amp;$a,&amp;$b);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.循环</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="keyword">array</span>(\<span class="string">'a\',\'b\',\'c\');</span></span><br><span class="line"><span class="string">foreach($a as &amp;$v)&#123;&#125;</span></span><br><span class="line"><span class="string">foreach($a as $v)&#123;&#125;</span></span><br><span class="line"><span class="string">var_dump($a); //a,b,b</span></span><br><span class="line"><span class="string">//当foreach循环结束的时候，由于$v为引用变量，因而$v 与 $a[ 2 ] 指向了同一个地址空间（共享变量值），</span></span><br><span class="line"><span class="string">//因而之后对$v的任何修改都会直接反映到数组$a中</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>3.unset只会删除变量。并不会清空变量值对应的内存空间：（这是与指针不同的地方）</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$a = <span class="string">"str"</span>;</span><br><span class="line">$b = &amp;$a;</span><br><span class="line"><span class="keyword">unset</span>($b);</span><br><span class="line"><span class="keyword">echo</span> $a;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.引用作为函数参数传递时，是可以被函数内部更改的</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">change</span><span class="params">(&amp;$a)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span>(is_array($a))&#123;</span><br><span class="line">       $a = <span class="keyword">array</span>();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">$test = range(<span class="number">1</span>,<span class="number">10</span>);</span><br><span class="line">change($test);</span><br><span class="line">print_r($test);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="0x07、日期"><a href="#0x07、日期" class="headerlink" title="0x07、日期"></a>0x07、日期</h2><ul>
<li><p>函数:</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">strtotime();</span><br><span class="line">date(<span class="string">'Y-m-d H:i:s'</span>,strtotime()); <span class="comment">//转化为格式日期</span></span><br><span class="line">date_parse(); <span class="comment">//把日期时间拆分为数组</span></span><br><span class="line">date_default_timezone_set(<span class="string">'UTC'</span>); <span class="comment">//设置时区</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取上个月第一天及最后一天</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> date(\<span class="string">'Y-m-01\', strtotime(\'-1 month\'));</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br><span class="line"><span class="string">echo date(\'Y-m-t\', strtotime(\'-1 month\'));</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br><span class="line"><span class="string">//获取上个月最后一天时间</span></span><br><span class="line"><span class="string">$times = date('</span>d<span class="string">')*24*3600;</span></span><br><span class="line"><span class="string">echo date("Y-m-d H:i:s",time()-$times);</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当月第一天及最后一天</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$BeginDate=date(\<span class="string">'Y-m-01\', strtotime(date("Y-m-d")));</span></span><br><span class="line"><span class="string">echo $BeginDate;</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br><span class="line"><span class="string">echo date(\'Y-m-d\', strtotime("$BeginDate +1 month -1 day"));</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>获取当前年份、月份、日期及天数</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">" 本月共有:"</span>.date(<span class="string">"t"</span>).<span class="string">"天"</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">" 当前年份"</span>.date(\<span class="string">'Y\');</span></span><br><span class="line"><span class="string">echo " 当前月份".date(\'m\');</span></span><br><span class="line"><span class="string">echo " 当前几号".date(\'d\');</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用函数及数组来获取当月第一天及最后一天</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getthemonth</span><span class="params">($date)</span></span>&#123;</span><br><span class="line">   $firstday = date(\<span class="string">'Y-m-01\', strtotime($date));</span></span><br><span class="line"><span class="string">   $lastday = date(\'Y-m-d\', strtotime("$firstday +1 month -1 day"));</span></span><br><span class="line"><span class="string">   return array($firstday,$lastday);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">$today = date("Y-m-d");</span></span><br><span class="line"><span class="string">$day=getthemonth($today);</span></span><br><span class="line"><span class="string">echo "当月的第一天: ".$day[0]." 当月的最后一天: ".$day[1];</span></span><br><span class="line"><span class="string">echo "&lt;br/&gt;";</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="0x08、正则"><a href="#0x08、正则" class="headerlink" title="0x08、正则"></a>0x08、正则</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$str=preg_replace(<span class="string">"/&lt;\\s*img\\s+[^&gt;]*?src\\s*=\\s*(\\\'|\\"</span>)(.*?)\\\\<span class="number">1</span>[^&gt;]*?\\/?\\s*&gt;/i<span class="string">", "</span> <span class="string">", $str); //过滤img标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/\\s+/<span class="string">", "</span> <span class="string">", $str); //过滤多余回车</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;[ ]+/si<span class="string">","</span>&lt;<span class="string">",$str); //过滤&lt;__("</span>&lt;<span class="string">"号后面带空格)</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;\\!--.*?--&gt;/si<span class="string">","</span><span class="string">",$str); //注释</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\!.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤DOCTYPE</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?html.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤html标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?head.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤head标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?meta.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤meta标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?body.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤body标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?link.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤link标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?form.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤form标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/cookie/si<span class="string">","</span>COOKIE<span class="string">",$str); //过滤COOKIE标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(applet.*?)&gt;(.*?)&lt;(\\/applet.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤applet标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?applet.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤applet标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(style.*?)&gt;(.*?)&lt;(\\/style.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤style标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?style.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤style标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(title.*?)&gt;(.*?)&lt;(\\/title.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤title标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?title.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤title标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(object.*?)&gt;(.*?)&lt;(\\/object.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤object标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?objec.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤object标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(noframes.*?)&gt;(.*?)&lt;(\\/noframes.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤noframes标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?noframes.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤noframes标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(i?frame.*?)&gt;(.*?)&lt;(\\/i?frame.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤frame标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?i?frame.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤frame标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(script.*?)&gt;(.*?)&lt;(\\/script.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤script标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&lt;(\\/?script.*?)&gt;/si<span class="string">","</span><span class="string">",$str); //过滤script标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/javascript/si<span class="string">","</span>Javascript<span class="string">",$str); //过滤script标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/vbscript/si<span class="string">","</span>Vbscript<span class="string">",$str); //过滤script标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/on([a-z]+)\\s*=/si<span class="string">","</span>On\\\\<span class="number">1</span>=<span class="string">",$str); //过滤script标签</span></span><br><span class="line"><span class="string">$str=preg_replace("</span>/&amp;<span class="comment">#/si","&amp;＃",$str); //过滤script标签</span></span><br></pre></td></tr></table></figure>

<h2 id="0x09、socket"><a href="#0x09、socket" class="headerlink" title="0x09、socket"></a>0x09、socket</h2><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">socket_accept() 接受一个Socket连接</span><br><span class="line">socket_bind() 把socket绑定在一个IP地址和端口上</span><br><span class="line">socket_clear_error() 清除socket的错误或最后的错误代码</span><br><span class="line">socket_close() 关闭一个socket资源</span><br><span class="line">socket_connect() 开始一个socket连接</span><br><span class="line">socket_create_listen() 在指定端口打开一个socket监听</span><br><span class="line">socket_create_pair() 产生一对没有差别的socket到一个数组里</span><br><span class="line">socket_create() 产生一个socket，相当于产生一个socket的数据结构</span><br><span class="line">socket_get_option() 获取socket选项</span><br><span class="line">socket_getpeername() 获取远程类似主机的ip地址</span><br><span class="line">socket_getsockname() 获取本地socket的ip地址</span><br><span class="line">socket_iovec_add() 添加一个新的向量到一个分散/聚合的数组</span><br><span class="line">socket_iovec_alloc() 这个函数创建一个能够发送接收读写的iovec数据结构</span><br><span class="line">socket_iovec_delete() 删除一个已分配的iovec</span><br><span class="line">socket_iovec_fetch() 返回指定的iovec资源的数据</span><br><span class="line">socket_iovec_free() 释放一个iovec资源</span><br><span class="line">socket_iovec_set() 设置iovec的数据新值</span><br><span class="line">socket_last_error() 获取当前socket的最后错误代码</span><br><span class="line">socket_listen() 监听由指定socket的所有连接</span><br><span class="line">socket_read() 读取指定长度的数据</span><br><span class="line">socket_readv() 读取从分散/聚合数组过来的数据</span><br><span class="line">socket_recv() 从socket里结束数据到缓存</span><br><span class="line">socket_recvfrom() 接受数据从指定的socket，如果没有指定则默认当前socket</span><br><span class="line">socket_recvmsg() 从iovec里接受消息</span><br><span class="line">socket_select() 多路选择</span><br><span class="line">socket_send() 这个函数发送数据到已连接的socket</span><br><span class="line">socket_sendmsg() 发送消息到socket</span><br><span class="line">socket_sendto() 发送消息到指定地址的socket</span><br><span class="line">socket_set_block() 在socket里设置为块模式</span><br><span class="line">socket_set_nonblock() socket里设置为非块模式</span><br><span class="line">socket_set_option() 设置socket选项</span><br><span class="line">socket_shutdown() 这个函数允许你关闭读、写、或指定的socket</span><br><span class="line">socket_strerror() 返回指定错误号的周详错误</span><br><span class="line">socket_write() 写数据到socket缓存</span><br><span class="line">socket_writev() 写数据到分散/聚合数组</span><br></pre></td></tr></table></figure>

<h2 id="0x10、php-fpm与nginx"><a href="#0x10、php-fpm与nginx" class="headerlink" title="0x10、php-fpm与nginx"></a>0x10、php-fpm与nginx</h2><h2 id="0x11、资源"><a href="#0x11、资源" class="headerlink" title="0x11、资源"></a>0x11、资源</h2><ul>
<li>PhpDocmentor</li>
</ul>
<h2 id="0x12、依赖管理——用于依赖管理的包和框架"><a href="#0x12、依赖管理——用于依赖管理的包和框架" class="headerlink" title="0x12、依赖管理——用于依赖管理的包和框架"></a>0x12、依赖管理——用于依赖管理的包和框架</h2><ul>
<li>Composer/Packagist : 一个包和依赖管理器</li>
<li>Composer Installers: 一个多框架Composer库安装器</li>
<li>Pickle: 可以在任意平台上安装PHP扩展包</li>
</ul>
<h2 id="0x13、依赖管理的附加部分——其它依赖管理的相关工具"><a href="#0x13、依赖管理的附加部分——其它依赖管理的相关工具" class="headerlink" title="0x13、依赖管理的附加部分——其它依赖管理的相关工具"></a>0x13、依赖管理的附加部分——其它依赖管理的相关工具</h2><ul>
<li>Satis : 静态的Composer库生成器</li>
<li>Composition: 一个运行时检查Composer环境的库</li>
<li>Version : 一个在语义上分析和比较的库</li>
<li>NameSpacer : 将下划线转为命名空间的库</li>
<li>Patch Installer: 使用Composer安装补丁的库</li>
<li>Composer Checker: 一个验证Composer配置的工具</li>
</ul>
<h2 id="0x14、框架——Web开发框架"><a href="#0x14、框架——Web开发框架" class="headerlink" title="0x14、框架——Web开发框架"></a>0x14、框架——Web开发框架</h2><ul>
<li>Symfony2 : 由独立组件构成的框架</li>
<li>Zend Framework 2: 同样是由独立组件构成的框架</li>
<li>Laravel 5: 简洁优雅的PHP Web开发框架</li>
<li>Aura PHP: 独立组件的框架</li>
<li>Yii2 : 用于开发大型Web应用的高性能PHP框架</li>
<li>Nette: 同样是由独立组件构成的框架</li>
<li>PPI Framework 2: 一个交互性的框架</li>
<li>Phalcon: 一个作为C扩展的框架</li>
</ul>
<h2 id="0x15、框架的附加部分——其它关于Web开发框架的相关工具"><a href="#0x15、框架的附加部分——其它关于Web开发框架的相关工具" class="headerlink" title="0x15、框架的附加部分——其它关于Web开发框架的相关工具"></a>0x15、框架的附加部分——其它关于Web开发框架的相关工具</h2><ul>
<li>Symfony CMF: 一个创建自定义CMS的内容管理框架</li>
<li>Knp RAD Bundle: Symfony2的快速应用程序包（RAD）</li>
</ul>
<h2 id="0x16、框架组件——来自Web开发框架的组件"><a href="#0x16、框架组件——来自Web开发框架的组件" class="headerlink" title="0x16、框架组件——来自Web开发框架的组件"></a>0x16、框架组件——来自Web开发框架的组件</h2><ul>
<li>Symfony2 Components: 关于Symphony2的组件</li>
<li>Zend Framework 2 Components: 关于ZF2的组件</li>
<li>Aura Components: 一个PHP5.4的组件包</li>
<li>Hoa Project: 另一个PHP组件包</li>
</ul>
<h2 id="0x17、微型框架——微型框架和路由"><a href="#0x17、微型框架——微型框架和路由" class="headerlink" title="0x17、微型框架——微型框架和路由"></a>0x17、微型框架——微型框架和路由</h2><ul>
<li>Silex: 基于Symphony2组件的微型框架</li>
<li>Slim: 另一个简单的微型框架</li>
<li>Bullet PHP: 用于构建REST APIs的微型框架</li>
<li>Fast Route: 快速路由选择库</li>
<li>Pux: 另一个快速路由选择库</li>
</ul>
<h2 id="0x18、微型框架的附加部分——其它相关的微型框架和路由"><a href="#0x18、微型框架的附加部分——其它相关的微型框架和路由" class="headerlink" title="0x18、微型框架的附加部分——其它相关的微型框架和路由"></a>0x18、微型框架的附加部分——其它相关的微型框架和路由</h2><ul>
<li>Silex Skeleton: 用于Silex的项目框架</li>
<li>Silex Web Profiler: 用于Silex的Web调试工具条</li>
<li>Stack: 用于Silex/Symphony的可堆叠中间件库</li>
<li>Slim Skeleton: 用于Slim的框架</li>
<li>Slim View: Slim的自定义视图集</li>
<li>Slim Middleware: Slim的自定义中间件集合</li>
</ul>
<h2 id="0x19、模板——模板和词法分析的库与工具"><a href="#0x19、模板——模板和词法分析的库与工具" class="headerlink" title="0x19、模板——模板和词法分析的库与工具"></a>0x19、模板——模板和词法分析的库与工具</h2><ul>
<li>Twig: 一种综合的模板语言</li>
<li>Twig Cache Extension: 用于Twig的模板片段缓存库</li>
<li>Mustache: PHP实现的Mustache模板语言</li>
<li>Phly Mustache: 另一个PHP实现的Mustache模板语言</li>
<li>MtHaml : PHP实现的HAML模板语言</li>
<li>PHPTAL: PHP实现的TAL模板语言</li>
<li>Plates: 一个原始的PHP模板库</li>
<li>Lex: 一个轻量级模板解析器</li>
</ul>
<h2 id="0x20、静态站点生成器——生成Web页面内容的预处理工具"><a href="#0x20、静态站点生成器——生成Web页面内容的预处理工具" class="headerlink" title="0x20、静态站点生成器——生成Web页面内容的预处理工具"></a>0x20、静态站点生成器——生成Web页面内容的预处理工具</h2><ul>
<li>Sculpin: 将Markdown和Twig转换为静态HTML的工具</li>
<li>Phrozn: 另一款将Textile、Markdown和Twig转为HTML的工具</li>
<li>HTTP——用于HTTP和抓取网站的库</li>
<li>Guzzle: 一个完整的HTTP客户端</li>
<li>Buzz: 另一个HTTP客户端</li>
<li>Requests: 一个简单的HTTP库</li>
<li>HTTPFul: 一个链式HTTP客户端</li>
<li>Goutte: 一个简单的Web抓取器</li>
<li>PHP VCR: 一个录制和回放HTTP请求的库</li>
<li>URL——解析URL的库</li>
<li>Purl: 一个URL操作库</li>
<li>PHP Domain Parser: 一个本地的后缀解析器</li>
<li>Email——用于发送和解析Email的库</li>
<li>SwiftMailer: 一个邮件程序的解决方案</li>
<li>PHPMailer: 另一个邮件程序的解决方案</li>
<li>Fetch: 一个IMAP库</li>
<li>Email Reply Parser: 一个邮件回复解析器库</li>
<li>Stampie: 关于邮件服务的库，比如SendGrid、PostMark、MailGun和Mandrill</li>
<li>CssToInlineStyles: 邮件模板中一个内联的CSS库</li>
</ul>
<h2 id="0x21、文件——关于文件处理和MIME类型检查"><a href="#0x21、文件——关于文件处理和MIME类型检查" class="headerlink" title="0x21、文件——关于文件处理和MIME类型检查"></a>0x21、文件——关于文件处理和MIME类型检查</h2><ul>
<li>Gaufrette: 一个文件流的抽象层</li>
<li>Flysystem: 另一个文件流的抽象层</li>
<li>Canal: 一个检查互联网媒体类型的库</li>
<li>Apache MIME Types: 一个解析Apache MIME类型的库</li>
<li>Ferret: 一个MIME检测库</li>
<li>Hoa Mime: 另一个MIME检测库</li>
<li>Lurker: 一个资源跟踪库</li>
<li>PHP File Locator: 一个在大型项目中定位文件的库</li>
<li>PHP FFmpeg: 一个用于FFmpeg视频包装的库</li>
<li>CSV: 一个CSV数据操作库</li>
</ul>
<h2 id="0x22、流——处理流的库"><a href="#0x22、流——处理流的库" class="headerlink" title="0x22、流——处理流的库"></a>0x22、流——处理流的库</h2><ul>
<li>Streamer: 一个简单的面向对象流包装库</li>
<li>依赖注入——实现依赖注入设计模式的库</li>
<li>Pimple: 一个小的依赖注入容器</li>
<li>Auryn: 另一个小的依赖注入容器</li>
<li>Orno Di: 一个易扩展的依赖注入容器</li>
<li>PHP DI: 一个使用标注实现的依赖注入</li>
<li>Acclimate: 依赖注入容器和服务定位器的通用接口</li>
</ul>
<h2 id="0x23、图像——处理图像的库"><a href="#0x23、图像——处理图像的库" class="headerlink" title="0x23、图像——处理图像的库"></a>0x23、图像——处理图像的库</h2><ul>
<li>Imagine: 一个图像处理库</li>
<li>PHP Image Workshop: 另一个图像处理库</li>
<li>Intervention Image: 同样还是一个图像处理库</li>
<li>GIF Frame Extractor: 一个提取GIF动画帧信息的库</li>
<li>GIF Creator: 从多幅图片中创建GIF动画的库</li>
<li>Image With Text: 在图像中嵌入文本的库</li>
<li>Color Extractor: 从图像中提取颜色的库</li>
</ul>
<h2 id="0x24、测试——测试代码库和生成测试数据的库"><a href="#0x24、测试——测试代码库和生成测试数据的库" class="headerlink" title="0x24、测试——测试代码库和生成测试数据的库"></a>0x24、测试——测试代码库和生成测试数据的库</h2><ul>
<li>PHPUnit: 一个单元测试框架</li>
<li>DBUnit: PHPUnit的代码测试库</li>
<li>ParaTest: PHPUnit的并行测试库</li>
<li>PHPSpec: 根据规范的单元测试库</li>
<li>Codeception: 一个全栈测试框架</li>
<li>AspectMock: PHPUnit/Codeception的模拟框架</li>
<li>Atoum: 一个简单的测试库</li>
<li>Mockery: 一个用于测试的模拟对象库</li>
<li>Phake: 另一个用于测试的模拟对象库</li>
<li>Prophecy: 一个强大的模拟框架</li>
<li>Faker: 一个伪数据生成库</li>
<li>Samsui: 另一个伪数据生成库</li>
<li>Alice: 用于生成复杂数据的库</li>
<li>Behat: 一个行为驱动开发（BDD）的测试框架</li>
<li>Pho: 另一个行为驱动开发的测试框架</li>
<li>Mink: Web验收测试</li>
<li>HTTP Mock: 一个在单元测试中模拟HTTP请求的库</li>
<li>VFS Stream: 一个用于测试的虚拟文件系统流包装</li>
<li>VFS: 另一个用于测试的虚拟文件系统</li>
<li>Locust: 一个Python开发的现代负载测试库</li>
</ul>
<h2 id="0x25、持续集成——持续集成的库和应用"><a href="#0x25、持续集成——持续集成的库和应用" class="headerlink" title="0x25、持续集成——持续集成的库和应用"></a>0x25、持续集成——持续集成的库和应用</h2><ul>
<li>Travis CI: 一个持续集成的平台</li>
<li>PHPCI: 一个PHP的开源持续集成平台</li>
<li>Sismo: 一个持续的测试服务器库</li>
<li>Jenkins: PHP支持的持续集成平台</li>
<li>JoliCi: PHP开发的由Docker支持的持续集成客户端</li>
</ul>
<h2 id="0x26、文档——生成项目文档的库"><a href="#0x26、文档——生成项目文档的库" class="headerlink" title="0x26、文档——生成项目文档的库"></a>0x26、文档——生成项目文档的库</h2><ul>
<li>Sami: 一个API文档生成器</li>
<li>APIGen: 另一个API文档生成器</li>
<li>PHP Documentor 2: 文档生成器</li>
<li>phpDox: 一个PHP项目的文档生成器（不仅仅是API文档）</li>
</ul>
<h2 id="0x27、安全性"><a href="#0x27、安全性" class="headerlink" title="0x27、安全性"></a>0x27、安全性</h2><ul>
<li>HTML Purifier: 一个标准的HTML过滤器</li>
<li>RandomLib: 生成随机数和随机字符串的库</li>
<li>True Random: 使用<a href="http://www.random.org生成随机数的库" target="_blank" rel="noopener">www.random.org生成随机数的库</a></li>
<li>SecurityMultiTool: 一个PHP安全库</li>
<li>PHPSecLib: 一个纯的PHP安全通信库</li>
<li>TCrypto: 一个简单的键值加密存储库</li>
<li>PHP IDS: 一个结构化的PHP安全层</li>
<li>PHP SSH: 面向对象的SSH包装库</li>
<li>IniScan: 一个扫描PHP INI文件安全的工具</li>
<li>SensioLabs Security Check: 一个根据安全建议检查Composer依赖的Web工具</li>
<li>Zed: 用于Web应用的集成渗透测试工具</li>
</ul>
<h2 id="0x28、密码"><a href="#0x28、密码" class="headerlink" title="0x28、密码"></a>0x28、密码</h2><ul>
<li>Password Compat: 一个用于新的PHP5.5密码功能的兼容库</li>
<li>phpass: 一个便携式密码哈希框架</li>
<li>PHP Password Lib: 一个用于生成和验证密码的库</li>
<li>Password Policy: 一个PHP和JavaScript的密码规则库</li>
<li>Password Validator: 验证和升级密码哈希的库</li>
<li>Zxcvbn PHP: 一个基于Zxcvbn JS的PHP显示密码强度估计库</li>
</ul>
<h2 id="0x29、代码分析"><a href="#0x29、代码分析" class="headerlink" title="0x29、代码分析"></a>0x29、代码分析</h2><ul>
<li>PHP Parser: 一个PHP编写的PHP解析器</li>
<li>PHPPHP: 一个PHP实现的PHP虚拟机</li>
<li>PHPSandbox: PHP的沙盒环境</li>
<li>Dissect: 词法和语法分析的工具集合</li>
<li>PHP Mess Detector: 一个扫描代码bug、次佳代码和未使用参数的库</li>
<li>PHP Code Sniffer: 一个检测PHP、CSS和JS代码标准冲突的库</li>
<li>PHPCPD: 一个检测复制和粘贴代码的库</li>
<li>PHP Analyser: 一个分析PHP代码中错误的库</li>
<li>PHP CS Fixer: 一个代码标准库</li>
<li>PHP Manipulator: 用于分析和修改PHP源代码的库</li>
<li>PHP Metrics: 一个静态测量库</li>
<li>PHP Refactoring Browser: 一个用于重构PHP代码的命令行工具</li>
<li>UBench: 一个简单的小型基准测试库</li>
<li>Athletic: 一个基于标注的基准测试库</li>
<li>Mondrian: 使用图论的代码分析工具</li>
<li>Scrutinizer: 检查PHP代码的Web工具</li>
<li>PHPLOC: 一个快速评估PHP项目大小的工具</li>
<li>xHprof: 另一个PHP性能评测工具</li>
<li>PHPCheckstyle: 一个帮助遵守特定代码规则的工具</li>
</ul>
<h2 id="0x30、调试"><a href="#0x30、调试" class="headerlink" title="0x30、调试"></a>0x30、调试</h2><ul>
<li>xDebug: 一个PHP的调试和分析工具</li>
<li>PHP Debug Bar: 一个调试工具条</li>
<li>PHP Console: Web调试控制台</li>
<li>Barbushin PHP Console: 一个使用Google Chrome的Web调试控制工具</li>
<li>PHPDBG: 一个交互性的PHP调试器</li>
<li>Tracy: 一个简单的错误检测、日志和时间测量库</li>
</ul>
<h2 id="0x31、构建工具"><a href="#0x31、构建工具" class="headerlink" title="0x31、构建工具"></a>0x31、构建工具</h2><ul>
<li>Go: 一个简单的PHP构建工具</li>
<li>Bob: 一个简单的项目自动化工具</li>
<li>Phake: 一个PHP克隆库</li>
<li>Box: 用来构建PHAR文件的工具</li>
<li>Phing: 依据Apache Ant的PHP项目构建系统</li>
</ul>
<h2 id="0x32、任务运行器"><a href="#0x32、任务运行器" class="headerlink" title="0x32、任务运行器"></a>0x32、任务运行器</h2><ul>
<li>Task: 依据Grunt和Gulp的纯PHP任务运行器</li>
<li>Robo: 面向对象的PHP任务运行器</li>
<li>Bldr: 构建在Symphony组件上的PHP任务运行器</li>
</ul>
<h2 id="0x33、导航"><a href="#0x33、导航" class="headerlink" title="0x33、导航"></a>0x33、导航</h2><ul>
<li>KnpMenu: 一个菜单库</li>
<li>Cartographer: 一个站点地图生成库</li>
</ul>
<h2 id="0x34、资源管理"><a href="#0x34、资源管理" class="headerlink" title="0x34、资源管理"></a>0x34、资源管理</h2><ul>
<li>Assetic: 一个资源管理的管道库</li>
<li>Pipe: 另一个资源管理的管道库</li>
<li>Munee: 一个资源优化库</li>
<li>JShrink: 一个JavaScript的最小化库</li>
<li>Puli: 一个检测资源绝对路径的库</li>
</ul>
<h2 id="0x35、地理定位"><a href="#0x35、地理定位" class="headerlink" title="0x35、地理定位"></a>0x35、地理定位</h2><ul>
<li>GeoCoder: 一个地理编码库</li>
<li>GeoTools: 一个地理工具相关的库</li>
<li>PHPGeo: 一个简单的地理库</li>
<li>GeoJSON: 一个GeoJSON的实现</li>
</ul>
<h2 id="0x36、日期和时间"><a href="#0x36、日期和时间" class="headerlink" title="0x36、日期和时间"></a>0x36、日期和时间</h2><ul>
<li>Carbon: 一个简单的日期时间API扩展</li>
<li>ExpressiveDate: 另一个日期时间API扩展</li>
<li>CalendR: 一个日历管理的库</li>
</ul>
<h2 id="0x37、事件"><a href="#0x37、事件" class="headerlink" title="0x37、事件"></a>0x37、事件</h2><ul>
<li>React: 一个事件驱动的非阻塞I/O库</li>
<li>Rx.PHP: 一个反应扩展库</li>
<li>Ratchet: 一个Web套接字库</li>
<li>Hoa WebSocket: 另一个Web套接字库</li>
<li>Hoa EventSource: 一个事件源库</li>
<li>Evenement: 一个事件调度库</li>
<li>FuelPHP Event: 另一个事件调度库</li>
</ul>
<h2 id="0x38、日志"><a href="#0x38、日志" class="headerlink" title="0x38、日志"></a>0x38、日志</h2><ul>
<li>Monolog: 一个完整的日志工具</li>
<li>KLogger: 一个易于使用的PSR-3日志类</li>
</ul>
<h2 id="0x39、电子商务"><a href="#0x39、电子商务" class="headerlink" title="0x39、电子商务"></a>0x39、电子商务</h2><ul>
<li>OmniPay: 一个多网关支付处理的框架</li>
<li>Payum: 一个用于支付的抽象库</li>
<li>Sylius: 一个开源的电子商务解决方案</li>
<li>Thelia: 另一个开源的电子商务解决方案</li>
<li>Money: PHP实现的Fowler金钱模式</li>
<li>Sebastian Money: 一个处理货币价值的库</li>
<li>Swap: 一个汇率库</li>
</ul>
<h2 id="0x40、PDF"><a href="#0x40、PDF" class="headerlink" title="0x40、PDF"></a>0x40、PDF</h2><p>-Snappy: 一个PDF和图像的生成库</p>
<ul>
<li>WKHTMLToPDF: 一个将HTML转换为PDF的工具</li>
</ul>
<h2 id="0x41、数据库"><a href="#0x41、数据库" class="headerlink" title="0x41、数据库"></a>0x41、数据库</h2><ul>
<li>Doctrine: 一个完整的DBAL和ORM</li>
<li>Doctrine Extensions: 一个Doctrine行为的扩展集合</li>
<li>Propel: 一个快速的ORM，迁移和查询库</li>
<li>Eloquent: Laravel 4 ORM</li>
<li>Baum: 一个Eloquent的嵌套集合</li>
<li>Spot2: MySQL的ORM映射器</li>
<li>RedBean: 一个轻量级、易配置的ORM</li>
<li>Pomm: 用于PostgreSQL的一个对象模型管理器</li>
<li>ProxyManager: 用于数据映射生成代理对象的工具集合</li>
</ul>
<h2 id="0x42、迁移"><a href="#0x42、迁移" class="headerlink" title="0x42、迁移"></a>0x42、迁移</h2><ul>
<li>PHPMig: 一个迁移管理库</li>
<li>Phinx: 一个数据库迁移管理库</li>
<li>Migrations: 另一个迁移管理库</li>
<li>Doctrine Migrations: 用于Doctrine的迁移库</li>
</ul>
<h2 id="0x43、NoSQL"><a href="#0x43、NoSQL" class="headerlink" title="0x43、NoSQL"></a>0x43、NoSQL</h2><ul>
<li>MongoQB: 一个MongoDB的查询构建库</li>
<li>Monga: 一个MongoDB的抽象库</li>
<li>Predis: 一个功能完全的Redis库</li>
</ul>
<h2 id="0x44、队列"><a href="#0x44、队列" class="headerlink" title="0x44、队列"></a>0x44、队列</h2><ul>
<li>Pheanstalk: 一个Beanstalkd客户端库</li>
<li>PHP AMQP: 一个纯PHP AMQP库</li>
<li>Thumper: 一个RabbitMQ模式库</li>
<li>Bernard: 一个多后端的抽象库</li>
</ul>
<h2 id="0x45、搜索"><a href="#0x45、搜索" class="headerlink" title="0x45、搜索"></a>0x45、搜索</h2><ul>
<li>ElasticSearch PHP: 用于ElasticSearch的官方客户端库</li>
<li>Elastica: 另一个ElasticSearch的客户端库</li>
<li>Solarium: Solr的客户端库</li>
<li>SphinxQL query builder: Sphinx搜索引擎的查询库</li>
</ul>
<h2 id="0x45、命令行"><a href="#0x45、命令行" class="headerlink" title="0x45、命令行"></a>0x45、命令行</h2><ul>
<li>Boris: 一个微型的PHP REPL</li>
<li>PsySH: 另一个PHP REPL</li>
<li>Pecan: 一个事件驱动，非阻塞内核</li>
<li>GetOpt: 一个命令行选择解析器</li>
<li>OptParse: 另一个命令行选择解析器</li>
<li>Commando: 一个简单的命令行选择解析器</li>
<li>GetOptionKit: 同样还是一个命令行选择解析器</li>
<li>Cron Expression: 计算cron运行日期的库</li>
<li>ShellWrap: 一个简单的命令行包装库</li>
<li>Hoa Console: 另一个命令行库</li>
<li>Shunt: 一个在多台远程机器上并行运行的命令行库</li>
<li>Cilex: 构建命令行工具的小型框架</li>
</ul>
<h2 id="0x46、身份验证"><a href="#0x46、身份验证" class="headerlink" title="0x46、身份验证"></a>0x46、身份验证</h2><ul>
<li>Sentry: 一个身份验证和授权的框架</li>
<li>Sentry Social: 一个用于社交网络身份验证的库</li>
<li>Opauth: 一个多供应的身份验证框架</li>
<li>OAuth2: 一个OAuth2身份验证服务器、资源服务器和客户端库</li>
<li>OAuth2 Server: 一个OAuth2服务器实现</li>
<li>PHP oAuthLib: 另一个OAuth库</li>
<li>TwitterOAuth: 同样是一个OAuth库</li>
<li>TwitterSDK: 一个经过完全测试的Twitter SDK</li>
<li>Hawk: 一个Hawk HTTP身份验证库</li>
<li>HybridAuth: 一个开源的社交登录库</li>
</ul>
<h2 id="0x47、标记"><a href="#0x47、标记" class="headerlink" title="0x47、标记"></a>0x47、标记</h2><ul>
<li>Decoda: 一个轻量级的标记解析库</li>
<li>PHP Markdown: Markdown解析器</li>
<li>CommonMark PHP: 一个支持CommonMark spec的Markdown解析器</li>
<li>Dflydev Markdown: 另一个Markdown解析器</li>
<li>Parsedown: 同样是一个Markdown解析器</li>
<li>Ciconia: 一个支持Github风格的Markdown解析器</li>
<li>Cebe Markdown: 一个快速、可扩展的Markdown解析器</li>
<li>HTML5 PHP: 一个HTML5解析和序列化的库</li>
</ul>
<h2 id="0x48、字符串"><a href="#0x48、字符串" class="headerlink" title="0x48、字符串"></a>0x48、字符串</h2><ul>
<li>ANSI to HTML5: 一个将ANSI转换为HTML5的库</li>
<li>Patchwork UTF-8: 处理UTF-8格式字符串的便携库</li>
<li>Hoa String: 另一个UTF-8格式的字符串库</li>
<li>Stringy: 一个多字节支持的字符串操纵库</li>
<li>Color Jizz: 一个处理和转换颜色的库</li>
<li>UUID: 生成UUIDs的库</li>
<li>Slugify: 一个将字符串转换为slug格式的库</li>
<li>Urlify: 一个Django URLify.js的PHP端口</li>
<li>Text: 一个文本处理库</li>
<li>SQL Formatter: 一个用于格式化SQL语句的库</li>
<li>UA Parser: 一个用于解析用户字符串的库</li>
</ul>
<h2 id="0x49、数字"><a href="#0x49、数字" class="headerlink" title="0x49、数字"></a>0x49、数字</h2><ul>
<li>Numbers PHP: 一个处理数字的库</li>
<li>Math: 处理较大数字的库</li>
<li>ByteUnits: 一个在二进制和测量系统中解析、格式化和转换字节单位的库</li>
<li>PHP Units of Measure: 一个测量单位间转换的库</li>
<li>PHP Conversion: 另一个测量单位间转换的库</li>
<li>LibPhoneNumber for PHP: PHP实现的Google电话号码处理系统库</li>
</ul>
<h2 id="0x50、过滤和验证"><a href="#0x50、过滤和验证" class="headerlink" title="0x50、过滤和验证"></a>0x50、过滤和验证</h2><blockquote>
<p>用于过滤和验证数据的库</p>
</blockquote>
<ul>
<li>Filterus: 一个简单的PHP过滤库</li>
<li>Respect Validate: 一个简单的验证库</li>
<li>Valitron: 另一个数据验证库</li>
<li>Upload: 一个处理文件上传和验证的库</li>
<li>DMS Filter: 一个基于标注的过滤库</li>
<li>MetaYaml: 支持YAML、JSON和XML的一个模式验证库</li>
<li>ISO-codes: 验证不同ISO和ZIP编码的库</li>
</ul>
<h2 id="0x51、REST和API"><a href="#0x51、REST和API" class="headerlink" title="0x51、REST和API"></a>0x51、REST和API</h2><ul>
<li>Apigility: 一个使用Zend Framework2构建的API构建器</li>
<li>Hateoas: 一个HATEOAS REST的web服务库</li>
<li>HAL: 一个超文本应用语言（HAL）构建库</li>
<li>Negotiation: 一个内容协商库</li>
<li>Drest: 一个将Doctrine实体展现为REST资源结点的库</li>
<li>Restler: 一个将PHP方法展现为RESTful web API的轻量级框架</li>
</ul>
<h2 id="0x52、缓存"><a href="#0x52、缓存" class="headerlink" title="0x52、缓存"></a>0x52、缓存</h2><ul>
<li>Alternative PHP Cache (APC): PHP的开源操作码缓存</li>
<li>Cache: 一个缓存库</li>
<li>Stash: 另一个缓存库</li>
</ul>
<h2 id="0x53、数据结构和存储"><a href="#0x53、数据结构和存储" class="headerlink" title="0x53、数据结构和存储"></a>0x53、数据结构和存储</h2><ul>
<li>Ardent: 一个数据结构库</li>
<li>PHP Collections: 一个简单的集合库</li>
<li>Serializer: 用于序列化和反序列化数据的库</li>
<li>PHP Object Storage: 一个用于对象存储的库</li>
<li>Fractal: 一个将复杂数据结构转换为JSON输出的库</li>
<li>Totem: 一个管理和创建数据修改集的库</li>
<li>PINQ: PHP实时Linq库</li>
<li>JsonMapper: 一个将内嵌JSON结构映射到PHP类上的库</li>
</ul>
<h2 id="0x54、通知"><a href="#0x54、通知" class="headerlink" title="0x54、通知"></a>0x54、通知</h2><ul>
<li>Nod: 一个通知库</li>
<li>Notificato: 一个处理推送消息的库</li>
<li>Notification Pusher: 设备推送通知的独立库</li>
<li>Notificator: 一个轻量级通知库</li>
</ul>
<h2 id="0x55、部署"><a href="#0x55、部署" class="headerlink" title="0x55、部署"></a>0x55、部署</h2><ul>
<li>Pomander: 一个PHP应用的部署工具</li>
<li>Rocketeer: PHP的快速和简单部署器</li>
<li>Envoy: 使用PHP运行SSH任务的工具</li>
<li>Plum: 一个部署库</li>
</ul>
<h2 id="0x56、第三方API"><a href="#0x56、第三方API" class="headerlink" title="0x56、第三方API"></a>0x56、第三方API</h2><ul>
<li>Amazon Web Service SDK: PHP AWS SDK官方库</li>
<li>S3 Stream Wrapper: Amazon S3的流包装库</li>
<li>Stripe: 官方的Stripe PHP库</li>
<li>Campaign Monitor: 官方的Campaign Monitor PHP库</li>
<li>Digital Ocean: 一个与Digital Ocean API交互的库</li>
<li>Github: 一个与Github API交互的库</li>
<li>PHP Github API: 另一个与Github API交互的库</li>
<li>Twitter OAuth: 一个与Twitter’s OAuth工作流交互的库</li>
<li>Twitter REST: 一个与Twitter’s REST API交互的库</li>
<li>Dropbox SDK: 官方的PHP Dropbox SDK库</li>
<li>Twilio: 官方的Twilio PHP REST API</li>
<li>Mailgun: 官方的Mailgun PHP API</li>
</ul>
<h2 id="0x57、扩展"><a href="#0x57、扩展" class="headerlink" title="0x57、扩展"></a>0x57、扩展</h2><ul>
<li>Zephir: 用于开发PHP扩展的一种在PHP和C++间的编译语言</li>
<li>PHP CPP: 一个用于开发PHP扩展的C++库</li>
</ul>
<h2 id="0x58、PHP安装"><a href="#0x58、PHP安装" class="headerlink" title="0x58、PHP安装"></a>0x58、PHP安装</h2><ul>
<li>HomeBrew: OSX的包管理器</li>
<li>HomeBrew PHP:一个HomeBrew的PHP接头</li>
<li>PHP OSX: 用于OSX的PHP安装器</li>
<li>PHP Brew: 一个PHP的版本管理和安装器</li>
<li>PHP Env: 一个PHP的版本管理器</li>
<li>PHP Switch: 另一个PHP的版本管理器</li>
<li>PHP Build: 一个PHP的版本安装器</li>
<li>VirtPHP: 一个用来创建和管理独立PHP开发环境的工具</li>
</ul>
<h2 id="0x59、开发环境"><a href="#0x59、开发环境" class="headerlink" title="0x59、开发环境"></a>0x59、开发环境</h2><ul>
<li>Vagrant: 一个便携式的开发环境工具</li>
<li>Ansible: 一个非常简单的编制框架</li>
<li>Puppet: 一个服务器自动化框架和应用</li>
<li>PuPHPet: 用于构建PHP开发虚拟机的Web工具</li>
<li>Protobox: 另一个用于构建PHP开发虚拟机的Web工具</li>
<li>Phansible: 一个用Ansible构建PHP开发开发虚拟机的Web工具</li>
</ul>
<h2 id="0x60、集成开发环境IDE"><a href="#0x60、集成开发环境IDE" class="headerlink" title="0x60、集成开发环境IDE"></a>0x60、集成开发环境IDE</h2><ul>
<li>Netbeans: 支持PHP和HTML5的IDE环境</li>
<li>Eclipse for PHP Developers : 基于Eclipse平台的PHP IDE</li>
<li>PhpStorm : 商业PHP IDE</li>
</ul>
<h2 id="0x61、Web应用"><a href="#0x61、Web应用" class="headerlink" title="0x61、Web应用"></a>0x61、Web应用</h2><ul>
<li>3V4L: 一个在线的PHP内核</li>
<li>DBV: 一个数据库版本控制应用</li>
<li>PHP Queue: 一个管理队列后端的应用</li>
<li>Composer as a Service: 作为一个zip文件下载Composer包的工具</li>
<li>MailCatcher: 一个抓取和浏览邮件的Web工具</li>
</ul>
<h2 id="0x62、源码解析"><a href="#0x62、源码解析" class="headerlink" title="0x62、源码解析"></a>0x62、源码解析</h2>]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql技术</title>
    <url>/2015/10/12/2015/10-12-mysql%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="0x00、数据库基本概念"><a href="#0x00、数据库基本概念" class="headerlink" title="0x00、数据库基本概念"></a>0x00、数据库基本概念</h2><p>1.数据模型：描述数据、数据关系、数据语义及一致性约束的概念工具集</p>
<ul>
<li>网络模型</li>
<li>层次模型</li>
<li>关系模型</li>
</ul>
<p>2.关系模型：用表来描述数据与数据间的关系<br>3.数据完整性和数据保护<br>4.mysql 1.0诞生于1995年<br>5.mysql以守护进程运行</p>
<h2 id="0x01、结构体系"><a href="#0x01、结构体系" class="headerlink" title="0x01、结构体系"></a>0x01、结构体系</h2><p>1.连接器<br>进行身份验证、线程重用,连接限制,检查内存,数据缓存；管理用户的连接，线程处理等需要缓存的需求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">"%connection%"</span>;</span><br></pre></td></tr></table></figure>

<p>2.连接池组件</p>
<p>3.缓存<br>全局和引擎特定的缓存和缓冲区</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like <span class="string">'%query_cache%'</span>;</span><br></pre></td></tr></table></figure>

<p>4.权限</p>
<p>5.表管理器</p>
<p>6.日志管理</p>
<p>7.sql接口组件<br>进行DML、DDL,存储过程、视图、触发器等操作和管理；用户通过SQL命令来查询所需结果。</p>
<p>8.插件式存储引擎</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>

<p>9.解析器<br>查询翻译对象的特权；SQL命令传递到解析器的时候会被解析器验证和解析</p>
<p>10.优化器<br>访问路径的统计数据</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; select @@optimizer_switch;</span><br></pre></td></tr></table></figure>

<p>11.管理服务与工具组件<br>备份和恢复的安全性，复制，集群，管理，配置，迁移和元数据</p>
<p>12.物理文件</p>
<ul>
<li><p>1.日志文件</p>
<ul>
<li>错误日志：errorlog</li>
<li>二进制日志：binlog</li>
<li>更新日志：update log</li>
<li>查询日志：query log</li>
<li>慢查询日志：slow query log</li>
<li>innodb在线redo日志：innodb redo log</li>
</ul>
</li>
<li><p>2.数据文件</p>
<ul>
<li>frm:任何存储引擎都有一个，存储表结构定义信息</li>
<li>MYD:MYISAM存储引擎专用，存储数据</li>
<li>MYI:MYISAM存储引擎专用，存储索引信息</li>
<li>idb和idbdata:innodb存储引擎存储数据，.idb存储独享表空间数据，idbdata存储共享表空间数据</li>
</ul>
</li>
<li><p>3.replication相关文件：</p>
<ul>
<li>master.info文件：存在于slave端的数据目录下，存放master端的ip，用户，连接密码和接口等数据</li>
<li>relay log和relay log index</li>
<li>relay-log.info文件</li>
</ul>
</li>
<li><p>4.其他文件</p>
<ul>
<li>system config file:my.cnf</li>
<li>pid file:存放mysql进程</li>
<li>socket file:unix\linux环境下才有，可以不用tcp协议连接而用unix的socket来连接mysql</li>
</ul>
</li>
</ul>
<h2 id="0x02、系统架构"><a href="#0x02、系统架构" class="headerlink" title="0x02、系统架构"></a>0x02、系统架构</h2><h3 id="1-逻辑模块"><a href="#1-逻辑模块" class="headerlink" title="1.逻辑模块"></a>1.逻辑模块</h3><p>1.SQL Layer:权限判断、sql解析、执行计划优化、query cache的处理</p>
<ul>
<li>初始化模块：在mysql server启动时，对整个系统做各种各样的优化，如：各种buffer、cache结构的初始化和内存空间申请，各种系统变量初始化，各种存储引擎初始化等</li>
<li>核心API:提供一些需要非常高效的底层操作功能的优化实现,包括各种底层数据结构的实现，特殊算法的实现，字符串处理，数字处理等，小文件I/O，格式化输出，以及最重要的内存管理部分</li>
<li>网络交换模块：抽象出底层网络交互所使用的接口api， 实现底层网络数据的接收与发送，以方便其他各个模块调用，以及对这一部分的维护。</li>
<li>Client&amp;Server 交换协议模块：任何C/S结构的软件系统， 都肯定会有自己独有的信息交互协议，MySQL也不例外。MySQL的Client &amp; Server 交互协议模块部分，实现了客户端与MySQL交互过程中的所有协议。当然这些协议都是建立在现有的OS和网络协议之上的，如TCP/IP以及Unix Socket</li>
<li>用户模块：主要包括用户的登录连接权限控制和用户的授权管理</li>
<li>访问控制模块：根据用户模块中各用户的授权信息， 以及数据库自身特有的各种约束， 来控制用户对数据的访问。 用户模块和访问控制模块两者结合起来， 组成了MySQL整个数据库系统的权限安全管理的功能</li>
<li>连接管理、连接线程和线程管理：负责监听对MySQL Server的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上MySQL Server的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server与客户端的通信，接受客户端的命令请求，传递Server端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的cache等</li>
<li>Query解析和转发模块：MySQL中我们习惯将所有Client端发送给Server端的命令都称为query， 在 MySQL Server里面，连接线程接收到客户端的一个 Query后，会直接将该 query传递给专门负责将各种Query进行分类然后转发给各个对应的处理模块， 这个模块就是query解析和转发模块。 其主要工作就是将query语句进行语义和语法的分析， 然后按照不同的操作类型进行分类，然后做出针对性的转发。</li>
<li>Query Cache模块：主要功能是将客户端提交给MySQL的Select类query请求的返回结果集cache到内存中， 与该query的一个hash值做一个对应。该Query所取数据的基表发生任何数据的变化之后， MySQL会自动使该query的Cache 失效。在读写比例非常高的应用系统中， Query Cache对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。</li>
<li>Query优化器模块：根据客户端请求的query语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个query语句的结果。</li>
<li>表变更管理模块：主要是负责完成一些DML和 DDL的query，如： update， delte， insert，create table， alter table等语句的处理</li>
<li>表维护模块：表的状态检查，错误修复，以及优化和分析等工作都是表维护模块需要做的事情。</li>
<li>系统状态管理模块：负责在客户端请求系统状态的时候， 将各种状态数据返回给用户， 像DBA常用的各种show status命令， show variables命令等， 所得到的结果都是由这个模块返回的</li>
<li>表管理器：表管理器的工作主要就是维护.frm等文件，以及一个cache，该cache中的主要内容是各个表的结构信息。此外它还维护table级别的锁管理。</li>
<li>日志记录模块：日志记录模块主要负责整个系统级别的逻辑层的日志的记录，包括error log， binary log， slow query log等</li>
<li>复制模块：可分为 Master 模块和 Slave 模块两部分， Master 模块主要负责在Replication环境中读取Master端的binary日志， 以及与 Slave端的I/O线程交互等工作。Slave模块比Master模块所要做的事情稍多一些，在系统中主要体现在两个线程上面。一个是负责从Master请求和接受binary日志， 并写入本地relay log中的I/O线程。 另外一个是负责从relay log中读取相关日志事件， 然后解析成可以在Slave端正确执行并得到和Master端完全相同的结果的命令并再交给Slave执行的SQL线程。</li>
<li>存储引擎接口模块：</li>
</ul>
<p>2.Storage Engine Layer</p>
<ul>
<li><p>MYISAM</p>
<ul>
<li>支持三种索引：B-tree索引、R-tree索引、Full-text索引</li>
<li>数据存放格式：静态固定长度(FIXED)、动态可变长度(DYNAMIC)、压缩格式(COMPRESSED)三种格式，同过创建表时指定ROW_FORMAT指定</li>
<li>不支持事务，表级锁</li>
</ul>
</li>
<li><p>innodb</p>
<ul>
<li>支持事务安装：四个级别READ UNCOMMITTED， READ COMMITTED， REPEATABLE READ和SERIALIZABLE。</li>
<li>数据多版本读取：</li>
<li>锁定机制的改进：实现了行级锁</li>
<li>支持外键</li>
<li>存在表空间概念：<ul>
<li>共享表空间：必须存在，innodb的undo信息和其他一些元数据信息都是存放在共享表空间里面的。 共享表空间的数据文件是可以设置为固定大小和可自动扩展大小两种形式</li>
<li>独享表空间</li>
</ul>
</li>
</ul>
</li>
<li><p>NDB Cluster</p>
<ul>
<li>负责管理各个节点的Manage节点主机</li>
<li>SQL 层的SQL服务器节点</li>
<li>Storage层的NDB数据节点，也就是上面说的NDB Cluster</li>
</ul>
</li>
</ul>
<h2 id="0x03、安全"><a href="#0x03、安全" class="headerlink" title="0x03、安全"></a>0x03、安全</h2><h3 id="1-网络"><a href="#1-网络" class="headerlink" title="1.网络"></a>1.网络</h3><h3 id="2-主机"><a href="#2-主机" class="headerlink" title="2.主机"></a>2.主机</h3><h3 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3.数据库"></a>3.数据库</h3><h3 id="4-代码"><a href="#4-代码" class="headerlink" title="4.代码"></a>4.代码</h3><h3 id="5-权限"><a href="#5-权限" class="headerlink" title="5.权限"></a>5.权限</h3><ul>
<li>1.有关权限信息主要存储在几个被称为 grant tables 的系统表中，即： mysql.User， mysql.db， mysql.Host， mysql.table_priv和mysql.column_priv</li>
<li>2.由于权限信息数据量比较小，而且访问又非常频繁，所以Mysql在启动的时候，就会将所有的权限信息都Load到内存中保存在几个特定的结构中。</li>
<li>3.议读者一般情况下尽量使用GRANT， REVOKE， CREATE USER以及DROP USER命令来进行用户和权限的变更操作， 尽量减少直接修改grant tables来实现用户和权限变更的操作</li>
<li>4.查询权限：SHOW GRANTS FOR ‘username’@’hostname’</li>
<li>5.权限级别：分为五个级别<ul>
<li><strong><code>Global Level:</code></strong> 称为全局权限控制， 所有权限信息都保存在mysql.user表中。 Global Level的所有权限都是针对整个mysqld的，对所有的数据库下的所有表及所有字段都有效。如果一个权限是以Global Level来授予的，则会覆盖其他所有级别的相同权限设置。只需要在执行GRANT命令的时候，用“ <em>.</em>”来指定适用范围是Global的即可，当有多个权限需要授予的时候，也并不需要多次重复执行GRANT命令，只需要一次将所有需要的权限名称通过逗号（ “ ,”）分隔开即可，</li>
<li><strong><code>Database Level:</code></strong> Database Level是在Global Level之下，其他三个Level之上的权限级别，其作用域即为所指定整个数据库中的所有对象。与Global Level的权限相比， Database Level主要少了以下几个权限：CREATE USER，FILE，PROCESS，RELOAD，REPLICATION CLIENT，REPLICATION SLAVE， SHOW DATABASES， SHUTDOWN， SUPER和USAGE这几个权限，没有增加任何权限。<ul>
<li>1.执行GRANT命令的时候，通过“ database.*”来限定权限作用域为database整个数据库</li>
<li>2.先通过USE命令选定需要授权的数据库，然后通过“ *”来限定作用域，这样授权的作用域实际上就是当前选定的整个数据库</li>
</ul>
</li>
<li><strong><code>Table Level:</code></strong> Database Level之下就是 Table Level的权限了， Table Level的权限可以被 GlobalLevel和Database Level的权限所覆盖， 同时也能覆盖Column Level和Routine Level的权限.权限作用范围是授权语句中所指定数据库的指定表。仅有ALTER， CREATE， DELETE， DROP， INDEX， INSERT， SELECT UPDATE这八种权限</li>
<li><strong><code>Column Level:</code></strong> 权限作用范围就更小了，仅仅是某个表的指定的某个（活某些）列。<ul>
<li>由于权限的覆盖原则， Column Level的权限同样可以被 Global， Database， Table这三个级别的权限中的相同级别所覆盖</li>
<li>而且由于 Column Level所针对的权限和 Routine Level的权限作用域没有重合部分，所以不会有覆盖与被覆盖的关系。</li>
<li>针对Column Level级别的权限仅有INSERT， SELECT和UPDATE这三种。</li>
<li>Column Level的权限授权语句语法基本和Table Level差不多，只是需要在权限名称后面将需要授权的列名列表通过括号括起来</li>
<li>某个用户在向某个表插入（ INSERT）数据的时候，如果该用户在该表中某列上面没有INSERT权限，则该列的数据将以默认值填充。这一点和很多其他的数据库都有一些区别，是MySQL自己在SQL上面所做的扩展</li>
</ul>
</li>
<li><strong><code>Routine Level:</code></strong> 权限主要只有 EXECUTE和 ALTER ROUTINE两种<ul>
<li>主要针对的对象是procedure和function这两种对象</li>
<li>在授予 Routine Level权限的时候，需要指定数据库和相关对象</li>
</ul>
</li>
<li><strong><code>GRANT权限:</code></strong> 拥有GRANT权限的用户可以将自身所拥有的任何权限全部授予其他任何用户是一个非常特殊也非常重要的权限。<ul>
<li>GRANT权限的授予方式也和其他任何权限都不太一样，通常都是通过在执行GRANT授权语句的时候在最后添加WITH GRANT OPTION子句达到授予GRANT权限的目的</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以上五个Level的权限中， Table、 Column和Routine三者在授权中所依赖（或者引用）的对象必须是已经存在的，而不像Database Level的权限授予，可以在当前不存在该数据库的时候就完成授权</p>
<h3 id="6-访问控制原理"><a href="#6-访问控制原理" class="headerlink" title="6.访问控制原理"></a>6.访问控制原理</h3><ul>
<li><p>1.两个模块：用户管理模块和访问控制模块</p>
</li>
<li><p>2.用户管理模块：</p>
<ul>
<li>主要是有user表</li>
<li>如果指定用户访问，需有-h选项指定连接ip，mysql默认用localhost指定连接</li>
<li>权限更新：FLUSH PRIVILEGES会强行让MySQL更新Load到内存中的权限信息；<ul>
<li>GRANT、 REVOKE或者CREATE USER和DROP USER操作会直接更新内存中俄权限信息；</li>
<li>重启MySQL会让MySQL完全从grant tables中读取权限信息</li>
<li>于Global Level的权限信息的修改，仅仅只有更改之后新建连接才会用到，对于已经连接上的session并不会受到影响。</li>
<li>而对于Database Level的权限信息的修改，只有当客户端请求执行了“ USE database_name” 命令之后，才会在重新校验中使用到新的权限信息。</li>
<li>所以有些时候如果在做了比较紧急的Global和Database这两个Level的权限变更之后，可能需要通过“ KILL” 命令将已经连接在MySQL中的session 杀掉强迫他们重新连接以使用更新后的权限。</li>
<li>对于Table Level和Column Level的权限，则会在下一次需要使用到该权限的Query被请求的时候生效，也就是说，对于应用来讲，这两个Level的权限，更新之后立刻就生效了，而不会需要执行“ KILL” 命令</li>
</ul>
</li>
</ul>
</li>
<li><p>3.访问控制模块：</p>
<ul>
<li>MySQL 接收到客户端的请求之后， 访问控制模块是需要校验该用户是否满足提交的请求所需要的权限。 权限校验过程是从最大范围的权限往最小范围的权限开始依次校验所涉及到的每个对象的每个权限</li>
<li>MySQL首先会查找存储在内存结构中的权限数据，首先查找 Global Level 权限，如果所需权限在 Global Level 都有定义（ GRANT或者 REVOKE），则完成权限校验（通过或者拒绝） ，如果没有找到所有权限的定义，则会继续往后查找Database Level 权限，进行 Global Level 未定义的所需权限的校验，如果仍然没有能够找到所有所需权限的定义， MySQL 会继续往更小范围的权限定义域查找，也就是 Table Level，最后则是 Column Level 或者 Routine Level</li>
<li>MySQL的权限是授予“ username@hostname” 的，也就是说，至少需要用户名和主机名二者才能确定一个访问者的权限。又由于hostname可以是一个含有通配符的域名，也可以是一个含有通配符的IP地址段。那么如果同一个用户有两条权限信息，一条是针对特定域名的， 另外一个是含有通配符的域名， 而且前者属于后者包含。 这时候MySQL如何来确定权限信息呢？实际上MySQL永远优先考虑更精确范围的权限。 在MySQL内部会按照username和hostname作一个排序， 对于相同username的权限， 其host信息越接近访问者的来源host， 则排序位置越靠前， 则越早被校验使用到。 而且， MySQL在权限校验过程中，只要找到匹配的权限之后， 就不会再继续往后查找是否还有匹配的权限信息， 而直接完成校验过程</li>
</ul>
</li>
</ul>
<h3 id="7-访问授权策略"><a href="#7-访问授权策略" class="headerlink" title="7.访问授权策略"></a>7.访问授权策略</h3><p>1.了解来访主机：<br>2.了解用户需求：<br>3.要用工作分类<br>4.确保只有绝对必要者拥有Grant Option权限</p>
<h3 id="8-安全设置注意项"><a href="#8-安全设置注意项" class="headerlink" title="8.安全设置注意项"></a>8.安全设置注意项</h3><p>1.确认mysql是否需要联网，通过使用“ –skip-networking” 参数选项，让MySQL不通过TCP/IP监听网络请求，而仅仅通过命名管道或共享内存(在Windows中)或Unix套接字文件(在Unix中)来和客户端连接交互<br>2.通过使用“ –skip-networking” 参数选项，让MySQL不通过TCP/IP监听网络请求，而仅仅通过命名管道或共享内存(在Windows中)或Unix套接字文件(在Unix中)来和客户端连接交互<br>3.使用SSL加密通道。<br>4.访问授权限定来访主机信息。<br>5.OS安全方面：关闭MySQL Server主机上面任何不需要的服务，这不仅能从安全方面减少潜在隐患，还能减轻主机的部分负担，尽可能提高性能。<br>6.用非root用户运行MySQL<br>7.文件和进程安全。MySQL相关的数据和日志文件和所在的文件夹属主和所属组都设置为mysql，且禁用其他所有用户（除了拥有超级权限的用户，如root）的读写权限。以防止数据或者日志文件被窃取或破坏。<br>8.确保MySQL Server所在的主机上所必要运行的其他应用或者服务足够安全，避免因为其他应用或者服务存在安全漏洞而被入侵者攻破防线<br>9.用户设置：密码复杂<br>10.安全参数：不需要使用的功能模块尽量都不要启用，如果不需要使用用户自定义函数，就不要在启动的时候使用“ –allow-suspicious-udfs” 参数选项，以防止被别有居心的潜在威胁者利用此功能而对MySQL的安全造成威胁；</p>
<ul>
<li>不需要从本地文件中Load数据到数据库中，就使用“ –local-infile=0” 禁用掉可以从客户端机器上Load文件到数据库中；</li>
<li>使用新的密码规则和校验规则（不要使用“ –old-passwords”启动数据库） ，这项功能是为了兼容旧版本的密码校验方式的，如无额数必要，不要使用该功能，旧版本的密码加密方式要比新的方式在安全方面弱很多</li>
</ul>
<h2 id="0x04、存储管理器"><a href="#0x04、存储管理器" class="headerlink" title="0x04、存储管理器"></a>0x04、存储管理器</h2><p>1.权限及完整性管理器<br>2.事务管理器</p>
<ul>
<li>原子性</li>
<li>一致性</li>
<li>持久性</li>
<li></li>
</ul>
<p>3.文件管理器<br>4.缓冲管理器<br>5.数据文件<br>6.数据字典<br>7.索引</p>
<h2 id="0x05、查询处理器"><a href="#0x05、查询处理器" class="headerlink" title="0x05、查询处理器"></a>0x05、查询处理器</h2><p>1.DDL解释器<br>2.DML编译器<br>3.查询计算引擎<br>4.预处理</p>
<h2 id="0x06、关系型数据库"><a href="#0x06、关系型数据库" class="headerlink" title="0x06、关系型数据库"></a>0x06、关系型数据库</h2><p>1.数据库<br>2.表、元组、类型、主键、外键、码、关系、属性<br>3.范式<br>4.数据抽象：物理层、逻辑层、视图层<br>5.关系运算：选择、投影、并、差、笛卡儿积、交、自然连接、除<br>6.外连接：左外连接、右外连接</p>
<h2 id="0x07、关键字-SQL"><a href="#0x07、关键字-SQL" class="headerlink" title="0x07、关键字(SQL)"></a>0x07、关键字(SQL)</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span>,<span class="keyword">delete</span>,<span class="keyword">drop</span>,<span class="keyword">select</span>,<span class="keyword">insert</span>,<span class="keyword">update</span>,<span class="keyword">set</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">database</span>,<span class="keyword">table</span>,<span class="keyword">index</span>,<span class="keyword">function</span>,process,<span class="keyword">trigger</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">show</span>,<span class="keyword">status</span>,<span class="keyword">processlist</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">where</span>,<span class="keyword">distinct</span>,<span class="keyword">as</span>,<span class="keyword">with</span>,<span class="keyword">or</span>,<span class="keyword">and</span>,<span class="keyword">like</span>,<span class="keyword">not</span> <span class="keyword">like</span>,<span class="keyword">between</span> <span class="keyword">and</span>,<span class="keyword">order</span> <span class="keyword">by</span>(DESE,ASE),<span class="keyword">group</span> <span class="keyword">by</span>,<span class="keyword">having</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">union</span>,<span class="keyword">union</span> <span class="keyword">all</span>,<span class="keyword">except</span>,<span class="keyword">except</span> <span class="keyword">all</span>,<span class="keyword">unique</span>,<span class="keyword">check</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">in</span>,<span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line"></span><br><span class="line">primary <span class="keyword">key</span>,<span class="keyword">foreign</span> <span class="keyword">key</span>,<span class="keyword">not</span> <span class="literal">null</span>,<span class="keyword">default</span>,<span class="keyword">auto</span> <span class="keyword">increment</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">grant</span>,<span class="keyword">revoke</span></span><br></pre></td></tr></table></figure>

<h2 id="0x08、SQL语句"><a href="#0x08、SQL语句" class="headerlink" title="0x08、SQL语句"></a>0x08、SQL语句</h2><p>1.DDL和DML</p>
<ul>
<li>创建操作</li>
<li>权限操作<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">grant</span> &lt;权限列表&gt; <span class="keyword">on</span> &lt;关系名或视图&gt; <span class="keyword">to</span> &lt;用户或角色&gt;</span><br><span class="line"><span class="keyword">revoke</span> &lt;权限列表&gt; <span class="keyword">on</span> &lt;关系名或试图&gt; <span class="keyword">from</span> &lt;用户或角色&gt;</span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">all</span> <span class="keyword">privileges</span> <span class="keyword">on</span> *.* <span class="keyword">to</span> <span class="string">'root'</span>@<span class="string">'%'</span> identify <span class="keyword">by</span> <span class="string">"password"</span>;<span class="keyword">flush</span> <span class="keyword">privileges</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>2.DDL：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span>\<span class="keyword">table</span>\<span class="keyword">index</span>\<span class="keyword">function</span>\<span class="keyword">view</span>\processor\<span class="keyword">trigger</span>\<span class="keyword">user</span></span><br><span class="line"><span class="keyword">alter</span></span><br><span class="line"><span class="keyword">drop</span></span><br></pre></td></tr></table></figure>

<p>3.DML</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line"><span class="keyword">update</span></span><br><span class="line"><span class="keyword">delete</span></span><br><span class="line"><span class="keyword">insert</span></span><br></pre></td></tr></table></figure>

<p>4.between and:是包含两端的值<br>5.is null,is not null:不能用=或!=号<br>6.unknown:也是一种值，在参与运算时<br>7.嵌套子查询</p>
<ul>
<li>in,not in;=some等价于in,但!=some却不等价与not in;any;all</li>
<li>exists;not exists</li>
</ul>
<p>8.创建视图</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> &lt;查询表达式&gt;</span><br></pre></td></tr></table></figure>

<p>9.删除操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> r [<span class="keyword">where</span> p]</span><br></pre></td></tr></table></figure>

<p>10.插入操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> r[(row_name,...)] <span class="keyword">values</span>()</span><br></pre></td></tr></table></figure>

<p>11.更新操作</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> r <span class="keyword">set</span> q <span class="keyword">where</span> p</span><br></pre></td></tr></table></figure>

<p>12.创建新类型</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">type</span> Dollar <span class="keyword">as</span> numberic(<span class="number">12</span>,<span class="number">2</span>) <span class="keyword">final</span></span><br></pre></td></tr></table></figure>

<p>13.完整性约束</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">not null,<span class="keyword">check</span>,<span class="keyword">unique</span></span><br></pre></td></tr></table></figure>

<p>14.参照完整性</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">foreign key</span><br></pre></td></tr></table></figure>

<p>15.where中用in比用or效率更快<br>16.在已知返回函数时，添加limit<br>17.在sql语句执行时，进行解析、优化、执行、结果几个步骤<br>18.在做更新是，用id来标记更新，否则会全表扫描<br>19.desc table_name  查看表结构</p>
<h2 id="0x09、内置函数-聚集函数-：不能组合使用"><a href="#0x09、内置函数-聚集函数-：不能组合使用" class="headerlink" title="0x09、内置函数(聚集函数)：不能组合使用"></a>0x09、内置函数(聚集函数)：不能组合使用</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">max(),min(),count(),avg(),sum()</span><br><span class="line">now(),curdate(),datetime(),timestamp(),curtime(),year()</span><br><span class="line">concat()</span><br></pre></td></tr></table></figure>

<h2 id="0x10、基本类型"><a href="#0x10、基本类型" class="headerlink" title="0x10、基本类型"></a>0x10、基本类型</h2><p>1.int(-2,147,483,648–2,147,483,647,4字节),samllint(-32,768–32,767,2字节),tinyint(-128–127,1字节),unsigned,bigint(-9223372036854775808–9223372036854775807,8字节)<br>2.char,varchar<br>3.data,time,timestamp<br>4.double,float,numberic<br>5.tiny text,text,medium text,long text<br>6.blob,medium blob,long blob<br>7.enum,set</p>
<h2 id="0x11、匹配"><a href="#0x11、匹配" class="headerlink" title="0x11、匹配"></a>0x11、匹配</h2><ul>
<li>%：匹配任意</li>
<li>_：匹配任意一个字符</li>
</ul>
<h2 id="0x12、存储过程"><a href="#0x12、存储过程" class="headerlink" title="0x12、存储过程"></a>0x12、存储过程</h2><h2 id="0x13、索引"><a href="#0x13、索引" class="headerlink" title="0x13、索引"></a>0x13、索引</h2><p>1.最适合索引的是在where之后的<br>2.使用唯一索引<br>3.使用短索引<br>4.利用最左前缀<br>5.不要过度索引</p>
<h2 id="0x14、数据库设计问题"><a href="#0x14、数据库设计问题" class="headerlink" title="0x14、数据库设计问题"></a>0x14、数据库设计问题</h2><p>1.数据冗余与不一致<br>2.数据访问困难<br>3.数据孤立<br>4.并发访问异常·<br>5.安全性问题<br>    原则：<br>    1.完整性：完整性约束、参照完整性、断言、授权<br>    2.原子性<br>6.实体集、联系集、属性<br>7.区分实体集内实体的方法：主键<br>8.适度冗余—减少join使用（查询频繁，更新较少字段）<br>9.大字段垂直拆分—（summary表优化）：字段大，访问少<br>10.大表水平拆分—基于类型的分拆优化<br>11.优化数据类型<br>    #1.用更小的数据类型，减小存储空间和io资源<br>    #2.选择合适的数据库类型加速比较</p>
<p>12.规范的对象命名</p>
<h2 id="0x15、数据库设计步骤"><a href="#0x15、数据库设计步骤" class="headerlink" title="0x15、数据库设计步骤"></a>0x15、数据库设计步骤</h2><p>1.刻画未来数据库用户的需求：需求规格说明书<br>2.概念设计阶段：实体-联系模型图(确保数据需求都被满足，并且不互相冲突),重点是如何描述数据及其相互关系<br>3.功能需求规则说明书：确保设计模式满足功能需求<br>4.逻辑设计阶段<br>5.物理设计阶段</p>
<h2 id="0x16、mysql存储引擎"><a href="#0x16、mysql存储引擎" class="headerlink" title="0x16、mysql存储引擎"></a>0x16、mysql存储引擎</h2><p>1.Innodb:事务安全<br>2.Myisam：非事务安全</p>
<h2 id="0x17、事务-锁"><a href="#0x17、事务-锁" class="headerlink" title="0x17、事务/锁"></a>0x17、事务/锁</h2><p>1.在同一个事务中，最好不使用不同存储引擎的表<br>2.DDL语句不能回滚<br>3.锁定机制直接影响数据库的并发处理能力和性能</p>
<ul>
<li>1.三种锁：行级锁、页级锁和表级锁</li>
<li>2.行级锁：锁定粒度最小，支持并发量大，消耗资源多，容易发生死锁。有Innodb，，NDB Cluster存储引擎</li>
<li>3.页级锁：处于行级锁和表级锁之间。有BerkeleyDB存储引擎</li>
<li>4.表级锁：最大粒度锁，实现逻辑简单，负面影响小，获取和释放锁速度很快，极少死锁，并发量小。有Myisam，Memory，csv存储引擎<ul>
<li>1)分为读锁定和写锁定，通过四个队列来维护两种锁定：<ul>
<li>Current  read-lock queue</li>
<li>Pending  read-lock queue</li>
<li>Current  write-lock queue</li>
<li>Pending  write-lock queue</li>
</ul>
</li>
<li>2)读锁定：满足下面条件后会立即通过，如果任何一个没有满足，都会被迫进入等待队列<ul>
<li>1.请求锁定的资源当前没有被写锁定</li>
<li>2.写锁定等待队列（ Pending write-lock queue）中没有更高优先级的写锁定等待</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x18、备份-复制"><a href="#0x18、备份-复制" class="headerlink" title="0x18、备份/复制"></a>0x18、备份/复制</h2><p>1.逻辑备份</p>
<ul>
<li>1.用mysqldump导出sql文件</li>
<li>2.生成特定分割文件</li>
</ul>
<p>2.物理备份</p>
<ul>
<li>1.备份物理数据文件，日志文件及配置文件等</li>
</ul>
<h2 id="0x19、优化建议"><a href="#0x19、优化建议" class="headerlink" title="0x19、优化建议"></a>0x19、优化建议</h2><p>1.如果opened_tables太大,应该把my.cnf中的table_cache变大<br>2.如果Key_reads太大,则应该把my.cnf中key_buffer_size变大.可以用Key_reads/Key_read_requests计算出cache失败率<br>3.如果Handler_read_rnd太大,则你写的SQL语句里很多查询都是要扫描整个表,而没有发挥索引的键的作用<br>4.如果Threads_created太大,就要增加my.cnf中thread_cache_size的值.可以用Threads_created/Connections计算cache命中率<br>5.如果Created_tmp_disk_tables太大,就要增加my.cnf中tmp_table_size的值,用基于内存的临时表代替基于磁盘的</p>
<h2 id="0x20、information-schema表"><a href="#0x20、information-schema表" class="headerlink" title="0x20、information_schema表"></a>0x20、information_schema表</h2><ul>
<li><strong><code>CHARACTER_SETS</code></strong> — 关于字符集信息</li>
<li><strong><code>COLLATIONS</code></strong> — 关于每个字符集的（排序）规则信息</li>
<li><strong><code>COLLATION_CHARACTER_SET_APPLICABILITY</code></strong> — 关于字符集和每种（排序）规则的对应关系信息</li>
<li><strong><code>COLUMNS</code></strong> — 关于表中的列信息</li>
<li><strong><code>COLUMN_PRIVILEGES</code></strong> — 关于MySQL对应账号所有列权限信息</li>
<li><strong><code>ENGINES</code></strong> — 关于存储引擎的信息</li>
<li><strong><code>EVENTS</code></strong> — 关于计划事件信息</li>
<li><strong><code>FILES</code></strong> — 从7.8版本（未使用MySQL Cluster版本的情况下）开始，此表会显示关于InnoDB数据文件信息。早前的版本中此表都显示的是关于NDB数据文件的存储信息。</li>
<li><strong><code>GLOBAL_STATUS</code></strong> — 关于服务端状态信息，7.6版本之后此表开始将被存放在PERFORMANCE_SCHEMA数据库中</li>
<li><strong><code>GLOBAL_VARIABLES</code></strong> — 关于服务端全局变量信息，7.6版本之后此表开始将被存放在PERFORMANCE_SCHEMA数据库中</li>
<li><strong><code>KEY_COLUMN_USAGE</code></strong> — 关于含有约束的键值列信息</li>
<li><strong><code>OPTIMIZER_TRACE</code></strong> — 关于内部优化器执行语句的追踪信息，启用相应追踪功能需要启动设置optimizer_trace变量</li>
<li><strong><code>PARAMETERS</code></strong> — 提供关于存储过程和功能函数所使用的参数及功能函数返回值信息</li>
<li><strong><code>PLUGINS</code></strong> — 关于服务端插件信息</li>
<li><strong><code>PROCESSLIST</code></strong> — 关于正在运行的线程信息</li>
<li><strong><code>REFERENTIAL_CONSTRAINTS</code></strong> — 关于外键信息</li>
<li><strong><code>ROUTINES</code></strong> — 关于存储过程和功能函数的相关信息</li>
<li><strong><code>SCHEMATA</code></strong> — 关于数据库的信息</li>
<li><strong><code>SCHEMA_PRIVILEGES</code></strong> — 关于MySQL用户账号所有的数据库权限</li>
<li><strong><code>SESSION_STATUS</code></strong> — 关于当前连接的状态信息，7.6版本之后此表开始将被存放在PERFORMANCE_SCHEMA数据库中</li>
<li><strong><code>SESSION_VARIABLES</code></strong> — 关于当前连接的会话变量信息，7.6版本之后此表开始将被存放在PERFORMANCE_SCHEMA数据库中</li>
<li><strong><code>STATISTICS</code></strong> – 关于表索引的统计信息</li>
<li><strong><code>TABLES</code></strong> — 关于数据库中表的信息</li>
<li><strong><code>TABLESPACES</code></strong> — 提供了活动的表空间的信息，注意此表不提供关于InnoDB表空间的元数据信息，你需要去INNODB_SYS_TABLESPACES和INNODB_SYS_DATAFILES下查看，当然MySQL 5.7.8以后，FILES表也提供了InnoDB表空间相关的元数据信息。</li>
<li><strong><code>TABLE_CONSTRAINTS</code></strong> — 关于表上的约束信息</li>
<li><strong><code>TABLE_PRIVILEGES</code></strong> — 关于由MySQL用户账号所有的对应表权限信息</li>
<li><strong><code>TRIGGERS</code></strong> — 关于数据库中触发器信息</li>
<li><strong><code>USER_PRIVILEGES</code></strong> — 关于MySQL用户账号所有的全局性的权限信息</li>
<li><strong><code>VIEWS</code></strong> — 关于数据库中视图信息</li>
<li><strong><code>INNODB_XXXX表</code></strong> — 这些表被用于监控正在进行的InnoDB活动，可以用于在出现问题前探测到这些低效的性能及承载问题。</li>
</ul>
<h2 id="0x21、配置参数-show-variables"><a href="#0x21、配置参数-show-variables" class="headerlink" title="0x21、配置参数:show variables;"></a>0x21、配置参数:show variables;</h2><p>auto_increment_increment:自增长键的步长<br>auto_increment_offset:自增长键的起始值<br>autocommit:<br>automatic_sp_privileges:<br>back_log:指定MySQL可能的连接数量。指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。不同的操作系统在这个队列大小上有它自己的限制。 试图设定back_log高于你的操作系统的限制将是无效的。<br>basedir:MySQL主程序所在路径，即：–basedir参数的值。<br>big_tables:<br>bind_address:<br>binlog_cache_size:<br>binlog_checksum, CRC32<br>binlog_direct_non_transactional_updates<br>binlog_format, STATEMENT<br>binlog_max_flush_queue_time<br>binlog_order_commits, ON<br>binlog_row_image, FULL<br>binlog_rows_query_log_events<br>binlog_stmt_cache_size, 32768<br>block_encryption_mode, aes-128-ecb<br>bulk_insert_buffer_size, 8388608<br>character_set_client, utf8<br>character_set_connection, utf8<br>character_set_database, utf8<br>character_set_filesystem, binary<br>character_set_results, utf8<br>character_set_server, latin1<br>character_set_system：指定系统字符类型 utf8<br>character_sets_dir:指定字符集路径，如： f:\wamp\bin\mysql\mysql5.6.17\share\charsets<br>collation_connection, utf8_general_ci<br>collation_database, utf8_general_ci<br>collation_server, latin1_swedish_ci<br>completion_type, NO_CHAIN<br>concurrent_insert：如果开启该参数，MySQL则允许在执行 SELECT 操作的同时进行 INSERT 操作。如果要关闭该参数，可以在启动 mysqld 时加载 –safe 选项，或者使用 –skip-new 选项。默认为： AUTO<br>connect_timeout：指定MySQL服务等待应答一个连接报文的最大秒数，超出该时间，MySQL向客户端返回 bad handshake。默认为10<br>core_file<br>datadir：指定数据库路径。即为 –datadir 选项的值，如： f:\wamp\bin\mysql\mysql5.6.17\data<br>date_format, %Y-%m-%d<br>datetime_format, %Y-%m-%d %H:%i:%s<br>default_storage_engine, InnoDB<br>default_tmp_storage_engine, InnoDB<br>default_week_format<br>delay_key_write：该参数只对 MyISAM 类型数据表有效。有如下的取值种类：<br>    off: 如果在建表语句中使用 CREATE TABLE … DELAYED_KEY_WRITES，则全部忽略DELAYED_KEY_WRITES;<br>    on: 如果在建表语句中使用 CREATE TABLE … DELAYED_KEY_WRITES，则使用该选项(默认);<br>    all: 所有打开的数据表都将按照 DELAYED_KEY_WRITES 处理。<br>    如果 DELAYED_KEY_WRITES 开启，对于已经打开的数据表而言，在每次索引更新时都不刷新带有<br>    DELAYED_KEY_WRITES 选项的数据表的key buffer，除非该数据表关闭。该参数会大幅提升写入键值的速<br>    度。如果使用该参数，则应该检查所有数据表：myisamchk –fast –force 。默认为ON<br>delayed_insert_limit：在插入delayed_insert_limit行后，INSERT DELAYED处理模块将检查是否有未执行的SELECT语句。如果有，在继续处理前执行允许这些语句。默认为 100<br>delayed_insert_timeout：一个INSERT DELAYED线程应该在终止之前等待INSERT语句的时间。默认为300<br>delayed_queue_size：为处理INSERT DELAYED分配的队列大小(以行为单位)。如果排队满了，任何进行INSERT DELAYED的客户必须等待队列空间释放后才能继续。默认为1000<br>disconnect_on_expired_password, ON<br>div_precision_increment, 4<br>end_markers_in_json<br>enforce_gtid_consistency<br>eq_range_index_dive_limit, 10<br>error_count<br>event_scheduler<br>expire_logs_days<br>explicit_defaults_for_timestamp, ON<br>external_user,<br>flush：在启动MySQL时加载 –flush 参数打开该功能。默认为 OFF<br>flush_time：如果该设置为非0值，那么每flush_time秒，所有打开的表将被关，以释放资源和sync到磁盘。注意：只建议在使用 Windows9x/Me 或者当前操作系统资源严重不足时才使用该参数!默认为 0<br>foreign_key_checks， ON<br>ft_boolean_syntax：搜索引擎维护员希望更改允许用于逻辑全文搜索的操作符。这些则由变量 ft_boolean_syntax 控制。默认为 + -&gt;&lt;()~*:””&amp;|<br>ft_max_word_len：指定被索引的关键词的最大长度。注意：在更改该参数值后，索引必须重建! 默认为84<br>ft_min_word_len：指定被索引的关键词的最小长度。注意：在更改该参数值后，索引必须重建! 默认为4<br>ft_query_expansion_limit, 20<br>ft_stopword_file：从 ft_stopword_file 变量指定的文件中读取列表。在修改了 stopword 列表后，必须重建 FULLTEXT 索引。默认为 (built-in)<br>general_log<br>general_log_file, f:\wamp\bin\mysql\mysql5.6.17\data\zxc-PC.log<br>group_concat_max_len, 1024<br>gtid_executed,<br>gtid_mode<br>gtid_next, AUTOMATIC<br>gtid_owned,<br>gtid_purged,<br>have_compress, YES<br>have_crypt, NO<br>have_dynamic_loading, YES<br>have_geometry, YES<br>have_openssl：YES， 使MySQL支持SSL加密协议。 DISABLED，则不支持<br>have_profiling, YES<br>have_query_cache, YES<br>have_rtree_keys, YES<br>have_ssl, DISABLED<br>have_symlink, YES<br>host_cache_size, 279<br>hostname, zxc-PC<br>identity<br>ignore_builtin_innodb<br>ignore_db_dirs,<br>init_connect,<br>init_file：指定一个包含SQL查询语句的文件，该文件在MySQL启动时将被加载，文件中的SQL语句也会被执行。<br>init_slave,<br>innodb_adaptive_flushing, ON<br>innodb_adaptive_flushing_lwm, 10<br>innodb_adaptive_hash_index, ON<br>innodb_adaptive_max_sleep_delay, 150000<br>innodb_additional_mem_pool_size, 8388608<br>innodb_api_bk_commit_interval, 5<br>innodb_api_disable_rowlock<br>innodb_api_enable_binlog<br>innodb_api_enable_mdl<br>innodb_api_trx_level<br>innodb_autoextend_increment, 64<br>innodb_autoinc_lock_mode, 1<br>innodb_buffer_pool_dump_at_shutdown<br>innodb_buffer_pool_dump_now<br>innodb_buffer_pool_filename, ib_buffer_pool<br>innodb_buffer_pool_instances, 8<br>innodb_buffer_pool_load_abort<br>innodb_buffer_pool_load_at_startup<br>innodb_buffer_pool_load_now<br>innodb_buffer_pool_size, 134217728<br>innodb_change_buffer_max_size, 25<br>innodb_change_buffering, all<br>innodb_checksum_algorithm, innodb<br>innodb_checksums, ON<br>innodb_cmp_per_index_enabled<br>innodb_commit_concurrency<br>innodb_compression_failure_threshold_pct, 5<br>innodb_compression_level, 6<br>innodb_compression_pad_pct_max, 50<br>innodb_concurrency_tickets, 5000<br>innodb_data_file_path, ibdata1:12M:autoextend<br>innodb_data_home_dir,<br>innodb_disable_sort_file_cache<br>innodb_doublewrite, ON<br>innodb_fast_shutdown, 1<br>innodb_file_format, Antelope<br>innodb_file_format_check, ON<br>innodb_file_format_max, Antelope<br>innodb_file_per_table, ON<br>innodb_flush_log_at_timeout, 1<br>innodb_flush_log_at_trx_commit, 1<br>innodb_flush_method,<br>innodb_flush_neighbors, 1<br>innodb_flushing_avg_loops, 30<br>innodb_force_load_corrupted<br>innodb_force_recovery<br>innodb_ft_aux_table,<br>innodb_ft_cache_size, 8000000<br>innodb_ft_enable_diag_print<br>innodb_ft_enable_stopword, ON<br>innodb_ft_max_token_size, 84<br>innodb_ft_min_token_size, 3<br>innodb_ft_num_word_optimize, 2000<br>innodb_ft_result_cache_limit, 2000000000<br>innodb_ft_server_stopword_table,<br>innodb_ft_sort_pll_degree, 2<br>innodb_ft_total_cache_size, 640000000<br>innodb_ft_user_stopword_table,<br>innodb_io_capacity, 200<br>innodb_io_capacity_max, 2000<br>innodb_large_prefix<br>innodb_lock_wait_timeout, 50<br>innodb_locks_unsafe_for_binlog<br>innodb_log_buffer_size, 8388608<br>innodb_log_compressed_pages, ON<br>innodb_log_file_size, 50331648<br>innodb_log_files_in_group, 2<br>innodb_log_group_home_dir, .<br>innodb_lru_scan_depth, 1024<br>innodb_max_dirty_pages_pct, 75<br>innodb_max_dirty_pages_pct_lwm<br>innodb_max_purge_lag<br>innodb_max_purge_lag_delay<br>innodb_mirrored_log_groups, 1<br>innodb_monitor_disable,<br>innodb_monitor_enable,<br>innodb_monitor_reset,<br>innodb_monitor_reset_all,<br>innodb_old_blocks_pct, 37<br>innodb_old_blocks_time, 1000<br>innodb_online_alter_log_max_size, 134217728<br>innodb_open_files, 2000<br>innodb_optimize_fulltext_only<br>innodb_page_size, 16384<br>innodb_print_all_deadlocks<br>innodb_purge_batch_size, 300<br>innodb_purge_threads, 1<br>innodb_random_read_ahead<br>innodb_read_ahead_threshold, 56<br>innodb_read_io_threads, 4<br>innodb_read_only<br>innodb_replication_delay<br>innodb_rollback_on_timeout<br>innodb_rollback_segments, 128<br>innodb_sort_buffer_size, 1048576<br>innodb_spin_wait_delay, 6<br>innodb_stats_auto_recalc, ON<br>innodb_stats_method, nulls_equal<br>innodb_stats_on_metadata<br>innodb_stats_persistent, ON<br>innodb_stats_persistent_sample_pages, 20<br>innodb_stats_sample_pages, 8<br>innodb_stats_transient_sample_pages, 8<br>innodb_status_output<br>innodb_status_output_locks<br>innodb_strict_mode<br>innodb_support_xa, ON<br>innodb_sync_array_size, 1<br>innodb_sync_spin_loops, 30<br>innodb_table_locks, ON<br>innodb_thread_concurrency<br>innodb_thread_sleep_delay, 10000<br>innodb_undo_directory, .<br>innodb_undo_logs, 128<br>innodb_undo_tablespaces<br>innodb_use_native_aio, ON<br>innodb_use_sys_malloc, ON<br>innodb_version, 5.6.17<br>innodb_write_io_threads, 4<br>insert_id<br>interactive_timeout：服务器在关上它前在一个交互连接上等待行动的秒数。一个交互的客户被定义为对mysql_real_connect()使用CLIENT_INTERACTIVE选项的客户。也可见wait_timeout。默认为 28800<br>join_buffer_size：用于全部联合(join)的缓冲区大小(不是用索引的联结)。缓冲区对2个表间的每个全部联结分配一次缓冲区，当增加索引不可能时，增加该值可得到一个更快的全部联结。(通常得到快速联结的最佳方法是增加索引。)默认为 262144<br>keep_files_on_create<br>key_buffer_size：用于索引块的缓冲区大小，增加它可得到更好处理的索引(对所有读和多重写)，到你能负担得起那样多。如果你使它太大，系统将开始变慢慢。必须为OS文件系统缓存留下一些空间。为了在写入多个行时得到更多的速度。默认为 8388608<br>key_cache_age_threshold, 300<br>key_cache_block_size, 1024<br>key_cache_division_limit, 100<br>large_files_support：开启大文件支持。默认为 ON<br>large_page_size<br>large_pages<br>last_insert_id<br>lc_messages, en_US<br>lc_messages_dir, f:\wamp\bin\mysql\mysql5.6.17\share<br>lc_time_names, en_US<br>license, GPL<br>local_infile, ON<br>lock_wait_timeout, 31536000<br>log_bin：开启 binary log。默认为 OFF<br>log_bin_basename,<br>log_bin_index,<br>log_bin_trust_function_creators<br>log_bin_use_v1_row_events<br>log_error, f:\wamp\bin\mysql\mysql5.6.17\data\zxc-PC.err<br>log_output, FILE<br>log_queries_not_using_indexes<br>log_slave_updates：如果使用链状同步或者多台Slave之间进行同步则需要开启此参数。默认为 OFF<br>log_slow_admin_statements<br>log_slow_slave_statements<br>log_throttle_queries_not_using_indexes<br>log_warnings, 1<br>long_query_time：如果一个查询所用时间超过该参数值，则该查询操作将被记录在Slow_queries中。默认为 10.000000<br>low_priority_updates<br>lower_case_file_system, ON<br>lower_case_table_names：1: MySQL总使用小写字母进行SQL操作;0: 关闭该功能。默认为 1<br>master_info_repository, FILE<br>master_verify_checksum<br>max_allowed_packet：一个查询语句包的最大尺寸。消息缓冲区被初始化为net_buffer_length字节，但是可在需要时增加到max_allowed_packet个字节。该值太小则会在处理大包时产生错误。如果使用大的BLOB列，必须增加该值。默认为 4194304<br>max_binlog_cache_size：指定binary log缓存的最大容量，如果设置的过小，则在执行复杂查询语句时MySQL会出错。默认为 18446744073709547520<br>max_binlog_size：指定binary log文件的最大容量。默认为 1073741824<br>max_binlog_stmt_cache_size, 18446744073709547520<br>max_connect_errors：对于同一主机，如果有超出该参数值个数的中断错误连接，则该主机将被禁止连接。如需对该主机进行解禁，执行：FLUSH HOST。默认为 100<br>max_connections：允许同时连接MySQL服务器的客户数量。如果超出该值，MySQL会返回Too many connections错误，但通常情况下，MySQL能够自行解决。默认为 151<br>max_delayed_threads：不要启动多于的这个数字的线程来处理INSERT DELAYED语句。如果你试图在所有INSERT DELAYED线程在用后向一张新表插入数据，行将被插入，就像DELAYED属性没被指定那样。默认为 20<br>max_error_count, 64<br>max_heap_table_size：内存表所能使用的最大容量。默认为 16777216<br>max_insert_delayed_threads, 20<br>max_join_size：如果要查询多于max_join_size个记录的联合将返回一个错误。如果要执行没有一个WHERE的语句并且耗费大量时间，且返回上百万行的联结，则需要加大该参数值。默认为 18446744073709551615<br>max_length_for_sort_data, 1024<br>max_prepared_stmt_count, 16382<br>max_relay_log_size<br>max_seeks_for_key, 4294967295<br>max_sort_length：在排序BLOB或TEXT值时使用的字节数(每个值仅头max_sort_length个字节被使用;其余的被忽略)。默认为 1024<br>max_sp_recursion_depth<br>max_tmp_tables：(该参数目前还没有作用)。一个客户能同时保持打开的临时表的最大数量。默认为 32<br>max_user_connections：指定来自同一用户的最多连接数。设置为0则代表不限制。默认为 0<br>max_write_lock_count：当出现max_write_lock_count个写入锁定数量后，开始允许一些被锁定的读操作开始执行。避免写入锁定过多，读取操作处于长时间等待状态。默认为 4294967295<br>metadata_locks_cache_size, 1024<br>metadata_locks_hash_instances, 8<br>min_examined_row_limit<br>multi_range_count, 256<br>myisam_data_pointer_size, 6<br>myisam_max_sort_file_size, 2146435072<br>myisam_mmap_size, 18446744073709551615<br>myisam_recover_options<br>myisam_repair_threads, 1<br>myisam_sort_buffer_size, 8388608<br>myisam_stats_method, nulls_unequal<br>myisam_use_mmap<br>named_pipe<br>net_buffer_length, 16384<br>net_read_timeout, 30<br>net_retry_count, 10<br>net_write_timeout, 60<br>new<br>old<br>old_alter_table<br>old_passwords<br>open_files_limit, 7048<br>optimizer_prune_level, 1<br>optimizer_search_depth, 62<br>optimizer_switch, index_merge=on,index_merge_union=on,index_merge_sort_union=on,index_merge_intersection=on,engine_condition_pushdown=on,index_condition_pushdown=on,mrr=on,mrr_cost_based=on,block_nested_loop=on,batched_key_access=off,materialization=on,semijoin=on,loosescan=on,firstmatch=on,subquery_materialization_cost_based=on,use_index_extensions=on<br>optimizer_trace, enabled=off,one_line=off<br>optimizer_trace_features, greedy_search=on,range_optimizer=on,dynamic_range=on,repeated_subselect=on<br>optimizer_trace_limit, 1<br>optimizer_trace_max_mem_size, 16384<br>optimizer_trace_offset, -1<br>performance_schema, ON<br>performance_schema_accounts_size, 100<br>performance_schema_digests_size, 10000<br>performance_schema_events_stages_history_long_size, 10000<br>performance_schema_events_stages_history_size, 10<br>performance_schema_events_statements_history_long_size, 10000<br>performance_schema_events_statements_history_size, 10<br>performance_schema_events_waits_history_long_size, 10000<br>performance_schema_events_waits_history_size, 10<br>performance_schema_hosts_size, 100<br>performance_schema_max_cond_classes, 80<br>performance_schema_max_cond_instances, 3504<br>performance_schema_max_file_classes, 50<br>performance_schema_max_file_handles, 32768<br>performance_schema_max_file_instances, 7693<br>performance_schema_max_mutex_classes, 200<br>performance_schema_max_mutex_instances, 15906<br>performance_schema_max_rwlock_classes, 40<br>performance_schema_max_rwlock_instances, 9102<br>performance_schema_max_socket_classes, 10<br>performance_schema_max_socket_instances, 322<br>performance_schema_max_stage_classes, 150<br>performance_schema_max_statement_classes, 168<br>performance_schema_max_table_handles, 4000<br>performance_schema_max_table_instances, 12500<br>performance_schema_max_thread_classes, 50<br>performance_schema_max_thread_instances, 402<br>performance_schema_session_connect_attrs_size, 512<br>performance_schema_setup_actors_size, 100<br>performance_schema_setup_objects_size, 100<br>performance_schema_users_size, 100<br>pid_file, f:\wamp\bin\mysql\mysql5.6.17\data\zxc-PC.pid<br>plugin_dir, f:\wamp\bin\mysql\mysql5.6.17\lib\plugin<br>port, 3306<br>preload_buffer_size, 32768<br>profiling<br>profiling_history_size, 15<br>protocol_version, 10<br>proxy_user,<br>pseudo_slave_mode<br>pseudo_thread_id, 2<br>query_alloc_block_size, 8192<br>query_cache_limit, 1048576<br>query_cache_min_res_unit, 4096<br>query_cache_size, 1048576<br>query_cache_type<br>query_cache_wlock_invalidate<br>query_prealloc_size, 8192<br>rand_seed1<br>rand_seed2<br>range_alloc_block_size, 4096<br>read_buffer_size, 131072<br>read_only<br>read_rnd_buffer_size, 262144<br>relay_log,<br>relay_log_basename,<br>relay_log_index,<br>relay_log_info_file, relay-log.info<br>relay_log_info_repository, FILE<br>relay_log_purge, ON<br>relay_log_recovery<br>relay_log_space_limit<br>report_host,<br>report_password,<br>report_port, 3306<br>report_user,<br>rpl_stop_slave_timeout, 31536000<br>secure_auth, ON<br>secure_file_priv,<br>server_id<br>server_id_bits, 32<br>server_uuid, 5c0971e1-3985-11e5-849c-dc0ea17af70f<br>shared_memory<br>shared_memory_base_name, MYSQL<br>skip_external_locking, ON<br>skip_name_resolve<br>skip_networking<br>skip_show_database<br>slave_allow_batching<br>slave_checkpoint_group, 512<br>slave_checkpoint_period, 300<br>slave_compressed_protocol<br>slave_exec_mode, STRICT<br>slave_load_tmpdir, C:\WINDOWS\TEMP<br>slave_max_allowed_packet, 1073741824<br>slave_net_timeout, 3600<br>slave_parallel_workers<br>slave_pending_jobs_size_max, 16777216<br>slave_rows_search_algorithms, TABLE_SCAN,INDEX_SCAN<br>slave_skip_errors<br>slave_sql_verify_checksum, ON<br>slave_transaction_retries, 10<br>slave_type_conversions,<br>slow_launch_time, 2<br>slow_query_log<br>slow_query_log_file, f:\wamp\bin\mysql\mysql5.6.17\data\zxc-PC-slow.log<br>socket, MySQL<br>sort_buffer_size, 262144<br>sql_auto_is_null<br>sql_big_selects, ON<br>sql_buffer_result<br>sql_log_bin, ON<br>sql_log_off<br>sql_mode, NO_ENGINE_SUBSTITUTION<br>sql_notes, ON<br>sql_quote_show_create, ON<br>sql_safe_updates, ON<br>sql_select_limit, 18446744073709551615<br>sql_slave_skip_counter<br>sql_warnings<br>ssl_ca,<br>ssl_capath,<br>ssl_cert,<br>ssl_cipher,<br>ssl_crl,<br>ssl_crlpath,<br>ssl_key,<br>storage_engine, InnoDB<br>stored_program_cache, 256<br>sync_binlog<br>sync_frm, ON<br>sync_master_info, 10000<br>sync_relay_log, 10000<br>sync_relay_log_info, 10000<br>system_time_zone,<br>table_definition_cache, 1400<br>table_open_cache, 2000<br>table_open_cache_instances, 1<br>thread_cache_size, 9<br>thread_concurrency, 10<br>thread_handling, one-thread-per-connection<br>thread_stack, 262144<br>time_format, %H:%i:%s<br>time_zone, SYSTEM<br>timed_mutexes<br>timestamp, 1449802723.239825<br>tmp_table_size, 16777216<br>tmpdir, C:\WINDOWS\TEMP<br>transaction_alloc_block_size, 8192<br>transaction_allow_batching<br>transaction_prealloc_size, 4096<br>tx_isolation, REPEATABLE-READ<br>tx_read_only<br>unique_checks, ON<br>updatable_views_with_limit, YES<br>version, 5.6.17<br>version_comment, MySQL Community Server (GPL)<br>version_compile_machine, x86_64<br>version_compile_os, Win64<br>wait_timeout, 28800<br>warning_count, 1</p>
<h2 id="0x22、性能指标-show-status"><a href="#0x22、性能指标-show-status" class="headerlink" title="0x22、性能指标:show status;"></a>0x22、性能指标:show status;</h2><p>  Aborted_clients：由于客户端没有正确关闭连接导致客户端终止而中断的连接数。global<br>  Aborted_connects:试图连接到MySQL服务器而失败的连接数。global<br>  Binlog_cache_disk_use:使用临时二进制日志缓存但超过binlog_cache_size值并使用临时文件来保存事务中的语句的事务数量.global<br>  Binlog_cache_use:使用临时二进制日志缓存的事务数量.global<br>  Binlog_stmt_cache_disk_use:<br>  Binlog_stmt_cache_use:<br>  Bytes_received:从所有客户端接收到的字节数。both<br>  Bytes_sent:发送给所有客户端的字节数。both<br>  Com_admin_commands:<br>  Com_alter_db:<br>  Com_alter_db_upgrade:<br>  Com_alter_event:<br>  Com_alter_function:<br>  Com_alter_procedure<br>  Com_alter_server<br>  Com_alter_table<br>  Com_alter_tablespace<br>  Com_alter_user<br>  Com_analyze<br>  Com_assign_to_keycache<br>  Com_begin<br>  Com_binlog<br>  Com_call_procedure<br>  Com_change_db, 1<br>  Com_change_master<br>  Com_check<br>  Com_checksum<br>  Com_commit<br>  Com_create_db<br>  Com_create_event<br>  Com_create_function<br>  Com_create_index<br>  Com_create_procedure<br>  Com_create_server<br>  Com_create_table<br>  Com_create_trigger<br>  Com_create_udf<br>  Com_create_user<br>  Com_create_view<br>  Com_dealloc_sql<br>  Com_delete<br>  Com_delete_multi<br>  Com_do<br>  Com_drop_db<br>  Com_drop_event<br>  Com_drop_function<br>  Com_drop_index<br>  Com_drop_procedure<br>  Com_drop_server<br>  Com_drop_table<br>  Com_drop_trigger<br>  Com_drop_user<br>  Com_drop_view<br>  Com_empty_query<br>  Com_execute_sql<br>  Com_flush<br>  Com_get_diagnostics<br>  Com_grant<br>  Com_ha_close<br>  Com_ha_open<br>  Com_ha_read<br>  Com_help<br>  Com_insert<br>  Com_insert_select<br>  Com_install_plugin<br>  Com_kill<br>  Com_load<br>  Com_lock_tables<br>  Com_optimize<br>  Com_preload_keys<br>  Com_prepare_sql<br>  Com_purge<br>  Com_purge_before_date<br>  Com_release_savepoint<br>  Com_rename_table<br>  Com_rename_user<br>  Com_repair<br>  Com_replace<br>  Com_replace_select<br>  Com_reset<br>  Com_resignal<br>  Com_revoke<br>  Com_revoke_all<br>  Com_rollback<br>  Com_rollback_to_savepoint<br>  Com_savepoint<br>  Com_select, 3<br>  Com_set_option, 6<br>  Com_show_binlog_events<br>  Com_show_binlogs<br>  Com_show_charsets<br>  Com_show_collations<br>  Com_show_create_db<br>  Com_show_create_event<br>  Com_show_create_func<br>  Com_show_create_proc<br>  Com_show_create_table<br>  Com_show_create_trigger<br>  Com_show_databases<br>  Com_show_engine_logs<br>  Com_show_engine_mutex<br>  Com_show_engine_status<br>  Com_show_errors<br>  Com_show_events<br>  Com_show_fields<br>  Com_show_function_code<br>  Com_show_function_status<br>  Com_show_grants<br>  Com_show_keys<br>  Com_show_master_status<br>  Com_show_open_tables<br>  Com_show_plugins<br>  Com_show_privileges<br>  Com_show_procedure_code<br>  Com_show_procedure_status<br>  Com_show_processlist<br>  Com_show_profile<br>  Com_show_profiles<br>  Com_show_relaylog_events<br>  Com_show_slave_hosts<br>  Com_show_slave_status<br>  Com_show_status, 2<br>  Com_show_storage_engines<br>  Com_show_table_status<br>  Com_show_tables<br>  Com_show_triggers<br>  Com_show_variables, 6<br>  Com_show_warnings<br>  Com_signal<br>  Com_slave_start<br>  Com_slave_stop<br>  Com_stmt_close<br>  Com_stmt_execute<br>  Com_stmt_fetch<br>  Com_stmt_prepare<br>  Com_stmt_reprepare<br>  Com_stmt_reset<br>  Com_stmt_send_long_data<br>  Com_truncate<br>  Com_uninstall_plugin<br>  Com_unlock_tables<br>  Com_update<br>  Com_update_multi<br>  Com_xa_commit<br>  Com_xa_end<br>  Com_xa_prepare<br>  Com_xa_recover<br>  Com_xa_rollback<br>  Com_xa_start<br>  Compression<br>  Connection_errors_accept<br>  Connection_errors_internal<br>  Connection_errors_max_connections<br>  Connection_errors_peer_address<br>  Connection_errors_select<br>  Connection_errors_tcpwrap<br>  Connections:试图连接到(不管是否成功)MySQL服务器的连接数.global<br>  Created_tmp_disk_tables:服务器执行语句时在硬盘上自动创建的临时表的数量.both<br>  Created_tmp_files:mysqld已经创建的临时文件的数量.global<br>  Created_tmp_tables:服务器执行语句时自动创建的内存中的临时表的数量。如果Created_tmp_disk_tables较大，你可能要增加tmp_table_size值使临时 表基于内存而不基于硬盘.both<br>  Delayed_errors:用INSERT DELAYED写的出现错误的行数(可能为duplicate key)。global<br>  Delayed_insert_threads:使用的INSERT DELAYED处理器线程数.global<br>  Delayed_writes:写入的INSERT DELAYED行数.global<br>  Flush_commands:执行的FLUSH语句数.global<br>  Handler_commit:内部提交语句数.both<br>  Handler_delete:行从表中删除的次数.both<br>  Handler_discover:MySQL服务器可以问NDB CLUSTER存储引擎是否知道某一名字的表。这被称作发现。Handler_discover说明通过该方法发现的次数。both<br>  Handler_external_lock:<br>  Handler_mrr_init:<br>  Handler_prepare:A counter for the prepare phase of two-phase commit operations.both<br>  Handler_read_first:索引中第一条被读的次数。如果较高，它建议服务器正执行大量全索引扫描；例如，SELECT col1 FROM foo，假定col1有索引。both<br>  Handler_read_key:根据键读一行的请求数。如果较高，说明查询和表的索引正确。both<br>  Handler_read_last:<br>  Handler_read_next:按照键顺序读下一行的请求数。如果你用范围约束或如果执行索引扫描来查询索引列，该值增加.both<br>  Handler_read_prev:按照键顺序读前一行的请求数。该读方法主要用于优化ORDER BY … DESC.both<br>  Handler_read_rnd:根据固定位置读一行的请求数。如果你正执行大量查询并需要对结果进行排序该值较高。你可能使用了大量需要MySQL扫描整个表的查询或你的连接没有正确使用键.both<br>  Handler_read_rnd_next:在数据文件中读下一行的请求数。如果你正进行大量的表扫描，该值较高。通常说明你的表索引不正确或写入的查询没有利用索引。both<br>  Handler_rollback:内部ROLLBACK语句的数量.both<br>  Handler_savepoint:在一个存储引擎放置一个保存点的请求数量。both<br>  Handler_savepoint_rollback:在一个存储引擎的要求回滚到一个保存点数目。both<br>  Handler_update:在表内更新一行的请求数。both<br>  Handler_write:在表内插入一行的请求数。both<br>  Innodb_available_undo_logs:<br>  Innodb_buffer_pool_bytes_data:<br>  Innodb_buffer_pool_bytes_dirty<br>  Innodb_buffer_pool_dump_status, not started<br>  Innodb_buffer_pool_load_status, not started<br>  Innodb_buffer_pool_pages_data:包含数据的页数(脏或干净)。global<br>  Innodb_buffer_pool_pages_dirty:当前的脏页数。global<br>  Innodb_buffer_pool_pages_flushed:要求清空的缓冲池页数.global<br>  Innodb_buffer_pool_pages_free:空页数。global<br>  Innodb_buffer_pool_pages_misc:忙的页数，因为它们已经被分配优先用作管理，例如行锁定或适用的哈希索引。该值还可以计算为Innodb_buffer_pool_pages_total – Innodb_buffer_pool_pages_free – Innodb_buffer_pool_pages_data。global<br>  Innodb_buffer_pool_pages_total:缓冲池总大小（页数）。global<br>  Innodb_buffer_pool_read_ahead:<br>  Innodb_buffer_pool_read_ahead_evicted<br>  Innodb_buffer_pool_read_ahead_rnd:InnoDB初始化的“随机”read-aheads数。当查询以随机顺序扫描表的一大部分时发生。global<br>  Innodb_buffer_pool_read_requests:InnoDB已经完成的逻辑读请求数。global<br>  Innodb_buffer_pool_reads:不能满足InnoDB必须单页读取的缓冲池中的逻辑读数量。global<br>  Innodb_buffer_pool_wait_free:一般情况，通过后台向InnoDB缓冲池写。但是，如果需要读或创建页，并且没有干净的页可用，则它还需要先等待页面清空。该计数器对等待实例进行记数。如果已经适当设置缓冲池大小，该值应小。global<br>  Innodb_buffer_pool_write_requests:向InnoDB缓冲池的写数量。global<br>  Innodb_data_fsyncs:fsync()操作数。global<br>  Innodb_data_pending_fsyncs:当前挂起的fsync()操作数。global<br>  Innodb_data_pending_reads:当前挂起的读数。global<br>  Innodb_data_pending_writes:当前挂起的写数。global<br>  Innodb_data_read:    至此已经读取的数据数量（字节）。global<br>  Innodb_data_reads:数据读总数量。global<br>  Innodb_data_writes:数据读写数量。global<br>  Innodb_data_written:至此已经写入的数据量（字节）。global<br>  Innodb_dblwr_pages_written:已经执行的双写操作数量.global<br>  Innodb_dblwr_writes:双写操作已经写好的页数.global<br>  Innodb_have_atomic_builtins:<br>  Innodb_log_waits<br>  Innodb_log_write_requests:日志写请求数。global<br>  Innodb_log_writes:向日志文件的物理写数量。global<br>  Innodb_num_open_files:<br>  Innodb_os_log_fsyncs:向日志文件完成的fsync()写数量。global<br>  Innodb_os_log_pending_fsyncs:挂起的日志文件fsync()操作数量。global<br>  Innodb_os_log_pending_writes:挂起的日志文件写操作.global<br>  Innodb_os_log_written:写入日志文件的字节数。global<br>  Innodb_page_size:编译的InnoDB页大小(默认16KB)。许多值用页来记数；页的大小很容易转换为字节。global<br>  Innodb_pages_created:创建的页数。global<br>  Innodb_pages_read:读取的页数。global<br>  Innodb_pages_written:写入的页数。global<br>  Innodb_row_lock_current_waits:当前等待的待锁定的行数。global<br>  Innodb_row_lock_time:行锁定花费的总时间，单位毫秒。global<br>  Innodb_row_lock_time_avg:    行锁定的平均时间，单位毫秒。global<br>  Innodb_row_lock_time_max:行锁定的最长时间，单位毫秒。global<br>  Innodb_row_lock_waits:一行锁定必须等待的时间数。global<br>  Innodb_rows_deleted:从InnoDB表删除的行数。global<br>  Innodb_rows_inserted:插入到InnoDB表的行数。global<br>  Innodb_rows_read:    从InnoDB表读取的行数。global<br>  Innodb_rows_updated:    InnoDB表内更新的行数。global<br>  Innodb_truncated_status_writes:<br>  Key_blocks_not_flushed:键缓存内已经更改但还没有清空到硬盘上的键的数据块数量。global<br>  Key_blocks_unused:键缓存内未使用的块数量。你可以使用该值来确定使用了多少键缓存.global<br>  Key_blocks_used:键缓存内使用的块数量。该值为高水平线标记，说明已经同时最多使用了多少块。global<br>  Key_read_requests:从缓存读键的数据块的请求数。global<br>  Key_reads:从硬盘读取键的数据块的次数。如果Key_reads较大，则Key_buffer_size值可能太小。可以用Key_reads/Key_read_requests计算缓存损失率。global<br>  Key_write_requests:将键的数据块写入缓存的请求数。global<br>  Key_writes:向硬盘写入将键的数据块的物理写操作的次数。global<br>  Last_query_cost:用查询优化器计算的最后编译的查询的总成本。用于对比同一查询的不同查询方案的成本。默认值0表示还没有编译查询。 默认值是0。Last_query_cost具有会话范围。global<br>  Last_query_partial_plans:<br>  Max_used_connections:服务器启动后已经同时使用的连接的最大数量。global<br>  Not_flushed_delayed_rows<br>  Open_files:打开的文件的数目。global<br>  Open_streams:打开的流的数量(主要用于记录)。global<br>  Open_table_definitions:缓存的.frm文件数量.global<br>  Open_tables:当前打开的表的数量。both<br>  Opened_files:文件打开的数量。不包括诸如套接字或管道其他类型的文件。 也不包括存储引擎用来做自己的内部功能的文件。global<br>  Opened_table_definitions:已经缓存的.frm文件数量.both<br>  Opened_tables:已经打开的表的数量。如果Opened_tables较大，table_cache 值可能太小。both<br>  Performance_schema_accounts_lost:<br>  Performance_schema_cond_classes_lost:<br>  Performance_schema_cond_instances_lost:<br>  Performance_schema_digest_lost:<br>  Performance_schema_file_classes_lost:<br>  Performance_schema_file_handles_lost:<br>  Performance_schema_file_instances_lost:<br>  Performance_schema_hosts_lost:<br>  Performance_schema_locker_lost:<br>  Performance_schema_mutex_classes_lost:<br>  Performance_schema_mutex_instances_lost:<br>  Performance_schema_rwlock_classes_lost:<br>  Performance_schema_rwlock_instances_lost:<br>  Performance_schema_session_connect_attrs_lost:<br>  Performance_schema_socket_classes_lost:<br>  Performance_schema_socket_instances_lost:<br>  Performance_schema_stage_classes_lost:<br>  Performance_schema_statement_classes_lost:<br>  Performance_schema_table_handles_lost:<br>  Performance_schema_table_instances_lost:<br>  Performance_schema_thread_classes_lost:<br>  Performance_schema_thread_instances_lost:<br>  Performance_schema_users_lost:<br>  Prepared_stmt_count:当前的预处理语句的数量。 (最大数为系统变量: max_prepared_stmt_count).global<br>  Qcache_free_blocks:查询缓存内自由内存块的数量。global<br>  Qcache_free_memory:用于查询缓存的自由内存的数量。global<br>  Qcache_hits:查询缓存被访问的次数。global<br>  Qcache_inserts:加入到缓存的查询数量。global<br>  Qcache_lowmem_prunes:由于内存较少从缓存删除的查询数量。global<br>  Qcache_not_cached:非缓存查询数(不可缓存，或由于query_cache_type设定值未缓存)。global<br>  Qcache_queries_in_cache:登记到缓存内的查询的数量.global<br>  Qcache_total_blocks:查询缓存内的总块数。global<br>  Queries:服务器执行的请求个数，包含存储过程中的请求。global<br>  Questions:已经发送给服务器的查询的个数。global<br>  Select_full_join:没有使用索引的联接的数量。如果该值不为0,你应仔细检查表的索引.both<br>  Select_full_range_join:在引用的表中使用范围搜索的联接的数量。both<br>  Select_range:在第一个表中使用范围的联接的数量。一般情况不是关键问题，即使该值相当大。both<br>  Select_range_check:在每一行数据后对键值进行检查的不带键值的联接的数量。如果不为0，你应仔细检查表的索引。both<br>  Select_scan:对第一个表进行完全扫描的联接的数量。both<br>  Slave_heartbeat_period:复制的心跳间隔.global<br>  Slave_last_heartbeat:<br>  Slave_open_temp_tables:从服务器打开的临时表数量.global<br>  Slave_received_heartbeats:从服务器心跳数.global<br>  Slave_retried_transactions:本次启动以来从服务器复制线程重试次数.global<br>  Slave_running:如果该服务器是连接到主服务器的从服务器，则该值为ON。global<br>  Slow_launch_threads:创建时间超过slow_launch_time秒的线程数。both<br>  Slow_queries:查询时间超过long_query_time秒的查询的个数。both<br>  Sort_merge_passes:排序算法已经执行的合并的数量。如果这个变量值较大，应考虑增加sort_buffer_size系统变量的值。both<br>  Sort_range:在范围内执行的排序的数量.both<br>  Sort_rows:已经排序的行数。both<br>  Sort_scan:通过扫描表完成的排序的数量。both<br>  Ssl_accept_renegotiates:<br>  Ssl_accepts<br>  Ssl_callback_cache_hits<br>  Ssl_cipher<br>  Ssl_cipher_list<br>  Ssl_client_connects<br>  Ssl_connect_renegotiates<br>  Ssl_ctx_verify_depth<br>  Ssl_ctx_verify_mode<br>  Ssl_default_timeout<br>  Ssl_finished_accepts<br>  Ssl_finished_connects<br>  Ssl_server_not_after<br>  Ssl_server_not_before<br>  Ssl_session_cache_hits<br>  Ssl_session_cache_misses<br>  Ssl_session_cache_mode NONE<br>  Ssl_session_cache_overflows<br>  Ssl_session_cache_size<br>  Ssl_session_cache_timeouts<br>  Ssl_sessions_reused<br>  Ssl_used_session_cache_entries<br>  Ssl_verify_depth<br>  Ssl_verify_mode<br>  Ssl_version,<br>  Table_locks_immediate:立即获得的表的锁的次数。global<br>  Table_locks_waited:不能立即获得的表的锁的次数。如果该值较高，并且有性能问题，你应首先优化查询，然后拆分表或使用复制。global<br>  Table_open_cache_hits:<br>  Table_open_cache_misses<br>  Table_open_cache_overflows<br>  Tc_log_max_pages_used<br>  Tc_log_page_size<br>  Tc_log_page_waits<br>  Threads_cached:线程缓存内的线程的数量。global<br>  Threads_connected:当前打开的连接的数量。global<br>  Threads_created:创建用来处理连接的线程数。如果Threads_created较大，你可能要增加thread_cache_size值。缓存访问率的计算方法Threads_created/Connections。global<br>  Threads_running:激活的（非睡眠状态）线程数。global<br>  Uptime:服务器已经运行的时间（以秒为单位）。global<br>  Uptime_since_flush_status:最近一次使用FLUSH STATUS 的时间（以秒为单位）。global</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>数据建模</title>
    <url>/2018/08/12/2018/08-12-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<h2 id="0x00、数据模型"><a href="#0x00、数据模型" class="headerlink" title="0x00、数据模型"></a>0x00、数据模型</h2><ul>
<li><p>为什么要建模</p>
<ul>
<li>定义如何存储信息，如何操作信息，以及信息的完整性等约束功能</li>
<li>影响了数据的形态和使用方式</li>
<li>需要满足不同的业务场景需要<ul>
<li>联机事务处理(OLTP):满足业务线需要，频繁的维护更新数据，强一致性</li>
<li>联机分析处理(OLAP):满足决策层需要，更多纬度的视角查询，满足统计决策</li>
</ul>
</li>
</ul>
</li>
<li><p><img src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B%E4%BD%9C%E7%94%A8.png" alt="数据模型作用"></p>
</li>
<li><p>定义数据如何存储</p>
</li>
<li><p>数据模型是定义数据如何输入和输出的一种模型。其主要作用是为信息系统提供数据的定义和格式。</p>
</li>
<li><p>数据模型是数据库系统的核心和基础，现有的数据库系统都是基于某种数据模型而建立起来的。</p>
</li>
<li><p>三要素</p>
<ul>
<li>数据结构：储存在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。<ul>
<li>比如结构化存储、非结构化存储</li>
<li>关联关系型，KV型</li>
</ul>
</li>
<li>数据操作：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。<ul>
<li>关系操作的select及其join、 group by、order by,insert,update, delete等</li>
<li>关系型数据库：oracle,SQLServer,DB2,Mysql。面向对象化</li>
<li>键值数据库：redis,mongodb,hbase等。存储非结构化，缓存等</li>
<li>时间序列数据库:InfluxDB，confluenceDB，Elasticsearch等。 存储日志类型，便于分析</li>
<li>流式数据库:MQ，Spark，Kafka。存储消息类型，不做永久性存储。发布-订阅型、消息队列、消息中间件</li>
</ul>
</li>
<li>数据完整性约束条件：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。[1]</li>
</ul>
</li>
</ul>
<h2 id="0x01、数据建模"><a href="#0x01、数据建模" class="headerlink" title="0x01、数据建模"></a>0x01、数据建模</h2><ul>
<li>建模过程中的主要活动包括：<ul>
<li>确定数据及其相关过程（如实地销售人员需要查看在线产品目录并提交新客户订单）。</li>
<li>定义数据（如数据类型、大小和默认值）。</li>
<li>确保数据的完整性（使用业务规则和验证检查）。</li>
<li>定义操作过程（如安全检查和备份）。</li>
<li>选择数据存储技术（如关系、分层或索引存储技术）。</li>
</ul>
</li>
<li>数据建模大致分为三个阶段，概念建模阶段，逻辑建模阶段和物理建模阶段。其中概念建模和逻辑建模阶段与数据库厂商毫无关系，换言之，与MySQL，SQL Server，Oracle没有关系。物理建模阶段和数据库厂商存在很大的联系，因为不同厂商对同一功能的支持方式不同，如高可用性，读写分离，甚至是索引，分区等。</li>
</ul>
<h2 id="0x02、数据存储历史"><a href="#0x02、数据存储历史" class="headerlink" title="0x02、数据存储历史"></a>0x02、数据存储历史</h2><ul>
<li>历史发展<ul>
<li>无库时代 ：没有专门的数据库，数据大多以文件形式存放</li>
<li>层次状数据库 ：使用层次状模型进行数据库设计和存放</li>
<li>网状数据库 ：使用网状模型进行数据库设计和存放</li>
<li>关系型数据库 ：使用关系型模型进行数据库设计和存放</li>
<li>非关系型数据库：为适应水平扩展性和处理超大量的数据环境，近几年发展非常迅速的发展，衍生类型非常多。</li>
<li>数据集市</li>
<li>数据仓库</li>
</ul>
</li>
</ul>
<h2 id="0x03、层次模型"><a href="#0x03、层次模型" class="headerlink" title="0x03、层次模型"></a>0x03、层次模型</h2><ul>
<li><img src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.jpg" alt="层次数据模型"></li>
<li>一种用树形结构描述实体及其之间关系的数据模型。在这种结构中，每一个记录类型都是用节点表示，记录类型之间的联系则用结点之间的有向线段来表示。每一个双亲结点可以有多个子节点但是每一个子节点只能有一个双亲结点。这种结构决定了采用层次模型作为数系组织方式的层次数据库系统只能处理一对多的实体联系。</li>
<li>层次模型是最早用于商品数据库管理系统的数据模型。</li>
<li>层次数据模型中最基本的数据关系是基本层次关系，它代表两个记录型之间一对多的关系，也叫做双亲子女关系（PCR）。</li>
<li>举例<ul>
<li><img src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.gif" alt="层次结构举例"></li>
<li>一个教师学生层次模型。该层次模型有4个记录类型，即实体。分别是：<ul>
<li>（1）记录型（实体）系是根结点，由系编号、系名、地点3个属性（字段）组成。它有两个子结点，分别是教研室实体和学生实体。</li>
<li>（2）记录型（实体）教研室是系的子结点，同时又是教师实体的双亲结点。它由教研室编号和教研室名两个属性（字段）组成。</li>
<li>（3）记录型（实体）学生由学号、姓名、成绩3个属性（字段）组成。</li>
<li>（4）记录型（实体）教师由教师号、姓名、研究方向3个属性（字段）组成。学生与教师是叶子结点，他们没有子结点。由系到教研室、教研室到教师、系到学生都是一对多的联系。</li>
</ul>
</li>
</ul>
</li>
<li>特征。在一个层次模型中的限制条件是：<ul>
<li>（1）有且仅有一个节点，无父节点，它为树的根；（有且仅有一个结点没有双亲，该节点就是根结点。）</li>
<li>（2）其他节点有且仅有一个父节点。（根以外的其他结点有且仅有一个双亲结点 ）这就使得层次数据库系统只能直接处理一对多的实体关系。</li>
<li>（3）任何一个给定的记录值只有按照其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离双亲记录值而独立存在。</li>
<li>因而层次模型只能表示“1一M”关系，而不能直接表示“M—M”关系。在层次模型中，一个结点称为一个记录型，用来描述实体集。每个记录型可以有一个或多个记录值，上层一个记录值对应下层一个或多个记录值，而下层每个记录值只能对应上层一个记录值。例如，系记录型有：计算机系、电信系等记录值。而计算机系的下层记录值有软件、结构、应用等研究室和数据结构、操作系统、数据库等课程，软件研究室下层又有员工和项目记录值，如图所示:</li>
<li><img src="/assets/images/2018/%E5%B1%82%E6%AC%A1%E6%A8%A1%E5%9E%8B%E8%AE%B0%E5%BD%95%E5%80%BC%E7%A4%BA%E4%BE%8B.gif" alt="层次模型记录值示例"></li>
<li>关于层次模型中实体集之间多对多的联系的处理，解决的方法是引入冗余结点。例如，学生和课程之间的多对多的联系，引入学生和课程的冗余结点，转换为两棵树：一棵树的根是学生，子结点是课程，它表现了一个学生可以选多门课程；一棵树的根是课程，子结点是学生，它反映了一门课程可以被多个学生选。至于冗余结点可以用虚拟结点实现：在冗余结点处仅存放一个指针，指向实际结点。</li>
</ul>
</li>
<li>数据完整性约束。层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。具体如下：<ul>
<li>（1）进行插入数据时，如果没有相应的双亲结点值就不能插入它的子结点值。例如，在上图层次数据库中，如果新调入一名教师，但尚未分配到某个教研室，这时就不能将新的教师插入到数据库中。</li>
<li>（2）进行删除数据时，如果删除双亲结点值，则相应的子结点值也被同时删除。例如，在上图中的层次数据库中，如果删除网络教研室，则该教研室的所有教师的数据将全部丢失。</li>
<li>（3）进行修改数据时，进行更新操作时，应更新所有相应记录，以保证数据的一致性。 [2]</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点:<ul>
<li>层次模型的数据结构比较简单，只需要几条命令就能操纵数据库，比较容易使用。</li>
<li>结构清晰，结点间联系简单，只要知道每个结点的双亲结点，就可以知道整个模型结构。现实世界中许多实体间联系本来就是呈现出一种很自然的层次关系，如表示行政层次，家族关系很关系</li>
</ul>
</li>
<li>缺点:<ul>
<li>（1）现实世界中很多联系是非层次性的，如多对多联系、一个结点具有多个双亲等。层次模型表示这类联系的方法很不灵活，不能直接表示两个以上的实体型间的的复杂的联系和实体型间的多对多联系。只能通过引入冗余数据或建非自然的数据组织如创建虚拟节点的方法来解决，易产生不一致性。</li>
<li>（2）对数据的插入和删除的操作限制太多。</li>
<li>（3）查询子女结点必须通过双亲结点，因为层次模型对任一结点的所有子树都规定了先后次序，这一限制隐含了对数据库存取路径的控制。树中父子结点之间只存在一种联系，因此，对树中的任一结点，只有一条自根结点到达它的路径。</li>
<li>（4）树结点中任何记录的属性只能是不可再分的简单数据类型。</li>
<li>（5）由于结构严密，层次命令趋于程序化。</li>
</ul>
</li>
</ul>
</li>
<li>层次模型的物理存储有两种实现方法：<ul>
<li>顺序法：按照层次顺序把所有的记录邻接存放，即通过物理空间的位置相邻来实现层次顺序。</li>
<li>指针法：各个记录存放时不是按层次顺序，而是用指针按层次顺序把它们链接起来。</li>
</ul>
</li>
<li>1969由IBM公司的IMS（Information Management System），这是IBM公司研制的最早的大型数据库系统程序产品</li>
</ul>
<h2 id="0x04、网状模型"><a href="#0x04、网状模型" class="headerlink" title="0x04、网状模型"></a>0x04、网状模型</h2><ul>
<li>定义<ul>
<li>用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型（Network Model）。</li>
<li>网状模型取消了层次模型的不能表示非树状结构的限制，两个或两个以上的结点都可以有多个双亲结点，则此时有向树变成了有向图，该有向图描述了网状模型。</li>
</ul>
</li>
<li>特征。网状模型的数据结构主要有以下两个特征:<ul>
<li>(1)允许有一个以上的节点无双亲。</li>
<li>(2)至少有一个节点可以有多于一个的双亲。</li>
<li>网状模型中每个结点表示一个记录型（实体），每个记录型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）间的父子关系。</li>
</ul>
</li>
<li>示例<ul>
<li><img src="/assets/images/2018/%E7%BD%91%E7%8A%B6%E6%A8%A1%E5%9E%8B%E7%A4%BA%E4%BE%8B.png" alt="网状模型示例"></li>
<li>课程（实体）的父节点由专业、教研室、学生。以课程和学生之间的关系来说，他们是一种m:n的关系，也就是说一个学生能够选修多门课程，一门课程也可以被多个学生同时选修。</li>
</ul>
</li>
<li>网状与层级数据库的区别<ul>
<li>层次模型中子结点与双亲结点的联系是唯一的，在网状模型中这种联系可以不唯一。</li>
<li>层次模型可以看作网状模型的特例</li>
<li>因此，在网状模型中要为每个联系命名，并指出与该联系有关的双亲记录和子记录。</li>
</ul>
</li>
<li>数据操作与完整性约束<ul>
<li>网状模型的数据操作主要包括查询、插入、删除和更新。具体如下：<ul>
<li>(1)进行插入操作时，允许插入尚未确定双亲结点值的子结点值。如可增加一名尚未分配到某个教研室的新老师，也可增加一些刚来报到还未分配宿舍的学生。</li>
<li>(2)进行删除操作时，只允许删除双亲结点值。如可删除一个教研室，而该科研室所有教师的信息仍保留在数据库中。</li>
<li>(3)修改数据时，可直接表示非树状结构，而无须像层次模型那样增加冗余结点，因此修改操作时只需要指定更新记录即可。</li>
</ul>
</li>
<li>进行更新操作时只需更新指定记录即可。因此，一般来说，网状模型没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统(如DBTG)对数据操作都加了一些限制，提供了一定的完整性约束。 [3]</li>
<li>DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句，主要有：<ul>
<li>(1)支持记录码的概念，码是唯一标识记录的数据项的集合。</li>
<li>(2)保证一个联系中双亲记录和子记录之间是一对多的联系。</li>
<li>(3)可以支持双亲记录和子记录之间某些约束条件。如有些子记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。</li>
</ul>
</li>
</ul>
</li>
<li>优缺点<ul>
<li>优点<ul>
<li>能够更为直接地描述现实客观世界。可表示实体间的多种复杂联系。</li>
<li>修改网状数据模型时，没有层次状数据模型的那么多的严格限制，可以删除一个节点的父节点而依旧保留该节点；也允许插入一个没有任何父节点的节点，这样的插入在层次状数据模型中是不被允许的，除非是首先插入的是根节点；</li>
<li>实体之间的关系在底层中可以借由指针指针实现。具有良好的性能，存取效率较高。</li>
</ul>
</li>
<li>缺点<ul>
<li>结构比较复杂，其数据定义语言(DDL)、数据操作语言(DML)复杂，用户不容易使用。而且应用环境越大，数据库的结构就变得越复杂，不利于最终用户掌握。</li>
<li>数据独立性差，由于实体间的联系本质上是通过存取路径表示的，因此应用程序在访问数据时要指定存取路径。</li>
<li>网状数据模型数据之间的彼此关联比较大，该模型其实一种导航式的数据模型结构，不仅要说明要对数据做些什么，还说明操作的记录的路径；</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x05、关系模型"><a href="#0x05、关系模型" class="headerlink" title="0x05、关系模型"></a>0x05、关系模型</h2><ul>
<li>网状数据库和层次数据库已经很好地解决了数据的集中和共享问题</li>
<li>但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。</li>
<li>1970年，IBM的研究员E.F.Codd博士发表《大型共享数据银行的关系模型》一文提出了关系模型的概念，论述了范式理论和衡量关系系统的12条标准，如定义了某些关系代数运算，研究了数据的函数相关，定义了关系的第三范式，从而开创了数据库的关系方法和数据规范化理论的研究，他为此获得了1981年的图灵奖。</li>
<li>关系模型有严格的数学基础，抽象级别比较高，而且简单清晰，便于理解和使用。但是当时也有人认为关系模型是理想化的数据模型，用来实现DBMS是不现实的，尤其担心关系数据库的性能难以接受，更有人视其为当时正在进行中的网状数据库规范化工作的严重威胁。</li>
</ul>
<h2 id="0x06、面向对象模型"><a href="#0x06、面向对象模型" class="headerlink" title="0x06、面向对象模型"></a>0x06、面向对象模型</h2><ul>
<li>电脑辅助设计</li>
<li>嵌套记录、多值属性、继承</li>
</ul>
<blockquote>
<p>实体-关系模型(ER模型)</p>
</blockquote>
<ul>
<li>实体集、关系集、属性</li>
<li>ER图</li>
<li>原子域和第一范式：name:first_name,last_name;address:address1,address2,address3</li>
<li>约束：唯一性约束、外键约束</li>
</ul>
<h2 id="0x07、数据仓库与操作型数据库的区别"><a href="#0x07、数据仓库与操作型数据库的区别" class="headerlink" title="0x07、数据仓库与操作型数据库的区别"></a>0x07、数据仓库与操作型数据库的区别</h2><ul>
<li>操作型数据库主要是用来支撑即时操作，对数据库的性能和质量要求都比较高。通常设计操作型数据库的都要遵循几个范式的约束，除非少数情况下为了性能进行妥协，才可能出现冗余</li>
<li>数据仓库的数据是来源于即时操作产生的数据，而不是直接来源于即时操作，所以它的数据质量是由操作型系统来保证的，而不是由几个范式来保证的。而且为了更好的跟踪历史信息，以及更快的产生报表，数据仓库的物理模型中存在着大量冗余字段</li>
</ul>
<h2 id="0x08、数据仓库简介"><a href="#0x08、数据仓库简介" class="headerlink" title="0x08、数据仓库简介"></a>0x08、数据仓库简介</h2><ul>
<li>数据模型是抽象描述现实世界的一种工具和方法，是通过抽象的实体及实体之间联系的形式，来表示现实世界中事务的相互关系的一种映射</li>
<li>数据模型表现的抽象的是实体和实体之间的关系，通过对实体和实体之间关系的定义和描述，来表达实际的业务中具体的业务关系。</li>
<li>数据库与数据仓库区别<ul>
<li>数据库：<ul>
<li>传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。</li>
<li>涉及到增删改查，都是小数据量的操作</li>
<li>业务数据库中的数据结构是为了完成交易而设计的，不是为了而查询和分析的便利设计的。</li>
<li>业务数据库大多是读写优化的，即又要读（查看商品信息），也要写（产生订单，完成支付）。因此对于大量数据的读（查询指标，一般是复杂的只读类型查询）是支持不足的。</li>
<li>业务性数据库</li>
<li>是3NF设计</li>
<li>比较流行的有：MySQL, Oracle, SqlServer</li>
</ul>
</li>
<li>数据仓库<ul>
<li>数据仓库系统的主要应用主要是OLAP（On-Line Analytical Processing），支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</li>
<li>数据结构为了分析和查询的便利；查询为主，分析的基数很大</li>
<li>只读优化的数据库，即不需要它写入速度多么快，只要做大量数据的复杂查询的速度足够快就行了。</li>
<li>分析性数据库</li>
<li>星行设计</li>
<li>比较流行的有：AWS Redshift, Greenplum, Hive</li>
</ul>
</li>
</ul>
</li>
<li>数据从业务性的数据库中提取、加工、导入分析性的数据库就是传统的 ETL 工作</li>
</ul>
<p><img src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B.jpg" alt="数据仓库模型"></p>
<ul>
<li>数据仓库模型<ul>
<li>业务建模，生成业务模型，主要解决业务层面的分解和程序化。</li>
<li>领域建模，生成领域模型，主要是对业务模型进行抽象处理，生成领域概念模型。</li>
<li>逻辑建模，生成逻辑模型，主要是将领域模型的概念实体以及实体之间的关系进行数据库层次的逻辑化。</li>
<li>物理建模，生成物理模型，主要解决，逻辑模型针对不同关系型数据库的物理化以及性能等一些具体的技术问题</li>
</ul>
</li>
<li>在整个数据仓库的模型的设计和架构中，既涉及到业务知识，也涉及到了具体的技术，我们既需要了解丰富的行业经验，同时，也需要一定的信息技术来帮助我们实现我们的数据模型，最重要的是，我们还需要一个非常适用的方法论，来指导我们自己针对我们的业务进行抽象，处理，生成各个阶段的模型</li>
</ul>
<p><img src="/assets/images/2018/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%A8%A1%E5%9E%8B%E6%9E%B6%E6%9E%84.jpg" alt="数据仓库架构"></p>
<ul>
<li>从上图我们可以看出，整个数据仓库的数据模型可以分为大概 5 大部分：<ul>
<li>系统记录域（System of Record）：这部分是主要的数据仓库业务数据存储区，数据模型在这里保证了数据的一致性。</li>
<li>内部管理域（Housekeeping）：这部分主要存储数据仓库用于内部管理的元数据，数据模型在这里能够帮助进行统一的元数据的管理。</li>
<li>汇总域（Summary of Area）：这部分数据来自于系统记录域的汇总，数据模型在这里保证了分析域的主题分析的性能，满足了部分的报表查询。</li>
<li>分析域（Analysis Area）：这部分数据模型主要用于各个业务部分的具体的主题业务分析。这部分数据模型可以单独存储在相应的数据集市中。</li>
<li>反馈域（Feedback Area）：可选项，这部分数据模型主要用于相应前端的反馈数据，数据仓库可以视业务的需要设置这一区域。</li>
</ul>
</li>
<li>通过对整个数据仓库模型的数据区域的划分，我们可以了解到，一个好的数据模型，不仅仅是对业务进行抽象划分，而且对实现技术也进行具体的指导，它应该涵盖了从业务到实现技术的各个部分。</li>
</ul>
<h2 id="0x09、ETL"><a href="#0x09、ETL" class="headerlink" title="0x09、ETL"></a>0x09、ETL</h2><ul>
<li>ETL，是英文 Extract-Transform-Load 的缩写，用来描述将数据从来源端经过抽取（extract）、交互转换（transform）、加载（load）至目的端的过程。ETL一词较常用在数据仓库，但其对象并不限于数据仓库。</li>
<li>ETL的质量问题具体表现为正确性、完整性、一致性、完备性、有效性、时效性和可获取性等几个特性</li>
<li>实现ETL，首先要实现ETL转换的过程。体现为以下几个方面：<ul>
<li>1、空值处理：可捕获字段空值，进行加载或替换为其他含义数据，并可根据字段空值实现分流加载到不同目标库。</li>
<li>2、规范化数据格式：可实现字段格式约束定义，对于数据源中时间、数值、字符等数据，可自定义加载格式。</li>
<li>3、拆分数据：依据业务需求对字段可进行分解。例，主叫号 861082585313-8148，可进行区域码和电话号码分解。</li>
<li>4、验证数据正确性：可利用Lookup及拆分功能进行数据验证。例如，主叫号861082585313-8148，进行区域码和电话号码分解后，可利用Lookup返回主叫网关或交换机记载的主叫地区，进行数据验证。</li>
<li>5、数据替换：对于因业务因素，可实现无效数据、缺失数据的替换。</li>
<li>6、Lookup：查获丢失数据 Lookup实现子查询，并返回用其他手段获取的缺失字段，保证字段完整性。</li>
<li>7、建立ETL过程的主外键约束：对无依赖性的非法数据，可替换或导出到错误数据文件中，保证主键唯一记录的加载。</li>
</ul>
</li>
</ul>
<h2 id="0x10、仓库建模阶段解析"><a href="#0x10、仓库建模阶段解析" class="headerlink" title="0x10、仓库建模阶段解析"></a>0x10、仓库建模阶段解析</h2><ul>
<li>业务建模：<ul>
<li>划分整个单位的业务，一般按照业务部门的划分，进行各个部分之间业务工作的界定，理清各业务部门之间的关系。</li>
<li>深入了解各个业务部门的内具体业务流程并将其程序化。</li>
<li>提出修改和改进业务部门工作流程的方法并程序化。</li>
<li>数据建模的范围界定，整个数据仓库项目的目标和阶段划分。</li>
</ul>
</li>
<li>领域概念建模<ul>
<li>抽取关键业务概念，并将之抽象化。</li>
<li>将业务概念分组，按照业务主线聚合类似的分组概念。</li>
<li>细化分组概念，理清分组概念内的业务流程并抽象化。</li>
<li>理清分组概念之间的关联，形成完整的领域概念模型。</li>
</ul>
</li>
<li>逻辑建模：<ul>
<li>业务概念实体化，并考虑其具体的属性</li>
<li>事件实体化，并考虑其属性内容</li>
<li>说明实体化，并考虑其属性内容</li>
</ul>
</li>
<li>物理建模：<ul>
<li>针对特定物理化平台，做出相应的技术调整</li>
<li>针对模型的性能考虑，对特定平台作出相应的调整</li>
<li>针对管理的需要，结合特定的平台，做出相应的调整</li>
<li>生成最后的执行脚本，并完善之。</li>
</ul>
</li>
</ul>
<h2 id="0x11、数据仓库建模方法"><a href="#0x11、数据仓库建模方法" class="headerlink" title="0x11、数据仓库建模方法"></a>0x11、数据仓库建模方法</h2><ul>
<li><p>数据仓库得建模方法同样也有很多种，每一种建模方法其实代表了哲学上的一个观点，代表了一种归纳，概括世界的一种方法</p>
</li>
<li><p>主要介绍:实体模型(范式模型、ER模型)，维度建模法，Data Vault模型，Anchor模型</p>
</li>
<li><p>1.实体关系(ER)模型: 范式建模法（Third Normal Form，3NF）</p>
<ul>
<li><img src="/assets/images/2018/%E6%A0%B7%E4%BE%8BER%E5%9B%BE.png" alt="样例ER图"></li>
<li>范式模型由数据仓库之父 Inmon 提倡</li>
<li>实体联系模型、实体关系模型或实体联系模式图</li>
<li>范式是数据库逻辑模型设计的基本理论，一个关系模型可以从第一范式到第五范式进行无损分解，这个过程也可称为规范化。在数据仓库的模型设计中目前一般采用第三范式，它有着严格的数学定义</li>
<li>实体类型可以分为强实体类型（Strong）和弱实体类型（Weak）两种。强实体类型又可称为独立型实体类型（Indepent），是指其每一个实体实例都能自己识别，而不需要依赖其他实体类型的实例的实体类型。弱实体类型也可称为依赖型实体类型（Depend），是指其每一个实体实例必须依赖其他实体类型的某个实例才能识别的实体类型。</li>
<li>第三范式<ul>
<li>每个属性值唯一，不具有多义性 ;</li>
<li>每个非主属性必须完全依赖于整个主键，而非主键的一部分 ;</li>
<li>每个非主属性不能依赖于其他关系中的属性，因为这样的话，这种属性应该归到其他关系中去。</li>
</ul>
</li>
<li>特点<ul>
<li>需要全面了解企业业务和数据。</li>
<li>实施周期非常长。</li>
<li>对建模人员的能力要求非常高。</li>
</ul>
</li>
<li>优点<ul>
<li>用E-R图表示的概念模型独立于具体的DBMS所支持的数据模型，它是各种数据模型的共同基础，因而比数据模型更一般、更抽象、更接近现实世界。</li>
</ul>
</li>
<li>缺点<ul>
<li>在E-R建模中，数据和应用相分离，E-R图仅仅着眼于数据，不能给我们提供更多关于业务流程的信息</li>
<li>表达方式比较弱，抽象能力比较低</li>
</ul>
</li>
</ul>
</li>
<li><p>2.维度建模法</p>
<ul>
<li><img src="/assets/images/2018/%E7%BA%AC%E5%BA%A6%E5%BB%BA%E6%A8%A1%E6%B3%95.jpg" alt="维度建模法"></li>
<li>数据仓库领域另一位大师 Ralph Kimball</li>
<li>其最简单的描述就是，按照事实表，维表来构建数据仓库，数据集市。</li>
<li>维度建模(dimensional modeling)是专门用于分析型数据库、数据仓库、数据集市建模的方法</li>
<li>维度模型是将关系模型的层次结构展开平铺而成。</li>
<li>这种方法的最被人广泛知晓的名字就是星型模式（Star-schema），雪花建模，星座建模</li>
<li>优点<ul>
<li>星型模式之所以广泛被使用，在于针对各个维作了大量的预处理，如按照维进行预先的统计、分类、排序等。通过这些预处理，能够极大的提升数据仓库的处理能力。特别是针对 3NF 的建模方法，星型模式在性能上占据明显的优势。</li>
<li>维度建模非常直观，紧紧围绕着业务模型，可以直观的反映出业务模型中的业务问题。不需要经过特别的抽象处理，即可以完成维度建模。这一点也是维度建模的优势。</li>
</ul>
</li>
<li>缺点<ul>
<li>缺点也是非常明显的，由于在构建星型模式之前需要进行大量的数据预处理，因此会导致大量的数据处理工作。而且，当业务发生变化，需要重新进行维度的定义时，往往需要重新进行维度数据的预处理。而在这些与处理过程中，往往会导致大量的数据冗余。</li>
<li>如果只是依靠单纯的维度建模，不能保证数据来源的一致性和准确性，而且在数据仓库的底层，不是特别适用于维度建模的方法</li>
</ul>
</li>
<li>维度建模的领域主要适用与数据集市层，它的最大的作用其实是为了解决数据仓库建模中的性能问题。维度建模很难能够提供一个完整地描述真实业务实体之间的复杂关系的抽象方法。</li>
</ul>
</li>
<li><p>3.Data Valut</p>
<ul>
<li>Data Vault是面向细节的，可追踪历史的，它是一组有连接关系的规范化的表的集合。这些表可以支持一个或多个业务功能，它是一种综合了第三范式（3NF）和星型模型优点的建模方法。其设计理念是要满足企业对灵活性、可扩展性、一致性和对需求的适应性要求，它是一种专为企业级数据仓库量身定制的建模方式。</li>
<li>可以看出Data Vault既是一种数据建模的方法论，又是构建企业数据仓库的一种具体方法。</li>
<li>Data Vault模型由三个模块组成，中心表、链接表、附属表。</li>
<li>建模方法论里定义了Data Vault的组成部分和组成部分之间的交互方式。Data Vault的建模方法中还包括了最佳实践，来指导构建企业数据仓库。例如，业务规则应该在数据的下游实现，就是说Data Vault只按照业务数据的原样保存数据，不做任何解释、过滤、清洗、转换。即使从不同数据源来的数据是自行矛盾的（例如同一个客户有不同的地址），Data Vault模型不会遵照任何业务的规则，如“系统A的地址为准”。Data Vault模型会保存两个不同版本的数据，对数据的解释将推迟到整个架构的后一个阶段（数据集市）。</li>
<li>中心表：中心表主要是存储一些日常用的一些业务关键码，比如客户号，发票号，流水号等等。它包括三个要素：<ul>
<li>代理键：这就是一些操作性的组件，包括客户号，发票号等等</li>
<li>装载时间戳：这里可以理解为ETL进行日加载的时间。</li>
<li>数据源：就是可以追索到的原系统，比如，CRM，ERP等</li>
</ul>
</li>
<li>链接表：是3NF的多对多关系的物理表现形式，它表现的是多个业务键之间的关系。它和范式模型的最大区别是将关系作为一个独立单元抽象出来，可以提升模型的扩展性。它主要包含以下特征:<ul>
<li>代理键</li>
<li>代理键间的映射关系</li>
<li>装载时间戳：这里可以理解为ETL进行日加载的时间。</li>
<li>数据源：就是可以追索到的原系统，比如，CRM，ERP等</li>
</ul>
</li>
<li>卫星表：<ul>
<li>业务领域中的其余信息可能随着时间而变化，所以卫星表必须有能力存储新的或者变化的各种粒度的数据，他们将被存储在卫星表内。卫星表是中心表的详细描述内容，一个中心表会有多个卫星表。它由中心表的代理键、装载时间、来源类型、详细的中心表描述信息等组成。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x12、范式模型-ER模型、实体模型"><a href="#0x12、范式模型-ER模型、实体模型" class="headerlink" title="0x12、范式模型(ER模型、实体模型)"></a>0x12、范式模型(ER模型、实体模型)</h2><p>-</p>
<h2 id="0x13、维度建模"><a href="#0x13、维度建模" class="headerlink" title="0x13、维度建模"></a>0x13、维度建模</h2><ul>
<li><p>数据仓库领域另一位大师 Ralph Kimball提出</p>
</li>
<li><p>维度建模以分析决策的需求出发构建模型。重点解决用户如何更快速完成分析需求，同时还有较好的大规模复杂查询的响应性能。</p>
</li>
<li><p>并不要求维度模型必须满足第3范式。</p>
</li>
<li><p>维度模型的部件是从需求定义的信息包中演化而来。</p>
</li>
<li><p>事实表包含了商业指标;维表包含了商业维度。每个维表中的层次结构用于下钻到更低级别的数据。</p>
</li>
<li><p>星形模式的优势包括:用户易于理解;优化浏览;提高查询处理速度;可以使用特别的提高性能的模式。</p>
</li>
<li><p>由事实表、纬度表、聚合表</p>
<ul>
<li>事实表：发生在现实世界中的操作型事件，其所产生的可度量数值，存储在事实表中。从最低的粒度级别来看，事实表行对应一个度量事件，反之亦然。比如投资事件、媒体报道等</li>
<li>纬度表：每个维度表都包含单一的主键列。维度表的主键可以作为与之关联的任何事实表的外键，当然，维度表行的描述环境应与事实表行完全对应。 维度表通常比较宽，是扁平型非规范表，包含大量的低粒度的文本属性。比如：公司、机构、基金、GP、个人等</li>
<li>聚合表：数据是按照最详细的格式存储在事实表中，各种报表可以充分利用这些数据。一般的查询语句在查询事实表时，一次操作经常涉及成千上万条记录，但是通过使用汇总、平均、极值等聚合技术可以大大降低数据的查询数量。因此，来自事实表中的底层数据应该事先经过聚合存储在中间表中。中间表存储了聚合信息，所以被称为聚合表，这种处理过程被称为聚合过程。</li>
</ul>
</li>
<li><p>事实表</p>
<ul>
<li>连接的事实表键。数据颗粒。完全的加和的指标。半加和的指标。大量的记录。只有一些属性。稀疏的数据。退化的维度。</li>
<li>连接的事实表主键。 事实表中的一行记录与所有维表中的相应记录相关。在这个事实表例子中，你可以发现订单的数量作为一个属性。假如维表是产品，时间，客户，以及销售代表。对这些维表，假 设维的层次结构中最低的层次分别是单独的产品，日历中的一天，一个特定的客户，以及一 个单独的销售代表。那么事实表中的一行就必须与特种特定的产品，一个特定的日期，一个 特定的客户，以及一个单独的销售代表相关。这意味着事实表中的记录必须可以由四个维表中的主键所唯一确定。由此，事实表中的主键必须是所有维表主键连接起来的组合键。</li>
<li>数据颗粒。 这是事实表的一个重要的特征。正如我们所知道的，数据粒度是指标的细节程度。在这个例子中，指标是在最细节的层次的。订单数量与以下的特征相关:一个单独的订单中某种 特定产品的数量，某个特定的日期，一个特定的客户，以及一位特定的销售代表。如果我们 只保留每个月中某种特定产品的销售量，那么数据颗粒就会与现在不同，而处在一个更高的 级别。</li>
<li>完全加和指标。让我们看看这些属性:order_dollars, extended_cost, quantiti_ordered。每一个都与一个特定的产品，一个特定的日期，一位特定的客户以及一位特定的销售代表相关。在一个查询当 中，我们假设用户希望得到某一个特定日期中某个州的客户对一个特定产品的订单总和。注 意，不是一个特定的客户，而是一个特定州中的所有客户。然后，我们需要找到事实表中所 有与这个州相关的所有客户，将 order_dollars, extended_cost, quantiti_ordered 这三个字段的 数值加和。这些属性的数值可以简单的汇总。这样的指标称为完全加和指标。完全加和指标 可以通过简单的加法进行汇总。当我们运行汇总事实表中指标的查询时，我们将不得不确认 这些指标是完全加和的。否则，将可能的不到正确的汇总数据。</li>
<li>半加和的指标。考虑事实表中的 margin_dollars 属性。举例来说，如果 order_dollars 时 120，extended_cost时 100，那么 margin_percentage 就是 20。这是通过计算 order_dollars 和 extended_cost 之后 得到的指标。如果你汇总事实表中某个州中所有客户的数值，你不能够将这些记录中的 margin_percentages 加起来就得到汇总数据。类似于 margin_percentage 这种衍生指标是非加 和的。它们称为半加和的指标。在执行汇总查询的时候，应当将半加和的指标和完全加和指 标区分开来。</li>
<li>表很长，但是不宽。通常一个事实表的属性要比一个维表少。一般来说只有 10 个甚至更少的属性。但是比较之下，事实表中的记录的数量是相当巨大的。我们举一个简单的例子，如果维表中有 3 种产品，5 个客户，30 天，10 个销售代表。那么，在这么少的维表记录数量下，事实表中 的记录数量将会有 4500 条。相对于维表的记录数量来说，这个数字是相当大的。如果你将 事实表展开成 2 位的表格，你会发现，维表只有很少的几列，但是有相当多的记录。</li>
<li>稀疏的数据。 我们讨论过事实表中的每一行都与一个特定的产品，一个特定的日期，一位特定的客户以及一个独立的销售代表相关。换句话说，对一个特定的产品，一个特定的日期，一位特定 的客户以及一个独立的销售代表，事实表中都由一个相应的记录。如果在一个临近假日的日 子里没有接到订单或者没有订单被处理，哪会发生什么呢?在这种日子中，事实表不会有相 关的记录。而且，其它维表也可能会导致事实表中出现空的指标值。那么，我们是否需要将 这些空的指标值放在事实表中呢?没有必要。因此，很重的一点就是要意识到这一类的稀疏 数据，并理解事实表中可能会存在数据隔断。</li>
<li>退化的维度。仔细的观察例子中的事实表。你会发现有 order_number 和 order_line 属性。这些属性不是指标，也不是事实。那么为什么这些属性会在事实表中呢?当你从操作形系统中获取维表 以及事实表的属性时，你会发现操作型系统中某些数据元素既不是事实也不是严格的维属 性。例如，这些属性是参考数字，例如订单数量，发票金额，订单流水号，等等。这些属性 在某些类型的分析中是有用的。例如，你可能在寻找每个订单中某种产品的平均数量。然后 你就需要将产品与订单中的数量联系起来，计算平均值。诸如例子中 order_number 和 order_line 的属性称为退化的维度，它们依然作为属性保留在事实表中。</li>
<li>不允许有空文本</li>
<li>用来存储事实的度量（measure）及指向各个维的外键值。</li>
<li>事实数据表的主要特点是包含数字数据（事实），并且这些数字信息可以汇总，以提供有关单位作为历史的数据，每个事实数据表包含一个由多个部分组成的索引，该索引包含作为外键的相关性纬度表的主键，而维度表包含事实记录的特性。</li>
<li>事实数据表不应该包含描述性的信息，也不应该包含除数字度量字段及使事实与纬度表中对应项的相关索引字段之外的任何数据。</li>
<li>包含在事实数据表中的“度量值”有两种：一种是可以累计的度量值，另一种是非累计的度量值</li>
<li>最有用的度量值是可累计的度量值，其累计起来的数字是非常有意义的。用户可以通过累计度量值获得汇总信息，例如可以汇总具体时间段内一组商店的特定商品的销售情况。非累计的度量值也可以用于事实数据表，单汇总结果一般是没有意义的，例如，在一座大厦的不同位置测量温度时，如果将大厦中所有不同位置的温度累加是没有意义的，但是求平均值是有意义的。</li>
<li>一般来说，一个事实数据表都要和一个或多个纬度表相关联，用户在利用事实数据表创建多维数据集时，可以使用一个或多个维度表</li>
</ul>
</li>
<li><p>纬度表</p>
<ul>
<li>维表用来保存该维的元数据，即维的描述信息，包括维的层次及成员类别等</li>
<li>维度表可以看作是用户来分析数据的窗口，纬度表中包含事实数据表中事实记录的特性，有些特性提供描述性信息，有些特性指定如何汇总事实数据表数据，以便为分析者提供有用的信息，维度表包含帮助汇总数据的特性的层次结构。例如，包含产品信息的维度表通常包含将产品分为食品、饮料、非消费品等若干类的层次结构，这些产品中的每一类进一步多次细分，直到各产品达到最低级别。</li>
<li>大数值的数字属性 文本属性 非直接相关属性 非规范化的， 具有上钻/下钻的能力 多级层次结构 相对少的记录</li>
<li>在维度表中，每个表都包含独立于其他维度表的事实特性，例如，客户维度表包含有关客户的数据。维度表中的列字段可以将信息分为不同层次的结构级。</li>
<li>维表键。维表的主键，可以维一的确定每一条记录</li>
<li>维表很宽。一般来说，一个维表会有相当多的属性/字段。有一些维表有 50 个以上的属性并 非是不寻常的。所以，我们说维表很宽。如果你将表格的列排列一下，维表将会水平展开。</li>
<li>非直接相关属性。维表中的某一些属性经常不会与其中的其它属性直接相关。例如，包裹的 大小与商品的品牌不是直接相关的;然而，包裹的大小与产品的品牌可能都是产品维度的属 性。</li>
<li>非规范化。维表是扁平的，而不是规范化的</li>
<li>文本属性。在维表中，很难找到任何用于计算的数值数据。维表中的属性一般是文本格式的。 这些属性表示商业维度中的部件的文本描述。用户可以采用这些描述构造它们的查询</li>
<li>上钻/下钻。维表中的属性提供了获取从高层次的汇总信息到低层次细节信息的能力。例如， 一个层次结构中有三个属性，邮政编码，城市，以及州。你可以得到按州为单位销售总量， 然后从下钻到以城市为单位的，以及以邮政编码为单位的销售总量。另一方面，你可以首先 得到以邮政编码为单位的销售总量，然后上钻到城市，以及州。</li>
<li>多级层次结构。以客户维举例，该维表存在一个包括客户所在邮政编码号，城市以及州的单 一的层次结构。但是，维表通常会有多级的层次结构，从而使钻取可以沿着这些层次结构中 的任何一个进行。以商店的产品维表为例。在这种情况下，市场营销部门可能自己制定将产 品分类到不同的产品目录以及产品部门的方法。另一方面，会计部门也许会用另外的方式将 产品归类到产品目录以及产品部门中。所以，在这个案例中，产品维表会有多套属性，包括 市场营销-产品-目录，市场营销-产品-部门，财务-产品-目录，财务-产品-部门。</li>
<li>相对少的记录。一个维表中的记录数通常会比事实表中的记录数量要少。一个汽车厂上的产 品维表可能只有 500 行。另一方面，事实表可能会有上百万行记录。</li>
</ul>
</li>
<li><p>事实表和维度表的设计原则</p>
<ul>
<li>事实表是用来存储主题的主干内容的。以日常的工作量为例，工作量可能具有如下属性：工作日期，人员，上班时长，加班时长，工作性质，是否外勤，工作内容，审核人。那么什么才是主干内容？很容易看出上班时长，加班时长是主干，也就是工作量主题的基本内容，那么工作日期，人员，工作性质，是否外勤，工作内容是否为主干信息呢？认真分析特征会发现，日期，人员，性质，是否外勤都是可以被分类的，例如日期有年-月-日的层次，人员也有上下级关系，外勤和正常上班也是两类上班考勤记录，而上班时长和加班时长则不具有此类意义。所以一般把能够分类的属性单独列出来，成为维度表，在事实表中维护事实与维度的引用关系。</li>
<li>总的来看，和其他建立主外键关系的表也都一样。但是维度表的建立是需要有层次的（虽然不是必须，但是也是典型特征），而事实表的建立是针对已经发生的事实的，是历史数据的存档，也就是说是不应该修改的。以测试部测试软件的Bug为例。每个Bug都是一个事实。这个Bug的状态在数据字典里可能设计成新建，转派，修复，拒绝等等。那么在事实表中Bug表中有一个字段为Status。当测试员或者开发人员改变了这个状态的值，事实表中该如何更新呢？是直接更新Status还是什么其他的方式？显然，为了能够追踪这个Bug的历史信息，应该是重新插入一条新的记录。那么这和以往的数据库设计有什么区别呢？可以看出对于原始记录和新插入的记录，其他字段全部是相同的，也就是全部冗余的。如果以BugID作为主键，这时候会发现主键都是冗余的（当然，插入之前只能删除主键）。所以可以看出，事实表一般是没有主键的。数据的质量完全由业务系统来把握。</li>
<li>维度表一般是有主键的，代表该类物质的一个单一个体，其他的字段一般都是有层次关系的。例如2009年2月19日是主键，那么它会有年–月–日这样的层次，为了方便统计，年月日不会在做聚合的时候才计算出来，而是在维护记录时已经计算出来。那么这些字段的冗余是否值得呢？可以这样解释：维度表的数据一般是比较少的，这个少是指相对事实表来讲的。因为事实表是与日俱增，而维度表则增长缓慢，所以绝对数字也不会太大。假如要做一个group by Year(TimeKey),那么在事实表和维度表做连接查询的时候，会产生与事实表一样大的数据量；如果没有这些维度表的分层，那么其一是会增加计算（需要根据时间字段去取出年份)，其二是由于引入了计算，索引会失效。这个代价比引入冗余字段要大的多。</li>
<li>维度表的主键一般都取整型值的标志列类型,这样也是为了节省事实表的存储空间.</li>
</ul>
</li>
<li><p>纬度表优缺点：</p>
<ul>
<li>数据冗余小（因为很多具体的信息都存在相应的维度表中了，比如用户信息就只有一份）</li>
<li>结构清晰（表结构一目了然）</li>
<li>便于做OLAP分析（数据分析用起来会很开心）</li>
<li>增加使用成本，比如查询时要关联多张表</li>
<li>数据不一致，比如用户发起购买行为的时候的数据，和我们维度表里面存放的数据不一致</li>
</ul>
</li>
<li><p>大宽表的优缺点：</p>
<ul>
<li>业务直观，在做业务的时候，这种表特别方便，直接能对到业务中。</li>
<li>使用方便，写sql的时候很方便。</li>
<li>数据冗余巨大，真的很大，在几亿的用户规模下，他的订单行为会很恐怖</li>
<li>粒度僵硬，什么都写死了，这张表的可复用性太低</li>
</ul>
</li>
</ul>
<ul>
<li>星型建模<ul>
<li>星形模式的键<ul>
<li>一个维表的每行都可以维表中的主键所唯一的识别</li>
<li>第一个原则来自于产品被存放到另外一个 仓库的情况。换句话来说，操作型系统中的产品键是有内在含义的.避免维表中的键有内在的含义</li>
<li>第二条原则就是:不要适用生产系统中的主键作为维表的主键。</li>
<li>替代键就是简单的系统 生成的序列号码。</li>
<li>替代键可以映射为生产系统的键。但是， 它们之间是不同的。通常的做法是将生产系统的键作为维表的附加属性</li>
</ul>
</li>
<li>虽然星形模式是一个关系模型，但是它不是一个规范化模型。在星形模式中，维表被故 意的非范式化了。这是星形模式与 OLTP 系统中的关系模式的基本区别。<ul>
<li>用户容易理解<ul>
<li>决策支持系统(例如数据仓库)的用户就不一样了。他们需要自己构造查询语句。在使 用第三方工具与数据仓库进行交互的过程中，他们要知道自己究竟需要什么。他们必须对数 据仓库中的有什么数据非常的熟悉，必须理解数据的结构，以及在整个模式中这些结构之间 的相互关系。</li>
<li>星形模式确切的反映了用户是如何想的，他们在查询和分析时需要什么数据。他们从商 业的角度来考虑问题。维表包含了用户经常查询和分析的属性。</li>
</ul>
</li>
<li>优化浏览<ul>
<li>关系用于连接不同 的表，以得到你所需要的信息。关系提供了操作数据库的能力。使用连接路径，可以将表与表之间的数据联系起来。</li>
<li>星形模式的一个主要的优势在于它优化了对数据库的浏览。即使你要找到查询结果看上 去很复杂，但是查询的过程是简单而且清晰的。</li>
</ul>
</li>
<li>最适于查询处理<ul>
<li>如果不考虑查询中涉及的维的数量，也不考虑查询的复杂程度，实际上每一个查询都只 是简单的使用一些参数过滤维表，得到一些维表结果，然后从事实表中得到相应的结果集。 这都得益于简单、清晰的连接路径以及星形模式。没有其它的方式能够达到这种效果了。</li>
<li>数据仓库查询的另一个重要方面就是上钻和下钻。让我们看一个下钻的场景。假设我们 已经得到了所有加利福尼亚州的顾客的所有扩展成本。结果是通过事实表的记录得到的。接 下来我们希望按照邮政编码来下钻这些结果。这可以通过选择在事实表中和相应邮政编码范 围的相关的记录。相反的，上钻是通过扩展事实表的选择记录的过程。</li>
</ul>
</li>
<li>星形连接和星形索引<ul>
<li>星形模式允许查询处理软件使用更优化的执行计划。它使得查询有能够更高的效率。星 形模式尤其适用于应用类似于星型连接或者星型索引这类提高性能的技术。</li>
<li>星型连接是一种高速，并型的，单独操作的多表连接。它可以通过一个单独的操作连接 多个表。这种特别的模式能够显著的提高查询性能。</li>
<li>星型索引是一种独特的索引，它可以提高连接的性能。这些索引建立在事实表的一个或 者多个外键上面。这些索引可以提高维表与事实表中连接速度。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>雪花建模<ul>
<li>纬度表进行规范化，拆分成多个表</li>
</ul>
</li>
<li>星座建模</li>
</ul>
<h2 id="0x14、范式模型和纬度模型区别"><a href="#0x14、范式模型和纬度模型区别" class="headerlink" title="0x14、范式模型和纬度模型区别"></a>0x14、范式模型和纬度模型区别</h2><ul>
<li><p>一般常规的数据仓库层级结构可分为：ods、dw(默认为汇总数据层，也可在细分为dwd(明细)与dw(汇总)两层)、dm共三层：</p>
<ul>
<li>ods层：称为接口层或近源数据层，表结构与源系统表结构高度相似，通常在ods层主要会做字段的筛选，枚举值转换，编码统一，异常&amp;缺失数据处理等操作。</li>
<li>dw层：称为中间层，按主题建模（域-&gt;主题）的明细数据层，数据粒度与ods层一致。</li>
<li>dm层：称为数据集市层，集市层是按照业务主题、分主题构建出来的、面向特定部门或人员的数据集合。</li>
</ul>
</li>
<li><p>维度建模源于Kimball提出的总线式的自下而上（DM-DW）的数据仓库架构。</p>
</li>
<li><p>特点：</p>
<ul>
<li>1.模型结构简单，星型模型为主；</li>
<li>2.开发周期短，能够快速迭代；</li>
<li>3.维护成本较高；</li>
</ul>
</li>
<li><p>范式建模源于Inmon提出的集线器的自上而下（EDW-DM）的数据仓库架构。</p>
</li>
<li><p>特点：</p>
<ul>
<li>1.同一份数据只存放在一个地方，因此只能从一个地方获取，没有数据冗余，保证了数据一致性；</li>
<li>2.解耦（系统级与业务级），方便维护；</li>
<li>3.开发周期较长，开发成本较高；</li>
</ul>
</li>
<li><p>用法</p>
<ul>
<li>dw层通常会采用范式建模，并且可以根据实际情况允许存在一些冗余。</li>
<li>dm层通常会采用维度建模，因为采用维度建模构建出来的数据模型更加符合普通人的认知、易于被普通人所理解，从而有利于数据的推广使用。</li>
</ul>
</li>
<li><p>维度模型将ER模型的层次结构平铺开来了，整个数据结构是平面化、单一层次的，数据结构很简单，但是维度表的冗余也会较多，灵活性比较差；优势则是查询简单快速，比如对产品维度的大类汇总，ER建模需要关联产品再通过关系表关联产品大类，而维度模型直接在产品维度表中就有了</p>
</li>
<li><p>ER模型和维度模型应用场景有所不同，ER模型更偏向于基础数据仓库的建设，保证高度抽象、高度一致性，要求业务稳定；而维度模型更多应用于数据集市，偏向于直接面对业务，保证查询效率</p>
</li>
<li><p>为什么 E-R 建模适用于 OLTP 系统。</p>
<ul>
<li>OLTP系统捕捉事件或者交易的详细信息</li>
<li>OLTP系统关注独立的事件</li>
<li>一个OLTP系统是通向微观交易的窗口</li>
<li>反映运行业务所需要的细节信息</li>
<li>仅仅适用于回答交易级别的问题</li>
<li>数据一致性，非冗余性，以及高效的数据存储是最重要的</li>
<li>避免了数据冗余 确保数据一致 表达微观的关系</li>
</ul>
</li>
<li><p>数据仓库需要回答全局问题</p>
<ul>
<li>数据仓库关注经理如何管理业务问题</li>
<li>数据仓库反映商业趋势</li>
<li>信息是围绕商业流程来组织的</li>
<li>答案显示了业务是如何衡量流程的</li>
<li>通过几个商业维度，可以衡量业务情况</li>
<li>捕捉关键指标 通过维度显示 面向商业用户</li>
</ul>
</li>
</ul>
<h2 id="0x15、数据层"><a href="#0x15、数据层" class="headerlink" title="0x15、数据层"></a>0x15、数据层</h2><ul>
<li>数据规范定义<ul>
<li>个性化的数据指标进行规范定义，抽象成：原子指标、时间周期、其他修饰词等三个要素。</li>
</ul>
</li>
<li>ODL(操作数据层)+BDL(基础数据层)+IDL(接口数据层)+ADS(应用数据层)</li>
<li>ODS(操作数据)层、CDM(公共维度模型)层、ADS(应用数据)层<ul>
<li>ODS层主要功能<ul>
<li>同步：结构化数据增量或全量同步到ODPS;</li>
<li>结构化：非结构化(日志)结构化处理并存储到ODPS;</li>
<li>累积历史、清洗：根据数据业务需求及稽核和审计要求保存历史数据、数据清洗;</li>
</ul>
</li>
<li>CDM层主要功能<ul>
<li>CDM层又细分为DWD层和DWS层，分别是明细宽表层和公共汇总数据层，采取维度模型方法基础，更多采用一些维度退化手法，减少事实表和维度表的关联，容易维度到事实表强化明细事实表的易用性;</li>
<li>同时在汇总数据层，加强指标的维度退化，采取更多宽表化的手段构建公共指标数据层，提升公共指标的复用性，减少重复的加工。</li>
</ul>
</li>
<li>ADS层主要功能<ul>
<li>个性化指标加工：不公用性;复杂性(指数型、比值型、排名型指标)</li>
<li>基于应用的数据组装：大宽表集市、横表转纵表、趋势指标串</li>
</ul>
</li>
</ul>
</li>
<li>流式数据结构，数据分层处理</li>
</ul>
<h2 id="0x16、查询方式"><a href="#0x16、查询方式" class="headerlink" title="0x16、查询方式"></a>0x16、查询方式</h2><ul>
<li>分组查询</li>
<li>钻取查询</li>
</ul>
<h2 id="0x17、数据仓库"><a href="#0x17、数据仓库" class="headerlink" title="0x17、数据仓库"></a>0x17、数据仓库</h2><ul>
<li><p>这种新类型的系统环境的特点如下:</p>
<ul>
<li>为分析任务设计的数据库</li>
<li>从多种应用程序中的得到的数据</li>
<li>方便使用，有益于用户的长时间互动操作</li>
<li>深入读取的数据使用</li>
<li>不需要IT顾问，用户可以与系统直接互动</li>
<li>同时包含当前和历史数据</li>
<li>用户可以运行查询并在线得到结果</li>
<li>用户可以创建报表</li>
</ul>
</li>
<li><p>在操作型系统和数据仓库之间，存在一个数据准备区域。在这个区域中，操作型 数据被清洗，并转化成为适合数据仓库使用的格式。</p>
</li>
<li><p>数据仓库是一种信息化环境，它有以下特点:</p>
<ul>
<li>提供对企业的一个综合而且完整的观察</li>
<li>使企业决策所需要的无论是当前数据还是历史数据都方便易得</li>
<li>使决策支持的互动工作不再需要借助操作型系统</li>
<li>使企业的信息保持一致性</li>
<li>提供了一个灵活的和互动的战略信息来源</li>
</ul>
</li>
<li><p>数据仓库可以向用户提供对数据的直接接触， 提供一个单独的关于经营情况的指标，还可以准确地记录发生的情况，可以使客户能够从多 种不同的视角观察这些数据。简单地说，数据仓库可以支持决策型的处理工作。</p>
</li>
<li><p>给数据仓库下一个定义:使用所有已经存在的数据，通过清洗和转化，提供有用的决策 信息。</p>
</li>
<li><p>一个数据仓库不是一个你购买来提供战略信息的简单的软件或者是硬件产品，而是一个 用户可以发现战略信息的计算机系统。在这个环境里，用户可以通过与数据的直接接触来做 出更好的决策。它是一个以用户为中心的环境。</p>
</li>
<li><p>让我们来总结一下这种叫做数据仓库的新型计算机环境的特点:</p>
<ul>
<li>数据分析和决策支持的完美环境</li>
<li>不固定，灵活而且交互式</li>
<li>百分之百用户驱动</li>
<li>非常适合提问-回答-再提问的模式</li>
<li>提供回答复杂、不可预测的问题的能力</li>
</ul>
</li>
<li><p>让我们来重新看看关于数据仓库的定义。数据仓库的基本概念如下:</p>
<ul>
<li>从操作型系统中提取所有数据</li>
<li>在需要的时候，可以将外部相关数据包含其中，例如工业标准指标</li>
<li>将多种数据源的数据进行整合</li>
<li>清洗并转换数据</li>
<li>用适合决策的格式存储数据</li>
</ul>
</li>
<li><p>包含了几个不同的功能:数据抽取，数据装载的功能，数据转换，数据存储，以及提供用户接口。</p>
</li>
<li><p>完整的数据。解决数据中存在的矛盾;整合来自不同操作型应用中的数据。</p>
<ul>
<li>储蓄账户   数据仓库主题</li>
<li>支票账户    主题=账户</li>
<li>贷款账户</li>
</ul>
</li>
<li><p>这里有一些需要标准化的项目:</p>
<ul>
<li>命名规则</li>
<li>编码</li>
<li>数据属性</li>
<li>度量单位</li>
</ul>
</li>
<li><p>有时间特性。数据仓库中的数据是和时间变化有关的数据:</p>
<ul>
<li>可以对过去的数据进行分析</li>
<li>与当前的信息相关</li>
<li>可以对未来进行预测</li>
</ul>
</li>
<li><p>数据的不变性</p>
<ul>
<li>历史数据，不需要变更</li>
<li>可以一天一次，两天一次或者一星期一次</li>
<li>我们在每次交易发生的时候，从操作型系统中增加、改变或者删除数据， 而并不是直接在数据仓库中进行更新。你不能在数据仓库中实时的删除数据。一旦数据存入 了数据仓库，你就不能对这个数据进行修改。数据仓库中的数据不像操作型系统中的数据那 样，可以随时修改。数据仓库中的数据是用来查询和分析的。</li>
</ul>
</li>
<li><p>数据粒度</p>
<ul>
<li>在一个操作型系统中，数据存储通常非常的详细。</li>
<li>当用户需要查询数据仓库来进行分析工作的时候，他或者她通常开始看总和数据。然后 可能需要看某个地区分类的数据。下一步通常是检查每个商店的销售情况。一般说来，用户 是从一个高的层次向低层次的细节过渡。</li>
<li>在数据仓库中，你会发现可以很有效地进行不同层次的数据求和。根据查询的需 要，你能够得到不同程度的细节情况。数据仓库中的数据粒度就是指这种细节的程度。低层 次的细节程度，数据粒度越细。当然，如果你想得到更加细节的数据，必须要在数据仓库中 存储大量的数据。所以，必须根据数据类型和希望达到的系统查询性能的要求，决定数据粒 度级别</li>
<li>数据粒度是数据的细节程度。根据需求的不同，需要不同层次的数据细节。数据仓库一 般含有至少两层的数据粒度。</li>
</ul>
</li>
<li><p>数据仓库和数据集市</p>
<ul>
<li>在开始决定建立数据仓库之前，你需要考虑以下这些问题:<ul>
<li>采取自上而下还是自下而上的方法?</li>
<li>企业范围还是部门范围?</li>
<li>先建立数据仓库还是数据集市?</li>
<li>建立向导还是直接实施</li>
<li>是否依赖数据集市?</li>
</ul>
</li>
<li>自上而下方法<ul>
<li>优点是:<ul>
<li>可以从整个企业的角度来看数据</li>
<li>体系结构完整——不是由不同的数据集市组成的</li>
<li>对数据内容的唯一、集中的存储</li>
<li>中央控制和集中的规则</li>
<li>对反复的查询能够做出快速的反应</li>
</ul>
</li>
<li>缺点是:<ul>
<li>需要花更多的时间来建造</li>
<li>失败的风险很高</li>
<li>需要高水平的综合技能</li>
<li>费用很高</li>
</ul>
</li>
</ul>
</li>
<li>自下而上的方法的:<ul>
<li>优点是<ul>
<li>实施快速而方便</li>
<li>良好的投资回报</li>
<li>失败的风险较小</li>
<li>渐进的，可以先建立重要的数据集市</li>
<li>项目团队可以从中学习和成长</li>
</ul>
</li>
<li>缺点是:<ul>
<li>每一个数据集市对数据的视角都比较窄</li>
<li>每个数据集市都有多余数据</li>
<li>总是有矛盾和不一致的数据</li>
<li>增加无法管理的接口</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>这种实用方法的步骤是这样的:<ul>
<li>从整个公司的角度来计划和定义需求</li>
<li>为完整的仓库创造一个体系结构</li>
<li>使数据内容一致而且标准化</li>
<li>将数据仓库作为一组数据集市来实施，每次一个</li>
</ul>
</li>
</ul>
</li>
<li><p>数据仓库中的元数据主要分为三类:</p>
<ul>
<li>操作型元数据<ul>
<li>数据仓库中的数据来自于企业中多个操作型系统。这些数据源系统包含了很多不同的数据结构，字段长度和数据类型也有不同。在这些数据中，你要对 不同来源的文件进行合并，解决编码和字段长度不同的问题。当你将这些信息传递给最终用 户的时候，你必须能将这些数据与最初的数据源联系起来。操作型元数据包含了所有操作型 数据源的信息。</li>
</ul>
</li>
<li>抽取和转换元数据<ul>
<li>抽取和转换元数据包含了源数据系统的信息，例如，抽取频率、抽 取方法和数据抽取的商业规则。而且，这一类的元数据包含了数据准备阶段数据转换的所有 信息。</li>
</ul>
</li>
<li>最终用户元数据<ul>
<li>最终用户元数据是数据仓库的向导。它使最终用户可以从数据仓库中 找到自己需要的信息。最终用户元数据允许最终用户使用自己商业终端和自己的习惯来查询 数据。</li>
</ul>
</li>
</ul>
</li>
<li><p>维表的更新</p>
<ul>
<li>事实表中的 数据却很少会改变。即便对以前的数字要作修改，这些修改的数据也会作为另外的修改行添 加到事实表中。</li>
<li>与事实表相比，维表要稳定的多。然而，与事实表只增加记录的 行数不一样的是，维表的变化不仅包括增加记录的行数，而且属性本身也会改变。</li>
</ul>
</li>
<li><p>慢速变化维</p>
<ul>
<li>通过考察修改维表的考虑因素，我们可以得出以下的原则:<ul>
<li>绝大部分的维都是不变的</li>
<li>很多维度虽然会变化，但是这种改变是缓慢的</li>
<li>源记录的产品键不会改变</li>
<li>产品描述以及其它的属性的改变都是缓慢的</li>
<li>在源OLTP系统中，新的值会覆盖旧的值</li>
<li>在数据仓库中，覆盖维表的属性并不总是适当的做法</li>
<li>修改维表的方法依赖于改变的方式，以及数据仓库中什么信息必须被保存。</li>
</ul>
</li>
<li>数据仓库的实践者对不同类型的修改采 用不同的技术。他们还为这 3 种修改维表的方式起了名字，分别称为第一类修改，第 2 类修 改，和第 3 类修改。<ul>
<li>第1类修改:改正错误。这些修改通常与修正源系统中的错误相关<ul>
<li>名称修改</li>
<li>通用原则:<ul>
<li>通常，这些修改与源系统中的改错有关;</li>
<li>这种修改在源系统中有时没有意义;</li>
<li>源系统中的旧的数值不能保留;</li>
<li>源系统中的修改不需要在数据仓库中保存。</li>
</ul>
</li>
<li>修改的方法是:<ul>
<li>用新的值覆盖维表中的旧数值</li>
<li>属性的旧数值不需要保留</li>
<li>对维表没有其它修改</li>
<li>维表中的键值不受影响</li>
<li>这类修改是最容易实施的</li>
</ul>
</li>
</ul>
</li>
<li>第2类修改:保存历史数据<ul>
<li>婚姻状态，住址迁移</li>
<li>以下是这一类修改 的原则:<ul>
<li>他们通常与源系统中的修改相关;</li>
<li>需要在数据仓库中保留历史数据</li>
<li>这一类修改将数据仓库中的历史数据分区</li>
<li>对属性的每一个修改都要保留</li>
</ul>
</li>
<li>修改方法是：<ul>
<li>在维表中增加一条新的记录，该记录存有修改后的数值</li>
<li>维表中可能会有一个有效日期字段</li>
<li>对原来维表中的原始记录没有作修改</li>
<li>原来的键不受影响</li>
<li>新的记录插入，该记录有一个新的替代键</li>
</ul>
</li>
</ul>
</li>
<li>第3类修改:暂时的(软性的)修改<ul>
<li>第3类修改的一些通用的原则:<ul>
<li>它们通常与源系统的临时修改相关</li>
<li>需要跟踪新旧两个属性值</li>
<li>新旧两个值用于比较改变所带来的效果</li>
<li>它们提供了前向和后向的跟踪能力</li>
</ul>
</li>
<li>第3类修改的方法如下:<ul>
<li>对受影响的属性，在维表中加入“旧的”字段</li>
<li>将“现有” 字段值赋值给“旧的”字段</li>
<li>将新的值赋给“现有”字段</li>
<li>加入一个“现有”有效日期</li>
<li>记录的键不受影响</li>
<li>不需要新的维表记录</li>
<li>现有的查询可以无缝的转换到“现有”的值</li>
<li>所有使用到“旧的”值的查询需要作相应的修改</li>
<li>这种技术对某段时期的临时修改最为适用</li>
<li>如果还有后续的修改，则需要使用更为复杂的技术</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>大维表。特别宽又特别深的维表</p>
<ul>
<li>多层次结构<ul>
<li>将大维度表分解成多个较为简单的小维度表</li>
<li>应该将快速变化的属性放到另一个维表中，而将缓慢变化的属性放在原来的表里面。</li>
</ul>
</li>
<li>废弃维度</li>
</ul>
</li>
<li><p>雪花模型</p>
<ul>
<li>使用雪花型结构的原因是明显的。通过减少维表中的所有长文本字段，你将节省存储空 间。</li>
<li>优势<ul>
<li>减少(很少的)存储空间</li>
<li>规范化的结构更容易更新和维护</li>
</ul>
</li>
<li>劣势<ul>
<li>模式比较复杂，用户不容易理解</li>
<li>浏览内容更为困难</li>
<li>额外的连接将使查询性能下降</li>
</ul>
</li>
<li>在数据仓库中，通常不推荐雪花化。在数据仓库中，查询性能极为重要，而雪花化将降低性能。</li>
<li>雪花化的原则是将维表中的低级的 属性移出，构建新的表。类似的，在一些情况下可以将一组属性分离，形成子维度。两个属 性集的粒度是不一样的。这个过程与雪花化技术很相像。</li>
</ul>
</li>
<li><p>事实表分层</p>
<ul>
<li>基础事实表</li>
<li>聚集事实表</li>
</ul>
</li>
<li><p>聚集事实表</p>
<ul>
<li>聚集是从最低粒度的事实表中衍生出来的预先计算的汇总数据。这些汇总数据形成了一 组独立的聚集事实表。你可以为一个特定的汇总构建一个聚集事实表</li>
<li>聚集事实表将最低粒度的数据通过维度层次结构汇总成更高层次的数据。</li>
<li>时间维度的层次结构最低的是天，最高的是年。商店维度的最低层次是城市，而产品维度的最低层次是产品。</li>
<li>多路聚集事实表<ul>
<li>如果从一个维度中的一个层次升到一个更高的层次，而在其它维度保持最低粒度，就生 成了一个单路聚集表</li>
</ul>
</li>
<li>你的汇总层次越高，稀疏程度比例就越高。</li>
<li>聚集策略的目标。除了提高数据仓库性能这个一般的目标之外，聚集还包括以下几个更实际的特定目标:<ul>
<li>不要陷在过多的聚集之中。记住，要支持聚集，需要额外的衍生维表。</li>
<li>尝试满足大多数用户的需求。尤其是你的高级用户。</li>
<li>建立聚集不能过多的增加存储容量。对具有较低稀疏比例的那些大型聚集要注意。</li>
<li>保持聚集对最终用户是不可见的。就是说，聚集必须对用户的查询是透明的。查询工具必须能够意识到聚集的存在，并正确的使用它。</li>
<li>尽量减少对数据缓存处理的影响。</li>
</ul>
</li>
</ul>
</li>
<li><p>星型模式族中的事实表共享维表。</p>
<ul>
<li>时间维表被族中的大多数事实表共享</li>
</ul>
</li>
<li><p>快照表和实务表</p>
<ul>
<li>财务数据仓库同样需要快照和事实表，这是由其分析特点决定的。这些数据仓库中，有 一类问题与“单独事务在一段特定时期中，如何影响某个特定账户”有关。而另一类问题则 关注特定时期期末特定账户的余额。事务表回答第一类问题;而快照则处理第 2 类问题。</li>
</ul>
</li>
<li><p>核心表和定制表</p>
</li>
<li><p>将事实标准化</p>
<ul>
<li>除了使维度一致之外，将事实标准化也是一个基本需求。我们知道，事实表可以跨越多 个星型模式。回顾一下的与事实表属性标准化相关的问题:<ul>
<li>保证在数据集市中的定义和术语是相同的</li>
<li>解决同名问题</li>
<li>需要标准化的类型包括利润，价格，成本，边际利润</li>
<li>保证每个事实表中所有的衍生单元使用同样的算法</li>
<li>保证每一个事实都使用正确的指标单位</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="0x18、数据迁移注意点"><a href="#0x18、数据迁移注意点" class="headerlink" title="0x18、数据迁移注意点"></a>0x18、数据迁移注意点</h2>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
