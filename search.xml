<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    
    <entry>
      <title></title>
      <link href="tools/httpie.html"/>
      <url>tools/httpie.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/nmap%E6%96%87%E6%A1%A3.html"/>
      <url>tools/nmap%E6%96%87%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="about/index.html"/>
      <url>about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="algorithms/index.html"/>
      <url>algorithms/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><ul><li><a href="basic.html">基础</a></li><li><a href="sort.html">排序算法</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="books/index.html"/>
      <url>books/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><ul><li><a href="deep-analysis-distributed-cache">深入分布式缓存:从原理到实践</a></li><li><a href="every-day-five-minutes-k8s">每天5分钟玩转kubernetes</a></li></ul><h2 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h2><ul><li><a href="gopl.html">go语言程序设计</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="categories/index.html"/>
      <url>categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/docker.html"/>
      <url>interview/docker.html</url>
      
        <content type="html"><![CDATA[<ul><li>docker进入到内部，停止内部启动docker时的进程，则docker会自动退出，然后docker停止。</li></ul><h3 id="docker的run、create、start的区别。"><a href="#docker的run、create、start的区别。" class="headerlink" title="docker的run、create、start的区别。"></a>docker的run、create、start的区别。</h3><ul><li>docker run相当于执行了两步操作：将镜像放入容器中（docker create）,然后将容器启动，使之变成运行时容器（docker start）。</li><li>docker start的作用是，重新启动已存在的镜像。也就是说，如果使用这个命令，我们必须事先知道这个容器的ID，或者这个容器的名字，我们可以使用docker ps找到这个容器的信息。</li><li>docker create是只创建容器，不启动。create不能后台运行，也就是不能有<code>-d</code>参数</li></ul><h3 id="写出一条创建容器运行的命令，并解释其参数"><a href="#写出一条创建容器运行的命令，并解释其参数" class="headerlink" title="写出一条创建容器运行的命令，并解释其参数"></a>写出一条创建容器运行的命令，并解释其参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --mount type&#x3D;bind,src&#x3D;&#x2F;data&#x2F;logs&#x2F;project,dst&#x3D;&#x2F;home&#x2F;log --name service_name -e token&#x3D;token_str image_name &#x2F;bin&#x2F;sh -c &quot;python main.py&quot;</span><br></pre></td></tr></table></figure><ul><li>-d:表示后台运行</li><li>–mount:挂在目录，让容器和主机共享目录</li><li>–name:运行的容器的名称</li><li>-e:添加环境变量</li></ul><h3 id="显示正在运行的容器"><a href="#显示正在运行的容器" class="headerlink" title="显示正在运行的容器"></a>显示正在运行的容器</h3><ul><li>docker ps</li></ul><h3 id="重命名容器"><a href="#重命名容器" class="headerlink" title="重命名容器"></a>重命名容器</h3><ul><li>docker rename old_name new_name</li><li>无论容器是运行还是停止，都可以进行重命名。过后就用新名称来操作就可用了。</li></ul><h3 id="启动中的容器可以直接删除吗"><a href="#启动中的容器可以直接删除吗" class="headerlink" title="启动中的容器可以直接删除吗"></a>启动中的容器可以直接删除吗</h3><ul><li>启动中的容器不允许直接删除，必须要先停止，在删除。</li></ul><h3 id="docker-service是干什么的？"><a href="#docker-service是干什么的？" class="headerlink" title="docker service是干什么的？"></a>docker service是干什么的？</h3><ul><li>docker swarm集群的管理工具</li></ul><h3 id="列出所有容器ID"><a href="#列出所有容器ID" class="headerlink" title="列出所有容器ID"></a>列出所有容器ID</h3><p>docker ps -aq</p><h3 id="查看所有运行或者不运行容器"><a href="#查看所有运行或者不运行容器" class="headerlink" title="查看所有运行或者不运行容器"></a>查看所有运行或者不运行容器</h3><p>docker ps -a</p><h3 id="停止所有的container（容器），这样才能够删除其中的images："><a href="#停止所有的container（容器），这样才能够删除其中的images：" class="headerlink" title="停止所有的container（容器），这样才能够删除其中的images："></a>停止所有的container（容器），这样才能够删除其中的images：</h3><p>docker stop $(docker ps -a -q) 或者 docker stop $(docker ps -aq)</p><h3 id="删除container（容器）："><a href="#删除container（容器）：" class="headerlink" title="删除container（容器）："></a>删除container（容器）：</h3><ul><li>删除停止运行的容器<br>  docker rm $(docker ps -a -q) 或者 docker rm $(docker ps -aq)</li><li>删除运行中的容器<br>  docker rm -f $(docker ps -a -q) 或者 docker rm -f $(docker ps -aq)</li></ul><h3 id="查看当前有些什么images"><a href="#查看当前有些什么images" class="headerlink" title="查看当前有些什么images"></a>查看当前有些什么images</h3><p>docker images</p><h3 id="删除images（镜像），通过image的id来指定删除谁"><a href="#删除images（镜像），通过image的id来指定删除谁" class="headerlink" title="删除images（镜像），通过image的id来指定删除谁"></a>删除images（镜像），通过image的id来指定删除谁</h3><p>docker rmi <image id></p><h3 id="想要删除untagged-images，也就是那些id为的image的话可以用"><a href="#想要删除untagged-images，也就是那些id为的image的话可以用" class="headerlink" title="想要删除untagged images，也就是那些id为的image的话可以用"></a>想要删除untagged images，也就是那些id为的image的话可以用</h3><p>docker rmi $(docker images | grep “^<none>“ | awk “{print $3}”)</p><h3 id="要删除全部image（镜像）的话"><a href="#要删除全部image（镜像）的话" class="headerlink" title="要删除全部image（镜像）的话"></a>要删除全部image（镜像）的话</h3><p>docker rmi $(docker images -q)</p><h3 id="强制删除全部image的话"><a href="#强制删除全部image的话" class="headerlink" title="强制删除全部image的话"></a>强制删除全部image的话</h3><p>docker rmi -f $(docker images -q)</p><h3 id="从容器到宿主机复制"><a href="#从容器到宿主机复制" class="headerlink" title="从容器到宿主机复制"></a>从容器到宿主机复制</h3><p> docker cp tomcat：/webapps/js/text.js /home/admin<br> docker  cp 容器名:  容器路径       宿主机路径</p><h3 id="从宿主机到容器复制"><a href="#从宿主机到容器复制" class="headerlink" title="从宿主机到容器复制"></a>从宿主机到容器复制</h3><p> docker cp /home/admin/text.js tomcat：/webapps/js<br> docker cp 宿主路径中文件      容器名  容器路径</p><h3 id="删除所有停止的容器"><a href="#删除所有停止的容器" class="headerlink" title="删除所有停止的容器"></a>删除所有停止的容器</h3><p>docker container prune</p><h3 id="删除所有不使用的镜像"><a href="#删除所有不使用的镜像" class="headerlink" title="删除所有不使用的镜像"></a>删除所有不使用的镜像</h3><p>docker image prune –force –all<br>docker image prune -f -a</p><h3 id="停止、启动、杀死、重启一个容器"><a href="#停止、启动、杀死、重启一个容器" class="headerlink" title="停止、启动、杀死、重启一个容器"></a>停止、启动、杀死、重启一个容器</h3><p>docker stop Name或者ID<br>docker start Name或者ID<br>docker kill Name或者ID<br>docker restart name或者ID</p><h3 id="docker进入容器，查看配置文件"><a href="#docker进入容器，查看配置文件" class="headerlink" title="docker进入容器，查看配置文件"></a>docker进入容器，查看配置文件</h3><p>docker exec ：在运行的容器中执行命令<br>        -d :分离模式: 在后台运行<br>        -i :即使没有附加也保持STDIN（标准输入） 打开,以交互模式运行容器，通常与 -t 同时使用；<br>        -t: 为容器重新分配一个伪输入终端，通常与 -i 同时使用；<br>docker exec -it  容器id或容器名称 /bin/bash</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="interview/index.html"/>
      <url>interview/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h3 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><a href="cs/index.html">计算机基础</a></h3><ul><li><a href="cs/basic.html">基础</a></li><li><a href="cs/os.html">操作系统</a></li></ul><h3 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="backend/index.md">后端</a></h3><ul><li><a href="backend/python.html">python</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a href="storage/index.html">数据库</a></h3><ul><li><a href="storage/basic.html">基础</a></li><li><a href="storage/mysql.html">mysql</a></li></ul><h3 id="前端"><a href="#前端" class="headerlink" title="前端"></a><a href="frontend/index.md">前端</a></h3><ul><li><a href="frontend/basic.html">大前端</a></li><li><a href="frontend/js.html">js</a></li><li><a href="frontend/vue.html">vue</a></li><li><a href="frontend/css.html">css</a></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a href="net/index.html">网络</a></h3><ul><li><a href="net/basic.html">基础</a></li><li><a href="net/http.html">http</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%9C%8D%E5%8A%A1%E5%99%A8.html"/>
      <url>interview/%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<h3 id="Apache与Nginx的优缺点比较"><a href="#Apache与Nginx的优缺点比较" class="headerlink" title="Apache与Nginx的优缺点比较"></a>Apache与Nginx的优缺点比较</h3><ul><li>1、nginx相对于apache的优点：<ul><li>轻量级，比apache 占用更少的内存及资源。高度模块化的设计，编写模块相对简单</li><li>抗并发，nginx 处理请求是异步非阻塞，多个连接（万级别）可以对应一个进程，而apache 则是阻塞型的，是同步多进程模型，一个连接对应一个进程，在高并发下nginx 能保持低资源低消耗高性能</li><li>nginx处理静态文件好，Nginx 静态处理性能比 Apache 高 3倍以上</li></ul></li><li>2、apache 相对于nginx 的优点：<ul><li>apache 的rewrite 比nginx 的rewrite 强大 ，模块非常多，基本想到的都可以找到 ，比较稳定，少bug ，nginx 的bug 相对较多</li></ul></li><li>3、原因：这得益于Nginx使用了最新的epoll（Linux 2.6内核）和kqueue（freebsd）网络I/O模型，而Apache则使用的是传统的select模型。目前Linux下能够承受高并发访问的 Squid、Memcached都采用的是epoll网络I/O模型。 处理大量的连接的读写，Apache所用的select网络I/O模型非常低效。</li></ul><h3 id="cgi与fastcgi的区别"><a href="#cgi与fastcgi的区别" class="headerlink" title="cgi与fastcgi的区别"></a>cgi与fastcgi的区别</h3><ul><li>cgi在2000年或更早的时候用得比较多， 以前web服务器一般只处理静态的请求，web服务器会根据这次请求的内容，然后会fork一个新进程来运行外部c程序 （或perl脚本…）， 这个进程会把处理完的数据返回给web服务器，最后web服务器把内容发送给用户，刚才fork的程也随之退出。 如果下次用户还请求改动态脚本，那么web服务器又再次fork一个新进程，周而复始的进行。</li><li>后来出现了一种更高级的方式是， web服务器可以内置perl解释器或php解释器。 也就是说这些解释器做成模块的方式，web服务器会在启动的时候就启动这些解释器。 当有新的动态请求进来时，web服务器就是自己解析这些perl或php脚本，省得重新fork一个进程，效率提了。</li><li>fastcgi的方式是，web服务器收到一个请求时，他不会重新fork一个进程（因为这个进程在web服务器启动时就开启了，而且不会退出），web服务器直接把内容传递给这个进程（进程间通信，但fastcgi使用了别的方式，tcp方式通信），这个进程收到请求后进行处理，把结果回给web服务器，最后自己接着等待下一个请求的到来，而不是退出。</li><li>在对数据进行处理的进程方面<ul><li>cgi<ul><li>fork一个新的进程进行处理。读取参数，处理数据，然后就结束生命期</li></ul></li><li>fastcgi<ul><li>用tcp方式跟远程机子上的进程或本地进程建立连接。要开启tcp端口，进入循环，等待数据的到来，处理数据</li></ul></li><li>举个例子: 服务端现在有个10万个字单词， 客户每次会发来一个字符串，问以这个字符串为前缀的单词有多少个。 那么可以写一个程序，这个程序会建一棵trie树，然后每次用户请求过来时可以直接到这个trie去查找。 但是如果以cgi的方式的话，这次请求结束后这课trie也就没了，等下次再启动该进程时，又要新建一棵trie树，这样的效率就太低下了。   而用fastcgi的方式的话，这课trie树在进程启动时建立，以后就可以直接在trie树上查询指定的前缀了。</li></ul></li></ul><h3 id="待处理的问题"><a href="#待处理的问题" class="headerlink" title="待处理的问题"></a>待处理的问题</h3><ul><li>nginx使用哪种网络协议</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>interview/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<ul><li>正则表达式如何判断非空</li><li>匹配中文字符的正则表达式</li><li>匹配双字节字符(包括汉字在内)</li><li>匹配空行的正则表达式</li><li>匹配HTML标记的正则表达式</li><li>匹配首尾空格的正则表达式</li><li>匹配Email地址的正则表达式</li><li>匹配网址URL的正则表达式</li><li>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)</li><li>匹配国内电话号码</li><li>匹配腾讯QQ号</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE.html"/>
      <url>interview/%E7%BB%BC%E5%90%88%E9%A1%B9%E7%9B%AE.html</url>
      
        <content type="html"><![CDATA[<ol><li>项目中遇到的困难（提前想好，并且把实现或者优化方法说清楚）</li><li>系统的量级、pv、uv等</li><li>应对高并发的解决办法（分布式）</li><li>在项目中主要负责了哪些工作。</li><li>nginx的负载均衡</li><li>分布式缓存的一致性，服务器如何扩容（哈希环</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E7%BD%91%E7%BB%9C.html"/>
      <url>interview/%E7%BD%91%E7%BB%9C.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul><li><ol><li>TCP报头格式</li></ol></li><li><ol start="2"><li>UDP报头格式</li></ol></li><li><ol start="3"><li>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</li></ol></li><li><ol start="4"><li>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</li></ol></li><li><ol start="5"><li>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</li></ol></li><li><ol start="6"><li>OSI协议、TCP/IP协议以及每层对应的协议。</li></ol></li><li><ol start="7"><li>SESSION机制、cookie机制</li></ol></li><li><ol start="8"><li>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</li></ol></li><li><ol start="9"><li>打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</li></ol></li><li><ol start="10"><li>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</li></ol></li><li><ol start="11"><li>IP地址子网划分</li></ol></li><li><ol start="12"><li>POST和GET区别</li></ol></li><li><ol start="13"><li>DNS解析过程</li></ol></li></ul><h2 id="深入部分"><a href="#深入部分" class="headerlink" title="深入部分"></a>深入部分</h2><ul><li><ol start="14"><li>TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）</li></ol></li><li><ol start="15"><li>地址解析协议ARP</li></ol></li><li><ol start="16"><li>交换机和路由器的区别</li></ol></li></ul><h3 id="HTTP-Keep-Alive的作用及应用场景"><a href="#HTTP-Keep-Alive的作用及应用场景" class="headerlink" title="HTTP Keep-Alive的作用及应用场景"></a>HTTP Keep-Alive的作用及应用场景</h3><ul><li>作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。</li><li>缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。</li><li>解决：Keep-Alive: timeout=5, max=100。timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</li></ul><h3 id="表单中-get与post提交方法的区别"><a href="#表单中-get与post提交方法的区别" class="headerlink" title="表单中 get与post提交方法的区别?"></a>表单中 get与post提交方法的区别?</h3><ul><li>get是发送请求HTTP协议通过url参数传递进行接收；数据量小；不太安全</li><li>post是实体数据,可以通过表单提交大量信息；数据量大；安全</li></ul><h3 id="下列HTTP状态码出现的可能原因-如何处理"><a href="#下列HTTP状态码出现的可能原因-如何处理" class="headerlink" title="下列HTTP状态码出现的可能原因, 如何处理"></a>下列HTTP状态码出现的可能原因, 如何处理</h3><ul><li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li><li>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li><li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li><li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。</li></ul><h3 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h3><h3 id="端口个数为什么是65535个？"><a href="#端口个数为什么是65535个？" class="headerlink" title="端口个数为什么是65535个？"></a>端口个数为什么是65535个？</h3><ul><li>在TCP、UDP协议的开头，会分别有16位来存储源端口号和目标端口号，所以端口个数是2^16-1=65535个。</li><li>端口被设计出来主要是为了给协议栈和应用对应：<ul><li>协议栈用端口号将数据分配给不同的应用层程序</li><li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li></ul></li></ul><h3 id="端口状态有哪些"><a href="#端口状态有哪些" class="headerlink" title="端口状态有哪些"></a>端口状态有哪些</h3><ul><li>1、LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。</li><li>2、ESTABLISHED状态。ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li><li>3、CLOSE_WAIT。对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li><li>4、TIME_WAIT<ul><li>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</li><li>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li></ul></li><li>5、SYN_SENT状态<ul><li>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</li></ul></li></ul><h3 id="http的s加密是在哪一层，如何处理的。"><a href="#http的s加密是在哪一层，如何处理的。" class="headerlink" title="http的s加密是在哪一层，如何处理的。"></a>http的s加密是在哪一层，如何处理的。</h3><ul><li>s指的是SSL或TLS加密。因为http是明文传输，为了数据安全，在应用层与传输层中间添加一个加密层来加密数据的传输。</li><li>这个加密用了对称加密和非对称加密的结合。</li></ul><h3 id="什么是socket，为什么要有socket。"><a href="#什么是socket，为什么要有socket。" class="headerlink" title="什么是socket，为什么要有socket。"></a>什么是socket，为什么要有socket。</h3><ul><li>socket是传输层协议的分装，让应用层更方便的进行网络编程。</li></ul><h3 id="urlencode和urldecode何时使用，有什么作用？"><a href="#urlencode和urldecode何时使用，有什么作用？" class="headerlink" title="urlencode和urldecode何时使用，有什么作用？"></a>urlencode和urldecode何时使用，有什么作用？</h3><ul><li>url中合法的字符有两大类<ul><li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li><li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（），圆括号（()`）</li></ul></li><li>用来传输中文编码，转换成统一安全字符格式。</li></ul><h3 id="python中如何使用urlencode和urldecode。"><a href="#python中如何使用urlencode和urldecode。" class="headerlink" title="python中如何使用urlencode和urldecode。"></a>python中如何使用urlencode和urldecode。</h3><ul><li>urllib.parse.quote(str,  safe=’/‘)<ul><li>http%3A//<a href="http://www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>urllib.parse.quote(str,  safe=’/:?=’)<ul><li><a href="http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>如上，默认会处理一些非中文字符串情况，所以可以对中文进行单独转义既可</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html"/>
      <url>interview/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<ul><li><ol><li>接口和抽象类区别</li></ol></li><li><ol start="2"><li>单继承</li></ol></li><li><ol start="3"><li>construct的调用顺序（子类父类之间）</li></ol></li><li><ol start="4"><li>设计模式（工厂模式、策略模式、单例模式、装饰模式比较常见）</li></ol></li><li><ol start="5"><li>OOP特性，通过哪些机制实现的</li></ol></li><li><ol start="6"><li>重写和重载区别</li></ol></li><li><ol start="7"><li>静态类静态方法</li></ol></li><li><ol start="8"><li>根据某个需求设计一个类（主要考虑类之间的继承关系和属性的权限设置）</li></ol></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91.html"/>
      <url>interview/%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<ol><li>项目中遇到的困难（提前想好，并且把实现或者优化方法说清楚）</li><li>系统的量级、pv、uv等</li><li>应对高并发的解决办法（分布式）</li><li>在项目中主要负责了哪些工作。</li><li>nginx的负载均衡</li><li>分布式缓存的一致性，服务器如何扩容（哈希环</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>手册</title>
      <link href="man/index.html"/>
      <url>man/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul><li><a href="python/basic.html">基础</a></li><li><a href="python/os.html">操作系统</a></li><li><a href="python/thread.html">线程与进程</a></li><li><a href="python/net.html">网络</a></li><li><a href="python/class.html">面向对象</a></li><li><a href="python/async.html">异步</a></li><li><a href="python/lib.html">库</a></li><li><a href="python/lib-collection.html">库-集合</a></li><li><a href="python/lib-dbutils.html">库-DBUtils</a></li><li><a href="python/lib-nameko.html">库-nameko</a></li><li><a href="python/lib-pymysql.html">库-pymysql</a></li><li><a href="python/lib-redis.html">库-redis</a></li><li><a href="python/lib-sqlalchemy.html">库-sqlalchemy</a></li></ul><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><ul><li><a href="rust/basic.html">基础</a></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="linux/commands.html">常用命令</a></li><li><a href="linux/crontab.html">定时任务</a></li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li><a href="docker/commands.html">常用命令</a></li></ul><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul><li>1.<a href="mysql/basic.html">架构介绍</a></li><li>2.<a href="mysql/commands.html">常用命令</a></li><li>3.<a href="mysql/character.html">编码类型</a></li><li>4.<a href="mysql/column_type.html">字段类型</a></li><li>5.<a href="mysql/transaction.html">事务处理</a></li><li>6.<a href="mysql/indexed.html">索引介绍</a></li></ul><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul><li><a href="vim/commands.html">常用命令</a></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="git/commands.html">常用命令</a></li></ul><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><ul><li><a href="django/model.html">django ORM常用操作</a></li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li><a href="chip/basic.md">芯片</a></li></ul><h2 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h2><ul><li><a href="storage/hbase/hbase简介">hbase</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/hive.html"/>
      <url>interview/hive.html</url>
      
        <content type="html"><![CDATA[<ul><li>Hive 原理<ul><li><ol><li>用户提交查询等任务给Driver。</li></ol></li><li><ol start="2"><li>编译器获得该用户的任务Plan。</li></ol></li><li><ol start="3"><li>编译器Compiler根据用户任务去MetaStore中获取需要的Hive的元数据信息。</li></ol></li><li><ol start="4"><li>编译器Compiler得到元数据信息，对任务进行编译，先将HiveQL转换为抽象语法树，然后将抽象语法树转换成查询块，将查询块转化为逻辑的查询计划，重写逻辑查询计划，将逻辑计划转化为物理的计划（MapReduce）, 最后选择最佳的策略。</li></ol></li><li><ol start="5"><li>将最终的计划提交给Driver。</li></ol></li><li><ol start="6"><li>Driver将计划Plan转交给ExecutionEngine去执行，获取元数据信息，提交给JobTracker或者SourceManager执行该任务，任务会直接读取HDFS中文件进行相应的操作。</li></ol></li><li><ol start="7"><li>获取执行的结果。</li></ol></li><li><ol start="8"><li>取得并返回执行结果。</li></ol></li></ul></li><li>Hive数据倾斜问题<ul><li>1.1)key分布不均匀</li><li>1.2)业务数据本身的</li><li>1.3)SQL语句造成数据倾斜</li><li>1&gt;参数调节：<ul><li>hive.map.aggr=true</li><li>hive.groupby.skewindata=true</li></ul></li><li>2&gt;SQL语句调节：<ul><li>1)选用join key 分布最均匀的表作为驱动表。做好列裁剪和filter操作，以达到两表join的时候，数据量相对变小的效果。</li><li>2)大小表Join： 使用map join让小的维度表（1000条以下的记录条数）先进内存。在Map端完成Reduce。</li><li>3)大表Join大表：把空值的Key变成一个字符串加上一个随机数，把倾斜的数据分到不同的reduce上，由于null值关联不上，处理后并不影响最终的结果。</li><li>4)count distinct大量相同特殊值：count distinct时，将值为空的情况单独处理，如果是计算count distinct，可以不用处理，直接过滤，在做后结果中加1。如果还有其他计算，需要进行group by，可以先将值为空的记录单独处理，再和其他计算结果进行union.</li></ul></li></ul></li><li>Mapreduce和hive的区别和联系<ul><li>hive是基于hadoop的数据仓库</li><li>那么为什么说hive是基于Hadoop的呢？<ul><li>之所以说hive是构建在Hadoop之上的数据仓库，简单的说是因为：</li><li>①数据存储在hdfs上</li><li>②数据计算用mapreduce</li></ul></li><li>Hive是一种建立在Hadoop文件系统上的数据仓库架构，并对存储在HDFS中的数据进行分析和管理；它可以将结构化的数据文件映射为一张数据库表，并提供完整的 SQL 查询功能，可以将 SQL 语句转换为 MapReduce 任务进行运行，通过自己的 SQL 去查询分析需要的内容，这套 SQL 简称 Hive SQL（HQL），使不熟悉MapReduce 的用户也能很方便地利用 SQL 语言对数据进行查询、汇总、分析。</li><li>Hive不支持更改数据的操作，Hive基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为MapReduce程序，在hadoop上运行，数据存储在HDFS上。</li></ul></li><li>HIVE与RDBMS关系数据库的区别<ul><li>1、hive存储的数据量比较大，适合海量数据，适合存储轨迹类历史数据，适合用来做离线分析、数据挖掘运算，事务性较差，实时性较差 ;rdbms一般数据量相对来说不会太大，适合事务性计算，实时性较好，更加接近上层业务</li><li>2、hive的计算引擎是hadoop的mapreduce，存储是hadoop的hdfs文件系统;rdbms的引擎由数据库自己设计实现例如mysql的innoDB，存储用的是数据库服务器本地的文件系统</li><li>3、hive由于基于hadoop所以存储和计算的扩展能力都很好;rdbms在这方面比较弱，比如orcale的分表和扩容就很头疼</li><li>4、hive表格没有主键、没有索引、不支持对具体某一行的操作，适合对批量数据的操作，不支持对数据的update操作，更新的话一般是先删除表然后重新落数据；rdbms事务性强，有主键、索引，支持对具体某一行的增删改查等操作</li><li>5、hive的SQL为HQL，与标准的RDBMS的SQL存在有不少的区别，相对来说功能有限；rdbms的SQL为标准SQL，功能较为强大。</li></ul></li><li>hive中的存储方式<ul><li>1.textfile<ul><li>Hive的默认存储格式<ul><li>存储方式：行存储</li><li>磁盘开销大数据解析开销大</li><li>压缩的text文件 hive无法进行合并和拆分</li></ul></li></ul></li><li>2.SequenceFile<ul><li>二进制文件以key,value的形式序列化到文件中</li><li>存储方式：行存储</li><li>可分割压缩</li><li>一般选择block压缩</li><li>优势是文件和Hadoop api中的mapfile是相互兼容的</li></ul></li><li>3.rcfile<ul><li>存储方式：数据按行分块每块按照列存储</li><li>压缩快快速列存取</li><li>读记录尽量涉及到的block最少</li><li>读取需要的列只需要读取每个row group 的头部定义。</li><li>读取全量数据的操作性能可能比sequencefile没有明显的优势</li></ul></li><li>4.orc<ul><li>存储方式：数据按行分块每块按照列存储</li><li>压缩快快速列存取</li><li>效率比rcfile高,是rcfile的改良版本</li></ul></li><li>5.自定义格式<ul><li>用户可以通过实现inputformat和 outputformat来自定义输入输出格式</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>资源</title>
      <link href="resource/index.html"/>
      <url>resource/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、电子书"><a href="#0x00、电子书" class="headerlink" title="0x00、电子书"></a>0x00、电子书</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">现代操作系统_第三版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf" target="_blank" rel="noopener">Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">Linux内核设计与实现_第三版.pdf</a></li></ul><h3 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h3><h4 id="2-1-python"><a href="#2-1-python" class="headerlink" title="2.1 python"></a>2.1 python</h4><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">python核心编程.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86.pdf" target="_blank" rel="noopener">Python网络数据采集.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/OReilly.Web.Scraping.with.Python.2015.6.pdf" target="_blank" rel="noopener">OReilly.Web.Scraping.with.Python.2015.6.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Machine%20Learning%20in%20Python.pdf" target="_blank" rel="noopener">Machine Learning in Python.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/The%20Django%20Book%202.0%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">The Django Book 2.0中文版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/%E3%80%8APython%20Cookbook%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E4%B8%AD%E6%96%87.pdf" target="_blank" rel="noopener">《Python Cookbook》第三版中文.pdf</a></li></ul><h4 id="2-2-golang"><a href="#2-2-golang" class="headerlink" title="2.2 golang"></a>2.2 golang</h4><ul><li><a href="http://www.gopl.io/" target="_blank" rel="noopener">go语言开发设计(原版)</a>, <a href="https://docs.hacknode.org/gopl-zh/" target="_blank" rel="noopener">go语言开发设计(中文版)</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/build-web-application-with-golang-en.pdf" target="_blank" rel="noopener">build-web-application-with-golang-en.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/effective-go-zh-en.pdf" target="_blank" rel="noopener">effective-go-zh-en.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">go高级编程.pdf</a></li></ul><h4 id="2-3-c"><a href="#2-3-c" class="headerlink" title="2.3 c++"></a>2.3 c++</h4><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/C%2B%2B/C%2B%2BPrimer%E7%AC%AC%E4%BA%94%E7%89%88.pdf" target="_blank" rel="noopener">C++Primer第五版.pdf</a></li></ul><h3 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3.数据库"></a>3.数据库</h3><h3 id="4-架构"><a href="#4-架构" class="headerlink" title="4.架构"></a>4.架构</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.pdf" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">Web性能权威指南.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Recommender%2BSystems%2BHandbook.pdf" target="_blank" rel="noopener">Recommender+Systems+Handbook.pdf</a></li><li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念及设计(第五版)</a></li></ul><h3 id="5-前端"><a href="#5-前端" class="headerlink" title="5.前端"></a>5.前端</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/javascript/%5BJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC6%E7%89%88)%5D.(JavaScript%EF%BC%9AThe.Definitive.Guide).David.Flanagan.%E6%96%87%E5%AD%97%E7%89%88.pdf" target="_blank" rel="noopener">JavaScript权威指南(第6版)</a></li></ul><h3 id="6-大数据"><a href="#6-大数据" class="headerlink" title="6.大数据"></a>6.大数据</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%9F%BA%E7%A1%80.pdf" target="_blank" rel="noopener">数据仓库基础.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E7%AC%AC%E5%9B%9B%E7%89%88.pdf" target="_blank" rel="noopener">数据仓库_第四版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/DW2.0%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%9E%84%E6%9E%B6.pdf" target="_blank" rel="noopener">DW2.0下一代数据仓库的构架.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The%20Data%20Warehouse%20Toolkit%2C%203rd%20Edition.pdf" target="_blank" rel="noopener">The Data Warehouse Toolkit, 3rd Edition.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The_Data_Warehouse_Lifecycle_Toolkit(Second%20Edition).pdf" target="_blank" rel="noopener">The_Data_Warehouse_Lifecycle_Toolkit(Second Edition).pdf</a></li></ul><h3 id="7-人工智能"><a href="#7-人工智能" class="headerlink" title="7.人工智能"></a>7.人工智能</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">神经网络与机器学习（原书第3版）.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%AE%BA.pdf" target="_blank" rel="noopener">自然语言处理综论.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%AF%AD%E4%B9%89%E7%BD%91%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.pdf" target="_blank" rel="noopener">语义网基础教程.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/PYTHON%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86.pdf" target="_blank" rel="noopener">PYTHON自然语言处理.pdf</a></li></ul><h3 id="8-网络"><a href="#8-网络" class="headerlink" title="8.网络"></a>8.网络</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">HTTP权威指南.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷1：协议.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B72%EF%BC%9A%E5%AE%9E%E7%8E%B0.pdf" target="_blank" rel="noopener">TCP_IP详解卷2：实现.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B73%EF%BC%9ATCP%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%AE%AE%EF%BC%8CHTTP%EF%BC%8CNNTP%E5%92%8CUNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷3：TCP事务协议，HTTP，NNTP和UNIX域协议.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP.pdf" target="_blank" rel="noopener">图解HTTP.pdf</a></li></ul><h3 id="9-算法"><a href="#9-算法" class="headerlink" title="9.算法"></a>9.算法</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/Algorithms%2C%204th%20Edition(%E7%AE%97%E6%B3%95%EF%BC%8C%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%8C%E8%8B%B1%E6%96%87%E7%89%88).pdf" target="_blank" rel="noopener">Algorithms, 4th Edition(算法，第四版，英文版).pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80_%E7%AC%AC3%E7%89%88.pdf" target="_blank" rel="noopener">算法设计与分析基础_第3版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/leetcode-solution.pdf" target="_blank" rel="noopener">leetcode-solution.pdf</a></li></ul><h3 id="99-数学"><a href="#99-数学" class="headerlink" title="99.数学"></a>99.数学</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%20%E5%8E%9F%E4%B9%A6%E7%AC%AC5%E7%89%88.pdf" target="_blank" rel="noopener">组合数学 原书第5版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E5%AD%A6/%5B%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8(%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%83%E7%89%88)%5DDiscrete%20Mathematics%20and%20Its%20Applications%20(7th).pdf" target="_blank" rel="noopener">离散数学及其应用(英文第七版)</a></li></ul><h2 id="0x01、视频教程"><a href="#0x01、视频教程" class="headerlink" title="0x01、视频教程"></a>0x01、视频教程</h2><h2 id="0x02、论文"><a href="#0x02、论文" class="headerlink" title="0x02、论文"></a>0x02、论文</h2><ul><li><a href="https://github.com/papers-we-love/papers-we-love" target="_blank" rel="noopener">papers-we-love</a></li></ul><h3 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1.分布式"></a>1.分布式</h3><ul><li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li></ul><h2 id="0x02、github图书库"><a href="#0x02、github图书库" class="headerlink" title="0x02、github图书库"></a>0x02、github图书库</h2><ul><li><a href="https://github.com/xsoer/learn-files" target="_blank" rel="noopener">https://github.com/xsoer/learn-files</a></li><li><a href="https://github.com/royeo/free-programming-books.pdf" target="_blank" rel="noopener">https://github.com/royeo/free-programming-books.pdf</a></li><li><a href="https://github.com/threerocks/studyFiles" target="_blank" rel="noopener">https://github.com/threerocks/studyFiles</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></li><li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="noopener">https://github.com/it-ebooks/it-ebooks-archive</a></li><li><a href="https://github.com/shivam-jha/DockerBooks" target="_blank" rel="noopener">https://github.com/shivam-jha/DockerBooks</a></li><li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md</a></li><li><a href="https://github.com/zhiwoeryi/eBook-3" target="_blank" rel="noopener">https://github.com/zhiwoeryi/eBook-3</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>kudu简介</title>
      <link href="math/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"/>
      <url>math/%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="0x00、整体简介"><a href="#0x00、整体简介" class="headerlink" title="0x00、整体简介"></a>0x00、整体简介</h1><ul><li>向量</li><li>矩阵</li><li>导数</li><li>数值计算</li><li>概率分布</li><li>参数估计</li><li>回归分析</li><li>判断问题</li></ul><h1 id="0x01、向量"><a href="#0x01、向量" class="headerlink" title="0x01、向量"></a>0x01、向量</h1><h1 id="0x02、矩阵"><a href="#0x02、矩阵" class="headerlink" title="0x02、矩阵"></a>0x02、矩阵</h1><h1 id="0x03、导数"><a href="#0x03、导数" class="headerlink" title="0x03、导数"></a>0x03、导数</h1><h1 id="0x04、数值计算"><a href="#0x04、数值计算" class="headerlink" title="0x04、数值计算"></a>0x04、数值计算</h1><h1 id="0x05、概率分布"><a href="#0x05、概率分布" class="headerlink" title="0x05、概率分布"></a>0x05、概率分布</h1><h1 id="0x06、参数估计"><a href="#0x06、参数估计" class="headerlink" title="0x06、参数估计"></a>0x06、参数估计</h1><h1 id="0x07、回归分析"><a href="#0x07、回归分析" class="headerlink" title="0x07、回归分析"></a>0x07、回归分析</h1><h1 id="0x08、判断问题"><a href="#0x08、判断问题" class="headerlink" title="0x08、判断问题"></a>0x08、判断问题</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="tags/index.html"/>
      <url>tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/curl.html"/>
      <url>tools/curl.html</url>
      
        <content type="html"><![CDATA[<p>cur是一个命令行工具</p><ul><li>-A<ul><li>设置请求的agent</li></ul></li><li>b</li><li>-H<ul><li>设置请求的header</li></ul></li><li>-s<ul><li>slince</li></ul></li><li>-S<ul><li>Show errors even when use -s</li></ul></li><li>-f<ul><li>fail</li></ul></li><li>-X<ul><li>用的请求方法</li><li>GET、POST</li></ul></li><li>-u, –user</li><li>-v, –verbose<ul><li>verbose，打印详细的请求</li></ul></li><li>—trace-back<ul><li>追踪请求</li></ul></li><li>-o<ul><li>–output</li><li>把请求的信息输出到文件</li></ul></li><li>-V, –version<ul><li>打印版本信息</li></ul></li><li>-t, –telnet-option</li></ul><ul><li><p><a href="https://curl.haxx.se/docs/manual.html" target="_blank" rel="noopener">文档</a></p></li><li><p>打印请求时长</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -H "X-REQ:MINIPRO" -w 'time_connect %&#123;time_connect&#125;\ntime_starttransfer %&#123;time_starttransfer&#125;\ntime_total %&#123;time_total&#125;\n'  http://local-mobile.funji.club/api/minipro/home/pk-park/</span><br></pre></td></tr></table></figure></li></ul><p>1）新建一个curl.txt文件，写入如下待确认的选项：<br>http_code: %{http_code}\n<br>content_type: %{content_type}\n<br>time_namelookup: %{time_namelookup}\n<br>time_connect: %{time_connect}\n<br>time_appconnect: %{time_appconnect}\n<br>time_redirect: %{time_redirect}\n<br>time_pretransfer: %{time_pretransfer}\n<br>time_starttransfer: %{time_starttransfer}\n<br>speed_download: %{speed_download}\n<br>speed_upload: %{speed_upload}\n<br>size_download: %{size_download}\n<br>size_upload: %{size_upload}\n<br>———-\n<br>time_total: %{time_total}\n </p><p>常用的变量如下表所示：<br>url_effective    上次访问的URL。<br>http_code    上一次 HTTP 或 FTP 数据传输过程中的 response 数值代码。<br>http_connect    上一次 CONNECT 请求中的数值代码<br>time_total    数据传输消耗的总时间，以秒为单位，精度为毫秒。<br>time_namelookup    从数据传输开始到域名解析完成所花费的时间。<br>time_connect    TCP连接建立成功所花费的时间。<br>time_appconnect    应用层协议，如 SSL/SSH、三次握手等过程完成所花费的时间。<br>time_redirect    从跳转链接被激活到真正开始从跳转链接下载数据所经过的时间。<br>time_starttransfer    从请求连接开始，到第一个字节被传送前所经过的时间。<br>size_download    数据传输过程中下载的总数据大小。<br>size_upload    数据传输过程中上传的总数据大小。<br>size_header    下载的数据包中，header 字段的总数据大小。<br>size_request    被发送的 HTTP request 的总数据大小。<br>speed_download    整个数据传输过程中的平均数据下载速度。<br>speed_upload    整个数据传输过程中的平均数据上传速度。<br>content_type    被请求访问的文件的 Content_Type 类型。<br>num_redirects    访问请求中包含的跳转链接数量。<br>redirect_url    跳转链接指向的URL<br>ssl_verify_result    SSL验证的结果。值为 0 时表示验证成功。 </p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/rdm.html"/>
      <url>tools/rdm.html</url>
      
        <content type="html"><![CDATA[<p>redis desktop manager</p><p>Redis desktop manager<br><a href="https://github.com/echo-layker/RedisDesktopManager-Mac/releases" target="_blank" rel="noopener">https://github.com/echo-layker/RedisDesktopManager-Mac/releases</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/tmux%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
      <url>tools/tmux%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="0x00、简介"><a href="#0x00、简介" class="headerlink" title="0x00、简介"></a>0x00、简介</h2><ul><li>终端复用神器</li></ul><h2 id="0x01、快捷键"><a href="#0x01、快捷键" class="headerlink" title="0x01、快捷键"></a>0x01、快捷键</h2><h3 id="1-tmux命令"><a href="#1-tmux命令" class="headerlink" title="1.tmux命令"></a>1.tmux命令</h3><ul><li><p>启动新会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux [new -s 会话名 -n 窗口名]</span><br></pre></td></tr></table></figure></li><li><p>恢复会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux at [-t 会话名]</span><br></pre></td></tr></table></figure></li><li><p>列出所有会话：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux ls</span><br></pre></td></tr></table></figure></li><li><p>关闭会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tmux kill-session -t 会话名</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-tmux内快捷键"><a href="#2-tmux内快捷键" class="headerlink" title="2.tmux内快捷键"></a>2.tmux内快捷键</h3><ul><li><p>会话</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:new&lt;回车&gt;  启动新会话</span><br><span class="line">s           列出所有会话</span><br><span class="line"><span class="meta">$</span><span class="bash">           重命名当前会话</span></span><br></pre></td></tr></table></figure></li><li><p>窗口 (标签页)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* c 创建一个新窗口</span><br><span class="line">* , 重命名当前窗口</span><br><span class="line">* w 列出所有窗口</span><br><span class="line">* % 水平分割窗口</span><br><span class="line">* " 竖直分割窗口</span><br><span class="line">* n 选择下一个窗口</span><br><span class="line">* p 选择上一个窗口</span><br><span class="line">* 0~9 选择0~9对应的窗口</span><br><span class="line"></span><br><span class="line">* h 将光标移入左侧的窗格*</span><br><span class="line">* j 将光标移入下方的窗格*</span><br><span class="line">* l 将光标移入右侧的窗格*</span><br><span class="line">* k 将光标移入上方的窗格*</span><br><span class="line">* q 显示窗格的编号</span><br><span class="line">* o 在窗格间切换</span><br><span class="line">* &#125; 与下一个窗格交换位置</span><br><span class="line">* &#123; 与上一个窗格交换位置</span><br><span class="line">* ! 在新窗口中显示当前窗格</span><br><span class="line">* x 关闭当前窗格</span><br></pre></td></tr></table></figure></li><li><p>调整窗口排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swap-window -s 3 -t 1  交换 3 号和 1 号窗口</span><br><span class="line">swap-window -t 1       交换当前和 1 号窗口</span><br><span class="line">move-window -t 1       移动当前窗口到 1 号</span><br></pre></td></tr></table></figure></li><li><p>窗格（分割窗口）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">  垂直分割</span></span><br><span class="line">"  水平分割</span><br><span class="line">o  交换窗格</span><br><span class="line">x  关闭窗格</span><br><span class="line">⍽  左边这个符号代表空格键 - 切换布局</span><br><span class="line">q 显示每个窗格是第几个，当数字出现的时候按数字几就选中第几个窗格</span><br><span class="line">&#123; 与上一个窗格交换位置</span><br><span class="line">&#125; 与下一个窗格交换位置</span><br><span class="line">z 切换窗格最大化/最小化</span><br></pre></td></tr></table></figure></li><li><p>杂项</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d  退出 tmux（tmux 仍在后台运行）</span><br><span class="line">t  窗口中央显示一个数字时钟</span><br><span class="line">?  列出所有快捷键</span><br><span class="line">:  命令提示符</span><br></pre></td></tr></table></figure><h2 id="0x02、配置文件"><a href="#0x02、配置文件" class="headerlink" title="0x02、配置文件"></a>0x02、配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">设置前缀为Ctrl + a</span></span><br><span class="line">set -g prefix C-a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">解除Ctrl+b 与前缀的对应关系</span></span><br><span class="line">unbind C-b</span><br><span class="line">bind C-a send-prefix # 绑定Ctrl+a为新的指令前缀</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置序号从1开始</span></span><br><span class="line">set -g base-index 1</span><br><span class="line">set -g pane-base-index 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将r 设置为加载配置文件，并显示<span class="string">"reloaded!"</span>信息</span></span><br><span class="line">bind r source-file ~/.tmux.conf \; display "Reloaded!"</span><br><span class="line"></span><br><span class="line">bind-key k select-pane -U # up</span><br><span class="line">bind-key j select-pane -D # down</span><br><span class="line">bind-key h select-pane -L # left</span><br><span class="line">bind-key l select-pane -R # right</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set -g mouse on # 支持鼠标选取文本等</span><br><span class="line"></span><br><span class="line">set -g status-interval 2 # 状态栏刷新时间</span><br><span class="line">set -g status-justify left # 状态栏列表左对齐</span><br><span class="line">setw -g monitor-activity on # 非当前窗口有内容更新时在状态栏通知</span><br><span class="line"></span><br><span class="line">set -g status-bg black # 设置状态栏背景黑色</span><br><span class="line">set -g status-fg yellow # 设置状态栏前景黄色</span><br><span class="line">set -g status-style "bg=black, fg=yellow" # 状态栏前景背景色</span><br><span class="line"></span><br><span class="line">set -g status-left "#[bg=#FF661D] " # 状态栏左侧内容</span><br><span class="line">set -g status-right "#S #[fg=green,bg=black]#(tmux-mem-cpu-load --colors --interval 2)#[default]"</span><br><span class="line">set -g status-left-length 300 # 状态栏左边长度300</span><br><span class="line">set -g status-right-length 500 # 状态栏右边长度500</span><br><span class="line"></span><br><span class="line">set -wg window-status-format " #I #W " # 状态栏窗口名称格式</span><br><span class="line">set -wg window-status-current-format " #I:#W#F " # 状态栏当前窗口名称格式(#I：序号，#w：窗口名称，#F：间隔符)</span><br><span class="line">set -wg window-status-separator "" # 状态栏窗口名称之间的间隔</span><br><span class="line">set -wg window-status-current-style "bg=red" # 状态栏当前窗口名称的样式</span><br><span class="line">set -wg window-status-last-style "fg=yellow" # 状态栏最后一个窗口名称的样式</span><br><span class="line"></span><br><span class="line">set -g message-style "bg=#202529, fg=#91A8BA" # 指定消息通知的前景、后景色</span><br></pre></td></tr></table></figure><h2 id="0x03、复制到系统"><a href="#0x03、复制到系统" class="headerlink" title="0x03、复制到系统"></a>0x03、复制到系统</h2><p>在 Mac 下使用 tmux，希望能够复制到系统粘贴板，可以通过下面的方式实现：</p><ul><li><p>1.安装 rettach-to-user-namespace</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install reattach-to-user-namespace</span><br></pre></td></tr></table></figure></li><li><p>2.修改 ~/.tmux.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set-option -g default-command "reattach-to-user-namespace -l zsh"</span><br><span class="line"><span class="meta">#</span><span class="bash"> buffer缓存复制到Mac系统粘贴板</span></span><br><span class="line">bind y run "tmux save-buffer - | reattach-to-user-namespace pbcopy" \; display-message "Copied tmux buffer to system clipboard"</span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac系统粘贴板内容复制到会话</span></span><br><span class="line">bind C-v run "reattach-to-user-namespace pbpaste | tmux load-buffer - \; paste-buffer -d"</span><br></pre></td></tr></table></figure></li><li><p>3.使用<br>在 tmux 中复制之后，按 prefix + y 就可以把 tmux 内复制的内容放到系统粘贴板了</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>工具集合</title>
      <link href="tools/index.html"/>
      <url>tools/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、插件"><a href="#一、插件" class="headerlink" title="一、插件"></a>一、插件</h2><ul><li>github<ul><li>sourcegraph</li><li>octotree</li></ul></li><li>剪切网页<ul><li>evernote</li></ul></li><li>调试接口<ul><li>JSONview</li></ul></li><li>词典<ul><li>沙拉查词</li></ul></li><li>广告<ul><li>广告终结者</li></ul></li><li>产品原型<ul><li>axure</li></ul></li><li>多tab管理<ul><li>Toby</li></ul></li></ul><h2 id="二、工具网站"><a href="#二、工具网站" class="headerlink" title="二、工具网站"></a>二、工具网站</h2><ul><li>json格式化<ul><li><a href="https://json.cn" target="_blank" rel="noopener">https://json.cn</a></li><li><a href="http://json.parser.online.fr" target="_blank" rel="noopener">http://json.parser.online.fr</a></li></ul></li><li>随机密码生成<ul><li><a href="https://www.sexauth.com/" target="_blank" rel="noopener">https://www.sexauth.com/</a></li><li><a href="https://suijimimashengcheng.51240.com/" target="_blank" rel="noopener">https://suijimimashengcheng.51240.com/</a></li><li><a href="https://www.dashlane.com/zh/features/password-generator" target="_blank" rel="noopener">https://www.dashlane.com/zh/features/password-generator</a></li></ul></li><li>正则表达式<ul><li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></li><li><a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">http://wangwl.net/static/projects/visualRegex</a></li></ul></li><li>问题讨论<ul><li><a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li><li><a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a></li></ul></li><li>文章<ul><li><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></li></ul></li></ul><h2 id="三、前沿科技网站"><a href="#三、前沿科技网站" class="headerlink" title="三、前沿科技网站"></a>三、前沿科技网站</h2><ul><li>论文<ul><li><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></li><li><a href="https://www.nature.com/" target="_blank" rel="noopener">https://www.nature.com/</a></li><li><a href="https://paperswelove.org/" target="_blank" rel="noopener">https://paperswelove.org/</a></li></ul></li></ul><h3 id="四、github系列"><a href="#四、github系列" class="headerlink" title="四、github系列"></a>四、github系列</h3><ul><li><p>awesome系列</p><ul><li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">https://github.com/sindresorhus/awesome</a></li></ul></li><li><p>算法</p><ul><li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">https://github.com/linyiqun/DataMiningAlgorithm</a></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/mac%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC.html"/>
      <url>tools/mac%E6%B8%85%E7%90%86%E8%84%9A%E6%9C%AC.html</url>
      
        <content type="html"><![CDATA[<h1 id="清理mac的脚本"><a href="#清理mac的脚本" class="headerlink" title="清理mac的脚本"></a>清理mac的脚本</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-23 14:29:23</li></ul><blockquote><h2 id="0x00、mac目录结构"><a href="#0x00、mac目录结构" class="headerlink" title="0x00、mac目录结构"></a>0x00、mac目录结构</h2></blockquote><ul><li><ol><li>清理废纸篓： 平时删除的不用的文件会被自动放到废纸篓中，如果不及时清理，仍会占用磁盘空间的，因此需要及时清理废纸篓</li></ol></li><li><ol start="2"><li>清理噪音文件：sudo rm -f  /System/Library/Speech/Voices/*</li></ol></li><li><ol start="3"><li>删除系统日志：sudo rm -rf /private/var/log/*</li></ol></li><li><ol start="4"><li>清理quicklook缓存文件：sudo rm -rf /private/var/folders/</li></ol></li><li><ol start="5"><li>删除临时文件：rm -rf /private/var/tmp/TM*</li></ol></li><li><ol start="6"><li>清理缓存文件：rm -rf  ~/Library/Caches/*</li></ol></li></ul><blockquote><h2 id="0x01、python获取文件处理方法"><a href="#0x01、python获取文件处理方法" class="headerlink" title="0x01、python获取文件处理方法"></a>0x01、python获取文件处理方法</h2></blockquote><blockquote><h2 id="0x02、python执行shell命令"><a href="#0x02、python执行shell命令" class="headerlink" title="0x02、python执行shell命令"></a>0x02、python执行shell命令</h2></blockquote><ul><li>os.system()</li></ul><blockquote><h2 id="0x03、"><a href="#0x03、" class="headerlink" title="0x03、"></a>0x03、</h2></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/backend/index.html"/>
      <url>interview/backend/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/cs/index.html"/>
      <url>interview/cs/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/frontend/index.html"/>
      <url>interview/frontend/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/iterm%E9%85%8D%E7%BD%AElzrz.html"/>
      <url>tools/iterm%E9%85%8D%E7%BD%AElzrz.html</url>
      
        <content type="html"><![CDATA[<h1 id="iterm2配置lzrz"><a href="#iterm2配置lzrz" class="headerlink" title="iterm2配置lzrz"></a>iterm2配置lzrz</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-09 12:11:30</li></ul><blockquote><h2 id="0x00、安装lzrz"><a href="#0x00、安装lzrz" class="headerlink" title="0x00、安装lzrz"></a>0x00、安装lzrz</h2></blockquote><ul><li>1.远程连接的服务器端必须要有sz、rz这两个工具，如果没有，可以执行安装。如在CentOS上安装的命令为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install lrzsz</span><br></pre></td></tr></table></figure></li><li>2.本地安装lzrz工具。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install lrzsz</span><br></pre></td></tr></table></figure><blockquote><h2 id="0x01、本地下载脚本"><a href="#0x01、本地下载脚本" class="headerlink" title="0x01、本地下载脚本"></a>0x01、本地下载脚本</h2></blockquote><ul><li>1.由于sz,rz是基于ZMODEM/YMODEM/XMODEM协议的，所以安装iterm2-zmodem<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;bin</span><br><span class="line">sudo wget https:&#x2F;&#x2F;raw.github.com&#x2F;mmastrac&#x2F;iterm2-zmodem&#x2F;master&#x2F;iterm2-send-zmodem.sh</span><br><span class="line">sudo wget https:&#x2F;&#x2F;raw.github.com&#x2F;mmastrac&#x2F;iterm2-zmodem&#x2F;master&#x2F;iterm2-recv-zmodem.sh</span><br><span class="line">sudo chmod 777 &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-*</span><br></pre></td></tr></table></figure></li></ul><blockquote><h2 id="0x02、配置iterm2"><a href="#0x02、配置iterm2" class="headerlink" title="0x02、配置iterm2"></a>0x02、配置iterm2</h2></blockquote><ul><li>1.打开Item2，点击preferences → profiles，选择某个profile，如Default，之后继续选择advanced → triggers，添加编辑添加如下triggers：<br>(Profiles -&gt; Open Profiles -&gt; Edit Profies -&gt; Advanced -&gt; Triggers -&gt; Edit )</li><li>2.rz配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regular Expression: rz waiting to receive.\*\*B0100</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-send-zmodem.sh</span><br></pre></td></tr></table></figure></li><li>3.sz配置<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Regular Expression: \*\*B00000000000000</span><br><span class="line">Action: Run Silent Coprocess</span><br><span class="line">Parameters: &#x2F;usr&#x2F;local&#x2F;bin&#x2F;iterm2-recv-zmodem.sh</span><br></pre></td></tr></table></figure></li><li>4.instant要全部checked</li></ul><blockquote><h2 id="0x03、配置完毕，进行尝试。"><a href="#0x03、配置完毕，进行尝试。" class="headerlink" title="0x03、配置完毕，进行尝试。"></a>0x03、配置完毕，进行尝试。</h2></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/net/index.html"/>
      <url>interview/net/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/storage/index.html"/>
      <url>interview/storage/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>项目规范</title>
      <link href="architecture/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83.html"/>
      <url>architecture/%E9%A1%B9%E7%9B%AE%E8%A7%84%E8%8C%83.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、前端"><a href="#一、前端" class="headerlink" title="一、前端"></a>一、前端</h2><h4 id="1-vue3"><a href="#1-vue3" class="headerlink" title="1.vue3"></a>1.vue3</h4><ul><li><a href="https://cli.vuejs.org/zh/" target="_blank" rel="noopener">vue-cli文档</a></li></ul><p>项目的创建方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> vue &lt; 3.0</span></span><br><span class="line">vue init webpack example</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 当然vue3.0也向后兼容上面的模式</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> vue &gt;= 3.0</span></span><br><span class="line">vue create example</span><br></pre></td></tr></table></figure><h4 id="2-vue2自动发布处理"><a href="#2-vue2自动发布处理" class="headerlink" title="2.vue2自动发布处理"></a>2.vue2自动发布处理</h4><p>其目录结构如下，可以在config文件建内进行配置不同环境所请求的后端<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11057" alt="3b683fe0b009266aa8f141d298853e3f.png"></p><p>package.json里有几种环境的编译<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11058" alt="916b0c2193c0796b369d2a1b22d5172e.png"></p><p>比如，<br>dev.env.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"development"'</span>,</span><br><span class="line">  ENV_CONFIG: <span class="string">'"dev"'</span>,</span><br><span class="line">  BASE_API: <span class="string">'"http://local-config.corp.funji.club/"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sit.env.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">  ENV_CONFIG: <span class="string">'"sit"'</span>,</span><br><span class="line">  BASE_API: <span class="string">'"http://configtest.corp.funji.club/"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>prod.env.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  NODE_ENV: <span class="string">'"production"'</span>,</span><br><span class="line">  ENV_CONFIG: <span class="string">'"prod"'</span>,</span><br><span class="line">  BASE_API: <span class="string">'"http://config.corp.funji.club/"'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在ci发布文件内，进行不同分支发布到不同环境的配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build-test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build-prod</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy-test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy-prod</span></span><br><span class="line"></span><br><span class="line"><span class="attr">variables:</span></span><br><span class="line">    <span class="attr">PROD_RSYNC_HOST:</span> <span class="string">"ali-funji-mainsite-01 ali-funji-mainsite-02 ali-funji-mainsite-03"</span></span><br><span class="line">    <span class="attr">DEV_RSYNC_HOST:</span> <span class="string">ali-funji-test-01</span></span><br><span class="line">    <span class="attr">RSYNC_PATH:</span> <span class="string">"/data/work/projects/$CI_PROJECT_NAME/"</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build-test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build-test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--registry=https://registry.npm.taobao.org</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build:sit</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">swarm-test-01</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">build-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">build-prod</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">install</span> <span class="string">--registry=https://registry.npm.taobao.org</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">build:prod</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">swarm-test-01</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-test:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rsync</span> <span class="string">-aP</span> <span class="string">--delete-after</span> <span class="string">./dist/.</span> <span class="string">$DEV_RSYNC_HOST:$RSYNC_PATH</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-fr</span> <span class="string">dist</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">swarm-test-01</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">dev</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy-prod:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">deploy-prod</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">for</span> <span class="string">host</span> <span class="string">in</span> <span class="string">$PROD_RSYNC_HOST;do</span> <span class="string">rsync</span> <span class="string">-aP</span> <span class="string">--delete-after</span> <span class="string">./dist/.</span> <span class="string">$host:$RSYNC_PATH;done</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">rm</span> <span class="string">-fr</span> <span class="string">dist</span></span><br><span class="line">  <span class="attr">tags:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">swarm-test-01</span></span><br><span class="line">  <span class="comment"># when: manual</span></span><br><span class="line">  <span class="attr">only:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><h4 id="3-图形界面"><a href="#3-图形界面" class="headerlink" title="3.图形界面"></a>3.图形界面</h4><p>vue从3.0开始有ui管理界面来进行所有vue项目的创建、启动、编译及相关性能检查，并且可以进行插件及包的安装和升级。启动ui界面，输入一下命令即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure><ul><li>在package.json里添加编译命令，进行mode处理</li><li>然后添加vue.config.js、.env.production、.env.test等文件</li><li>自动发布时，进行不同的打包命令处理</li></ul><h2 id="二、前后端联调"><a href="#二、前后端联调" class="headerlink" title="二、前后端联调"></a>二、前后端联调</h2><ul><li><p>vue配置文件里的proxyTable<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11079" alt="cd653c9bcffd3555eb5308694e7f74f8.png"></p></li><li><p>node起代理服务</p></li><li><p>nginx反向代理服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name local-relation.corp.funji.club;</span><br><span class="line">    access_log &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;minipro_access.log;</span><br><span class="line">    error_log &#x2F;usr&#x2F;local&#x2F;var&#x2F;log&#x2F;nginx&#x2F;minipro_error.log;</span><br><span class="line"></span><br><span class="line">    location ^~ &#x2F;api&#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;relationtest.corp.funji.club;</span><br><span class="line">        proxy_pass_header       Authorization;</span><br><span class="line">        proxy_pass_header       WWW-Authenticate;</span><br><span class="line">        proxy_set_header Host $host;</span><br><span class="line">        proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;localhost:8701;</span><br><span class="line">        #root &#x2F;Users&#x2F;yy&#x2F;zxc&#x2F;works&#x2F;meta_ui&#x2F;dist;</span><br><span class="line">        #index  index.html index.htm;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在/etc/hosts文件内，添加域名映射</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地域名</span></span><br><span class="line">127.0.0.1 local-relation.corp.funji.club</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试环境域名，如果运营同学已经开启内网访问，则不需要进行配置</span></span><br><span class="line">192.168.156.65 relationtest.corp.funji.club</span><br></pre></td></tr></table></figure><h2 id="三、django"><a href="#三、django" class="headerlink" title="三、django"></a>三、django</h2></li></ul><h4 id="1-token配置"><a href="#1-token配置" class="headerlink" title="1.token配置"></a>1.token配置</h4><p>两种配置模式<br>一、 export<br>先export token到系统环境变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export CONFIGTOKEN=fhaskdijfijoqwejrfisd23k</span><br></pre></td></tr></table></figure><p>然后在代码里进行获取系统变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config = requests.get(<span class="string">'http://config.corp.funji.club/api/v2/config/'</span>,</span><br><span class="line">            headers=&#123;<span class="string">"TOKEN"</span>: os.environ[<span class="string">'CONFIGTOKEN'</span>]&#125;).json()[<span class="string">'data'</span>]</span><br></pre></td></tr></table></figure><p>二、默认值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">config = requests.get(<span class="string">'http://config.corp.funji.club/api/v2/config/'</span>,</span><br><span class="line">            headers=&#123;<span class="string">"TOKEN"</span>: os.environ.get(<span class="string">'CONFIGTOKEN'</span>,<span class="string">'fhaskdijfijoqwejrfisd23k'</span>)&#125;).json()[<span class="string">'data'</span>]</span><br></pre></td></tr></table></figure><p>这里只进行测试环境的token值。<br>线上的话，可以写到ci文件里</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--env CONFIGTOKEN&#x3D;dda6058183d242b49805b45591868200</span><br></pre></td></tr></table></figure><p>也可以用gitlab的环境变量进行替换<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11065" alt="c0ba5f37e8210ddfcc5a0fc7822165f4.png"></p><p>然后在ci文件里用${CONFIG_TOKEN}进行获取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-e CONFIG_TOKEN=$&#123;CONFIG_TOKEN&#125;</span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11070" alt="8a6d220bde0987ee0b3bc0843701eab2.png"></p><h4 id="2-debug模式关闭"><a href="#2-debug模式关闭" class="headerlink" title="2.debug模式关闭"></a>2.debug模式关闭</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">debug = config[<span class="string">'env'</span>] == <span class="string">'test'</span></span><br></pre></td></tr></table></figure><h4 id="3-关闭跨域"><a href="#3-关闭跨域" class="headerlink" title="3.关闭跨域"></a>3.关闭跨域</h4><p>在本地开始时，前端用nginx或者node进行代理，不需要后端开启跨域。<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11082" alt="9399757439ba0954a5145c75fdbf16a5.png"></p><h4 id="4-api设置，name命名"><a href="#4-api设置，name命名" class="headerlink" title="4.api设置，name命名"></a>4.api设置，name命名</h4><ul><li>要以api开头，不要让nginx进行拦截；否则url最后不太’/‘不会自动跳转<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11074" alt="990288e1be33f1da319aad815aee832b.png"><br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11078" alt="ee68bd3da356f09e610689cfa25a0048.png"></li><li>每个url可以用name来命名，便于识别、进行auth认证和权限管理判断<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11073" alt="be34f5329c1826a91d8abdc661bb6721.png"><br>在settings中配置不需要登录的url<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11075" alt="41287d04787b950fcc93be0b700441fa.png"><br>然后，在中间件里，进行判断即可。<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11076" alt="2699f4ec6ae0d7e33dc9624e0bc4a967.png"></li></ul><h4 id="5-全局handle-rsp"><a href="#5-全局handle-rsp" class="headerlink" title="5.全局handle_rsp"></a>5.全局handle_rsp</h4><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11071" alt="04ca8c3948a786ec589c2e1f5ab699de.png"><br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11072" alt="1794266a286ac9b51e5371f1812ca5fd.png"></p><h4 id="6-部署发布错误"><a href="#6-部署发布错误" class="headerlink" title="6.部署发布错误"></a>6.部署发布错误</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 热更新</span></span><br><span class="line">gunicorn business_api_app.wsgi:application -c gunicorn.conf.py --reload</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印出具体错误信息</span></span><br><span class="line">gunicorn business_api_app.wsgi:application -c gunicorn.conf.py --preload</span><br></pre></td></tr></table></figure><h2 id="四、CI文件"><a href="#四、CI文件" class="headerlink" title="四、CI文件"></a>四、CI文件</h2><ul><li>stages</li><li>变量</li></ul><h2 id="五、docker常用命令"><a href="#五、docker常用命令" class="headerlink" title="五、docker常用命令"></a>五、docker常用命令</h2><h4 id="1-单个容器"><a href="#1-单个容器" class="headerlink" title="1.单个容器"></a>1.单个容器</h4><ul><li><p>查看镜像</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure></li><li><p>查看启动中的容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤查看</span></span><br><span class="line">docker ps |grep &lt;容器名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 过滤,不区分大小写查看</span></span><br><span class="line">docker ps |grep -i &lt;容器名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看全部容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure></li><li><p>查看容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs &lt;容器id或name&gt;</span><br></pre></td></tr></table></figure></li><li><p>删除容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器id或者name&gt;</span><br></pre></td></tr></table></figure><h4 id="2-swarm集群"><a href="#2-swarm集群" class="headerlink" title="2.swarm集群"></a>2.swarm集群</h4></li><li><p>查看swarm有哪些服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ls</span><br></pre></td></tr></table></figure></li><li><p>查看某个服务分布情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service ps &lt;服务名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看服务日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认查看所有，到当前为止</span></span><br><span class="line">docker service logs &lt;服务名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有，并持续追看</span></span><br><span class="line">docker service logs -f &lt;服务名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看近5分钟，并持续追看</span></span><br><span class="line">docker service logs -f --since="5m" &lt;服务名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看近1小时，并持续追看</span></span><br><span class="line">docker service logs -f --since="1h" &lt;服务名称&gt;</span><br></pre></td></tr></table></figure></li><li><p>服务删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker service rm &lt;服务名称&gt;</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-容器运行"><a href="#3-容器运行" class="headerlink" title="3.容器运行"></a>3.容器运行</h4><ul><li><p>临时启动容器并进入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it &lt;image-name&gt; /bin/sh -c "shell命令"</span><br></pre></td></tr></table></figure></li><li><p>swarm创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker service create</span><br><span class="line">    --name=&lt;名称&gt;  # 容器名称</span><br><span class="line">    --mount type=bind,src=/data/logs/$CI_PROJECT_NAME,dst=/home/log  # 挂在目录映射，物理机:容器</span><br><span class="line">    -p 1902:1902  # 映射端口</span><br><span class="line">    --replicas 2  # 服务个数</span><br><span class="line">    --env CONFIGTOKEN=d4bc9cc17c9f424e9229fa640064bae7 # 环境变量</span><br><span class="line">    reg.corp.funji.club/dev_env/$CI_PROJECT_NAME  # 镜像</span><br><span class="line">    /bin/sh -c "/usr/local/webserver/Python3.7/bin/gunicorn minipro_api.wsgi:application -c gunicorn.conf.py --preload" # 命令</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> /usr/<span class="built_in">local</span>/webserver/Python3.7/bin/gunicorn，为什么路径这么长，因为这个安装包不在默认的系统PATH里，所有找不到。所有要全路径的引用、</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%9F%BA%E7%A1%80.html"/>
      <url>interview/%E5%9F%BA%E7%A1%80.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-对于软件运行机制的理解。"><a href="#1-对于软件运行机制的理解。" class="headerlink" title="1.对于软件运行机制的理解。"></a>1.对于软件运行机制的理解。</h3><ul><li>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</li><li>具体的工作流程是<ul><li>1.在控制器指挥下，从存储器上取出指令；</li><li>2.分析指令，得到计算命令和待操作的数；</li><li>3.从存储器上取出待计算的数放入运算器；</li><li>4.运算器计算结果；</li><li>5.输出到存储器或输出设备。</li></ul></li></ul><h3 id="2-对于好的代码架构的理解？或者好的代码结构是怎样的？"><a href="#2-对于好的代码架构的理解？或者好的代码结构是怎样的？" class="headerlink" title="2.对于好的代码架构的理解？或者好的代码结构是怎样的？"></a>2.对于好的代码架构的理解？或者好的代码结构是怎样的？</h3><ul><li>高内聚、低耦合</li><li>易扩展，维护方便</li><li>避免过度设计</li><li>可读性高，结构清晰</li><li>代码风格统一</li><li>低复杂性，简练</li></ul><h3 id="3-对于编码规范的理解，有哪些好的编程规范"><a href="#3-对于编码规范的理解，有哪些好的编程规范" class="headerlink" title="3.对于编码规范的理解，有哪些好的编程规范"></a>3.对于编码规范的理解，有哪些好的编程规范</h3><ul><li>变量命名规范</li><li>代码缩进规范</li><li>大小写规范</li><li>注释规范</li><li>可读性强</li></ul><h3 id="4-编程安全应该注意哪些问题"><a href="#4-编程安全应该注意哪些问题" class="headerlink" title="4.编程安全应该注意哪些问题"></a>4.编程安全应该注意哪些问题</h3><ul><li>表单数据验证</li><li>防范SQL语句注入攻击</li><li>程序资源的释放。例如内存泄漏、数据库连接、文件句柄等资源</li><li>线程安全性</li><li>数据类型校验</li></ul><h3 id="5-如何提升开发效率？提升开发效率的方法有哪些？"><a href="#5-如何提升开发效率？提升开发效率的方法有哪些？" class="headerlink" title="5.如何提升开发效率？提升开发效率的方法有哪些？"></a>5.如何提升开发效率？提升开发效率的方法有哪些？</h3><ul><li>大显示器</li><li>机械键盘</li><li>编辑器快捷键</li><li>快速文档查询能力</li><li>需求的准确理解，防止可能的返工</li></ul><h3 id="6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"><a href="#6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？" class="headerlink" title="6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"></a>6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</h3><ul><li>保证开发结果与需求相符</li><li>保证代码的正确性、可靠性</li><li>新的功能是否影响旧有的功能</li></ul><h3 id="7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"><a href="#7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？" class="headerlink" title="7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"></a>7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</h3><h3 id="对于软件运行机制的理解。"><a href="#对于软件运行机制的理解。" class="headerlink" title="对于软件运行机制的理解。"></a>对于软件运行机制的理解。</h3><ul><li><p>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</p></li><li><p>具体的工作流程是</p><ul><li>1在控制器指挥下，从存储器上取出指令；</li><li>2分析指令，得到计算命令和待操作的数；</li><li>3从存储器上取出待计算的数放入运算器；</li><li>4运算器计算结果；</li><li>5输出到存储器或输出设备。</li></ul></li><li><p>因此存储器是关键。存储器分为：寄存器（CPU内部，用于存放待操作数和结果）；高速缓存（通常在CPU内部，用做数据缓冲区）；内存；外存。</p></li><li><p>接下来是具体的命令执行，这需要预先定义好CPU能执行的命令，即CPU的指令集，用来计算和控制计算机系统的一套指令的集合，典型的有Intel X86指令集和ARM指令集。具体的指令以二进制码表示，包含一个或多个字节，也包含指令码（具体命令）和操作数（要操作的数或地址）。在具体的执行中，把宏观层次的命令转换为满足指令集要求的二进制代码，然后才能在计算机上运行；参见CPU的具体组成成分运算器 ALU和寄存器和控制器的工作流程。</p></li><li><p>最后程序的执行就是在以上基础进行的，一开始使用机器语言的时候，具体的命令形式是1001010101010011 00011110这样的。这个虽然足够底层能够直接与计算机进行交互，但不是一般人能够搞得定的，于是就有更高层次的抽象，汇编语言，变成add 0 1这种相对来说比较友好的语言；接着就是高级语言了，更加抽象，但接近我们一般人的思维习惯，如d = a*b+c;当然，这是前人的工作成果，他们把很多的细节封装起来，我们这些后人之间调用就行，不用管其具体的转换即具体的编译，不然一句程序有可能转换为多句指令，而且其执行的次序和次数之类的细节，各种内存地址和数据的调用足够使人发疯。</p></li><li><p>对于设计模式的理解，为什么要有设计模式，用过什么设计模式，每个的应用场景是怎样的？</p><ul><li>设计模式主要分三个类型:创建型、结构型和行为型。<br>创建型：<br>一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 ；<br>应用场景：一个无状态的类使用单例模式节省内存资源。<br>二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br>应用场景：一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。<br>三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。     应用场景：由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义 一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。<br>四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br>应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。<br>五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br>应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限</li></ul></li></ul><p>行为型：<br>    六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br>  应用场景：迭代。<br>    七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br>应用场景： 某个实例的变化将影响其他多个对象。<br>    八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。<br>应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类<br>     九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。<br>应用场景：将命令者与执行者完全解耦。<br>    十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br>应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。<br>    十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。       应用场景：<br>   十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系<br>    十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。<br>    十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。<br>    十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>    十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>结构型：<br>    十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。<br>    十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。<br>    十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问<br>    二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。<br>    二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。<br>    二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br>    二十三、Flyweight，享元模式</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/chip/index.html"/>
      <url>man/chip/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/cs/basic.html"/>
      <url>man/cs/basic.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/cs/index.html"/>
      <url>man/cs/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/django/08%E8%B7%AF%E7%94%B1.html"/>
      <url>man/django/08%E8%B7%AF%E7%94%B1.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/django/07%E7%BC%93%E5%AD%98.html"/>
      <url>man/django/07%E7%BC%93%E5%AD%98.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/django/index.html"/>
      <url>man/django/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/docker/index.html"/>
      <url>man/docker/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/git/index.html"/>
      <url>man/git/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/istio/index.html"/>
      <url>man/istio/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/kubernetes/index.html"/>
      <url>man/kubernetes/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/linux/index.html"/>
      <url>man/linux/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/net/url%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.html"/>
      <url>man/net/url%E8%AF%B7%E6%B1%82%E6%B5%81%E7%A8%8B.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/istio/basic.html"/>
      <url>man/istio/basic.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/rust/lib.html"/>
      <url>man/rust/lib.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/rust/rust%E5%A4%84%E7%90%86json.html"/>
      <url>man/rust/rust%E5%A4%84%E7%90%86json.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="algorithms/sort.html"/>
      <url>algorithms/sort.html</url>
      
        <content type="html"><![CDATA[<p>本文是常见的排序算法的一个简单总结，也是算法导论第三版的一些摘要记录，以作备忘和查询。</p><h2 id="0X00、简介"><a href="#0X00、简介" class="headerlink" title="0X00、简介"></a>0X00、简介</h2><ul><li><p>1.排序的定义：</p><ul><li>输入：n个数的一个序列&lt;a1,a2,…,an&gt;</li><li>输出：序列的一个排列&lt;a1’,a2’,…,an’&gt;,满足a1’&lt;=a2’&lt;=…&lt;=an’</li></ul></li><li><p>2.排序算法复杂度概览</p></li></ul><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>Out-place</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr></tbody></table><ul><li><p>3.术语解释</p><ul><li>稳定性：如果a=b，且a在b前面，排序后a仍然在b前面，则说算法是稳定的；否则就是不稳定的。</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul></li><li><p>4.关于时间复杂度的排序:</p><ul><li>(O(n^2))排序:各类简单排序：直接插入、直接选择和冒泡排序；</li><li>(O(nlog2n))排序:快速排序、堆排序和归并排序；</li><li>O(n1+§))排序，§是介于0和1之间的常数:希尔排序</li><li>(O(n))排序:基数排序、桶、箱排序。</li></ul></li><li><p>5.关于稳定性的排序：</p><ul><li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li><li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li></ul></li></ul><h2 id="0X01、冒泡排序"><a href="#0X01、冒泡排序" class="headerlink" title="0X01、冒泡排序"></a>0X01、冒泡排序</h2><p>冒泡排序是一种流行但是低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p><h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h4><ul><li><p>语言描述</p><ul><li>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>3.针对所有的元素重复以上的步骤，除了最后一个；</li><li>4.重复步骤1~3，直到排序完成。</li></ul></li><li><p>伪代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">1  for i &#x3D; 1 to A.length - 1</span><br><span class="line">2    for j &#x3D; A.length downto i+1</span><br><span class="line">3       if A[j] &lt; A[j-1]</span><br><span class="line">4           exchange A[j] with A[j-1]</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(n^2)</li><li>平均情况：T(n) = O(n^2)</li></ul></li><li>空间复杂度：O(1)</li></ul><h4 id="3-代码实现如下"><a href="#3-代码实现如下" class="headerlink" title="3.代码实现如下"></a>3.代码实现如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, cnt<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>] , a[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#for i in range(cnt-2):</span></span><br><span class="line">    <span class="comment">#    for j in range(cnt-1, i, -1):</span></span><br><span class="line">    <span class="comment">#        if a[j] &lt; a[j-1]:</span></span><br><span class="line">    <span class="comment">#            a[j], a[j-1] = a[j-1], a[j]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bubble_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X02、插入排序"><a href="#0X02、插入排序" class="headerlink" title="0X02、插入排序"></a>0X02、插入排序</h2><p>插入排序(Insertion-Sort)是一种简单有效的排序方法。整体思想就是把后边一个待排的元素和前边已经排序好的元素做比较，如果比这元素大，就把前边的元素依次后移，直到找到一个比待排元素小的值，在其后边插入既可。然后在排序下一个待排元素。</p><h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li><p>语言描述</p><ul><li>1.从第一个元素开始，该元素可以认为已经被排序；</li><li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>4.将新元素插入到该位置后；</li><li>5.重复步骤2~5。</li></ul></li><li><p>伪代码描述</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">1  for j &#x3D; 2 to A.length:</span><br><span class="line">2    key &#x3D; A[j]</span><br><span class="line">3    i &#x3D; j - 1</span><br><span class="line">4    while i &gt; 0 and A[i] &gt; key:</span><br><span class="line">5        A[i+1] &#x3D; A[i]</span><br><span class="line">6        i &#x3D; i - 1</span><br><span class="line">7    A[i+1] &#x3D; key</span><br></pre></td></tr></table></figure><h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度：<ul><li>最佳情况：T(n) = O(n)。</li><li>最坏情况：T(n) = O(n^2)。</li><li>平均情况：T(n) = O(n^2)。</li></ul></li><li>空间复杂度：<ul><li>O(1)。因为其要占用一个存储空间来放置key。</li></ul></li></ul><h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt - <span class="number">1</span>):</span><br><span class="line">        value = a[i+<span class="number">1</span>]</span><br><span class="line">        pre_index = i</span><br><span class="line">        <span class="keyword">while</span> (pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; a[pre_index]):</span><br><span class="line">            a[pre_index + <span class="number">1</span>] = a[pre_index]</span><br><span class="line">            pre_index -= <span class="number">1</span></span><br><span class="line">        a[pre_index+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    insert_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X03、选择排序"><a href="#0X03、选择排序" class="headerlink" title="0X03、选择排序"></a>0X03、选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1.算法分析"></a>1.算法分析</h4><ul><li>1.初始状态：无序区为R[1..n]，有序区为空；</li><li>2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>3.n-1趟结束，数组有序化了。</li></ul><h4 id="2-算法复杂度-1"><a href="#2-算法复杂度-1" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>最佳情况：T(n) = O(n2)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cnt)[i:]:</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; a[minIndex]:</span><br><span class="line">                a[minIndex], a[j] = a[j], a[minIndex]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    selection_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X04、希尔排序"><a href="#0X04、希尔排序" class="headerlink" title="0X04、希尔排序"></a>0X04、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="2-算法复杂度-2"><a href="#2-算法复杂度-2" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>最佳情况：T(n) = O(nlog2 n)</li><li>最坏情况：T(n) = O(nlog2 n)</li><li>平均情况：T(n) =O(nlog2n)　</li></ul><h4 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    算法思路：</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)，最好：O(n)，最坏：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    gap = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, cnt, <span class="number">1</span>):</span><br><span class="line">            tmp = a[i]</span><br><span class="line">            pre_index = i - gap</span><br><span class="line">            <span class="keyword">while</span> pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> a[pre_index] &gt; tmp:</span><br><span class="line">                a[pre_index+gap] = a[pre_index]</span><br><span class="line">                pre_index -= gap</span><br><span class="line">            a[pre_index+gap] = tmp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    shell_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X05、归并排序"><a href="#0X05、归并排序" class="headerlink" title="0X05、归并排序"></a>0X05、归并排序</h2><p>归并排序是分治思想的一种实现。这里分治模式的每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li><li>解决这些子问题，递归的求解各个子问题。然而，若小问题的规模足够小，则直接求解。</li><li>合并这些子问题的解成原问题的解。<br>这便是分治模式的思想。把大问题拆分成几个规模较小的子问题，把子问题在拆分成几个在小的问题，直至可以直接求解。然后把所有子问题的解合并就是原问题的解。</li></ul><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>归并排序完全是分治思想的实现。</p><ul><li><p>语言描述</p><ul><li>分解。分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li><li>解决。使用归并排序递归地排序两个子序列。</li><li>合并。合并两个已排序的子序列以产生已排序的答案。</li></ul></li><li><p>伪代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MERGE(A,p,q,r)</span><br><span class="line">1  n1 &#x3D; p - q + 1</span><br><span class="line">2  n2 &#x3D; r - q</span><br><span class="line">3  let L[1..n1+1] and R[1..n2+1] to be new arrays</span><br><span class="line">4  for i &#x3D; 1 to n1</span><br><span class="line">5    L[i] &#x3D; A[p+i-1]</span><br><span class="line">6  for j &#x3D; 1 to n2</span><br><span class="line">7    R[j] &#x3D; A[q+j]</span><br><span class="line">8  L[n1+1] &#x3D; ∞</span><br><span class="line">9  R[n2+1] &#x3D; ∞</span><br><span class="line">10 i &#x3D; 1</span><br><span class="line">11 j &#x3D; 1</span><br><span class="line">12 for k &#x3D; p to r</span><br><span class="line">13   if L[i] &lt;&#x3D; R[j]</span><br><span class="line">14      A[k] &#x3D; L[i]</span><br><span class="line">15      i &#x3D; i+1</span><br><span class="line">16   else</span><br><span class="line">17      A[k] &#x3D; R[j]</span><br><span class="line">18      j &#x3D; j+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2     q &#x3D; (p+r)&#x2F;2</span><br><span class="line">3     MERGE-SORT(A,p,q)</span><br><span class="line">4     MERGE-SORT(A,q+1,r)</span><br><span class="line">5     MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-算法复杂度-3"><a href="#2-算法复杂度-3" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    mid = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(a[:mid]), merge_sort(a[mid:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left: list, right: list)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure><h2 id="0X06、快速排序"><a href="#0X06、快速排序" class="headerlink" title="0X06、快速排序"></a>0X06、快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="1-算法思路-2"><a href="#1-算法思路-2" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li><p>语言描述</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>伪代码描述</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2    q &#x3D; PARTITION(A,p,r)</span><br><span class="line">3    QUICKSORT(A,p,q-1)</span><br><span class="line">4    QUICKSORT(A,q+1,r)</span><br><span class="line"></span><br><span class="line">PARTITION(A,p,r)</span><br><span class="line">1  x &#x3D; A[r]</span><br><span class="line">2  i &#x3D; p-1</span><br><span class="line">3  for j &#x3D; p to r-1</span><br><span class="line">4    if A[j] &lt;&#x3D; x</span><br><span class="line">5        i &#x3D; i+1</span><br><span class="line">6        exchange A[i] with A[j]</span><br><span class="line">7  exchange A[i+1] with A[r]</span><br><span class="line">8  return i+1</span><br></pre></td></tr></table></figure><h4 id="2-算法复杂度-4"><a href="#2-算法复杂度-4" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)　</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= array[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i+<span class="number">1</span>], array[r] = array[r], array[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[len(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    quick_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X07、计数排序"><a href="#0X07、计数排序" class="headerlink" title="0X07、计数排序"></a>0X07、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="1-算法思路-3"><a href="#1-算法思路-3" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="2-算法复杂度-5"><a href="#2-算法复杂度-5" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</p><h4 id="3-算法实现-5"><a href="#3-算法实现-5" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    leng = len(array)</span><br><span class="line">    c = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, leng):</span><br><span class="line">        c[array[i]] = c[array[i]]+<span class="number">1</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>]+c[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(leng<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res[c[array[i]]<span class="number">-1</span>] = array[i]</span><br><span class="line">        c[array[i]] = c[array[i]]<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(count_sort(a))</span><br></pre></td></tr></table></figure><h2 id="0X08、基数排序"><a href="#0X08、基数排序" class="headerlink" title="0X08、基数排序"></a>0X08、基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="1-算法思路-4"><a href="#1-算法思路-4" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ul><h4 id="2-算法复杂度-6"><a href="#2-算法复杂度-6" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)<br>基数排序有两种方法：<br>MSD 从高位开始进行排序 LSD 从低位开始进行排序<br>基数排序 vs 计数排序 vs 桶排序<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h4 id="3-算法实现-6"><a href="#3-算法实现-6" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j//(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    radix_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X09、桶排序"><a href="#0X09、桶排序" class="headerlink" title="0X09、桶排序"></a>0X09、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h4 id="1-算法思路-5"><a href="#1-算法思路-5" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li></ul><h4 id="2-算法复杂度-7"><a href="#2-算法复杂度-7" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)　</p><h4 id="3-算法实现-7"><a href="#3-算法实现-7" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(lista)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        h.append(node(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lista)):</span><br><span class="line">        tmp = node(lista[i])</span><br><span class="line">        map = lista[i]//<span class="number">10</span></span><br><span class="line">        p = h[map]</span><br><span class="line">        <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">            h[map].next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span>(p.next != <span class="literal">None</span> <span class="keyword">and</span> p.next.key &lt;= tmp.key):</span><br><span class="line">                p = p.next</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        q = h[i].next</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">None</span>):</span><br><span class="line">            lista[k] = q.key</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bucket_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X10、堆排序"><a href="#0X10、堆排序" class="headerlink" title="0X10、堆排序"></a>0X10、堆排序</h2><p>堆排序(heap-sort),和归并排序一样，不同于插入排序的是，堆排序的时间复杂度是O(nlogn)。与插入排序相同，不同于堆排序的是，堆排序具有空间原址性：任何时候都需要常数个额外的元素空间来存储临时数据。<br>其思想便是引用一种成为堆的数据结构。常见的有大根堆（最大堆）和小根堆（最小堆）。在排序中一般使用大根堆，小根堆通常构建优先队列。</p><ul><li>大根堆：<ul><li>除了根以外的所有节点i都满足：A[PARENT(i)]&gt;=A[i]</li></ul></li><li>小根堆：<ul><li>除了根以外的所有节点i都满足：A[PARENT(i)]&lt;=A[i]</li></ul></li></ul><h4 id="1-算法思路-6"><a href="#1-算法思路-6" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>伪代码描述<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 用于维护最大根堆的性质</span><br><span class="line"># 对于树高为h的大根堆，其时间复杂度为O(h)</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">1  l &#x3D; LEFT(i)</span><br><span class="line">2  r &#x3D; RIGHT(i)</span><br><span class="line">3  if l &lt;&#x3D; A.heap-size and A[l] &gt; A[i]</span><br><span class="line">4    largest &#x3D; l</span><br><span class="line">5  else larget &#x3D; r</span><br><span class="line">6  if r &lt;&#x3D; A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">7    largest &#x3D; r</span><br><span class="line">8  if largest !&#x3D; i</span><br><span class="line">9    exchange A[i] with A[largest]</span><br><span class="line">10   MAX-HEAPIFY(A,largest)</span><br><span class="line"></span><br><span class="line"># 建堆</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">1  A.heap-size &#x3D; A.length</span><br><span class="line">2  for i &#x3D; ⌊A.length&#x2F;2⌋ downto 1</span><br><span class="line">3    MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">HEAP-SORT(A)</span><br><span class="line">1  BUILD-MAX-HEAP(A)</span><br><span class="line">2  for i &#x3D; A.length downto 2</span><br><span class="line">3    exchange A[1] with A[i]</span><br><span class="line">4    MAX-HEAPIFY(A, 1)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-算法复杂度-8"><a href="#2-算法复杂度-8" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-8"><a href="#3-算法实现-8" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_param</span><span class="params">(L, i, j)</span>:</span></span><br><span class="line">    L[i], L[j] = L[j], L[i]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    temp = L[start]</span><br><span class="line"></span><br><span class="line">    i = start</span><br><span class="line">    j = <span class="number">2</span> * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end) <span class="keyword">and</span> (L[j] &lt; L[j + <span class="number">1</span>]):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt; L[j]:</span><br><span class="line">            L[i] = L[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    L[i] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    L_length = len(L) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    first_sort_count = L_length // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first_sort_count):</span><br><span class="line">        heap_adjust(L, first_sort_count - i, L_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L_length - <span class="number">1</span>):</span><br><span class="line">        L = swap_param(L, <span class="number">1</span>, L_length - i)</span><br><span class="line">        heap_adjust(L, <span class="number">1</span>, L_length - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    L = deque(a)</span><br><span class="line">    L.appendleft(<span class="number">0</span>)</span><br><span class="line">    print(heap_sort(L))</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%90%8E%E7%AB%AF.html"/>
      <url>interview/%E5%90%8E%E7%AB%AF.html</url>
      
        <content type="html"><![CDATA[<h1 id="后端开发面试题"><a href="#后端开发面试题" class="headerlink" title="后端开发面试题"></a>后端开发面试题</h1><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>这篇文章翻译自一位外国友人的关于面试后端程序员的文章，我比较喜爱这篇文章。一是因为它极大的拓宽了我的视角，另一方面是其中的一些问题非常具有启发性。不仅对于面试者，对于面试官来说也是个不错的参考。于是迫不及待的翻译了一下，给各位看官做个参考。</p><p>这篇文章中，许多问题我并没有完全理解，所以翻译可能存在不准确的地方。如果有读者发现有一些翻译有误或者不好的地方，请不吝赐教。</p><p>原文参见 <a href="https://github.com/arialdomartini" target="_blank" rel="noopener">@arialdomartini</a>的: <a href="https://github.com/arialdomartini/Back-End-Developer-Interview-Questions" target="_blank" rel="noopener">Back-End Developer Interview Questions</a></p><p>以下是原文翻译。</p><h1 id="后端开发面试题-1"><a href="#后端开发面试题-1" class="headerlink" title="后端开发面试题"></a>后端开发面试题</h1><p>在面试的时候，我并不特别喜欢问一些技术性的问题。我更喜欢的方式是这样的: 和面试者坐在一起，看一些实际的代码，解决一些实际的问题。并且用一整天的时间，让团队所有成员轮流和面试者进行结对编程。虽然如此，但是一些技术问题仍然可以用来很好地启动一段有深度的谈话，能够让面试者和面试官相互都有更加深入的了解。</p><p>这个仓库包含了可以用来考核面试者的一系列后端面试题。但绝不是说，面试官必须用每个面试题来考核面试者（这样可能要耗费好几个小时）。根据你期望面试者拥有的技能，从这个列表中有选择的挑一些题目，可以帮助你在特定技能上考核面试者。</p><p>应当承认的是，这个项目的灵感来自于<a href="https://github.com/darcyclarke" target="_blank" rel="noopener">@darcyclarke</a>的文章<a href="https://github.com/darcyclarke/Front-end-Developer-Interview-Questions" target="_blank" rel="noopener">Front-end Job Interview Questions</a></p><p><strong>注意:</strong> 请记住，这些面试题中有许多问题是开放式的，能引导讨论一些有趣的问题。相比那些有直接答案的问题来说，这种问题能够让你对面试者的能力有更多的了解。再一次强调，我认为仅仅是问问题是不够的。要通过与面试者较长时间的结对编程来完成面试: 这是你们相互了解对方的风格和方法、让面试者了解未来工作的最佳手段之一。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a><a name='toc'>目录</a></h2><ol><li><a href="#general">通用问题</a></li><li><a href="#open">开放式问题</a></li><li><a href="#patterns">设计模式相关问题</a></li><li><a href="#design">代码设计相关问题</a></li><li><a href="#languages">语言相关问题</a></li><li><a href="#web">Web相关问题</a></li><li><a href="#databases">数据库相关问题</a></li><li><a href="#nosql">非关系型数据库相关问题</a></li><li><a href="#codeversioning">代码版本管理相关问题</a></li><li><a href="#concurrency">并发问题</a></li><li><a href="#distributed">分布式系统相关问题</a></li><li><a href="#management">软件生命周期和团队管理相关问题</a></li><li><a href="#algorithms">逻辑和算法相关问题</a></li><li><a href="#architecture">软件架构相关问题</a></li><li><a href="#soa">面向服务架构(SOA)和微服务(Microservice)相关问题</a></li><li><a href="#security">安全相关问题</a></li><li><a href="#billgates">比尔盖茨式问题</a></li><li><a href="#snippets">代码示例问题</a></li></ol><h4 id="通用问题-↑"><a href="#通用问题-↑" class="headerlink" title="通用问题: [↑]"></a><a name='general'>通用问题:</a> <a href="#toc">[↑]</a></h4><ul><li>语言设计中空引用(<a href="http://programmers.stackexchange.com/questions/12777/are-null-references-really-a-bad-thing" target="_blank" rel="noopener">null reference</a>)的存在有什么问题？假设你想要将空引用的概念从你的首选语言中移除，可能导致什么结果？</li><li>为什么函数式编程重要？什么时候适用函数式语言？</li><li>设计(design)、架构(architecture)、功能(functionality)和美学(aesthetic)之间有什么区别？讨论一下。</li><li>微软、谷歌、欧朋(opera)和火狐这类公司是如何从他们的浏览器中获利的？</li><li>为什么打开TCP套接字有很大的开销？</li><li>封装的重要性体现在哪儿？</li><li>什么是实时系统？它与普通系统有什么区别？</li><li>实时语言(real-time language)和堆内存分配(heap memory allocation)之间的关系是什么？</li><li>不变性(Immutability)是指: (变量的)值只能在创建的时候被设置一次，之后就不能被改变。为什么不变性对写更加安全的代码有帮助？</li><li>可变值(mutable values)和不可变值(immutable values)有哪些优缺点？</li><li>什么是O/R阻抗失衡(Object-Relational impedence mismatch)？</li><li>如果你需要使用缓存，你使用哪些原则来确定缓存的大小？</li><li>TCP和HTTP有什么区别？</li><li>在客户端渲染(client-side rendering)和服务端渲染(server-side rendering)之间，你是如何权衡的？</li><li>如何在一个不可靠的协议之上构建一个可靠的通信协议？</li></ul><h4 id="开放式问题-↑"><a href="#开放式问题-↑" class="headerlink" title="开放式问题: [↑]"></a><a name='open'>开放式问题:</a> <a href="#toc">[↑]</a></h4><ul><li>为什么人们会抵制变化？</li><li>如何向你的祖母解释什么是线程？</li><li>作为一个软件工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</li><li>什么是好的代码？</li><li>解释什么是流(Streaming)和如何实现一个流？</li><li>假设你的公司给你一周的时间，用来改善你和同事的生活: 你将如何使用这一周？</li><li>本周你学了什么？</li><li>所有的设计中都会有美学元素(aesthetic element)的存在。问题是，你认为美学元素是你的朋友还是敌人？</li><li>列出最近你读过的5本书。</li><li>假设目前有个大型公司（非常有钱），他们的开发流程是瀑布式流程（Waterfall），如果需要你在他们公司引入持续交付（<a href="https://en.wikipedia.org/wiki/Continuous_delivery" target="_blank" rel="noopener">Continue Devivery</a>），你会怎么做？</li><li>我们来谈谈”<em>重复造轮子</em>“,”<em>非我发明症</em>“, “<em>吃自己做出来的狗粮</em>“的这些做法吧。</li></ul><p>(注: 重复造轮子: Reinventing the wheel; 非我发明症:Not Invented Here Syndrome; 吃自己做出来的狗粮: Eating Your Own Dog Food)</p><ul><li>在你当前的工作流中，什么事情是你计划下一步需要自动化的？</li><li>为什么写软件是困难的？是什么使软件的维护变得困难？</li><li>你更喜欢在全新项目（Green Field Project）上工作还是在已有项目(Brown Field Project)基础上工作？为什么？</li><li><a href="https://github.com/alex/what-happens-when" target="_blank" rel="noopener">当你在浏览器地址栏输入google.com回车之后都发生了什么?</a></li><li>当操作系统CPU处于空闲的时候，它可能在处理哪些事情？</li><li>如何向一个5岁的孩子解释什么是Unicode/数据库事务？</li><li>如何维护单体架构(monolithic architecture)？</li><li>一个”专业的开发者”意味着什么？</li><li>软件开发是艺术、是技艺还是工程？你的观点是什么？</li><li>“喜欢这个的人也喜欢…”，如何在一个电子商务商店里实现这种功能？</li><li>为什么在创新上，企业会比创业公司慢些？</li><li>为什么说，对于涉及密码学的问题，你不应该尝试应用自己的发明或者设计？</li></ul><h4 id="设计模式相关问题-↑"><a href="#设计模式相关问题-↑" class="headerlink" title="设计模式相关问题: [↑]"></a><a name='patterns'>设计模式相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>请用一个例子表明，全局对象是邪恶的存在。</li><li>假设你工作的系统不支持事务性，你会如何从头开始实现它？</li><li>什么是好莱坞原则（Hollywood Principles）？</li><li>关于迪米特法则(最少知识原则): 写一段代码违反它, 然后修复它。</li></ul><p>（注: 迪米特法则：the Law of Demeter, 最少知识原则： the Principle of Least Knowledge）</p><ul><li>Active-Record模式有什么限制和缺陷？</li><li>Data-Mapper模式和Active-Record模式有什么区别？</li><li>空对象模式(Null Object Pattern)的目的是什么？</li><li>为什么组合(Composition)比继承(Inheritance)更好？</li><li>什么是反腐败层(Anti-corruption Layer)?</li><li>你可以写一个线程安全的单例(Singleton)类吗？</li><li>数据抽象(Data Abstraction)能力是指能改变实现而不影响客户端的这种能力。请构造一个一个例子，违反这个特性，并且尝试修复它。</li><li>你是如何处理依赖关系地狱(Dependency Hell)的？</li><li>为什么说goto语句是恶魔般的存在？</li><li>健壮性是进行软件设计时的一个通用原则，它建议 <em>“发送时要保守，接收时要开放”</em>。这也经常被写成，“做一个有耐心的读者，做一个谨慎的作者”。你能解释一些这背后的逻辑吗？</li></ul><p>译者注： “发送时要保守，接收时要开发”的原文是： “Be conservative in what you send, be liberal in what you accept”，有点类似于“严于律己，宽于待人”的意味。</p><h4 id="代码设计相关问题-↑"><a href="#代码设计相关问题-↑" class="headerlink" title="代码设计相关问题: [↑]"></a><a name='design'>代码设计相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>你在进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</li><li>内聚和耦合的区别是什么？</li><li>重构在哪些场景下有用？</li><li>代码中的注释有用吗？</li><li>设计和架构有什么区别？</li><li>为什么在测试驱动开发(TDD)中是先写测试，再写代码？</li><li>C++支持多继承，Java 允许类实现多个接口。这些特性对正交性有什么影响？使用多继承和使用多接口有区别吗？[这个问题来自Andrew .Hunt 和 David Thomas写的《程序员修炼之道》]</li><li>在存储过程（Stored Procedures）中写业务逻辑有什么优缺点？</li></ul><h4 id="语言相关问题-↑"><a href="#语言相关问题-↑" class="headerlink" title="语言相关问题: [↑]"></a><a name='languages'>语言相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>告诉我你的首选语言的三个最坏的缺陷。</li><li>为什么现在函数式编程这么越来越受关注？</li><li>闭包是什么？它有什么用途？闭包和类有什么共同点？</li><li>泛型有什么用途？</li><li>什么是高阶函数？有什么用途？用你的首选语言写个例子出来。</li><li>讨论一下，如何写一个循环，然后把它转换成递归函数，要避免易变性。</li><li>有些语言将函数视为第一公民，这是什么意思？</li><li>用一个例子说明匿名函数是有用的。</li><li>什么是动态方法调度(Dynamic Method Dispatch)？</li><li>名字空间(Namespace)有什么用？有什么可以替代它的吗？</li><li>谈谈Java和C#之间的互操作性(Interoperability) (任选其他两门语言都行)</li><li>为什么很多软件工程师不喜欢Java？</li><li>你认为好的语言好在哪里？差的语言差在哪里？</li><li>写两个函数，一个是”引用透明的(Referentially Transparent)”，另一个是”引用不透明的(Referentially Opaque)”。讨论之。</li><li>什么是栈？什么是堆？</li><li>为什么一个语言中，”函数是第一公民”是很重要的？</li><li>模式匹配(Pattern Matching)和Switch语句(Switch clauses)的区别在哪儿？</li><li>为什么有些语言设计上没有异常机制？这有什么优缺点？</li><li>如果<code>Cat</code>是一个<code>Animal</code>, 那么<code>TaskCare&lt;Cat&gt;</code>是一个<code>TakeCare&lt;Animal&gt;</code>吗？</li></ul><h4 id="web相关问题-↑"><a href="#web相关问题-↑" class="headerlink" title="web相关问题: [↑]"></a><a name='web'>web相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>为什么”第一方cookie(first-party cookie)”和”第三方cookie(third-party cookie)”被如此不同的对待？</li></ul><h4 id="数据库相关问题-↑"><a href="#数据库相关问题-↑" class="headerlink" title="数据库相关问题: [↑]"></a><a name='databases'>数据库相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>如果要你将一个项目从MySQL迁移至PostgreSQL中，你会如何迁移？</li><li>为什么<code>SELECT * FROM table WHERE field = null</code>不能匹配空的字段？</li><li>什么是ACID(原子性，一致性，隔离性，持久性)原则？</li><li>你是如何进行数据库模式(Database schema)迁移的？</li><li>延迟加载(lazy loading)是如何实现的？什么场景下有用？他有什么缺陷？</li><li>什么是N+1问题？</li><li>如何找出应用中开销最大的查询？</li></ul><h4 id="非关系型数据库相关问题-↑"><a href="#非关系型数据库相关问题-↑" class="headerlink" title="非关系型数据库相关问题: [↑]"></a><a name='nosql'>非关系型数据库相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>什么是最终一致性(Eventual Consistency)？</li><li>关于CAP理论，举一些CP、AP、CA系统的例子。</li><li>NoSQL是如何解决可伸缩性的挑战的？</li><li>什么情况下你会使用类似于MongoDB的文档数据库而不是关系型数据库（如Mysql或者PostgreSQL）？</li></ul><h4 id="代码版本管理相关问题-↑"><a href="#代码版本管理相关问题-↑" class="headerlink" title="代码版本管理相关问题: [↑]"></a><a name='codeversioning'>代码版本管理相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>为什么在Mercurial或者git中(管理)分支比SVN容易？</li><li>分散式版本控制系统（比如git），相比集中式版本控制系统（如svn）有哪些优势和劣势？</li></ul><p>(注:集中式版本控制系统: Centralized Version Control Systems；分散式版本控制系统: Distributed Version Control Systems)</p><ul><li>能描述一下什么是GitHubFlow和GitFlow工作流吗？</li><li>什么是rebase？</li><li>为什么合并操作(merge)在Mercurial和git中比在SVN和CVS中容易？</li></ul><h4 id="并发问题-↑"><a href="#并发问题-↑" class="headerlink" title="并发问题: [↑]"></a><a name='concurrency'>并发问题:</a> <a href="#toc">[↑]</a></h4><ul><li>为什么我们需要并发呢？解释一下。</li><li>为什么测试多线程/并发代码这么困难？</li><li>什么是竞争条件（Race Condition）？用任何一个语言写一个例子。</li><li>什么是死锁？用代码解释一下。</li><li>什么是饿死？</li><li>什么是Wait-Free算法？</li></ul><h4 id="分布式系统相关问题-↑"><a href="#分布式系统相关问题-↑" class="headerlink" title="分布式系统相关问题: [↑]"></a><a name='distributed'>分布式系统相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>怎么测试一个分布式系统？</li><li>什么场景下你会在两个系统中采用异步通信机制？</li><li>远程过程调用的通用缺点是什么？</li><li>如果你为了可扩展性和鲁棒性而构建一个分布式的系统，分别在封闭安全的网络环境情况下，和地理上的位置不同但是网络环境不是封闭和安全的情况下，你会考虑什么不同的事情？</li><li>在Web应用中如何管理容错性？在桌面端呢？</li><li>在分布式系统中，如何处理故障？</li><li>让我们来谈谈在网络分区(network partitions)情况下的几种（一致性）解决方案吧。</li><li>你认为分布式计算中有哪些谬论？</li><li>你在什么时候会使用Request/Response模式，什么时候使用Publish/Subscribe模式？</li></ul><h4 id="软件生命周期和团队管理相关问题-↑"><a href="#软件生命周期和团队管理相关问题-↑" class="headerlink" title="软件生命周期和团队管理相关问题: [↑]"></a><a name='management'>软件生命周期和团队管理相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li><p>什么是敏捷（Agility）？</p></li><li><p>你是如何处理遗留代码（Legacy Code）的？</p></li><li><p>假设我是你们公司的CEO，请向我解释什么是看板，并且说服我在它上面投资。</p></li><li><p>敏捷（Agility）和瀑布（Waterfall）之间的最大区别是什么？</p></li><li><p>作为团队管理者，你对会议太多这个问题是如何处理的？</p></li><li><p>你会如何处理延期很长时间了的项目？</p></li><li><p>“<em>个体与交互重于过程和工具</em>“和”<em>客户协作重于合同谈判</em>“占了敏捷宣言（Agile Manifesto）的一半，谈论一下这两个观念。</p></li><li><p>如果你是你们公司的CTO，你会采取什么样的决策？</p></li><li><p>你觉得项目经理有用吗？</p></li><li><p>如果要你组织一个弹性工作制的开发团队（即没有强制工作时间的要求），并且假期制度是”按需休假”，你会如何做？</p></li><li><p>你会如何管理一个人员流动非常高的团队？如何在不加薪的条件下说服团队成员不要离开？</p></li><li><p>除了代码之外，你最关注你的同事的哪3项素质？</p></li><li><p>关于代码，你最希望非技术人员能知道的的三件事是什么？</p></li></ul><h4 id="逻辑和算法相关问题-↑"><a href="#逻辑和算法相关问题-↑" class="headerlink" title="逻辑和算法相关问题: [↑]"></a><a name='algorithms'>逻辑和算法相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>只用LIFO栈如何构造一个FIFO队列？只用FIFO队列如何构造一个LIFO栈？</li><li>写一段有栈溢出的代码。</li><li>写一个尾递归版本的阶乘函数。</li><li>使用任何一个语言，写一个REPL，功能是echo你输入的字符串。然后将它演化成一个逆波兰表达式的计算器。</li><li>如果需要你设计一个文件系统磁盘碎片整理程序，你会如何设计？</li><li>写一个生成随机迷宫的程序。</li><li>写一段有内存泄漏的示例代码。</li><li>随机生成一个的数字序列，里面每个数字都不同。</li><li>写一个简单的垃圾回收系统。</li><li>使用任何一门语言，写一个基本的消息代理。</li><li>写一个基础的web服务器，然后画一张线路图，展示你将来还想要实现的功能。</li><li>如何对一个10GB的文件进行排序？如果是10TB的数据，你会采用什么方法？</li><li>请实现<code>rnd()</code>函数</li></ul><h4 id="软件架构相关问题-↑"><a href="#软件架构相关问题-↑" class="headerlink" title="软件架构相关问题: [↑]"></a><a name='architecture'>软件架构相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>什么情况下缓存是没用的，甚至是危险的？</li><li>为什么事件驱动的架构能提高可扩展性(scalability)？</li><li>什么样的代码是可读性强的代码？</li><li>紧急设计(Emergent Design)和演化架构(Evolutionary Architecture)之间的区别是什么？</li><li>横向扩展(scale out) vs 纵向扩展(scale up): 有什么区别？分别在什么场景下使用？</li><li>分布式系统中如何处理”故障切换(failover)”和”用户会话(user session)”？</li><li>什么是CQRS(Command Query Responsibility Segregation)?他和最早的Command-Query Separation原则有什么区别？</li><li>什么是三层架构？</li><li>如何设计一个可扩展性高的系统？</li><li>处理C10k问题的策略有哪些？</li><li>如果让你来设计一个去中心化的P2P系统，你会如何设计？</li><li>为什么CGI的扩展性不好？</li><li>在设计系统时，你如何防止供应商依赖(<a href="https://sourcemaking.com/antipatterns/vendor-lock-in" target="_blank" rel="noopener">Vendor Lock-in</a>)？</li><li>在可扩展性上，发布/订阅(Publish-Subscribe)模式有什么缺点？</li><li>80年代以后，CPU有哪些变化？这些变化，对编程产生了什么影响？</li><li>性能生命周期(performace lifecycle)中，你认为哪个部分是需要考虑进去的？ 如何管理？</li><li>除了恶意攻击造成的拒绝服务现象以外，哪些设计或者架构上的问题会导致拒绝服务？</li><li>性能和可扩展性之间有什么关系？</li><li>什么时候紧耦合是OK的？</li><li>一个系统要有什么特征才能适配云计算环境(Cloud Ready)？</li><li>Does unity of design imply an aristocracy of architects?</li></ul><h4 id="面向服务架构-SOA-和微服务-Microservice-相关问题-↑"><a href="#面向服务架构-SOA-和微服务-Microservice-相关问题-↑" class="headerlink" title="面向服务架构(SOA)和微服务(Microservice)相关问题: [↑]"></a><a name='soa'>面向服务架构(SOA)和微服务(Microservice)相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>在SOA中，为什么长期存活的事务(Long-lived transation)不被看好，而Saga却被看好？</li><li>SOA和MicroService之间有什么区别？</li><li>我们来谈谈Web服务的版本管理、版本兼容性、重大变更管理这些事情吧.</li><li>在saga中事务和补偿操作(compensation operation)之间的区别是什么？在SOA中呢？</li><li>微服务不能做得太”微”，你认为什么时候微服务太”微”了？</li><li>MicroService架构的优劣是什么？</li></ul><h4 id="安全相关问题-↑"><a href="#安全相关问题-↑" class="headerlink" title="安全相关问题: [↑]"></a><a name='security'>安全相关问题:</a> <a href="#toc">[↑]</a></h4><ul><li>什么是双因素认证(Two Factor Authentication)？在一个已有的Web应用中，你如何实现这种机制？</li></ul><h4 id="比尔盖茨式问题-↑"><a href="#比尔盖茨式问题-↑" class="headerlink" title="比尔盖茨式问题: [↑]"></a><a name='billgates'>比尔盖茨式问题:</a> <a href="#toc">[↑]</a></h4><ul><li>如果你把一面镜子放在扫描仪上，会发生什么？</li><li>假设有一个和你完全一样的克隆人，而他是你的上司，你愿意和他工作吗？</li><li>现在请你面试一下我。</li><li>为什么Quora上的回答会比Yahoo Answer上的回答好？</li><li>对手是现代语言，你的任务是要为Cobol辩护，你会如何进行？</li><li>10年后的你是什么样子？</li><li>假设你是我老板，我被解雇了。你会如何通知我？</li><li>我想要重构一个系统，而你想要从头重写。我们来争论一下该怎么弄吧。然后我们反转角色，再争论一下。</li><li>老板要你对公司撒谎，你的反应是什么？</li><li>如果你可以穿越到以前，你会给年轻时候的你什么建议？</li></ul><h4 id="代码示例问题-↑"><a href="#代码示例问题-↑" class="headerlink" title="代码示例问题: [↑]"></a><a name='snippets'>代码示例问题:</a> <a href="#toc">[↑]</a></h4><ul><li>这段Javascript函数的输出是什么？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hookupevents</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">"button"</span> + i)</span><br><span class="line">      .addEventListener(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(i);</span><br><span class="line">      &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>关于类型擦除(Type Erasure)，这段Java代码的输出是什么？为什么？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; li = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">ArrayList&lt;Float&gt; lf = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</span><br><span class="line"><span class="keyword">if</span> (li.getClass() == lf.getClass()) <span class="comment">// evaluates to true</span></span><br><span class="line">  System.out.println(<span class="string">"Equal"</span>);</span><br></pre></td></tr></table></figure><ul><li>你能指出哪儿有内存泄漏吗？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>if</code>语句，或者更加通用点，条件表达式通常是过程式编程/命令式编程的形式。你能去掉这段代码中的<code>switch</code>语句，用面向对象的方式来修改这段代码吗？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Formatter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Service service;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Formatter</span><span class="params">(Service service)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.service = service;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">doTheJob</span><span class="params">(String theInput)</span> </span>&#123;</span><br><span class="line">        String response = service.askForPermission();</span><br><span class="line">        <span class="keyword">switch</span> (response) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"FAIL"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"OK"</span>:</span><br><span class="line">            <span class="keyword">return</span> String.format(<span class="string">"%s%s"</span>, theInput, theInput);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>你能去掉这里的<code>if</code>语句，将它改成更加面向对象吗？</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TheService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FileHandler fileHandler;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FooRepository fooRepository;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TheService</span><span class="params">(FileHandler fileHandler, FooRepository fooRepository)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileHandler = fileHandler;</span><br><span class="line">        <span class="keyword">this</span>.fooRepository = fooRepository;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Execute</span><span class="params">(<span class="keyword">final</span> String file)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> String rewrittenUrl = fileHandler.getXmlFileFromFileName(file);</span><br><span class="line">        <span class="keyword">final</span> String executionId = fileHandler.getExecutionIdFromFileName(file);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((executionId == <span class="string">""</span>) || (rewrittenUrl == <span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Foo knownFoo = fooRepository.getFooByXmlFileName(rewrittenUrl);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (knownFoo == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> knownFoo.DoThat(file);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何重构这段代码？</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT error = S_OK;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(SUCCEEDED(Operation1()))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SUCCEEDED(Operation2()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(SUCCEEDED(Operation3()))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(SUCCEEDED(Operation4()))</span><br><span class="line">                &#123;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    error = OPERATION4FAILED;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                error = OPERATION3FAILED;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            error = OPERATION2FAILED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        error = OPERATION1FAILED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E7%AE%97%E6%B3%95.html"/>
      <url>interview/%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<ul><li>第一：复杂度估算和排序算法（上）<ul><li>1) 时间复杂度和空间复杂度</li><li>2）认识对数器</li><li>3）冒泡排序</li><li>4）选择排序</li><li>5）插入排序</li><li>6）如何分析递归过程的时间复杂度</li><li>7）归并排序</li><li>8）小和问题</li></ul></li><li>第二：复杂度估算和排序算法（下）<ul><li>1）荷兰国旗问题</li><li>2）随机快速排序</li><li>3）堆结构与堆排序</li><li>4）认识排序算法的稳定性</li><li>5）认识比较器</li><li>6）桶排序</li><li>7）计数排序</li><li>8）基数排序</li><li>9）数组排序后的最大差值问题</li><li>10）排序算法在工程中的应用</li></ul></li><li>第三：章栈、队列、链表、数组和矩阵结构<br>  1）栈结构<br>  2）队列结构<br>  3）链表结构<br>  4）数组结构<br>  5）矩阵结构<br>  6）二分搜索的扩展</li><li>第四：二叉树结构<ul><li>1）二叉树结构</li><li>2）二叉树的递归与非递归遍历</li><li>3）打印二叉树</li><li>4）判断搜索二叉树</li><li>5）判断完全二叉树</li><li>6）判断平衡二叉树</li><li>7）折纸问题</li><li>8）二叉树节点的前驱节点与后继节点</li><li>9）二叉树的序列化和反序列化</li></ul></li><li>第五：和哈希函数有关的三个结构与并查集<br>  1）哈希函数与哈希表<br>  2）布隆过滤器详解<br>  3）一致性哈希结构<br>  4）并查集结构与应用（岛问题）</li><li>第六：章图算法<br>  1）图结构的表示方法<br>  2）图的深度优先遍历与宽度优先遍历<br>  3）拓扑排序问题<br>  4）最小生成树问题<br>  5）单源最短路径问题</li><li>第七：前缀树、堆结构和贪心算法<br>  1）前缀树<br>  2）堆结构的扩展与应用<br>  3）介绍贪心算法及其相关题目<br>  4）在面试中如何快速的尝试出贪心策略</li><li>第八：暴力递归到动态规划<br>  1）递归<br>  2）动态规划<br>  3）如何把暴力递归套路的变成动态规划<br>算法高级：<br>第一：KMP算法和Manacher算法<br>  1）KMP算法及其扩展面试题目<br>  2）Manacher算法及其扩展面试题目<br>第二：窗口内最大值的更新结构和单调栈结构<br>  1）窗口内最大值的更新结构<br>  2）单调栈结构<br>第三：Morris遍历和sortedMap<br>  1）二叉树的Morris遍历<br>  2）跳表结构<br>  3）AVL树和红黑树结构<br>【今日头条、拼多多题目】<br>分类算法的理解<ul><li>决策树的原理</li><li>支持向量机</li><li>逻辑斯蒂回归<br>聚类算法的理解</li><li>均值聚类，可选的参数，如果确定聚类个数</li><li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li><li>xgboost</li><li>gbdt<br>【面试题目】</li><li><ol><li>二叉树前序递归遍历算法（手写代码）</li></ol></li><li><ol start="2"><li>二叉树的前中后遍历</li></ol></li><li><ol start="3"><li>二叉树的文件存储，也就是序列化。</li></ol></li><li><ol start="4"><li>二叉树遍历，描述下层序遍历。</li></ol></li><li><ol start="5"><li>二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。</li></ol></li><li><ol start="6"><li>二维数组，每行递增，每列递增，实现查找。</li></ol></li><li><ol start="7"><li>二维数组，每行递增，每列递增，求第k大的数。</li></ol></li><li><ol start="8"><li>什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。</li></ol></li><li><ol start="9"><li>介绍二叉树前序遍历非递归遍历算法（手写代码）</li></ol></li><li><ol start="10"><li>介绍大顶堆和小顶堆</li></ol></li><li><ol start="11"><li>从一组数中找出和为sum的三个数（leetcode）</li></ol></li><li><ol start="12"><li>冒泡排序(手写代码)</li></ol></li><li><ol start="13"><li>写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）</li></ol></li><li><ol start="14"><li>写一个二叉树的非递归的后续遍历</li></ol></li><li><ol start="15"><li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)</li></ol></li><li><ol start="16"><li>写个动态规划，最长公共子序列</li></ol></li><li><ol start="17"><li>判断一个字符串是否为另外一个字符串旋转之后的字符串</li></ol></li><li><ol start="18"><li>前k大的数</li></ol></li><li><ol start="19"><li>单链表的翻转</li></ol></li><li><ol start="20"><li>去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。</li></ol></li><li><ol start="21"><li>去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’。（Code）</li></ol></li><li><ol start="22"><li>合法括号匹配</li></ol></li><li><ol start="23"><li>在一个字符串中，找出最长的无重复字符的字串</li></ol></li><li><ol start="24"><li>在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）</li></ol></li><li><ol start="25"><li>堆排序(手写代码)</li></ol></li><li><ol start="26"><li>堆是怎么调整的。</li></ol></li><li><ol start="27"><li>复杂链表的复制<br>【大数据题目】</li></ol></li><li><ol><li>100亿数字，怎么统计前100大的？</li></ol></li><li><ol start="2"><li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li></ol></li><li><ol start="3"><li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li></ol></li><li><ol start="4"><li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li></ol></li><li><ol start="5"><li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li></ol></li><li><ol start="6"><li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li></ol></li><li><ol start="7"><li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li></ol></li><li><ol start="8"><li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li></ol></li><li><ol start="9"><li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li></ol></li><li><ol start="10"><li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li></ol></li><li><ol start="11"><li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li></ol></li><li><ol start="12"><li>海量数据的topk问题。</li></ol></li></ul></li></ul><ul><li><ol start="2"><li>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</li></ol><ul><li><ol start="3"><li>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</li></ol></li><li><ol start="4"><li>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</li></ol></li><li><ol start="5"><li>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</li></ol></li><li><ol start="6"><li>二分查找（一般会深入，如寻找数组总和为K的两个数字）</li></ol></li><li><ol start="7"><li>两个栈实现队列。</li></ol></li><li><ol start="8"><li>图（深度广度优先遍历、单源最短路径、最小生成树）</li></ol></li><li><ol start="9"><li>动态规划问题。</li></ol></li><li><ol start="10"><li>深入</li></ol></li><li><ol start="11"><li>红黑树性质</li></ol></li><li><ol start="12"><li>分治法和动态规划的区别</li></ol></li><li><ol start="13"><li>计算时间复杂度</li></ol></li><li><ol start="14"><li>二叉树和哈希表查找的时间复杂度</li></ol></li></ul></li></ul><ul><li><p>常用的数据结构有哪些？</p><ul><li>Arrays</li><li>Binary Trees</li><li>Graphs</li><li>Linked Lists</li><li>Matrixes</li><li>Stacks</li><li>Queues</li><li>Heaps</li><li>Hash Tables</li></ul></li><li><p>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。<br>&lt;？php<br>function fuhuan($allnum, $ti){<br>   $arr = array();<br>   for($i = 0; $i &lt; $allnum; $i++){</p><pre><code>$arr[$i] = $i;</code></pre><p>   }</p><p>   $nums = 1;<br>   while(count($arr) &gt; 1){</p><pre><code> foreach ($arr as $key =&gt; $value) {     if($nums == $ti){         unset($arr[$key]);         $nums = 1;     }else{         $nums++;     }}</code></pre><p>   }<br>   $new_arr = array_values($arr);<br>   var_dump($new_arr[0] + 1);<br>}<br>fuhuan(10,10);</p></li></ul><ul><li>常用的数据结构有哪些？</li><li>Graph Data Structure Interview Questions<ul><li>Breadth First Search</li><li>Depth First Search</li><li>A* Search</li><li>Dijkstra Algorithm</li><li>Comparing BFS, DFS, A* and Dijkstra</li></ul></li><li>Linked List Interview Questions (coming soon)<ul><li>Inserting and Removing nodes</li><li>Comparing Strings</li><li>Reversing a List</li><li>Selecting a Random Node</li></ul></li><li>Dynamic Programming Interview Questions (coming soon)<ul><li>Fibonacci Number Sequence</li><li>Longest Common Subsequence</li></ul></li><li>Sorting an Searching Interview Questions (coming soon)<ul><li>Binary Search</li><li>Bubble Sort</li><li>Insertion Sort</li><li>Merge Sort</li><li>Heap Sort</li><li>Quick Sort</li><li>Interpolation</li><li>Tree/Binary Search Tree</li><li>Minimum Depth</li><li>Maximum Path Sum</li></ul></li><li>Number Theory Interview Questions (coming soon)<ul><li>Euclid’s GCD Algorithm</li><li>Extending Euclid’s GCD Algorithm</li><li>Diophantine Equation</li><li>Chinese Remainder Theorem</li><li>Modular Inverse</li><li>Semi-Perfect Numbers</li></ul></li><li>String Interview Questions (coming soon)<ul><li>Reversing a String</li><li>Checking if String contains only digits</li><li>Finding Duplicate Characters in a String</li><li>How to Convert a String to Integer</li><li>Removing Duplicate Characters in a String</li><li>Finding the Maximum Occuring Character in a String</li><li>Find the First Non-Repeating Character in a String</li><li>Checking if Two Strings are Anagrams of Each Other</li><li>Counting the Number of Words in a String</li></ul></li><li>Array Interview Questions (coming soon)<ul><li>Finding the Missing Number from Array</li><li>Finding Duplicate Integers in an Array</li><li>Finding the Largest and Smallest Number in Unsorted Array</li><li>Removing Duplicates from an Array</li><li>Reversing an Array</li><li>Finding the k-th Smallest Integer in an Unsorted Array</li><li>Finding Common Elements Between Multiple Arrays</li></ul></li><li>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。</li></ul><p>其中算法，主要是以下几种：<br>•基础技巧：分治、二分、贪心<br>•排序算法：快速排序、归并排序、计数排序<br>•搜索算法：回溯、递归、深度优先遍历，广度优先遍历，二叉搜索树等<br>•图论：最短路径、最小生成树<br>•动态规划：背包问题、最长子序列<br>数据结构，主要有如下几种：<br>•数组与链表：单 / 双向链表<br>•栈与队列<br>•哈希表<br>•堆：最大堆 ／ 最小堆<br>•树与图：最近公共祖先、并查集<br>•字符串：前缀树（字典树） ／ 后缀树</p><p>leetcode 经典题目的解析<br>简单难度</p><ol start="20"><li>Valid Parentheses：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/20.validParentheses.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/20.validParentheses.md</a><br>26.remove-duplicates-from-sorted-array：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/26.remove-duplicates-from-sorted-array.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/26.remove-duplicates-from-sorted-array.md</a></li><li>merge-sorted-array：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/88.merge-sorted-array.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/88.merge-sorted-array.md</a><br>136.single-number：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/136.single-number.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/136.single-number.md</a><br>167.two-sum-ii-input-array-is-sorted：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/167.two-sum-ii-input-array-is-sorted.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/167.two-sum-ii-input-array-is-sorted.md</a></li><li>majority-element：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/169.majority-element.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/169.majority-element.md</a><br>190.reverse-bits：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/190.reverse-bits.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/190.reverse-bits.md</a><br>191.number-of-1-bits：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/191.number-of-1-bits.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/191.number-of-1-bits.md</a><br>203.remove-linked-list-elements：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/203.remove-linked-list-elements.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/203.remove-linked-list-elements.md</a><br>206.reverse-linked-list：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/206.reverse-linked-list.md</a><br>219.contains-duplicate-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/219.contains-duplicate-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/219.contains-duplicate-ii.md</a><br>226.invert-binary-tree：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/226.invert-binary-tree.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/226.invert-binary-tree.md</a><br>283.move-zeroes：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/283.move-zeroes.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/283.move-zeroes.md</a><br>349.intersection-of-two-arrays：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/349.intersection-of-two-arrays.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/349.intersection-of-two-arrays.md</a><br>中等难度<ol start="2"><li>Add Two Numbers：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/2.addTwoNumbers.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/2.addTwoNumbers.md</a></li><li>Longest Substring Without Repeating Characters：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/3.longestSubstringWithoutRepeatingCharacters.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/3.longestSubstringWithoutRepeatingCharacters.md</a></li><li>container-with-most-water：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/11.container-with-most-water.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/11.container-with-most-water.md</a></li><li>Remove Nth Node From End of List：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/19.removeNthNodeFromEndofList.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/19.removeNthNodeFromEndofList.md</a></li><li>Swap Nodes In Pairs：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/24.swapNodesInPairs.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/24.swapNodesInPairs.md</a></li></ol></li><li>combination-sum：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/39.combination-sum.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/39.combination-sum.md</a></li><li>combination-sum-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/40.combination-sum-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/40.combination-sum-ii.md</a></li><li>permutations：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/46.permutations.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/46.permutations.md</a></li><li>permutations-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/47.permutations-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/47.permutations-ii.md</a></li><li>jump-game：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/55.jump-game.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/55.jump-game.md</a></li><li>unique-paths：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/62.unique-paths.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/62.unique-paths.md</a><br>75.sort-colors：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/75.sort-colors.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/75.sort-colors.md</a></li><li>subsets：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/78.subsets.md</a><br>86.partition-list：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/86.partition-list.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/86.partition-list.md</a></li><li>subsets-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/90.subsets-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/90.subsets-ii.md</a><br>92.reverse-linked-list-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/92.reverse-linked-list-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/92.reverse-linked-list-ii.md</a><br>94.binary-tree-inorder-traversal：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/94.binary-tree-inorder-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/94.binary-tree-inorder-traversal.md</a><br>102.binary-tree-level-order-traversal：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/102.binary-tree-level-order-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/102.binary-tree-level-order-traversal.md</a><br>103.binary-tree-zigzag-level-order-traversal：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/103.binary-tree-zigzag-level-order-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/103.binary-tree-zigzag-level-order-traversal.md</a><br>139.word-break：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/139.word-breakmd" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/139.word-breakmd</a><br>144.binary-tree-preorder-traversal：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/144.binary-tree-preorder-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/144.binary-tree-preorder-traversal.md</a></li><li>evaluate-reverse-polish-notation：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/150.evaluate-reverse-polish-notation.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/150.evaluate-reverse-polish-notation.md</a></li><li>maximum-product-subarray：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/152.maximum-product-subarray.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/152.maximum-product-subarray.md</a><br>199.binary-tree-right-side-view：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/199.binary-tree-right-side-view.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/199.binary-tree-right-side-view.md</a><br>201.bitwise-and-of-numbers-range：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/201.bitwise-and-of-numbers-range.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/201.bitwise-and-of-numbers-range.md</a></li><li>implement-trie-prefix-tree：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/208.implement-trie-prefix-tree.md</a></li><li>minimum-size-subarray-sum：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/209.minimum-size-subarray-sum.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/209.minimum-size-subarray-sum.md</a></li><li>lowest-common-ancestor-of-a-binary-tree：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/236.lowest-common-ancestor-of-a-binary-tree.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/236.lowest-common-ancestor-of-a-binary-tree.md</a></li><li>product-of-array-except-self：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/238.product-of-array-except-self.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/238.product-of-array-except-self.md</a><br>240.search-a-2-d-matrix-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/240.search-a-2-d-matrix-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/240.search-a-2-d-matrix-ii.md</a></li><li>perfect-squares：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/279.perfect-squares.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/279.perfect-squares.md</a><br>322.coin-change：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/322.coin-change.md</a></li><li>increasing-triplet-subsequence：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/334.increasing-triplet-subsequence.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/334.increasing-triplet-subsequence.md</a><br>328.odd-even-linked-list：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/328.odd-even-linked-list.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/328.odd-even-linked-list.md</a><br>416.partition-equal-subset-sum：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/416.partition-equal-subset-sum.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/416.partition-equal-subset-sum.md</a><br>445.add-two-numbers-ii：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/445.add-two-numbers-ii.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/445.add-two-numbers-ii.md</a><br>518.coin-change-2：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/518.coin-change-2.md</a><br>875.koko-eating-bananas：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/875.koko-eating-bananas.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/875.koko-eating-bananas.md</a><br>877.stone-game：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/877.stone-game.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/877.stone-game.md</a><br>887.super-egg-drop：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/887.super-egg-drop.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/887.super-egg-drop.md</a><br>900.rle-iterator：<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/900.rle-iterator.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/900.rle-iterator.md</a><br>困难难度</li><li>merge-k-sorted-lists<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/23.merge-k-sorted-lists.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/23.merge-k-sorted-lists.md</a></li><li>trapping-rain-water<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/42.trapping-rain-water.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/42.trapping-rain-water.md</a></li><li>longest-consecutive-sequence<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/128.longest-consecutive-sequence.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/128.longest-consecutive-sequence.md</a><br>145.binary-tree-postorder-traversal<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/145.binary-tree-postorder-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/145.binary-tree-postorder-traversal.md</a><br>146.lru-cache<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/146.lru-cache.md</a></li><li>sliding-window-maximum<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/239.sliding-window-maximum.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/239.sliding-window-maximum.md</a></li><li>find-median-from-data-stream.md<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/295.find-median-from-data-stream.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/295.find-median-from-data-stream.md</a><br>301.remove-invalid-parentheses<br><a href="https://github.com/azl397985856/leetcode/blob/master/problems/301.remove-invalid-parentheses.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/problems/301.remove-invalid-parentheses.md</a><br>数据结构与算法的总结<br>数据结构：<br><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md（草稿）" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/basic-data-structure.md（草稿）</a><br>二叉树的遍历：<br><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-tree-traversal.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/binary-tree-traversal.md</a><br>动态规划：<br><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/dynamic-programming.md</a><br>哈夫曼编码和游程编码：<br><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/run-length-encode-and-huffman-encode.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/run-length-encode-and-huffman-encode.md</a><br>布隆过滤器：<br><a href="https://github.com/azl397985856/leetcode/blob/master/thinkings/bloom-filter.md" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/thinkings/bloom-filter.md</a><br>anki 卡片<br>Anki主要分为两个部分:一部分是关键点到题目的映射，另一部分是题目到思路，关键点，代码的映射。<br>全部卡片都在：<br><a href="https://github.com/azl397985856/leetcode/blob/master/assets/anki/leetcode.apkg" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/assets/anki/leetcode.apkg</a><br>使用方法<br>anki - 文件 - 导入 - 下拉格式选择“打包的 anki集合”，然后选中你下载好的文件，确定即可。更多关于anki使用方法的请查看：<br><a href="https://apps.ankiweb.net/" target="_blank" rel="noopener">https://apps.ankiweb.net/</a><br>目前已更新卡片一览（仅列举正面）：<br>•二分法解决问题的关键点是什么，相关问题有哪些<br>•如何用栈的特点来简化操作， 涉及到的题目有哪些？<br>•双指针问题的思路以及相关题目有哪些？<br>•滑动窗口问题的思路以及相关题目有哪些？<br>•回溯法解题的思路以及相关题目有哪些？<br>计划<br>494.target-sum：<br><a href="https://github.com/azl397985856/leetcode/blob/master/todo/494.target-sum.js" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/todo/494.target-sum.js</a><br>609.find-duplicate-file-in-system：<br><a href="https://github.com/azl397985856/leetcode/blob/master/todo/609.find-duplicate-file-in-system.js" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/todo/609.find-duplicate-file-in-system.js</a><br>10.regular-expression-matching：<br><a href="https://github.com/azl397985856/leetcode/blob/master/todo/10.regular-expression-matching.js" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/todo/10.regular-expression-matching.js</a><br>365.water-and-jug-problem：<br><a href="https://github.com/azl397985856/leetcode/blob/master/todo/365.water-and-jug-problem.js" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/todo/365.water-and-jug-problem.js</a><br>anki 卡片 完善：<br><a href="https://github.com/azl397985856/leetcode/blob/master/assets/anki" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/assets/anki</a><br>字符串类问题汇总：<br><a href="https://github.com/azl397985856/leetcode/blob/master/todo/str/" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode/blob/master/todo/str/</a><br>参考链接：<br><a href="https://github.com/azl397985856/leetcode" target="_blank" rel="noopener">https://github.com/azl397985856/leetcode</a></li></ol><p>1、哪些机器学习算法不需要做归一化处理？<br>点击见参考答案：参考答案<br>2、树形结构为什么不需要归一化？<br>点击见参考答案：参考答案<br>3、在k-means或kNN，我们常用欧氏距离来计算最近的邻居之间的距离，有时也用曼哈顿距离，请对比下这两种距离的差别？<br>点击见参考答案：参考答案<br>4、请简要说说一个完整机器学习项目的流程<br>点击见参考答案：参考答案<br>5、逻辑斯特回归为什么要对特征进行离散化？<br>点击见参考答案：参考答案<br>6、简单介绍下LR？<br>点击见参考答案：参考答案<br>7、overfitting怎么解决？<br>点击见参考答案：参考答案<br>8、LR和SVM的联系与区别？<br>点击见参考答案：参考答案<br>9、什么是熵？<br>点击见参考答案：参考答案<br>10、说说梯度下降法？<br>点击见参考答案：参考答案<br>11、牛顿法和梯度下降法有什么不同？<br>点击见参考答案：参考答案<br>12、熵、联合熵、条件熵、相对熵、互信息的定义？<br>点击见参考答案：参考答案<br>13、说说你知道的核函数？<br>点击见参考答案：参考答案<br>14、什么是拟牛顿法（Quasi-Newton Methods）？<br>点击见参考答案：参考答案<br>15、kmeans的复杂度？<br>点击见参考答案：参考答案<br>16、请说说随机梯度下降法的问题和挑战？<br>点击见参考答案：参考答案</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/spark.html"/>
      <url>interview/spark.html</url>
      
        <content type="html"><![CDATA[<ul><li>Spark 算子有哪些，项目用到哪些算子<br>  *</li><li>Spark 广播变量<br>  *</li><li>Spark内存溢出<br>  *</li><li>Spark OOM问题解决办法<br>  *</li><li>Spark 任务执行速度倾斜问题解决方案<br>  *</li><li>Spark与Hadoop MapReduce的异同<ul><li>首先Spark是借鉴了mapreduce并在其基础上发展起来的，继承了其分布式计算的优点并改进了mapreduce明显的缺陷，但是二者也有不少的差异具体如下：<ul><li>1、spark把运算的中间数据存放在内存，迭代计算效率更高；mapreduce的中间结果需要落地，需要保存到磁盘，这样必然会有磁盘io操做，影响性能。</li><li>2、spark容错性高，它通过弹性分布式数据集RDD来实现高效容错，RDD是一组分布式的存储在节点内存中的只读性质的数据集，这些集合是弹性的，某一部分丢失或者出错，可以通过整个数据集的计算流程的血缘关系来实现重建；mapreduce的话容错可能只能重新计算了，成本较高。</li><li>3、spark更加通用，spark提供了transformation和action这两大类的多个功能api，另外还有流式处理sparkstreaming模块、图计算GraphX等等；mapreduce只提供了map和reduce两种操作，流计算以及其他模块的支持比较缺乏。</li><li>4、spark框架和生态更为复杂，首先有RDD、血缘lineage、执行时的有向无环图DAG、stage划分等等，</li><li>很多时候spark作业都需要根据不同业务场景的需要进行调优已达到性能要求；mapreduce框架及其生态相对较为简单，对性能的要求也相对较弱，但是运行较为稳定，适合长期后台运行。</li></ul></li><li>最后总结：<ul><li>spark生态更为丰富，功能更为强大、性能更佳，适用范围更广；mapreduce更简单、稳定性好、适合离线海量数据挖掘计算。</li></ul></li></ul></li><li>Spark streaming的数据来源<br>  *</li><li>Spark与hadoop的shuffle有何异同<br>  *</li><li>Spark RDD操作map与flatmap的区别<ul><li>map：对RDD每个元素转换，文件中的每一行数据返回一个数组对象</li><li>flatMap：对RDD每个元素转换，然后再扁平化将所有的对象合并为一个对象，文件中的所有行数据仅返回一个数组对象，会抛弃值为null的值</li></ul></li><li>Spark  RDD的理解<br>  *</li><li>Spark 有哪些算子<br>  *</li><li>Spark 的stage的理解<br>  *</li><li>Spark 宽依赖和窄依赖<br>  *</li><li>Sparkcore 的广播变量<br>  *</li><li>Spark 累加变量<br>  *</li><li>Spark 二次排序<br>  *</li><li>Spark reduceByKey和groupByKey区别<br>  *</li><li>为什么要进行序列化<ul><li>序列化可以减少数据的体积，减少存储空间，高效存储和传输数据，不好的是使用的时候要反序列化，非常消耗CPU</li></ul></li><li>介绍一下join操作优化经验？<ul><li>join其实常见的就分为两类： map-side join 和  reduce-side join。当大表和小表join时，用map-side join能显著提高效率。将多份数据进行关联是数据处理过程中非常普遍的用法，不过在分布式计算系统中，这个问题往往会变的非常麻烦，因为框架提供的 join 操作一般会将所有数据根据 key 发送到所有的 reduce 分区中去，也就是 shuffle 的过程。造成大量的网络以及磁盘IO消耗，运行效率极其低下，这个过程一般被称为 reduce-side-join。如果其中有张表较小的话，我们则可以自己实现在 map 端实现数据关联，跳过大量数据进行 shuffle 的过程，运行时间得到大量缩短，根据不同数据可能会有几倍到数十倍的性能提升。</li><li>备注：这个题目面试中非常非常大概率见到，务必搜索相关资料掌握，这里抛砖引玉。</li></ul></li><li>collect功能是什么，其底层是怎么实现的？<ul><li>driver通过collect把集群中各个节点的内容收集过来汇总成结果，collect返回结果是Array类型的，collect把各个节点上的数据抓过来，抓过来数据是Array型，collect对Array抓过来的结果进行合并，合并后Array中只有一个元素，是tuple类型（KV类型的）的。</li></ul></li><li>rdd有几种操作类型？<ul><li>1）transformation，rdd由一种转为另一种rdd</li><li>2）action，</li><li>3）cronroller，crontroller是控制算子,cache,persist，对性能和效率的有很好的支持</li></ul></li><li>RDD创建有哪几种方式？<ul><li>1).使用程序中的集合创建rdd</li><li>2).使用本地文件系统创建rdd</li><li>3).使用hdfs创建rdd，</li><li>4).基于数据库db创建rdd</li><li>5).基于Nosql创建rdd，如hbase</li><li>6).基于s3创建rdd，</li><li>7).基于数据流，如socket创建rdd</li></ul></li><li>RDD有哪些缺陷？<ul><li>1）不支持细粒度的写和更新操作（如网络爬虫），spark写数据是粗粒度的所谓粗粒度，就是批量写入数据，为了提高效率。但是读数据是细粒度的也就是说可以一条条的读</li><li>2）不支持增量迭代计算，Flink支持</li></ul></li><li>RDD的弹性表现在哪几点？<ul><li>1）自动的进行内存和磁盘的存储切换；</li><li>2）基于Lingage的高效容错；</li><li>3）task如果失败会自动进行特定次数的重试；</li><li>4）stage如果失败会自动进行特定次数的重试，而且只会计算失败的分片；</li><li>5）checkpoint和persist，数据计算之后持久化缓存</li><li>6）数据调度弹性，DAG TASK调度和资源无关</li><li>7）数据分片的高度弹性，a.分片很多碎片可以合并成大的，b.par</li></ul></li><li>对于Spark中的数据倾斜问题你有什么好的方案？<ul><li>1前提是定位数据倾斜，是OOM了，还是任务执行缓慢，看日志，看WebUI</li><li>2解决方法，有多个方面<ul><li>避免不必要的shuffle，如使用广播小表的方式，将reduce-side-join提升为map-side-join</li><li>分拆发生数据倾斜的记录，分成几个部分进行，然后合并join后的结果</li><li>改变并行度，可能并行度太少了，导致个别task数据压力大</li><li>两阶段聚合，先局部聚合，再全局聚合</li><li>自定义paritioner，分散key的分布，使其更加均匀</li><li>详细解决方案参考博文《Spark数据倾斜优化方法》</li></ul></li></ul></li><li>你所理解的Spark的shuffle过程？<ul><li>1）shuffle过程的划分</li><li>2）shuffle的中间结果如何存储</li><li>3）shuffle的数据如何拉取过来</li><li>可以参考这篇博文：<a href="http://www.cnblogs.com/jxhd1/p/6528540.html" target="_blank" rel="noopener">http://www.cnblogs.com/jxhd1/p/6528540.html</a></li></ul></li><li>spark的有几种部署模式，每种模式特点？<ul><li>1）本地模式Spark不一定非要跑在hadoop集群，可以在本地，起多个线程的方式来指定。将Spark应用以多线程的方式直接运行在本地，一般都是为了方便调试，本地模式分三类<ul><li>local：只启动一个executor</li><li>local[k]:启动k个executor</li><li>local启动跟cpu数目相同的 executor</li></ul></li><li>2)standalone模式<ul><li>分布式部署集群， 自带完整的服务，资源管理和任务监控是Spark自己监控，这个模式也是其他模式的基础，</li></ul></li><li>3)Spark on yarn模式<ul><li>分布式部署集群，资源和任务监控交给yarn管理，但是目前仅支持粗粒度资源分配方式，包含cluster和client运行模式，cluster适合生产，driver运行在集群子节点，具有容错功能，client适合调试，dirver运行在客户端</li></ul></li><li>4）Spark On Mesos模式。官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。用户可选择两种调度模式之一运行自己的应用程序：<ul><li>1)   粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。</li><li>2)   细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。</li></ul></li></ul></li><li>Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？<ul><li>可以画一个这样的技术栈图先，然后分别解释下每个组件的功能和场景</li><li>1）Spark core：是其它组件的基础，spark的内核，主要包含：有向循环图、RDD、Lingage、Cache、broadcast等，并封装了底层通讯框架，是Spark的基础。</li><li>2）SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行类似Map、Reduce和Join等复杂操作，将流式计算分解成一系列短小的批处理作业。</li><li>3）Spark sql：Shark是SparkSQL的前身，Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询，同时进行更复杂的数据分析</li><li>4）BlinkDB ：是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎，它允许用户通过权衡数据精度来提升查询响应时间，其数据的精度被控制在允许的误差范围内。</li><li>5）MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib、MLI、ML Optimizer和MLRuntime。</li><li>6）GraphX是Spark中用于图和图并行计算</li></ul></li><li>Spark中Work的主要工作是什么？<ul><li>主要功能：管理当前节点内存，CPU的使用状况，接收master分配过来的资源指令，通过ExecutorRunner启动程序分配任务，worker就类似于包工头，管理分配新进程，做计算的服务，相当于process服务。</li><li>需要注意的是：1）worker会不会汇报当前信息给master，worker心跳给master主要只有workid，它不会发送资源信息以心跳的方式给mater，master分配的时候就知道work，只有出现故障的时候才会发送资源。</li><li>2）worker不会运行代码，具体运行的是Executor是可以运行具体appliaction写的业务逻辑代码，操作代码的节点，它不会运行程序的代码的。</li></ul></li><li>Spark为什么比mapreduce快？<ul><li>1）基于内存计算，减少低效的磁盘交互；</li><li>2）高效的调度算法，基于DAG；</li><li>3)容错机制Linage，精华部分就是DAG和Lingae</li></ul></li><li>简单说一下hadoop和spark的shuffle相同和差异？<ul><li>1）从 high-level 的角度来看，两者并没有大的差别。 都是将 mapper（Spark 里是 ShuffleMapTask）的输出进行 partition，不同的 partition 送到不同的 reducer（Spark 里 reducer 可能是下一个 stage 里的 ShuffleMapTask，也可能是 ResultTask）。Reducer 以内存作缓冲区，边 shuffle 边 aggregate 数据，等到数据 aggregate 好以后进行 reduce() （Spark 里可能是后续的一系列操作）。</li><li>2）从 low-level 的角度来看，两者差别不小。 Hadoop MapReduce 是 sort-based，进入 combine() 和 reduce() 的 records 必须先 sort。这样的好处在于 combine/reduce() 可以处理大规模的数据，因为其输入数据可以通过外排得到（mapper 对每段数据先做排序，reducer 的 shuffle 对排好序的每段数据做归并）。目前的 Spark 默认选择的是 hash-based，通常使用 HashMap 来对 shuffle 来的数据进行 aggregate，不会对数据进行提前排序。如果用户需要经过排序的数据，那么需要自己调用类似 sortByKey() 的操作；如果你是Spark 1.1的用户，可以将spark.shuffle.manager设置为sort，则会对数据进行排序。在Spark 1.2中，sort将作为默认的Shuffle实现。</li><li>3）从实现角度来看，两者也有不少差别。 Hadoop MapReduce 将处理流程划分出明显的几个阶段：map(), spill, merge, shuffle, sort, reduce() 等。每个阶段各司其职，可以按照过程式的编程思想来逐一实现每个阶段的功能。在 Spark 中，没有这样功能明确的阶段，只有不同的 stage 和一系列的 transformation()，所以 spill, merge, aggregate 等操作需要蕴含在 transformation() 中。</li><li>如果我们将 map 端划分数据、持久化数据的过程称为 shuffle write，而将 reducer 读入数据、aggregate 数据的过程称为 shuffle read。那么在 Spark 中，问题就变为怎么在 job 的逻辑或者物理执行图中加入 shuffle write 和 shuffle read 的处理逻辑？以及两个处理逻辑应该怎么高效实现？</li><li>Shuffle write由于不要求数据有序，shuffle write 的任务很简单：将数据 partition 好，并持久化。之所以要持久化，一方面是要减少内存存储空间压力，另一方面也是为了 fault-tolerance。</li></ul></li><li>Mapreduce和Spark的都是并行计算，那么他们有什么相同和区别<ul><li>两者都是用mr模型来进行并行计算:</li><li>1)hadoop的一个作业称为job，job里面分为map task和reduce task，每个task都是在自己的进程中运行的，当task结束时，进程也会结束。</li><li>2)spark用户提交的任务成为application，一个application对应一个sparkcontext，app中存在多个job，每触发一次action操作就会产生一个job。这些job可以并行或串行执行，每个job中有多个stage，stage是shuffle过程中DAGSchaduler通过RDD之间的依赖关系划分job而来的，每个stage里面有多个task，组成taskset有TaskSchaduler分发到各个executor中执行，executor的生命周期是和app一样的，即使没有job运行也是存在的，所以task可以快速启动读取内存进行计算。</li><li>3)hadoop的job只有map和reduce操作，表达能力比较欠缺而且在mr过程中会重复的读写hdfs，造成大量的io操作，多个job需要自己管理关系。spark的迭代计算都是在内存中进行的，API中提供了大量的RDD操作如join，groupby等，而且通过DAG图可以实现良好的容错。</li></ul></li><li>spark有哪些组件？<ul><li>1）master：管理集群和节点，不参与计算。</li><li>2）worker：计算节点，进程本身不参与计算，和master汇报。</li><li>3）Driver：运行程序的main方法，创建spark context对象。</li><li>4）spark context：控制整个application的生命周期，包括dagsheduler和task scheduler等组件。</li><li>5）client：用户提交程序的入口。</li></ul></li><li>spark工作机制？<ul><li>用户在client端提交作业后，会由Driver运行main方法并创建spark context上下文。</li><li>执行add算子，形成dag图输入dagscheduler，按照add之间的依赖关系划分stage输入task scheduler。 task scheduler会将stage划分为task set分发到各个节点的executor中执行。</li></ul></li><li>spark的优化怎么做？<ul><li>spark调优比较复杂，但是大体可以分为三个方面来进行，</li><li>1）平台层面的调优：防止不必要的jar包分发，提高数据的本地性，选择高效的存储格式如parquet，</li><li>2）应用程序层面的调优：过滤操作符的优化降低过多小任务，降低单条记录的资源开销，处理数据倾斜，复用RDD进行缓存，作业并行化执行等等，</li><li>3）JVM层面的调优：设置合适的资源量，设置合理的JVM，启用高效的序列化方法如kyro，增大off head内存等等</li></ul></li><li>简要描述Spark分布式集群搭建的步骤<ul><li>1）准备linux环境，设置集群搭建账号和用户组，设置ssh，关闭防火墙，关闭seLinux，配置host，hostname</li><li>2）配置jdk到环境变量</li><li>3）搭建hadoop集群，如果要做master ha，需要搭建zookeeper集群修改hdfs-site.xml,hadoop_env.sh,yarn-site.xml,slaves等配置文件</li><li>4）启动hadoop集群，启动前要格式化namenode</li><li>5）配置spark集群，修改spark-env.xml，slaves等配置文件，拷贝hadoop相关配置到spark conf目录下</li><li>6)启动spark集群。</li></ul></li><li>什么是RDD宽依赖和窄依赖？<ul><li>RDD和它依赖的parent RDD(s)的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。</li><li>1）窄依赖指的是每一个parent RDD的Partition最多被子RDD的一个Partition使用</li><li>2）宽依赖指的是多个子RDD的Partition会依赖同一个parent RDD的Partition</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>ma消息队列</title>
      <link href="architecture/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/mq%E9%98%9F%E5%88%97.html"/>
      <url>architecture/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/mq%E9%98%9F%E5%88%97.html</url>
      
        <content type="html"><![CDATA[<p>以Push模型为主，从零开始分析设计一个消息队列时需要考虑到的问题，如RPC、高可用、顺序和重复消息、可靠投递、消费关系解析<br>也会分析以Kafka为代表的pull模型所具备的优点<br>最后是一些高级主题，如用批量/异步提高性能、pull模型的系统设计理念、存储子系统的设计、流量控制的设计、公平调度的实现等。其中最后四个方面会放在下篇讲解</p><p>业务解耦/最终一致性/广播/错峰流控</p><ul><li><p>解耦是消息队列要解决的最本质问题</p></li><li><p>最终一致性指的是两个系统的状态保持一致，要么都成功，要么都失败</p><ul><li>强一致性，分布式事务，但落地太难且成本太高</li></ul></li><li><p>消息队列的基本功能之一是进行广播</p></li><li><p>错峰与流控。试想上下游对于事情的处理能力是不同的。<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p7909" alt="d24b87ec6f938f10c9ed42b5f9c43415.png"></p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>微服务</title>
      <link href="architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%96%87%E6%A1%A3.html"/>
      <url>architecture/%E5%BE%AE%E6%9C%8D%E5%8A%A1/%E6%96%87%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>特点</p><ul><li>高内聚低耦合：将改变原因相同的聚一起，将改变原因不同的相分离</li><li>明确的分离关注点，关注点间的耦合最小化，以及潜在的高变动率导致业务敏捷性和工程速度的提升。</li><li>你的接口是测试中最终要的部分。你的接口测试会告诉用户真正看到的东西，但其他测试会告诉你怎样保证用户能够看到这些结果。</li></ul></li><li><p>下列问题不应该出现：</p><ul><li>不同服务需要协调部署。</li><li>you ship client libraries。</li><li>一个服务中的变动会引起其他服务中的变动或导致意料外的后果。</li><li>多个服务共享持久存储。</li><li>不能随意更改服务持久层。</li><li>工程师需要精通其他团队服务的设计和架构。</li><li>你拥有适用于所有服务的合规控制权。</li><li>基础设施不可编程。</li><li>不能一键部署和复原。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题</title>
      <link href="interview/frontend/basic.html"/>
      <url>interview/frontend/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、HTML"><a href="#0x00、HTML" class="headerlink" title="0x00、HTML"></a>0x00、HTML</h2><h2 id="0x01、CSS"><a href="#0x01、CSS" class="headerlink" title="0x01、CSS"></a>0x01、CSS</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>display:none和visibility:hidden有什么区别</li><li>html引入样式的方式有几种</li><li>什么是盒模型</li><li>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</li><li>CSS什么是伪类，伪类有那些，有什么作用？</li><li>flex布局是什么，都有哪些语法，相比grid布局有什么不同？</li><li>css如何动态计算高度或宽度？</li></ul><h4 id="2-sass"><a href="#2-sass" class="headerlink" title="2.sass"></a>2.sass</h4><ul><li>什么是SASS？</li><li>sass的优缺点</li><li>SASS中的嵌套规则是什么？</li><li>有哪些运算符，都有什么作用？</li><li>如何在SASS中引用父选择器？</li></ul><h2 id="0x02、JS"><a href="#0x02、JS" class="headerlink" title="0x02、JS"></a>0x02、JS</h2><h4 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>介绍js有哪些内置对象？</li><li>null，undefined 的区别？</li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</li><li>如何将字符串转化为数字，例如’12.3b’</li><li>字符串转化为数组，数组转化为字符串</li><li>如何判断一个对象中是否存在某个属性。</li><li>空数据组的boolean值</li><li>字符串替换值用什么方法？全部替换如何做？</li><li>什么是原型链</li></ul><h4 id="2-es6"><a href="#2-es6" class="headerlink" title="2.es6"></a>2.es6</h4><ul><li>新增了什么语法</li></ul><h4 id="3-typescript"><a href="#3-typescript" class="headerlink" title="3.typescript"></a>3.typescript</h4><ul><li>您对Typescript中的类有什么了解？列出类的一些功能。</li><li>如何从TypeScript中的子类调用基类构造函数？</li><li>内部模块和外部模块有什么区别？</li><li>请解释Typescript中的装饰器？</li><li>TypeScript类中属性/方法的默认可见性是什么？</li><li>如何在TypeScript中检查null和undefined？</li><li>readonly 和 const 有什么区别？</li></ul><h2 id="0x03、Vue"><a href="#0x03、Vue" class="headerlink" title="0x03、Vue"></a>0x03、Vue</h2><h2 id="0x04、React"><a href="#0x04、React" class="headerlink" title="0x04、React"></a>0x04、React</h2><ul><li>React 中 refs 的作用是什么？</li><li>createElement 与 cloneElement 的区别是什么？</li><li>组件的生命周期有哪些，生命周期的函数有哪些？</li><li>什么情况下组件会被更新</li><li>指令有哪些</li><li>子父组件如何通信</li></ul><h2 id="0x05、综合"><a href="#0x05、综合" class="headerlink" title="0x05、综合"></a>0x05、综合</h2><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h4><ul><li>前端性能优化有哪些？</li><li>cookie和session</li><li>本地存储类型及限制</li><li>webpack打包如何优化</li></ul><h4 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h4><ul><li>网络请求流程</li></ul><h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h4><ul><li>数据提交</li><li>跨域问题如何解决</li></ul><h4 id="4-业务场景"><a href="#4-业务场景" class="headerlink" title="4.业务场景"></a>4.业务场景</h4><ul><li>单点登录实现</li></ul><h4 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h4><ul><li>判断是否是数字、正数</li><li>替换变量</li></ul><h2 id="0x06、小程序"><a href="#0x06、小程序" class="headerlink" title="0x06、小程序"></a>0x06、小程序</h2><h4 id="1-uniapp"><a href="#1-uniapp" class="headerlink" title="1.uniapp"></a>1.uniapp</h4><h4 id="2-Taro"><a href="#2-Taro" class="headerlink" title="2.Taro"></a>2.Taro</h4><ul><li>为什么要用这个</li><li>坑在哪里</li><li>设计稿尺寸问题</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题</title>
      <link href="interview/frontend/vue.html"/>
      <url>interview/frontend/vue.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul><li><p>####1.请谈谈Vue中的MVVM模式</p><ul><li>MVVM全称是Model-View-ViewModel</li><li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</li><li>DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li></ul></li><li><p>####2.v-show和v-if指令的共同点和不同点?</p><ul><li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li><li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li></ul></li><li><p>####3.如何让CSS只在当前组件中起作用?</p><ul><li>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></li></ul></li><li><p>####4.Vue中引入组件的步骤?</p><ul><li>1.采用ES6的import … from …语法或CommonJS的require()方法引入组件</li><li>2.对组件进行注册,代码如下</li><li>3.使用组件<my-component></my-component><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="组件间如何传递值或调用"><a href="#组件间如何传递值或调用" class="headerlink" title="组件间如何传递值或调用"></a>组件间如何传递值或调用</h4></li><li><p>####5.在Vue中使用插件的步骤</p><ul><li>采用ES6的import … from …语法或CommonJS的require()方法引入插件</li><li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li></ul></li><li><p>####6.请列举出3个Vue中常用的生命周期钩子函数?</p><ul><li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li><li>mounted:  el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li><li>activated: keep-alive组件激活时调用</li></ul></li><li><p>####7.请简述下Vuex的原理和使用方法</p><ul><li><p>数据单向流动</p></li><li><p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</p></li><li><p>Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</p></li><li><p>上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p><ul><li>state中保存着共有数据</li><li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li><li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>css面试题</title>
      <link href="interview/frontend/css.html"/>
      <url>interview/frontend/css.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>display:none和visibility:hidden的区别？</p><ul><li>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li></ul></li><li><p>CSS中link 和@import的区别是？</p><ul><li>(1) link属于HTML标签，而@import是CSS提供</li><li>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li><li>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li><li>(4) link方式的样式的权重 高于@import的权重.</li></ul></li><li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p><ul><li>选择符<ul><li>1.id选择器（ # myid）</li><li>2.类选择器（.myclassname）</li><li>3.标签选择器（div, h1, p）</li><li>4.相邻选择器（h1 + p）</li><li>5.子选择器（ul &gt; li）</li><li>6.后代选择器（li a）</li><li>7.通配符选择器（ * ）</li><li>8.属性选择器（a[rel = “external”]）</li><li>9.伪类选择器（a: hover, li:nth-child）</li></ul></li><li>优先级原则<ul><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li></ul></li><li>优先级为:<ul><li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li><li>!important &gt; id &gt; class &gt; tag</li><li>important 比 内联优先级高</li></ul></li><li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li><li>不可继承的样式：border padding margin width height</li></ul></li><li><p>display有哪些值？说明他们的作用。</p><ul><li>block     块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none     缺省值。象行内元素类型一样显示。</li><li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table     此元素会作为块级表格来显示。</li><li>inherit     规定应该从父元素继承 display 属性的值。</li></ul></li><li><p>position属性：指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型</p><ul><li>默认值：static</li><li>可选择值：relative、absolute、fixed、static、sticky、inherit</li><li>static:默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li>relative:生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li>fiexd:生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>absoluate:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>sticky:粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li><li>inherit:规定应该从父元素继承 position 属性的值。</li></ul></li><li><p>display属性：规定元素应该生成的框的类型</p><ul><li>none:此元素不会被显示</li><li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li><li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li><li>inline-block:行内块元素。（CSS2.1 新增的值）</li><li>list-item: 此元素会作为列表显示。</li><li>run-in: 此元素会根据上下文作为块级元素或内联元素显示。</li><li>compact:CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>marker:CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>table: 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</li><li>inline-table: 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</li><li>table-row-group: 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</li><li>table-header-group: 此元素会作为一个或多个行的分组来显示（类似 <thead>）。</li><li>table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</li><li>table-row: 此元素会作为一个表格行显示（类似 <tr>）。</li><li>table-column-group: 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</li><li>table-column: 此元素会作为一个单元格列显示（类似 <col>）</li><li>table-cell: 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）</li><li>table-caption: 此元素会作为一个表格标题显示（类似 <caption>）</li><li>inherit:规定应该从父元素继承 display 属性的值。</li><li>flex:用flex布局</li></ul></li><li><p>盒模型</p><ul><li>总共有四层，从外到内是：margin、border、padding、content</li><li>一个盒子中主要的属性就5个：width、height、padding、border、margin。<ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。<br>如果设置background-color，那么border以内的所有都会有背景色。<br>如果想让盒子保持大小不变，那么就要保证border以内的，也就是padding+content的width和height保持不变。</li></ul></li></ul></li><li><p>像素</p><ul><li>基准像素</li></ul></li><li><p>行内元素与块元素</p><ul><li>块元素</li><li>行内元素</li></ul></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>display:flex</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础面试题</title>
      <link href="interview/net/basic.html"/>
      <url>interview/net/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul><li><ol><li>TCP报头格式</li></ol></li><li><ol start="2"><li>UDP报头格式</li></ol></li><li><ol start="3"><li>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</li></ol></li><li><ol start="4"><li>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</li></ol></li><li><ol start="5"><li>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</li></ol></li><li><ol start="6"><li>OSI协议、TCP/IP协议以及每层对应的协议。</li></ol></li><li><ol start="7"><li>SESSION机制、cookie机制</li></ol></li><li><ol start="8"><li>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</li></ol></li><li><ol start="9"><li>打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</li></ol></li><li><ol start="10"><li>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</li></ol></li><li><ol start="11"><li>IP地址子网划分</li></ol></li><li><ol start="12"><li>POST和GET区别</li></ol></li><li><ol start="13"><li>DNS解析过程</li></ol></li></ul><h2 id="深入部分"><a href="#深入部分" class="headerlink" title="深入部分"></a>深入部分</h2><ul><li><ol start="14"><li>TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）</li></ol></li><li><ol start="15"><li>地址解析协议ARP</li></ol></li><li><ol start="16"><li>交换机和路由器的区别</li></ol></li></ul><h3 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h3><h3 id="端口个数为什么是65535个？"><a href="#端口个数为什么是65535个？" class="headerlink" title="端口个数为什么是65535个？"></a>端口个数为什么是65535个？</h3><ul><li>在TCP、UDP协议的开头，会分别有16位来存储源端口号和目标端口号，所以端口个数是2^16-1=65535个。</li><li>端口被设计出来主要是为了给协议栈和应用对应：<ul><li>协议栈用端口号将数据分配给不同的应用层程序</li><li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li></ul></li></ul><h3 id="端口状态有哪些"><a href="#端口状态有哪些" class="headerlink" title="端口状态有哪些"></a>端口状态有哪些</h3><ul><li>1、LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。</li><li>2、ESTABLISHED状态。ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li><li>3、CLOSE_WAIT。对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li><li>4、TIME_WAIT<ul><li>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</li><li>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li></ul></li><li>5、SYN_SENT状态<ul><li>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</li></ul></li></ul><h3 id="http的s加密是在哪一层，如何处理的。"><a href="#http的s加密是在哪一层，如何处理的。" class="headerlink" title="http的s加密是在哪一层，如何处理的。"></a>http的s加密是在哪一层，如何处理的。</h3><ul><li>s指的是SSL或TLS加密。因为http是明文传输，为了数据安全，在应用层与传输层中间添加一个加密层来加密数据的传输。</li><li>这个加密用了对称加密和非对称加密的结合。</li></ul><h3 id="什么是socket，为什么要有socket。"><a href="#什么是socket，为什么要有socket。" class="headerlink" title="什么是socket，为什么要有socket。"></a>什么是socket，为什么要有socket。</h3><ul><li>socket是传输层协议的分装，让应用层更方便的进行网络编程。</li></ul><h3 id="urlencode和urldecode何时使用，有什么作用？"><a href="#urlencode和urldecode何时使用，有什么作用？" class="headerlink" title="urlencode和urldecode何时使用，有什么作用？"></a>urlencode和urldecode何时使用，有什么作用？</h3><ul><li>url中合法的字符有两大类<ul><li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li><li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（），圆括号（()`）</li></ul></li><li>用来传输中文编码，转换成统一安全字符格式。</li></ul><h3 id="python中如何使用urlencode和urldecode。"><a href="#python中如何使用urlencode和urldecode。" class="headerlink" title="python中如何使用urlencode和urldecode。"></a>python中如何使用urlencode和urldecode。</h3><ul><li>urllib.parse.quote(str,  safe=’/‘)<ul><li>http%3A//<a href="http://www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>urllib.parse.quote(str,  safe=’/:?=’)<ul><li><a href="http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>如上，默认会处理一些非中文字符串情况，所以可以对中文进行单独转义既可</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>http面试题</title>
      <link href="interview/net/http.html"/>
      <url>interview/net/http.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP-Keep-Alive的作用及应用场景"><a href="#HTTP-Keep-Alive的作用及应用场景" class="headerlink" title="HTTP Keep-Alive的作用及应用场景"></a>HTTP Keep-Alive的作用及应用场景</h3><ul><li>作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。</li><li>缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。</li><li>解决：Keep-Alive: timeout=5, max=100。timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</li></ul><h3 id="表单中-get与post提交方法的区别"><a href="#表单中-get与post提交方法的区别" class="headerlink" title="表单中 get与post提交方法的区别?"></a>表单中 get与post提交方法的区别?</h3><ul><li>get是发送请求HTTP协议通过url参数传递进行接收；数据量小；不太安全</li><li>post是实体数据,可以通过表单提交大量信息；数据量大；安全</li></ul><h3 id="下列HTTP状态码出现的可能原因-如何处理"><a href="#下列HTTP状态码出现的可能原因-如何处理" class="headerlink" title="下列HTTP状态码出现的可能原因, 如何处理"></a>下列HTTP状态码出现的可能原因, 如何处理</h3><ul><li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li><li>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li><li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li><li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql面试题</title>
      <link href="interview/storage/mysql.html"/>
      <url>interview/storage/mysql.html</url>
      
        <content type="html"><![CDATA[<h3 id="Mysql存储引擎有哪些？有什么区别？"><a href="#Mysql存储引擎有哪些？有什么区别？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？"></a>Mysql存储引擎有哪些？有什么区别？</h3><ul><li>innodb、myisam</li><li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li><li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li></ul><h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><ul><li>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。</li><li>char 固定长度，所以在处理速度上要比</li></ul><h3 id="1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？"><a href="#1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？" class="headerlink" title="1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？"></a>1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？</h3><ul><li><p>数据库事务</p><ul><li>将一组相关操作组合为一个要么全部成功要么全部失败的单元</li><li>具有ACID（原子性、一致性、隔离性和持久性）属性<ul><li>原子性(Atomicity)：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li><li>一致性(Consistent)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须于一致性状态</li><li>隔离性(Isolation)：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所扰，多个并发事务之间要相互隔离。</li><li>持久性(Duration)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul></li></ul></li><li><p>事物隔离级别</p><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul></li><li><p>脏读、幻读、不可重复读</p><ul><li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</li><li>不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li></ul></li><li><p>备注：</p><ul><li>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</li><li>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</li><li>当前事务的隔离级别：select @@tx_isolation;<a id="more"></a><h3 id="2-优化数据库的方法。说说-SQL-优化之道"><a href="#2-优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="2.优化数据库的方法。说说 SQL 优化之道"></a>2.优化数据库的方法。说说 SQL 优化之道</h3></li></ul></li><li><p>主机性能</p></li><li><p>内存使用性能</p></li><li><p>网络传输性能</p></li><li><p>SQL语句执行性能</p></li></ul><h3 id="3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别"><a href="#3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别" class="headerlink" title="3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别"></a>3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</h3><h3 id="为什么要用-B-tree-作为-MySql-索引的数据结构"><a href="#为什么要用-B-tree-作为-MySql-索引的数据结构" class="headerlink" title="为什么要用 B+tree 作为 MySql 索引的数据结构"></a>为什么要用 B+tree 作为 MySql 索引的数据结构</h3><h3 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h3><h3 id="Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？"><a href="#Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？"></a>Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？</h3><h3 id="varchar和char有什么区别-1"><a href="#varchar和char有什么区别-1" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><h3 id="DDL、DML、DCL-分别指什么"><a href="#DDL、DML、DCL-分别指什么" class="headerlink" title="DDL、DML、DCL 分别指什么"></a>DDL、DML、DCL 分别指什么</h3><h3 id="explain-命令"><a href="#explain-命令" class="headerlink" title="explain 命令"></a>explain 命令</h3><h3 id="数据库的几大范式"><a href="#数据库的几大范式" class="headerlink" title="数据库的几大范式"></a>数据库的几大范式</h3><h3 id="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"><a href="#说说分库与分表设计，分库与分表带来的分布式困境与对应之策" class="headerlink" title="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"></a>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</h3><h3 id="什么是自适应哈希索引（AHI）"><a href="#什么是自适应哈希索引（AHI）" class="headerlink" title="什么是自适应哈希索引（AHI）"></a>什么是自适应哈希索引（AHI）</h3><h3 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h3><h3 id="常见的几种分布式-ID-的设计方案"><a href="#常见的几种分布式-ID-的设计方案" class="headerlink" title="常见的几种分布式 ID 的设计方案"></a>常见的几种分布式 ID 的设计方案</h3>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础面试题</title>
      <link href="interview/storage/basic.html"/>
      <url>interview/storage/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h3><ul><li>唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</li><li>为什么要用 B+tree 作为 MySql 索引的数据结构</li><li>聚集索引与非聚集索引的区别</li><li>DDL、DML、DCL 分别指什么</li><li>explain 命令</li><li>数据库的几大范式</li><li>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</li><li>什么是自适应哈希索引（AHI）</li><li>limit 20000 加载很慢怎么解决</li><li>常见的几种分布式 ID 的设计方案<br>基础部分<ul><li><ol><li>事务四大特性（ACID）</li></ol></li><li><ol start="2"><li>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别</li></ol></li><li><ol start="3"><li>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</li></ol></li><li><ol start="4"><li>数据库的优化（从sql语句优化和索引两个部分回答）</li></ol></li><li><ol start="5"><li>索引有B+索引和hash索引，各自的区别</li></ol></li><li><ol start="6"><li>B+索引数据结构，和B树的区别</li></ol></li><li><ol start="7"><li>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</li></ol></li><li><ol start="8"><li>聚集索引和非聚集索引区别。</li></ol></li><li><ol start="9"><li>有哪些锁（乐观锁悲观锁），select时怎么加排它锁</li></ol></li><li><ol start="10"><li>关系型数据库和非关系型数据库区别</li></ol></li><li><ol start="11"><li>了解nosql</li></ol></li><li><ol start="12"><li>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</li></ol></li><li><ol start="13"><li>数据库的主从复制</li></ol></li><li><ol start="14"><li>使用explain优化sql和索引</li></ol></li><li><ol start="15"><li>long_query怎么解决</li></ol></li><li><ol start="16"><li>内连接、外连接、交叉连接、笛卡儿积等<br>深入</li></ol></li><li><ol><li>MVCC机制</li></ol></li><li><ol start="2"><li>根据具体场景，说明版本控制机制</li></ol></li><li><ol start="3"><li>死锁怎么解决</li></ol></li><li><ol start="4"><li>varchar和char的使用场景。</li></ol></li><li><ol start="5"><li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li></ol></li></ul></li></ul><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><ul><li>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li></ul><h3 id="优化MYSQL数据库的方法"><a href="#优化MYSQL数据库的方法" class="headerlink" title="优化MYSQL数据库的方法?"></a>优化MYSQL数据库的方法?</h3><ul><li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM</li><li>使用连接（JOIN）来代替子查询</li><li>使用联合(UNION)来代替手动创建的临时表</li><li>建立索引</li></ul><p>varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</p><h3 id="优化数据库的方法。说说-SQL-优化之道"><a href="#优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="优化数据库的方法。说说 SQL 优化之道"></a>优化数据库的方法。说说 SQL 优化之道</h3><ul><li>主机性能</li><li>内存使用性能</li><li>网络传输性能</li><li>SQL语句执行性能</li></ul><h3 id="ACID规则"><a href="#ACID规则" class="headerlink" title="ACID规则"></a>ACID规则</h3><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p><ul><li>1、A (Atomicity) 原子性<ul><li>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li><li>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li></ul></li><li>2、C (Consistency) 一致性<ul><li>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li></ul></li><li>3、I (Isolation) 独立性<ul><li>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</li><li>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li></ul></li><li>4、D (Durability) 持久性<ul><li>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%89%8D%E7%AB%AF/html.html"/>
      <url>interview/%E5%89%8D%E7%AB%AF/html.html</url>
      
        <content type="html"><![CDATA[<p>HTML</p><ul><li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul><li>1）创建新节点<ul><li>createDocumentFragment() //创建一个DOM</li><li>createElement() //创建一个具体的</li><li>createTextNode() //创建一个文本节点</li></ul></li><li>2）添加、移除、替换、插入<ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //并没有insertAfter()</li></ul></li><li>3）查找<ul><li>getElementsByTagName() //通过标签名</li><li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li><li>getElementById() //通过元素Id，唯一性</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%89%8D%E7%AB%AF/css.html"/>
      <url>interview/%E5%89%8D%E7%AB%AF/css.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>display:none和visibility:hidden的区别？</p><ul><li>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li></ul></li><li><p>CSS中link 和@import的区别是？</p><ul><li>(1) link属于HTML标签，而@import是CSS提供</li><li>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li><li>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li><li>(4) link方式的样式的权重 高于@import的权重.</li></ul></li><li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p><ul><li>选择符<ul><li>1.id选择器（ # myid）</li><li>2.类选择器（.myclassname）</li><li>3.标签选择器（div, h1, p）</li><li>4.相邻选择器（h1 + p）</li><li>5.子选择器（ul &gt; li）</li><li>6.后代选择器（li a）</li><li>7.通配符选择器（ * ）</li><li>8.属性选择器（a[rel = “external”]）</li><li>9.伪类选择器（a: hover, li:nth-child）</li></ul></li><li>优先级原则<ul><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li></ul></li><li>优先级为:<ul><li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li><li>!important &gt; id &gt; class &gt; tag</li><li>important 比 内联优先级高</li></ul></li><li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li><li>不可继承的样式：border padding margin width height</li></ul></li><li><p>display有哪些值？说明他们的作用。</p><ul><li>block     块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none     缺省值。象行内元素类型一样显示。</li><li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table     此元素会作为块级表格来显示。</li><li>inherit     规定应该从父元素继承 display 属性的值。</li></ul></li><li><p>position属性：指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型</p><ul><li>默认值：static</li><li>可选择值：relative、absolute、fixed、static、sticky、inherit</li><li>static:默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li>relative:生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li>fiexd:生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>absoluate:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>sticky:粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li><li>inherit:规定应该从父元素继承 position 属性的值。</li></ul></li><li><p>display属性：规定元素应该生成的框的类型</p><ul><li>none:此元素不会被显示</li><li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li><li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li><li>inline-block:行内块元素。（CSS2.1 新增的值）</li><li>list-item: 此元素会作为列表显示。</li><li>run-in: 此元素会根据上下文作为块级元素或内联元素显示。</li><li>compact:CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>marker:CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>table: 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</li><li>inline-table: 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</li><li>table-row-group: 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</li><li>table-header-group: 此元素会作为一个或多个行的分组来显示（类似 <thead>）。</li><li>table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</li><li>table-row: 此元素会作为一个表格行显示（类似 <tr>）。</li><li>table-column-group: 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</li><li>table-column: 此元素会作为一个单元格列显示（类似 <col>）</li><li>table-cell: 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）</li><li>table-caption: 此元素会作为一个表格标题显示（类似 <caption>）</li><li>inherit:规定应该从父元素继承 display 属性的值。</li><li>flex:用flex布局</li></ul></li><li><p>盒模型</p><ul><li>总共有四层，从外到内是：margin、border、padding、content</li><li>一个盒子中主要的属性就5个：width、height、padding、border、margin。<ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。<br>如果设置background-color，那么border以内的所有都会有背景色。<br>如果想让盒子保持大小不变，那么就要保证border以内的，也就是padding+content的width和height保持不变。</li></ul></li></ul></li><li><p>像素</p><ul><li>基准像素</li></ul></li><li><p>行内元素与块元素</p><ul><li>块元素</li><li>行内元素</li></ul></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>display:flex</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%89%8D%E7%AB%AF/sass.html"/>
      <url>interview/%E5%89%8D%E7%AB%AF/sass.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>什么是SASS？</p><ul><li>SASS（Syntactically Awesome Stylesheet）是一个CSS预处理器，有助于减少CSS的重复，节省时间。</li><li>它是更稳定和强大的CSS扩展语言，描述文档的样式干净和结构。</li></ul></li><li><p>为什么要使用SASS？</p><ul><li>它是预处理语言，它为CSS提供缩进语法（它自己的语法）。</li><li>它允许更有效地编写代码和易于维护。</li><li>它是包含CSS的所有功能的CSS的超集，是一个开源的预处理器，以 Ruby 编码。</li><li>它提供了比平面CSS好的结构格式的文档样式。</li><li>它使用可重复使用的方法，逻辑语句和一些内置函数，如颜色操作，数学和参数列表</li></ul></li><li><p>列出SASS的一些功能？</p><ul><li>它是更稳定，强大，与CSS的版本兼容。</li><li>它是超集的CSS和基于JavaScript。</li><li>它被称为CSS的语法糖，这意味着它使用户更容易阅读或表达的东西更清楚。</li><li>它使用自己的语法并编译为可读的CSS。</li><li>你可以在更少的时间内轻松地编写CSS代码。</li><li>它是一个开源的预处理器，被解释为CSS。</li></ul></li><li><p>SASS的优点是什么？</p><ul><li>它允许在编程结构中编写干净的CSS。</li><li>它有助于编写CSS更快。</li><li>它是CSS的超集，帮助设计师和开发人员更有效率和快速地工作。</li><li>由于Sass兼容所有版本的CSS，我们可以使用任何可用的CSS库。</li><li>可以使用嵌套语法和有用的函数，如颜色操作，数学和其他值</li></ul></li><li><p>SASS的缺点是什么？</p><ul><li>开发人员需要时间了解此预处理器中存在的新功能。</li><li>如果更多的人在同一个网站上工作，那么将使用相同的预处理器。 有些人使用Sass，有些人使用CSS直接编辑文件。 因此，它将变得难以与现场工作。</li><li>有机会失去浏览器的内置元素检查器的好处。</li></ul></li><li><p>列出SASS支持的两种语法？</p><ul><li>SASS支持两种语法，即 SCSS 和缩进语法。</li><li>SCSS（Sassy CSS）是CSS语法的扩展，可以更容易地维护大型样式表，并且可以识别供应商特定的语法和许多CSS。 SCSS文件使用扩展名 .scss 。</li><li>缩进是较旧的语法，有时仅称为 Sass 。 使用这种形式的语法，可以简洁地编写CSS。 SASS文件使用扩展名 .sass 。</li></ul></li><li><p>有多少种方法可以使用SASS？</p><ul><li>您可以使用三种不同的方式使用SASS:<ul><li>作为命令行工具</li><li>作为一个Ruby模块</li><li>作为Rack启用框架的插件</li></ul></li></ul></li><li><p>SASS中的嵌套规则是什么？</p><ul><li>嵌套是不同逻辑结构的组合。 使用SASS，我们可以将多个CSS规则相互组合。 如果使用多个选择器，则可以在另一个选择器中使用一个选择器来创建复合选择器。</li></ul></li><li><p>如何在SASS中引用父选择器？</p><ul><li>您可以使用＆amp; 字符选择父级选择器。 它告诉父选择器应该插入的位置。</li></ul></li><li><p>如何在SASS中写入占位符选择器？</p><ul><li>SASS使用 class 或 id 选择器支持占位符选择器。 在正常CSS中，这些用“＃”或“。”指定，但在SASS中，它们替换为“％”。</li></ul></li><li><p>列出SASS上的不同类型的运算符？</p><ul><li>有5种类型的运算符:<ul><li>数字运算符</li><li>颜色运算符</li><li>字符串运算符</li><li>布尔运算符</li><li>列表运算符</li></ul></li></ul></li><li><p>什么是数字运算？</p><ul><li>它允许诸如加法，减法，乘法和除法的数学运算。</li></ul></li><li><p>什么是彩色运算？</p><ul><li>它允许使用颜色分量和算术运算。</li></ul></li><li><p>什么是列表运算？</p><ul><li>列表表示使用逗号或空格分隔的一系列值。</li></ul></li><li><p>什么是布尔运算？</p><ul><li>您可以使用and、or和not（与或非）对Sass脚本执行布尔运算。</li></ul></li><li><p>SASS中的括号是什么？</p><ul><li>括号是一对标记，通常用圆括号（）或方括号[]来标记，这提供了影响操作顺序的符号逻辑。</li></ul></li><li><p>什么是SASS中的插值？</p><ul><li>它使用＃{} 语法提供选择器和属性名称中的SassScript变量。 您可以在花括号中指定变量或属性名称。</li></ul></li><li><p>什么是可变默认值？</p><ul><li>您可以通过向变量值的结尾添加！default 标志来设置变量的默认值。如果值已经分配给变量，则不会重新分配该值。</li></ul></li><li><p>什么是导入指令？</p><ul><li>它直接采用文件名导入，所有导入的文件将合并到一个单一的CSS文件。</li></ul></li><li><p>什么是媒体指令？</p><ul><li>它将样式规则设置为不同的媒体类型。</li></ul></li><li><p>什么是扩展指令？</p><ul><li>它用于共享选择器之间的规则和关系。 它可以在一个类中扩展所有其他类样式，也可以应用自己的特定样式。</li></ul></li><li><p>什么是根指令？</p><ul><li>它是一个嵌套规则的集合，它能够在文档的根节点创建样式块。</li></ul></li><li><p>什么是@if指令？</p><ul><li>它用于基于表达式求值的结果选择性地执行代码语句。</li></ul></li><li><p>什么是@else if指令？</p><ul><li>@else if语句与@if指令一起使用，每当@if语句失败，则尝试@else if语句，如果它们也失败，则执行@else。</li></ul></li><li><p>什么是@for指令？</p><ul><li>它允许您在循环中生成样式。 计数器变量用于设置每次迭代的输出。</li></ul></li><li><p>什么是@each指令？</p><ul><li>在@each指令中，定义了一个包含列表中每个项目的值的变量。</li></ul></li><li><p>什么是@mixin指令？</p><ul><li>它用于定义mixin，其中包含可选的mixin名称之后的变量和参数。</li></ul></li><li><p>什么是@include指令？</p><ul><li>它用于在文档中包含mixin，由mixin定义的样式可以包含在当前规则中。</li></ul></li><li><p>什么是mixin 参数?</p><ul><li>SassScript值可以作为mixin中的参数，当mixin包含并在mixin中作为变量使用时，可以将其作为参数。</li></ul></li><li><p>列出两种类型的mixin参数？</p><ul><li>有两种类型的mixin参数:</li><li>关键字参数</li><li>可变参数</li></ul></li><li><p>什么是关键字参数？</p><ul><li>它用于在mixin中包含参数。 命名的参数可以按任何顺序传递，参数的默认值可以省略。</li></ul></li><li><p>什么是可变参数？</p><ul><li>变量参数用于将任意数量的参数传递给mixin。 它包含传递给函数或mixin的关键字参数。</li></ul></li><li><p>什么是函数指令？</p><ul><li>使用函数指令，可以创建自己的函数，并在脚本上下文中使用它们，或者可以使用任何值。</li></ul></li><li><p>什么是SASS输出样式？</p><ul><li>SASS生成的CSS文件由反映文档结构的默认CSS样式组成。 默认的CSS样式很好，但可能不适合所有情况。</li></ul></li><li><p>什么是嵌套CSS样式？</p><ul><li>嵌套样式是SASS的默认样式。 这种方式的样式在处理大型CSS文件时非常有用。</li></ul></li><li><p>什么是扩展CSS样式？</p><ul><li>在扩展输出样式中，每个属性和规则都有自己的线。 与嵌套CSS样式相比，它需要更多的空间。</li></ul></li><li><p>什么是紧凑的CSS样式？</p><ul><li>紧凑的CSS风格竞争力比Expanded和Nested占用更少的空间。 它主要关注选择器而不是其属性。</li></ul></li><li><p>什么是压缩CSS样式？</p><ul><li>与所有其他样式相比，压缩的CSS样式占用最少的空间。 它仅提供空格，以在文件末尾分隔选择器和换行符。</li></ul></li><li><p>有多少种注释类型？</p><ul><li>Sass支持两种类型的注释:</li><li>多行注释 - 使用/* 和 */ 写入。 多行注释保存在CSS输出中。</li><li>单行注释 - 这些是使用 // 和注释写成的。 单行注释不会保留在CSS输出中。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%89%8D%E7%AB%AF/%E6%B1%87%E6%80%BB.html"/>
      <url>interview/%E5%89%8D%E7%AB%AF/%E6%B1%87%E6%80%BB.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、HTML"><a href="#0x00、HTML" class="headerlink" title="0x00、HTML"></a>0x00、HTML</h2><h2 id="0x01、CSS"><a href="#0x01、CSS" class="headerlink" title="0x01、CSS"></a>0x01、CSS</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>display:none和visibility:hidden有什么区别</li><li>html引入样式的方式有几种</li><li>什么是盒模型</li><li>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</li><li>CSS什么是伪类，伪类有那些，有什么作用？</li><li>flex布局是什么，都有哪些语法，相比grid布局有什么不同？</li><li>css如何动态计算高度或宽度？</li></ul><h4 id="2-sass"><a href="#2-sass" class="headerlink" title="2.sass"></a>2.sass</h4><ul><li>什么是SASS？</li><li>sass的优缺点</li><li>SASS中的嵌套规则是什么？</li><li>有哪些运算符，都有什么作用？</li><li>如何在SASS中引用父选择器？</li></ul><h2 id="0x02、JS"><a href="#0x02、JS" class="headerlink" title="0x02、JS"></a>0x02、JS</h2><h4 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>介绍js有哪些内置对象？</li><li>null，undefined 的区别？</li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</li><li>如何将字符串转化为数字，例如’12.3b’</li><li>字符串转化为数组，数组转化为字符串</li><li>如何判断一个对象中是否存在某个属性。</li><li>空数据组的boolean值</li><li>字符串替换值用什么方法？全部替换如何做？</li><li>什么是原型链</li></ul><h4 id="2-es6"><a href="#2-es6" class="headerlink" title="2.es6"></a>2.es6</h4><ul><li>新增了什么语法</li></ul><h4 id="3-typescript"><a href="#3-typescript" class="headerlink" title="3.typescript"></a>3.typescript</h4><ul><li>您对Typescript中的类有什么了解？列出类的一些功能。</li><li>如何从TypeScript中的子类调用基类构造函数？</li><li>内部模块和外部模块有什么区别？</li><li>请解释Typescript中的装饰器？</li><li>TypeScript类中属性/方法的默认可见性是什么？</li><li>如何在TypeScript中检查null和undefined？</li><li>readonly 和 const 有什么区别？</li></ul><h2 id="0x03、Vue"><a href="#0x03、Vue" class="headerlink" title="0x03、Vue"></a>0x03、Vue</h2><h2 id="0x04、React"><a href="#0x04、React" class="headerlink" title="0x04、React"></a>0x04、React</h2><ul><li>React 中 refs 的作用是什么？</li><li>createElement 与 cloneElement 的区别是什么？</li><li>组件的生命周期有哪些，生命周期的函数有哪些？</li><li>什么情况下组件会被更新</li><li>指令有哪些</li><li>子父组件如何通信</li></ul><h2 id="0x05、综合"><a href="#0x05、综合" class="headerlink" title="0x05、综合"></a>0x05、综合</h2><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h4><ul><li>前端性能优化有哪些？</li><li>cookie和session</li><li>本地存储类型及限制</li><li>webpack打包如何优化</li></ul><h4 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h4><ul><li>网络请求流程</li></ul><h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h4><ul><li>数据提交</li><li>跨域问题如何解决</li></ul><h4 id="4-业务场景"><a href="#4-业务场景" class="headerlink" title="4.业务场景"></a>4.业务场景</h4><ul><li>单点登录实现</li></ul><h4 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h4><ul><li>判断是否是数字、正数</li><li>替换变量</li></ul><h2 id="0x06、小程序"><a href="#0x06、小程序" class="headerlink" title="0x06、小程序"></a>0x06、小程序</h2><h4 id="1-uniapp"><a href="#1-uniapp" class="headerlink" title="1.uniapp"></a>1.uniapp</h4><h4 id="2-Taro"><a href="#2-Taro" class="headerlink" title="2.Taro"></a>2.Taro</h4><ul><li>为什么要用这个</li><li>坑在哪里</li><li>设计稿尺寸问题</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/index.html"/>
      <url>interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/index.html</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h3 id="0x00、设计思想"><a href="#0x00、设计思想" class="headerlink" title="0x00、设计思想"></a>0x00、设计思想</h3><ul><li>语言设计原则</li><li>语言特点</li><li>语言适用场景</li><li>简述解释型和编译型语言<ul><li>编译型语言<ul><li>把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。</li><li>执行速度快、效率高</li><li>依赖编译器、跨平台性差些。</li><li>如C、C++、Delphi、Pascal，Fortran。</li><li>优点：编译器⼀般会有预编译的过程对代码进⾏优化。因为编译只做⼀次，运⾏时不需要编译，所以编译型语⾔的程序执⾏效率⾼。可以脱离语⾔环境独立运⾏。</li><li>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运⾏环境⽣成机器码，不同的操作系统之间移植就会有问题，需要根据运⾏的操作系统环境编译不同的可执⾏⽂件。</li></ul></li><li>解释型语言<ul><li>把做好的源程序翻译一句，然后执行一句，直至结束！</li><li>执行速度慢、效率低</li><li>依赖解释器、跨平台性好。</li><li>优点：有良好的平台兼容性，在任何环境中都可以运⾏，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不⽤停机维护。</li><li>缺点：每次运⾏的时候都要解释⼀遍，性能上不如编译型语⾔。</li></ul></li><li>混合型<ul><li>没有直接编译称为机器语言，而是编译称为字节码</li><li>然后在虚拟机上用解释方式执行字节码。</li><li>如java、python等</li></ul></li></ul></li><li>机器码与字节码<ul><li>机器码是电脑的CPU可直接解读的数据</li><li>字节码是二进制文件,一种中间码</li></ul></li><li>编程规范有哪些</li><li>注释、文档如何实现</li></ul><h3 id="0x01、基础操作"><a href="#0x01、基础操作" class="headerlink" title="0x01、基础操作"></a>0x01、基础操作</h3><ul><li>关键字有哪些，有什么作用</li><li>关键字是否可以赋值</li><li>基础数据类型有哪些</li><li>如何区别可变数据类型和不可变数据类型</li><li>变量作用域</li><li>判断变量是否相等</li><li>是否有常量？常量如何定义？常量特性？</li><li>普通打印</li><li>结构化打印</li><li>字符填充为固定宽度</li><li>字符串带变量拼接</li><li>对象打印</li><li>条件判断有哪些？</li><li>循环遍历有哪些？各有什么好用处？循环遍历时改变遍历对象的值</li><li>路径如何做到穷举、全覆盖</li><li>操作符可否重载？哪些情况可以重载？为什么要有重载？</li><li>变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？</li><li>字符串截取成数组，数组拼接成字符串</li><li>数组去重，数组内某个值的数量，数组排序，数组反转，两个数组合并，两个数组求并集和差集</li><li>字符串是否包含某个值，是否以某个值开始、结尾，字符串长度，字符串前后去除无效字符(比如空格)，字符串大小写转换，获取字符的某几位，</li><li>字符串转json，json转成列表或字典</li><li>是否有深浅拷贝，都是做什么的，适用场景是什么？<ul><li>浅拷贝：不管多么复杂的数据结构，只copy对象最外层本身，该对象引用的其他对象不copy， 内存里两个变量的地址是一样的，一个改变另一个也改变。</li><li>深拷贝：完全复制原变量的所有数据，内存中生成一套完全一样的内容；只是值一样，内存地址不一样，一方修改另一方不受影响</li></ul></li></ul><h3 id="0x02、常用数据结构"><a href="#0x02、常用数据结构" class="headerlink" title="0x02、常用数据结构"></a>0x02、常用数据结构</h3><ul><li>动态列表</li><li>hash</li><li>字典</li><li>队列</li><li>堆栈</li></ul><h3 id="0x03、系统操作"><a href="#0x03、系统操作" class="headerlink" title="0x03、系统操作"></a>0x03、系统操作</h3><ul><li>获取用户输入</li><li>获取命令行参数</li><li>命令参数化</li><li>获取系统环境变量</li><li>获取文件路径</li></ul><h3 id="0x04、文件操作"><a href="#0x04、文件操作" class="headerlink" title="0x04、文件操作"></a>0x04、文件操作</h3><ul><li>创建文件夹</li><li>递归创建文件夹</li><li>创建文件</li><li>读文件</li><li>写文件</li><li>读大文件</li><li>移动文件夹及文件</li><li>重命名文件夹及文件</li></ul><h3 id="0x05、时间操作"><a href="#0x05、时间操作" class="headerlink" title="0x05、时间操作"></a>0x05、时间操作</h3><ul><li>获取当前时间</li><li>获取当前日期</li><li>获取前天、30天前、上个季度、一年前日期</li><li>字符串日期时间转时间类型</li><li>时间类型转字符串时间日期</li><li>日期时间中获取日期</li><li>获取整分、整时的时间</li><li>时间戳转时间、转字符串</li><li>字符串时间转时间戳</li><li></li></ul><h3 id="0x06、正则操作"><a href="#0x06、正则操作" class="headerlink" title="0x06、正则操作"></a>0x06、正则操作</h3><ul><li>匹配数字、小数</li><li>匹配字母，区分、不区分大小写</li><li>匹配汉字</li><li>匹配url</li><li>匹配邮箱</li><li>匹配手机号</li><li>匹配域名</li><li>url截取成协议、域名、path、params</li></ul><h3 id="0x07、上传下载"><a href="#0x07、上传下载" class="headerlink" title="0x07、上传下载"></a>0x07、上传下载</h3><ul><li>上传、下载文件</li><li>上传、下载图像</li></ul><h3 id="0x08、线程-进程"><a href="#0x08、线程-进程" class="headerlink" title="0x08、线程/进程"></a>0x08、线程/进程</h3><ul><li>线程与进程的区别</li><li>多线程执行</li><li>多进程执行</li><li>多进程共享变量</li><li>多线程锁如何使用</li></ul><h3 id="0x09、网络操作"><a href="#0x09、网络操作" class="headerlink" title="0x09、网络操作"></a>0x09、网络操作</h3><ul><li>http请求</li><li>socket编程</li></ul><h3 id="0x10、面向对象"><a href="#0x10、面向对象" class="headerlink" title="0x10、面向对象"></a>0x10、面向对象</h3><ul><li>继承</li><li>多态</li><li>封装</li><li>对象序列化传输，反序列化执行</li><li>判断某个实例是不是属于某个类</li></ul><h3 id="0x11、异常处理"><a href="#0x11、异常处理" class="headerlink" title="0x11、异常处理"></a>0x11、异常处理</h3><ul><li>错误、异常处理</li></ul><h3 id="0x12、工程"><a href="#0x12、工程" class="headerlink" title="0x12、工程"></a>0x12、工程</h3><ul><li>包管理</li><li>装饰器是什么，如何实现</li><li>编程模式是什么，都有哪些，作用是什么，如何实现？</li></ul><h3 id="0x13、常用方法实现"><a href="#0x13、常用方法实现" class="headerlink" title="0x13、常用方法实现"></a>0x13、常用方法实现</h3><ul><li>递归</li><li>排序</li><li>查找</li><li>数学库</li><li>随机数</li><li>加密算法</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/hive.html"/>
      <url>interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/hive.html</url>
      
        <content type="html"><![CDATA[<ul><li>Hive 原理<ul><li><ol><li>用户提交查询等任务给Driver。</li></ol></li><li><ol start="2"><li>编译器获得该用户的任务Plan。</li></ol></li><li><ol start="3"><li>编译器Compiler根据用户任务去MetaStore中获取需要的Hive的元数据信息。</li></ol></li><li><ol start="4"><li>编译器Compiler得到元数据信息，对任务进行编译，先将HiveQL转换为抽象语法树，然后将抽象语法树转换成查询块，将查询块转化为逻辑的查询计划，重写逻辑查询计划，将逻辑计划转化为物理的计划（MapReduce）, 最后选择最佳的策略。</li></ol></li><li><ol start="5"><li>将最终的计划提交给Driver。</li></ol></li><li><ol start="6"><li>Driver将计划Plan转交给ExecutionEngine去执行，获取元数据信息，提交给JobTracker或者SourceManager执行该任务，任务会直接读取HDFS中文件进行相应的操作。</li></ol></li><li><ol start="7"><li>获取执行的结果。</li></ol></li><li><ol start="8"><li>取得并返回执行结果。</li></ol></li></ul></li><li>Hive数据倾斜问题<ul><li>1.1)key分布不均匀</li><li>1.2)业务数据本身的</li><li>1.3)SQL语句造成数据倾斜</li><li>1&gt;参数调节：<ul><li>hive.map.aggr=true</li><li>hive.groupby.skewindata=true</li></ul></li><li>2&gt;SQL语句调节：<ul><li>1)选用join key 分布最均匀的表作为驱动表。做好列裁剪和filter操作，以达到两表join的时候，数据量相对变小的效果。</li><li>2)大小表Join： 使用map join让小的维度表（1000条以下的记录条数）先进内存。在Map端完成Reduce。</li><li>3)大表Join大表：把空值的Key变成一个字符串加上一个随机数，把倾斜的数据分到不同的reduce上，由于null值关联不上，处理后并不影响最终的结果。</li><li>4)count distinct大量相同特殊值：count distinct时，将值为空的情况单独处理，如果是计算count distinct，可以不用处理，直接过滤，在做后结果中加1。如果还有其他计算，需要进行group by，可以先将值为空的记录单独处理，再和其他计算结果进行union.</li></ul></li></ul></li><li>Mapreduce和hive的区别和联系<ul><li>hive是基于hadoop的数据仓库</li><li>那么为什么说hive是基于Hadoop的呢？<ul><li>之所以说hive是构建在Hadoop之上的数据仓库，简单的说是因为：</li><li>①数据存储在hdfs上</li><li>②数据计算用mapreduce</li></ul></li><li>Hive是一种建立在Hadoop文件系统上的数据仓库架构，并对存储在HDFS中的数据进行分析和管理；它可以将结构化的数据文件映射为一张数据库表，并提供完整的 SQL 查询功能，可以将 SQL 语句转换为 MapReduce 任务进行运行，通过自己的 SQL 去查询分析需要的内容，这套 SQL 简称 Hive SQL（HQL），使不熟悉MapReduce 的用户也能很方便地利用 SQL 语言对数据进行查询、汇总、分析。</li><li>Hive不支持更改数据的操作，Hive基于数据仓库，提供静态数据的动态查询。其使用类SQL语言，底层经过编译转为MapReduce程序，在hadoop上运行，数据存储在HDFS上。</li></ul></li><li>HIVE与RDBMS关系数据库的区别<ul><li>1、hive存储的数据量比较大，适合海量数据，适合存储轨迹类历史数据，适合用来做离线分析、数据挖掘运算，事务性较差，实时性较差 ;rdbms一般数据量相对来说不会太大，适合事务性计算，实时性较好，更加接近上层业务</li><li>2、hive的计算引擎是hadoop的mapreduce，存储是hadoop的hdfs文件系统;rdbms的引擎由数据库自己设计实现例如mysql的innoDB，存储用的是数据库服务器本地的文件系统</li><li>3、hive由于基于hadoop所以存储和计算的扩展能力都很好;rdbms在这方面比较弱，比如orcale的分表和扩容就很头疼</li><li>4、hive表格没有主键、没有索引、不支持对具体某一行的操作，适合对批量数据的操作，不支持对数据的update操作，更新的话一般是先删除表然后重新落数据；rdbms事务性强，有主键、索引，支持对具体某一行的增删改查等操作</li><li>5、hive的SQL为HQL，与标准的RDBMS的SQL存在有不少的区别，相对来说功能有限；rdbms的SQL为标准SQL，功能较为强大。</li></ul></li><li>hive中的存储方式<ul><li>1.textfile<ul><li>Hive的默认存储格式<ul><li>存储方式：行存储</li><li>磁盘开销大数据解析开销大</li><li>压缩的text文件 hive无法进行合并和拆分</li></ul></li></ul></li><li>2.SequenceFile<ul><li>二进制文件以key,value的形式序列化到文件中</li><li>存储方式：行存储</li><li>可分割压缩</li><li>一般选择block压缩</li><li>优势是文件和Hadoop api中的mapfile是相互兼容的</li></ul></li><li>3.rcfile<ul><li>存储方式：数据按行分块每块按照列存储</li><li>压缩快快速列存取</li><li>读记录尽量涉及到的block最少</li><li>读取需要的列只需要读取每个row group 的头部定义。</li><li>读取全量数据的操作性能可能比sequencefile没有明显的优势</li></ul></li><li>4.orc<ul><li>存储方式：数据按行分块每块按照列存储</li><li>压缩快快速列存取</li><li>效率比rcfile高,是rcfile的改良版本</li></ul></li><li>5.自定义格式<ul><li>用户可以通过实现inputformat和 outputformat来自定义输入输出格式</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/java.html"/>
      <url>interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/java.html</url>
      
        <content type="html"><![CDATA[<ul><li><ol><li>Spring拦截器、实现了哪些方法？底层原理</li></ol></li><li><ol start="2"><li>AOP如何配置，底层原理、2种动态代理，aop注解实现，xml定义切面</li></ol></li><li><ol start="3"><li>Bean的作用域，单例模式是否线程安全？恶汉模式是否线程安全？bean如何结束生命周期？</li></ol></li><li><ol start="4"><li>Spring事务种类，如何回滚，A方法调用B方法，在B方法中出现异常，会回滚吗？（动态代理）</li></ol></li><li><ol start="5"><li>快速排序时间复杂度</li></ol></li><li><ol start="6"><li>JVM内存结构详细分配，各比例是多少</li></ol></li><li><ol start="7"><li>讲讲dubbo，数据库主从复制，2个节点读写分离，如何在读节点马上读到主节点写入的值</li></ol></li><li><ol start="8"><li>springboot和springmvc的区别</li></ol></li><li><ol start="9"><li>hashmap原理，hashcode做异或？位运算呢？</li></ol></li><li>10原子锁和同步锁的区别，CAS底层原理</li><li>JVM调优，如何解决OOM</li><li><ol><li>目前的JDK使用的是什么垃圾回收算法，为什么要用这个算法？</li></ol></li><li><ol start="2"><li>什么时候fullGC？</li></ol></li><li><ol start="3"><li>类加载机制、说的详细点，符号引用如何解析，双亲委派模型</li></ol></li><li><ol start="4"><li>如何设计服务器中session指定时间过期</li></ol></li><li><ol start="5"><li>AOP原理？ 讲讲动态代理</li></ol></li><li><ol start="6"><li>spring中各种context有什么功能，他们之间有什么联系？</li></ol></li><li><ol start="7"><li>leftjoin和rightjoin的区别？</li></ol></li><li><ol start="8"><li>讲讲TCP四次挥手，如何处理服务器大量端口处在timewait？</li></ol></li><li><ol start="9"><li>缓存中维护100个键值对（LRU算法）</li></ol></li><li><ol start="10"><li>谈谈synchronized、CAS</li></ol></li><li><ol start="11"><li>支持高并发的数据结构，如ConcurrentHashMap的底层数据结构</li></ol></li><li><ol start="12"><li>基于AQS实现的锁、信号量、计数器原理</li></ol></li><li><ol start="13"><li>Runnable与Callable的区别</li></ol></li><li><ol start="14"><li>线程池的优势和作用</li></ol></li><li><ol><li>介绍下线程池，阻塞队列的用法，无界队列真的无界吗？</li></ol></li><li><ol start="2"><li>说一下redis</li></ol></li><li><ol start="3"><li>kafka存储模型与网络模型</li></ol></li><li><ol start="4"><li>zookeeper与redis实现分布式锁</li></ol></li><li><ol start="5"><li>乐观锁与悲观锁的区别</li></ol></li><li><ol start="6"><li>分布式全局唯一ID如何生成，有哪些生成方式</li></ol></li><li><ol start="7"><li>什么样的场景会出现服务器雪崩场景，具体怎么来解决。</li></ol></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1/nameko.html"/>
      <url>interview/%E5%BE%AE%E6%9C%8D%E5%8A%A1/nameko.html</url>
      
        <content type="html"><![CDATA[<h3 id="namkeo一直starting而起不来的问题有哪些"><a href="#namkeo一直starting而起不来的问题有哪些" class="headerlink" title="namkeo一直starting而起不来的问题有哪些"></a>namkeo一直starting而起不来的问题有哪些</h3><ul><li>入口文件开始没有添加eventlet库</li><li>rabbitmq链接不上</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb.html"/>
      <url>interview/%E6%95%B0%E6%8D%AE%E5%BA%93/mongodb.html</url>
      
        <content type="html"><![CDATA[<h3 id="有哪些索引，如何建立索引，效率如何。"><a href="#有哪些索引，如何建立索引，效率如何。" class="headerlink" title="有哪些索引，如何建立索引，效率如何。"></a>有哪些索引，如何建立索引，效率如何。</h3><ul><li>普通索引，唯一索引</li><li>效率会有大幅度提升<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection.createIndex(&#123;'':true&#125;)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93.html"/>
      <url>interview/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<h3 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h3><ul><li>唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</li><li>为什么要用 B+tree 作为 MySql 索引的数据结构</li><li>聚集索引与非聚集索引的区别</li><li>Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM 区别、优缺点、使用场景？</li><li>varchar和char有什么区别</li><li>DDL、DML、DCL 分别指什么</li><li>explain 命令</li><li>数据库的几大范式</li><li>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</li><li>什么是自适应哈希索引（AHI）</li><li>limit 20000 加载很慢怎么解决</li><li>常见的几种分布式 ID 的设计方案<br>基础部分<ul><li><ol><li>事务四大特性（ACID）</li></ol></li><li><ol start="2"><li>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别</li></ol></li><li><ol start="3"><li>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</li></ol></li><li><ol start="4"><li>数据库的优化（从sql语句优化和索引两个部分回答）</li></ol></li><li><ol start="5"><li>索引有B+索引和hash索引，各自的区别</li></ol></li><li><ol start="6"><li>B+索引数据结构，和B树的区别</li></ol></li><li><ol start="7"><li>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</li></ol></li><li><ol start="8"><li>聚集索引和非聚集索引区别。</li></ol></li><li><ol start="9"><li>有哪些锁（乐观锁悲观锁），select时怎么加排它锁</li></ol></li><li><ol start="10"><li>关系型数据库和非关系型数据库区别</li></ol></li><li><ol start="11"><li>了解nosql</li></ol></li><li><ol start="12"><li>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</li></ol></li><li><ol start="13"><li>数据库的主从复制</li></ol></li><li><ol start="14"><li>使用explain优化sql和索引</li></ol></li><li><ol start="15"><li>long_query怎么解决</li></ol></li><li><ol start="16"><li>内连接、外连接、交叉连接、笛卡儿积等<br>深入</li></ol></li><li><ol><li>MVCC机制</li></ol></li><li><ol start="2"><li>根据具体场景，说明版本控制机制</li></ol></li><li><ol start="3"><li>死锁怎么解决</li></ol></li><li><ol start="4"><li>varchar和char的使用场景。</li></ol></li><li><ol start="5"><li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li></ol></li></ul></li></ul><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><ul><li>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li></ul><h3 id="优化MYSQL数据库的方法"><a href="#优化MYSQL数据库的方法" class="headerlink" title="优化MYSQL数据库的方法?"></a>优化MYSQL数据库的方法?</h3><ul><li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM</li><li>使用连接（JOIN）来代替子查询</li><li>使用联合(UNION)来代替手动创建的临时表</li><li>建立索引</li></ul><h3 id="Mysql存储引擎有哪些？有什么区别？"><a href="#Mysql存储引擎有哪些？有什么区别？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？"></a>Mysql存储引擎有哪些？有什么区别？</h3><ul><li>innodb、myisam</li><li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li><li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li></ul><h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><ul><li>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。</li><li>char 固定长度，所以在处理速度上要比varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</li></ul><h3 id="优化数据库的方法。说说-SQL-优化之道"><a href="#优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="优化数据库的方法。说说 SQL 优化之道"></a>优化数据库的方法。说说 SQL 优化之道</h3><ul><li>主机性能</li><li>内存使用性能</li><li>网络传输性能</li><li>SQL语句执行性能</li></ul><h3 id="ACID规则"><a href="#ACID规则" class="headerlink" title="ACID规则"></a>ACID规则</h3><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p><ul><li>1、A (Atomicity) 原子性<ul><li>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li><li>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li></ul></li><li>2、C (Consistency) 一致性<ul><li>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li></ul></li><li>3、I (Isolation) 独立性<ul><li>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</li><li>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li></ul></li><li>4、D (Durability) 持久性<ul><li>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%95%B0%E6%8D%AE%E5%BA%93/redis.html"/>
      <url>interview/%E6%95%B0%E6%8D%AE%E5%BA%93/redis.html</url>
      
        <content type="html"><![CDATA[<h2 id="Redis基础相关问题"><a href="#Redis基础相关问题" class="headerlink" title="Redis基础相关问题"></a>Redis基础相关问题</h2><ul><li><ol><li>Redis 是什么？说说它的优点和缺点？</li></ol></li><li><ol start="2"><li>Redis与memcached相比有哪些优势？</li></ol></li><li><ol start="3"><li>Redis支持哪几种数据类型？</li></ol></li><li><ol start="4"><li>Redis主要消耗什么物理资源？</li></ol></li><li><ol start="5"><li>Redis有哪几种数据淘汰策略？</li></ol></li><li><ol start="6"><li>Redis官方为什么不提供Windows版本？</li></ol></li><li><ol start="7"><li>一个字符串类型的值能存储最大容量是多少？</li></ol></li><li><ol start="8"><li>如何将 Redis 放到应用程序中？</li></ol></li><li><ol start="9"><li>使用 Redis 的时候应用程序是如何进行读写的？</li></ol></li><li><ol start="10"><li>为什么Redis需要把所有数据放到内存中？</li></ol></li><li><ol start="11"><li>什么是CAP理论？</li></ol></li></ul><h2 id="Redis集群相关问题"><a href="#Redis集群相关问题" class="headerlink" title="Redis集群相关问题"></a>Redis集群相关问题</h2><ul><li><ol><li>Redis集群方案应该怎么做？都有哪些方案？</li></ol></li><li><ol start="2"><li>Redis集群方案什么情况下会导致整个集群不可用？</li></ol></li><li><ol start="3"><li>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</li></ol></li><li><ol start="4"><li>Redis有哪些适合的场景？</li></ol></li><li><ol start="5"><li>Redis支持的Java客户端都有哪些？官方推荐用哪个？</li></ol></li><li><ol start="6"><li>Redis和Redisson有什么关系？</li></ol></li><li><ol start="7"><li>Jedis与Redisson对比有什么优缺点？</li></ol></li><li><ol start="8"><li>说说Redis哈希槽的概念？</li></ol></li><li><ol start="9"><li>Redis集群的主从复制模型是怎样的？</li></ol></li><li><ol start="10"><li>Redis集群会有写操作丢失吗？为什么？</li></ol></li><li><ol start="11"><li>Redis集群之间是如何复制的？</li></ol></li><li><ol start="12"><li>Redis集群最大节点个数是多少？</li></ol></li><li><ol start="13"><li>Redis集群如何选择数据库？</li></ol></li><li><ol start="14"><li>Redis中的管道有什么用？</li></ol></li></ul><h2 id="Redis分布式锁等相关问题"><a href="#Redis分布式锁等相关问题" class="headerlink" title="Redis分布式锁等相关问题"></a>Redis分布式锁等相关问题</h2><ul><li><ol><li>使用过Redis分布式锁么，它是怎么实现的？</li></ol></li><li><ol start="2"><li>简述Redis分布式锁的缺陷？</li></ol></li><li><ol start="3"><li>讲讲对Redisson实现Redis分布式锁的底层原理的理解？</li></ol></li><li><ol start="4"><li>加锁机制，锁互斥机制，watch dog自动延期机制，可重入加锁机制，锁释放机制是什么？</li></ol></li><li><ol start="5"><li>Redis 的 Setnx 命令是如何实现分布式锁的？</li></ol></li><li><ol start="6"><li>说说对Setnx 的实现锁的原理的理解？</li></ol></li><li><ol start="7"><li>如何避免死锁的出现？</li></ol></li><li><ol start="8"><li>怎么理解Redis事务？</li></ol></li><li><ol start="9"><li>Redis事务相关的命令有哪几个？</li></ol></li><li><ol start="10"><li>Redis key的过期时间和永久有效分别怎么设置？</li></ol></li><li><ol start="11"><li>Redis如何做内存优化？</li></ol></li><li><ol start="12"><li>Redis回收进程如何工作的？</li></ol></li><li><ol start="13"><li>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</li></ol></li><li><ol start="14"><li>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</li></ol></li></ul><h2 id="Redis结合MySQL-的相关问题"><a href="#Redis结合MySQL-的相关问题" class="headerlink" title="Redis结合MySQL 的相关问题"></a>Redis结合MySQL 的相关问题</h2><ul><li><ol><li>Redis 如何与 MySQL 数据库结合起来？</li></ol></li><li><ol start="2"><li>应用通过 Redis 客户端进行读取并展示，是所有的数据都是这么做吗？</li></ol></li><li><ol start="3"><li>在修改数据的时候是修改到 Redis 吗？还是直接修改 MySQL?</li></ol></li><li><ol start="4"><li>如果修改 Redis 中数据，那什么时候同步到 MySQL，是被迫的，还是开发人员可控的？</li></ol></li><li><ol start="5"><li>如果直接修改 MySQL 中数据，那 Redis 中数据会被同步吗，如何做到的？</li></ol></li></ul><h3 id="1-Redis-是什么？说说它的优点和缺点？"><a href="#1-Redis-是什么？说说它的优点和缺点？" class="headerlink" title="1.Redis 是什么？说说它的优点和缺点？"></a>1.Redis 是什么？说说它的优点和缺点？</h3><h3 id="使用redis有哪些好处？"><a href="#使用redis有哪些好处？" class="headerlink" title="使用redis有哪些好处？"></a>使用redis有哪些好处？</h3><ul><li>(1) 速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)</li><li>(2) 支持丰富数据类型，支持string，list，set，sorted set，hash</li><li>(3) 支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行</li><li>(4) 丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li></ul><h3 id="redis相比memcached有哪些优势？"><a href="#redis相比memcached有哪些优势？" class="headerlink" title="redis相比memcached有哪些优势？"></a>redis相比memcached有哪些优势？</h3><ul><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型</li><li>Redis中，并不是所有的数据都一直存储在内存中的，这是和Memcached相比一个最大的区别。</li><li>Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcached只是简单的K/V缓存。</li><li>他们的扩展都需要做集群；实现方式：master-slave、Hash。</li><li>如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached。当然，这和你的应用场景和数据特性有关。</li><li>如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcached都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。</li><li>Redis和Memcache在写入性能上面差别不大，读取性能上面尤其是批量读取性能上面Memcache更强</li></ul><h3 id="redis常见性能问题和解决方案："><a href="#redis常见性能问题和解决方案：" class="headerlink" title="redis常见性能问题和解决方案："></a>redis常见性能问题和解决方案：</h3><ul><li>(1) Master最好不要做任何持久化工作，如RDB内存快照和AOF日志文件</li><li>(2) 如果数据比较重要，某个Slave开启AOF备份数据，策略设置为每秒同步一次</li><li>(3) 为了主从复制的速度和连接的稳定性，Master和Slave最好在同一个局域网内</li><li>(4) 尽量避免在压力很大的主库上增加从库</li><li>(5) 主从复制不要用图状结构，用单向链表结构更为稳定，即：Master &lt;- Slave1 &lt;- Slave2 &lt;- Slave3…<br>这样的结构方便解决单点故障问题，实现Slave对Master的替换。如果Master挂了，可以立刻启用Slave1做Master，其他不变。</li></ul><h3 id="使用过Redis分布式锁么，它是什么回事？"><a href="#使用过Redis分布式锁么，它是什么回事？" class="headerlink" title="使用过Redis分布式锁么，它是什么回事？"></a>使用过Redis分布式锁么，它是什么回事？</h3><ul><li>先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。</li></ul><h3 id="Redis如何做持久化的？"><a href="#Redis如何做持久化的？" class="headerlink" title="Redis如何做持久化的？"></a>Redis如何做持久化的？</h3><p>bgsave做镜像全量持久化，aof做增量持久化。因为bgsave会耗费较长时间，不够实时，在停机的时候会导致大量丢失数据，所以需要aof来配合使用。在redis实例重启时，会使用bgsave持久化文件重新构建内存，再使用aof重放近期的操作指令来实现完整恢复重启之前的状态。<br>对方追问那如果突然机器掉电会怎样？取决于aof日志sync属性的配置，如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。<br>对方追问bgsave的原理是什么？你给出两个词汇就可以了，fork和cow。fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h3 id="redis支持的类型有哪些"><a href="#redis支持的类型有哪些" class="headerlink" title="redis支持的类型有哪些"></a>redis支持的类型有哪些</h3><ul><li>set</li><li>sortedSet</li><li>list</li><li>string</li><li>int</li><li>hash</li></ul><h3 id="CAP理论"><a href="#CAP理论" class="headerlink" title="CAP理论"></a>CAP理论</h3><ul><li>CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer’s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:<ul><li>一致性(Consistency) (所有节点在同一时间具有相同的数据)</li><li>可用性(Availability) (保证每个请求不管成功或者失败都有响应)</li><li>分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作)</li></ul></li><li>CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。因此，根据CAP原理分成了满足CA原则、满足CP原则和满足AP原则三大类：<ul><li>CA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。</li><li>CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。</li><li>AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。</li></ul></li></ul><h2 id="redis批量执行命令"><a href="#redis批量执行命令" class="headerlink" title="redis批量执行命令"></a>redis批量执行命令</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">try_pipeline</span><span class="params">()</span>:</span></span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="keyword">with</span> r.pipeline(transaction=<span class="literal">False</span>) <span class="keyword">as</span> p:</span><br><span class="line">        p.sadd(<span class="string">'seta'</span>, <span class="number">1</span>).sadd(<span class="string">'seta'</span>, <span class="number">2</span>).srem(<span class="string">'seta'</span>, <span class="number">2</span>).lpush(<span class="string">'lista'</span>, <span class="number">1</span>).lrange(<span class="string">'lista'</span>, <span class="number">0</span>, <span class="number">-1</span>)</span><br><span class="line">        p.execute()</span><br><span class="line">    <span class="keyword">print</span> time.time() - start</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>llvm</title>
      <link href="man/cs/llvm.html"/>
      <url>man/cs/llvm.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><p><a href="https://llvm.org/" target="_blank" rel="noopener">官网</a></p></li><li><p><a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener">github</a></p></li><li><p><a href="https://www.infoworld.com/article/3247799/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html" target="_blank" rel="noopener">What is LLVM? </a></p></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LLVM 全称是 Low Level Virtual Machine，它是源自 the University of Illinois 的一个研究项目，该项目旨在提供一个现代化的编译机制，使得对任何编程语言既可以做到静态编译也可以动态编译，而且非常高效。后来 LLVM 项目逐渐发展，并孵化了许多子项目，比如 Clang，LLDB， OpenMP 等。</p><p>一般来说，编译器会将源语言翻译为一种“中间语言(IR)”，之后再由 中间语言 利用后端程序和设备翻译为目标平台的汇编语言。不同编译器的中间语言IR是不一样的，IR集中体现了编译器的主要特征——算法，优化方式，汇编流程等等。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="man/cs/web%E5%BC%80%E5%8F%91.html"/>
      <url>man/cs/web%E5%BC%80%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<h1 id="Web开发技术"><a href="#Web开发技术" class="headerlink" title="Web开发技术"></a>Web开发技术</h1><ul><li>了解http协议</li><li>cookie与session</li><li>nginx</li></ul><p>协议层面<br>   http<br>   ftp<br>   tcp/udp<br>   ip<br>爬虫层面</p><p>前端层面<br>    html<br>    js<br>    css<br>前端框架<br>    vue<br>多端编译<br>    flutter<br>后端层面<br>    django<br>服务器层面<br>    nginx的配置<br>数据库层面<br>    mysql<br>缓存层面<br>    redis<br>架构层面<br>    分布式<br>    高可用<br>    高可靠<br>系统功能<br>    权限设计<br>    埋点分析<br>系统安全<br>大数据处理<br>    数据仓库<br>    数据ETL<br>数据可视化<br>效率工具</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/cs/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html"/>
      <url>man/cs/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88.html</url>
      
        <content type="html"><![CDATA[<ul><li>time: 2020-02-18 09:28:30</li></ul><h2 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h2><ul><li>uuid</li><li>有向无环图来管理任务依赖调度</li><li>磁盘存储</li><li>内存管理</li><li>缓存</li></ul><h2 id="爬虫业务"><a href="#爬虫业务" class="headerlink" title="爬虫业务"></a>爬虫业务</h2><ul><li>定时任务。定时任务的设置<ul><li>crontab</li><li>celery</li><li>定时器</li><li>sleep时长</li><li>各种定时任务管理系统。airflow、azkaban等。</li></ul></li><li>需要精确到秒级运行<ul><li>这个要看秒级精确到程度，<ul><li>如果是10s内，可以用sleep来运行。</li><li>如果大于10s，则可以用定时的方式来实现，不过可能需要找些工具平台来做，因为crontab并不支持任务精确到秒级。比如：<a href="https://github.com/ouqiang/gocron" target="_blank" rel="noopener">gocron</a>,这个管理系统提供精确到秒级。</li></ul></li></ul></li><li>sleep做定时运行<ul><li>坏处是下次运行时间不太确定，这个要看任务的执行时间长短，而不是正点运行。</li><li>好处是在较小任务的间隔下，频繁的执行，这个实现起来比较容易。可以忽略少量失败的情况下，而且没有下游时间点要求较严格的情况下，比较友好的实现。</li><li>而且这种实现方式需要任务常驻运行，启动方式有多种</li></ul></li><li>常驻任务管理<ul><li>直接命令执行。这个启动方式是前台执行，如果退出命令，则停止了；只能强制退出terminal，让其在一个终端下以前台的方式来运行。</li><li>nohup来启动。<ul><li>例如：nohup python src/main.py &amp; &gt; nohup.out 。这样进程就会在后台运行</li><li>但如果程序有异常，就会抛出异常，自动退出。</li></ul></li><li>supervisor来启动守护进程管理。<ul><li>有配置文件来统一管理，</li></ul></li><li>docker来管理，失败重启并通知</li></ul></li><li>定时任务的依赖调度管理<ul><li>用有向无环图来管理任务，确定任务执行的顺序、失败操作，多路并发运行，保证可靠性。</li><li>常用的系统有：airflow(python)</li></ul></li><li>html解析<ul><li>xpath。好用、快捷(内置python、用c语言实现)</li><li>bs4库。</li></ul></li><li>爬虫框架<ul><li>scripy</li></ul></li><li>ip代理</li></ul><h2 id="Web服务"><a href="#Web服务" class="headerlink" title="Web服务"></a>Web服务</h2><ul><li>单点登录</li><li>安全规范</li><li>消息通知</li><li>缓存</li><li>高可靠、高并发</li></ul><h2 id="大数据"><a href="#大数据" class="headerlink" title="大数据"></a>大数据</h2><h4 id="数据同步"><a href="#数据同步" class="headerlink" title="数据同步"></a>数据同步</h4><ul><li>mysql2mysql</li><li>mysql2hbase</li><li>mysql2kudu</li></ul><h2 id="NLP相关"><a href="#NLP相关" class="headerlink" title="NLP相关"></a>NLP相关</h2><ul><li>命名实体识别</li><li>图片文字提取</li><li>实体关系挖掘</li><li>文本相似度匹配</li><li>自动摘要</li></ul><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><ul><li>什么是微服务，微服务的优缺点，什么场景适用微服务。</li></ul><h2 id="服务发布"><a href="#服务发布" class="headerlink" title="服务发布"></a>服务发布</h2><ul><li>自动部署发布</li></ul><h2 id="服务统计"><a href="#服务统计" class="headerlink" title="服务统计"></a>服务统计</h2><ul><li>日志</li><li>请求量</li><li>PV、UV</li></ul><h2 id="网络请求"><a href="#网络请求" class="headerlink" title="网络请求"></a>网络请求</h2><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><ul><li>优化sql<ul><li>添加索引</li><li>少用子查询</li></ul></li></ul><h2 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h2><ul><li>防止暴力破解登录<ul><li>修改常用登录的端口</li><li>fail2ban软件来监控<ul><li>如果失败了，在设置时长内禁止登录。</li></ul></li></ul></li></ul><h2 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分享</title>
      <link href="man/cs/%E5%88%86%E4%BA%AB.html"/>
      <url>man/cs/%E5%88%86%E4%BA%AB.html</url>
      
        <content type="html"><![CDATA[<p>kudu技术<br>http协议<br>分布式理论<br>  raft协议<br>Xpath<br>Io多路复用<br>不隆过滤器<br>mvcc<br>python魔术方法<br>python字符串<br>python字典<br>python遍历<br>python多线程多进程<br>python正则<br>python网络库</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/cs/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.html"/>
      <url>man/cs/%E7%BC%96%E7%A8%8B%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<h3 id="0x00、设计思想"><a href="#0x00、设计思想" class="headerlink" title="0x00、设计思想"></a>0x00、设计思想</h3><ul><li>语言设计原则</li><li>语言特点</li><li>语言适用场景</li><li>简述解释型和编译型语言<ul><li>编译型语言<ul><li>把做好的源程序全部编译成二进制代码的可运行程序。然后，可直接运行这个程序。</li><li>执行速度快、效率高</li><li>依赖编译器、跨平台性差些。</li><li>如C、C++、Delphi、Pascal，Fortran。</li><li>优点：编译器⼀般会有预编译的过程对代码进⾏优化。因为编译只做⼀次，运⾏时不需要编译，所以编译型语⾔的程序执⾏效率⾼。可以脱离语⾔环境独立运⾏。</li><li>缺点：编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运⾏环境⽣成机器码，不同的操作系统之间移植就会有问题，需要根据运⾏的操作系统环境编译不同的可执⾏⽂件。</li></ul></li><li>解释型语言<ul><li>把做好的源程序翻译一句，然后执行一句，直至结束！</li><li>执行速度慢、效率低</li><li>依赖解释器、跨平台性好。</li><li>优点：有良好的平台兼容性，在任何环境中都可以运⾏，前提是安装了解释器（虚拟机）。灵活，修改代码的时候直接修改就可以，可以快速部署，不⽤停机维护。</li><li>缺点：每次运⾏的时候都要解释⼀遍，性能上不如编译型语⾔。</li></ul></li><li>混合型<ul><li>没有直接编译称为机器语言，而是编译称为字节码</li><li>然后在虚拟机上用解释方式执行字节码。</li><li>如java、python等</li></ul></li></ul></li><li>机器码与字节码<ul><li>机器码是电脑的CPU可直接解读的数据</li><li>字节码是二进制文件,一种中间码</li></ul></li><li>编程规范有哪些</li><li>注释、文档如何实现</li></ul><h3 id="0x01、基础操作"><a href="#0x01、基础操作" class="headerlink" title="0x01、基础操作"></a>0x01、基础操作</h3><ul><li>关键字有哪些，有什么作用</li><li>关键字是否可以赋值</li><li>基础数据类型有哪些</li><li>如何区别可变数据类型和不可变数据类型</li><li>变量作用域</li><li>判断变量是否相等</li><li>是否有常量？常量如何定义？常量特性？</li><li>普通打印</li><li>结构化打印</li><li>字符填充为固定宽度</li><li>字符串带变量拼接</li><li>对象打印</li><li>条件判断有哪些？</li><li>循环遍历有哪些？各有什么好用处？循环遍历时改变遍历对象的值</li><li>路径如何做到穷举、全覆盖</li><li>操作符可否重载？哪些情况可以重载？为什么要有重载？</li><li>变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？</li><li>字符串截取成数组，数组拼接成字符串</li><li>数组去重，数组内某个值的数量，数组排序，数组反转，两个数组合并，两个数组求并集和差集</li><li>字符串是否包含某个值，是否以某个值开始、结尾，字符串长度，字符串前后去除无效字符(比如空格)，字符串大小写转换，获取字符的某几位，</li><li>字符串转json，json转成列表或字典</li><li>是否有深浅拷贝，都是做什么的，适用场景是什么？<ul><li>浅拷贝：不管多么复杂的数据结构，只copy对象最外层本身，该对象引用的其他对象不copy， 内存里两个变量的地址是一样的，一个改变另一个也改变。</li><li>深拷贝：完全复制原变量的所有数据，内存中生成一套完全一样的内容；只是值一样，内存地址不一样，一方修改另一方不受影响</li></ul></li></ul><h3 id="0x02、常用数据结构"><a href="#0x02、常用数据结构" class="headerlink" title="0x02、常用数据结构"></a>0x02、常用数据结构</h3><ul><li>动态列表</li><li>hash</li><li>字典</li><li>队列</li><li>堆栈</li></ul><h3 id="0x03、系统操作"><a href="#0x03、系统操作" class="headerlink" title="0x03、系统操作"></a>0x03、系统操作</h3><ul><li>获取用户输入</li><li>获取命令行参数</li><li>命令参数化</li><li>获取系统环境变量</li><li>获取文件路径</li></ul><h3 id="0x04、文件操作"><a href="#0x04、文件操作" class="headerlink" title="0x04、文件操作"></a>0x04、文件操作</h3><ul><li>创建文件夹</li><li>递归创建文件夹</li><li>创建文件</li><li>读文件</li><li>写文件</li><li>读大文件</li><li>移动文件夹及文件</li><li>重命名文件夹及文件</li></ul><h3 id="0x05、时间操作"><a href="#0x05、时间操作" class="headerlink" title="0x05、时间操作"></a>0x05、时间操作</h3><ul><li>获取当前时间</li><li>获取当前日期</li><li>获取前天、30天前、上个季度、一年前日期</li><li>字符串日期时间转时间类型</li><li>时间类型转字符串时间日期</li><li>日期时间中获取日期</li><li>获取整分、整时的时间</li><li>时间戳转时间、转字符串</li><li>字符串时间转时间戳</li><li></li></ul><h3 id="0x06、正则操作"><a href="#0x06、正则操作" class="headerlink" title="0x06、正则操作"></a>0x06、正则操作</h3><ul><li>匹配数字、小数</li><li>匹配字母，区分、不区分大小写</li><li>匹配汉字</li><li>匹配url</li><li>匹配邮箱</li><li>匹配手机号</li><li>匹配域名</li><li>url截取成协议、域名、path、params</li></ul><h3 id="0x07、上传下载"><a href="#0x07、上传下载" class="headerlink" title="0x07、上传下载"></a>0x07、上传下载</h3><ul><li>上传、下载文件</li><li>上传、下载图像</li></ul><h3 id="0x08、线程-进程"><a href="#0x08、线程-进程" class="headerlink" title="0x08、线程/进程"></a>0x08、线程/进程</h3><ul><li>线程与进程的区别</li><li>多线程执行</li><li>多进程执行</li><li>多进程共享变量</li><li>多线程锁如何使用</li></ul><h3 id="0x09、网络操作"><a href="#0x09、网络操作" class="headerlink" title="0x09、网络操作"></a>0x09、网络操作</h3><ul><li>http请求</li><li>socket编程</li></ul><h3 id="0x10、面向对象"><a href="#0x10、面向对象" class="headerlink" title="0x10、面向对象"></a>0x10、面向对象</h3><ul><li>继承</li><li>多态</li><li>封装</li><li>对象序列化传输，反序列化执行</li><li>判断某个实例是不是属于某个类</li></ul><h3 id="0x11、异常处理"><a href="#0x11、异常处理" class="headerlink" title="0x11、异常处理"></a>0x11、异常处理</h3><ul><li>错误、异常处理</li></ul><h3 id="0x12、工程"><a href="#0x12、工程" class="headerlink" title="0x12、工程"></a>0x12、工程</h3><ul><li>包管理</li><li>装饰器是什么，如何实现</li><li>编程模式是什么，都有哪些，作用是什么，如何实现？</li></ul><h3 id="0x13、常用方法实现"><a href="#0x13、常用方法实现" class="headerlink" title="0x13、常用方法实现"></a>0x13、常用方法实现</h3><ul><li>递归</li><li>排序</li><li>查找</li><li>数学库</li><li>随机数</li><li>加密算法</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/cs/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E9%9D%A0%E5%BC%80%E5%8F%91.html"/>
      <url>man/cs/%E9%AB%98%E6%80%A7%E8%83%BD%E9%AB%98%E5%8F%AF%E9%9D%A0%E5%BC%80%E5%8F%91.html</url>
      
        <content type="html"><![CDATA[<ul><li>添加try catch</li><li>类型比较判断</li><li>异步执行</li><li>多线程、多进程执行</li></ul><p>用redis做一个分布式锁。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/django/01%E6%80%BB%E7%BB%93.html"/>
      <url>man/django/01%E6%80%BB%E7%BB%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="Django文档"><a href="#Django文档" class="headerlink" title="Django文档"></a>Django文档</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-23 10:33:20</li></ul><h2 id="0x00、问题总结"><a href="#0x00、问题总结" class="headerlink" title="0x00、问题总结"></a>0x00、问题总结</h2><ul><li><p>整体的数据流程</p><ul><li>是典型的MVT模型(model、view、template)</li></ul></li><li><p>gunicron启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; --reload 参数可以进行自动加载</span><br><span class="line">sudo gunicorn [项目名称].wsgi:application -b 127.0.0.1:8000 --reload</span><br></pre></td></tr></table></figure></li><li><p>django的mysql包没有错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 在init文件内添加下面代码</span><br><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure></li><li><p>django的env配置</p><ul><li>安装django-environ=0.4.5</li><li>新建一个.env文件，同时创建.env.example文件</li><li>在setting.py中进行配置替换</li></ul></li><li><p>多个python的web框架使用比较</p></li><li><p>vue配置element</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;在main.js中配置</span><br><span class="line">&#x2F;&#x2F; 引入element</span><br><span class="line">import ElementUI from &#39;element-ui&#39;</span><br><span class="line">import &#39;element-ui&#x2F;lib&#x2F;theme-chalk&#x2F;index.css&#39;</span><br><span class="line">&#x2F;&#x2F;全局注册</span><br><span class="line">Vue.use(ElementUI)</span><br></pre></td></tr></table></figure></li><li><p>django中的model定义表名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Meta:</span><br><span class="line">    db_table &#x3D; &#39;user&#39;</span><br></pre></td></tr></table></figure></li><li><p>django的view</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def index(request):</span><br><span class="line">    rows &#x3D; User.objects.values(&quot;id&quot;,&quot;name&quot;,&quot;email&quot;,&quot;create_time&quot;,&quot;update_time&quot;).all()</span><br><span class="line">    rsp &#x3D; &#123;&quot;code&quot;:0, &quot;msg&quot;:&quot;OK&quot;, &quot;data&quot;:list(rows)&#125;</span><br><span class="line">    return JsonResponse(rsp)</span><br></pre></td></tr></table></figure></li><li><p>Django接收post数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input[]&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input[]&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input[]&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;input[]&quot;&gt;</span><br><span class="line">inputs &#x3D; request.POST.getlist(&#39;input[]&#39;)</span><br></pre></td></tr></table></figure></li></ul><ul><li>执行某个py文件<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> django</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这两行很重要，用来寻找项目根目录，os.path.dirname要写多少个根据要运行的python文件到根目录的层数决定</span></span><br><span class="line">BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))</span><br><span class="line">sys.path.append(BASE_DIR)</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">'DJANGO_SETTINGS_MODULE'</span>, <span class="string">'business_api_app.settings'</span>)</span><br><span class="line">django.setup()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tasks</span><span class="params">()</span>:</span></span><br><span class="line">    rows = Person.objects.all()</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">        print(row)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    tasks()</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x04、view"><a href="#0x04、view" class="headerlink" title="0x04、view"></a>0x04、view</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">util.apiAxios = function(url, params, response) &#123;</span><br><span class="line">  this.ajax(&#123;</span><br><span class="line">     method: <span class="string">'POST'</span>,</span><br><span class="line">     url: url,</span><br><span class="line">     data: params,</span><br><span class="line">     params: params,</span><br><span class="line">     transformRequest: [function (data) &#123;</span><br><span class="line">         let ret = <span class="string">''</span></span><br><span class="line">          <span class="keyword">for</span> (let it <span class="keyword">in</span> data) &#123;</span><br><span class="line">            ret += encodeURIComponent(it) + <span class="string">'='</span> + encodeURIComponent(data[it]) + <span class="string">'&amp;'</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret</span><br><span class="line">    &#125;],</span><br><span class="line">    headers:&#123;<span class="string">'Content-Type'</span>: <span class="string">"application/x-www-form-urlencoded"</span>&#125;</span><br><span class="line">  &#125;).then(function (res) &#123;</span><br><span class="line">      response(res);</span><br><span class="line">  &#125;).catch(function (err) &#123;</span><br><span class="line">      response(err);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/django/04%E6%97%A5%E5%BF%97.html"/>
      <url>man/django/04%E6%97%A5%E5%BF%97.html</url>
      
        <content type="html"><![CDATA[<h3 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">LOGGING = &#123;</span><br><span class="line">    <span class="string">'version'</span>: <span class="number">1</span>,  <span class="comment"># 指明dictConnfig的版本，目前就只有一个版本，哈哈</span></span><br><span class="line">    <span class="string">'disable_existing_loggers'</span>: <span class="literal">False</span>,  <span class="comment"># 表示是否禁用所有的已经存在的日志配置</span></span><br><span class="line">    <span class="string">'formatters'</span>: &#123;  <span class="comment"># 格式器</span></span><br><span class="line">        <span class="string">'verbose'</span>: &#123;  <span class="comment"># 详细</span></span><br><span class="line">            <span class="string">'format'</span>: <span class="string">'%(levelname)s %(asctime)s %(module)s %(process)d %(thread)d %(message)s'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'standard'</span>: &#123;  <span class="comment"># 标准</span></span><br><span class="line">            <span class="string">'format'</span>: <span class="string">'[%(asctime)s] [%(levelname)s] %(message)s'</span></span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># handlers：用来定义具体处理日志的方式，可以定义多种，"default"就是默认方式，"console"就是打印到控制台方式。file是写入到文件的方式，注意使用的class不同</span></span><br><span class="line">    <span class="string">'handlers'</span>: &#123; <span class="comment"># 处理器，在这里定义了两个个处理器</span></span><br><span class="line">        <span class="string">'console'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>: <span class="string">'logging.StreamHandler'</span>,</span><br><span class="line">            <span class="string">'stream'</span>: <span class="string">'ext://sys.stdout'</span>,   <span class="comment"># 文件重定向的配置，将打印到控制台的信息都重定向出去 python manage.py runserver &gt;&gt; /home/aea/log/test.log</span></span><br><span class="line">            <span class="comment"># 'stream': open('/home/aea/log/test.log','a'),  #虽然成功了，但是并没有将所有内容全部写入文件，目前还不清楚为什么</span></span><br><span class="line">            <span class="string">'formatter'</span>: <span class="string">'standard'</span>   <span class="comment"># 制定输出的格式，注意 在上面的formatters配置里面选择一个，否则会报错</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'file'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>: <span class="string">'logging.FileHandler'</span>,</span><br><span class="line">            <span class="string">'filename'</span>: <span class="string">'/home/aea/log/jwt_test.log'</span>,  <span class="comment">#这是将普通日志写入到日志文件中的方法，</span></span><br><span class="line">            <span class="string">'formatter'</span>: <span class="string">'standard'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'default'</span>: &#123;</span><br><span class="line">            <span class="string">'level'</span>:<span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'class'</span>:<span class="string">'logging.handlers.RotatingFileHandler'</span>,</span><br><span class="line">            <span class="string">'filename'</span>: <span class="string">'/home/aea/log/all.log'</span>,     <span class="comment">#日志输出文件</span></span><br><span class="line">            <span class="string">'maxBytes'</span>: <span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>,                  <span class="comment">#文件大小</span></span><br><span class="line">            <span class="string">'backupCount'</span>: <span class="number">5</span>,                         <span class="comment">#备份份数</span></span><br><span class="line">            <span class="string">'formatter'</span>:<span class="string">'standard'</span>,                   <span class="comment">#使用哪种formatters日志格式</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment"># 上面两种写入日志的方法是有区别的，前者是将控制台下输出的内容全部写入到文件中，这样做的好处就是我们在views代码中的所有print也会写在对应的位置</span></span><br><span class="line">        <span class="comment"># 第二种方法就是将系统内定的内容写入到文件，具体就是请求的地址、错误信息等，小伙伴也可以都使用一下然后查看两个文件的异同。</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'loggers'</span>: &#123;  <span class="comment"># log记录器，配置之后就会对应的输出日志</span></span><br><span class="line">        <span class="comment"># django 表示就是django本身默认的控制台输出，就是原本在控制台里面输出的内容，在这里的handlers里的file表示写入到上面配置的file-/home/aea/log/jwt_test.log文件里面</span></span><br><span class="line">        <span class="comment"># 在这里的handlers里的console表示写入到上面配置的console-/home/aea/log/test.log文件里面</span></span><br><span class="line">        <span class="string">'django'</span>: &#123;</span><br><span class="line">            <span class="string">'handlers'</span>: [<span class="string">'console'</span>,<span class="string">'file'</span>],</span><br><span class="line">            <span class="comment"># 这里直接输出到控制台只是请求的路由等系统console，当使用重定向之后会把所有内容输出到log日志</span></span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'propagate'</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'django.request '</span>:&#123;</span><br><span class="line">            <span class="string">'handlers'</span>: [<span class="string">'console'</span>,<span class="string">'file'</span>],</span><br><span class="line">            <span class="string">'level'</span>: <span class="string">'WARNING'</span>,  <span class="comment"># 配合上面的将警告log写入到另外一个文件</span></span><br><span class="line">            <span class="string">'propagate'</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'django.db.backends'</span>: &#123;</span><br><span class="line">            <span class="string">'handlers'</span>: [<span class="string">'file'</span>], <span class="comment"># 指定file handler处理器，表示只写入到文件</span></span><br><span class="line">            <span class="string">'level'</span>:<span class="string">'DEBUG'</span>,</span><br><span class="line">            <span class="string">'propagate'</span>: <span class="literal">True</span>,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是对参数和配置的解释</p><p>level:级别</p><p>一个记录器是日志系统的一个实体，每一个记录器是一个已经命名好的可以将消息为进程写入的“桶”。<br>每一个记录器都会有一个日志等级，每个等级描述了记录器即将处理的信息的严重性，python定义了以下六个等级：<br>级别  值   描述<br>CRITICAL    50  关键错误/消息,描述已经发生的严重问题<br>ERROR       40  错误,描述已经发生的主要问题<br>WARNING     30  警告消息,描述已经发生的小问题<br>INFO        20  通知消息,普通的系统信息列表内容<br>DEBUG       10  调试,出于调试目的的低层次系统信息<br>NOTSET      0   无级别<br>处理器/记录器 关键字参数：</p><p>关键字参数   描述<br>filename    将日志消息附加到指定文件名的文件<br>filemode    指定用于打开文件模式, 文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。<br>format      用于生成日志消息的格式字符串<br>datefmt     用于输出日期和时间的格式字符串<br>level       设置记录器的级别<br>propagate   可以基于每个记录器控制该传播。 如果您不希望特定记录器传播到其父项，则可以关闭此行为。<br>stream      提供打开的文件，用于把日志消息发送到文件。可以指定输出到sys.stderr,sys.stdout或者文件，默认为sys.stderr。<br>            若同时列出了filename和stream两个参数，则stream参数会被忽略。<br>format: 日志消息格式</p><p>格式  描述<br>%(name)s        记录器的名称<br>%(levelno)s     数字形式的日志记录级别<br>%(levelname)s   日志记录级别的文本名称<br>%(filename)s    执行日志记录调用的源文件的文件名称<br>%(pathname)s    执行日志记录调用的源文件的路径名称<br>%(funcName)s    执行日志记录调用的函数名称<br>%(module)s      执行日志记录调用的模块名称<br>%(lineno)s      执行日志记录调用的行号<br>%(created)s     执行日志记录的时间<br>%(asctime)s     日期和时间<br>%(msecs)s       毫秒部分<br>%(thread)d      线程ID<br>%(threadName)s  线程名称<br>%(process)d     进程ID<br>%(message)s     记录的消息<br>内置处理器</p><p>logging模块提供了一些处理器，可以通过各种方式处理日志消息。使用addHandler()方法将这些处理器添加给Logger对象。另外还可以为每个处理器配置它自己的筛选和级别。<br>logging.StreamHandler                               可以向类似与sys.stdout或者sys.stderr的任何文件对象(file object)输出信息<br>logging.FileHandler                                 将日志消息写入文件filename。<br>logging.handlers.DatagramHandler(host，port)        发送日志消息给位于制定host和port上的UDP服务器。使用UDP协议，将日志信息发送到网络<br>logging.handlers.HTTPHandler(host, url)             使用HTTP的GET或POST方法将日志消息上传到一台HTTP 服务器。<br>logging.handlers.RotatingFileHandler(filename)      将日志消息写入文件filename。如果文件的大小超出maxBytes制定的值，那么它将被备份为filenamel。<br>logging.handlers.SocketHandler                      使用TCP协议，将日志信息发送到网络。<br>logging.handlers.SysLogHandler                      日志输出到syslog<br>logging.handlers.NTEventLogHandler                  远程输出日志到Windows NT/2000/XP的事件日志<br>logging.handlers.SMTPHandler                        远程输出日志到邮件地址<br>logging.handlers.MemoryHandler                      日志输出到内存中的制定buffer<br>注意：由于内置处理器还有很多，如果想更深入了解。可以查看官方手册。<br>django提供的内置记录器</p><p>django      在Django层次结构中的所有消息记录器。没有使用此名称发布消息，而是使用下面的记录器之一。<br>django.request      与请求处理相关的日志消息。5xx响应被提升为错误消息；4xx响应被提升为警告消息。<br>django.server       与由RunServer命令调用的服务器所接收的请求的处理相关的日志消息。HTTP 5XX响应被记录为错误消息，4XX响应被记录为警告消息，其他一切都被记录为INFO。<br>django.template     与模板呈现相关的日志消息<br>django.db.backends  有关代码与数据库交互的消息。例如，请求执行的每个应用程序级SQL语句都在调试级别记录到此记录器</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/django/03%E4%B8%AD%E9%97%B4%E4%BB%B6.html"/>
      <url>man/django/03%E4%B8%AD%E9%97%B4%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<h4 id="1-中间件"><a href="#1-中间件" class="headerlink" title="1.中间件"></a>1.中间件</h4><p>判断登陆及权限，做IP拦截，客户端设备识别，过滤恶意请求<br>官方说法：中间件是一个用来处理Django的请求和响应的框架级别的钩子。它是一个轻量、低级别的插件系统，用于在全局范围内改变Django的输入和输出。每个中间件组件都负责做一些特定的功能。说的真实点，其实中间件就是帮助我们在视图函数执行之前和执行之后都可以做一些额外的操作，它本质上就是一个自定义类，类中定义了几个办法，Django框架会在请求的特定的时间去执行这些方法。</p><p>在Django中，其实我们一直都在使用中间件，在Django项目的settings.py文件中，有一项就是中间件的配置：MIDDLEWARE。是一个列表，列表中是一个个字符串，这些字符串其实一个个类，也就是一个个中间件。</p><p>中间件可以定义五个方法，分别是：（主要的是process_request和process_response）</p><ol><li>process_request(self,request)</li><li>process_view(self,request,view_func,view_args,view_kwargs)</li><li>process_template_response(self,request,response)</li><li>process_exception(self,request,exception)</li><li>process_response(self,request,response)<br>以上方法的返回值可以是None或一个HttpResponse对象，如果是None，则继续按照Django定义的规则向后继续执行，如果是HttpResponse对象，则直接将对象返回给用户。</li></ol><p>process_reqeusts</p><ol><li>中间件的process_request方法是在执行视图函数之前执行的。</li><li>当配置多个中间件时，会按照MIDDLEWARE中的注册顺序，也就是列表的索引值，从前到后依次执行的。</li><li>不同中间件之间传递的request都是同一个对象</li></ol><p>process_response<br>1.它有两个参数，一个是request，一个是response，request就是上述例子中一样的对象，response是视图函数返回的HttpResponse对象。该方法的返回值也必须是HttpResponse对象。<br>2.process_response方法是在视图函数之后执行的，并且顺序是MD1比MD2先执行。(此时settings.py中 MD2比MD1先注册)<br>3.多个中间件中的process_response方法是按照MIDDLEWARE中的注册顺序倒序执行的，也就是说第一个中间件的process_request方法首先执行，而它的process_response方法最后执行，最后一个中间件的process_request方法最后一个执行，它的process_response方法是最先执行。</p><p>process_view<br>process_view(self, request, view_func, view_args, view_kwargs)<br>该方法有四个参数<br>request是HttpRequest对象。<br>view_func是Django即将使用的视图函数。 （它是实际的函数对象，而不是函数的名称作为字符串。）<br>view_args是将传递给视图的位置参数的列表.<br>view_kwargs是将传递给视图的关键字参数的字典。 view_args和view_kwargs都不包含第一个视图参数（request）。<br>它应该返回None或一个HttpResponse对象。 如果返回None，Django将继续处理这个请求，执行任何其他中间件的process_view方法，然后在执行相应的视图。 如果它返回一个HttpResponse对象，Django不会调用适当的视图函数。 它将执行中间件的process_response方法并将应用到该HttpResponse并返回结果。<br>process_view方法是在process_request之后，视图函数之前执行的，执行顺序按照MIDDLEWARE中的注册顺序从前到后顺序执行的。</p><p>process_exception<br>process_exception(self, request, exception)<br>该方法两个参数:<br>一个HttpRequest对象<br>一个exception是视图函数异常产生的Exception对象。<br>这个方法只有在视图函数中出现异常了才执行，它返回的值可以是一个None也可以是一个HttpResponse对象。如果是HttpResponse对象，Django将调用模板和中间件中的process_response方法，并返回给浏览器，否则将默认处理异常。如果返回一个None，则交给下一个中间件的process_exception方法来处理异常。它的执行顺序也是按照中间件注册顺序的倒序执行。<br>如果视图函数中无异常，process_exception方法不执行。</p><p>process_template_response<br>process_template_response(self, request, response)<br>它的参数，一个HttpRequest对象，response是TemplateResponse对象（由视图函数或者中间件产生）。<br>process_template_response是在视图函数执行完成后立即执行，但是它有一个前提条件，那就是视图函数返回的对象有一个render()方法（或者表明该对象是一个TemplateResponse对象或等价方法）。<br>视图函数执行完之后，立即执行了中间件的process_template_response方法，顺序是倒序，先执行MD1的，在执行MD2的，接着执行了视图函数返回的HttpResponse对象的render方法，返回了一个新的HttpResponse对象，接着执行中间件的process_response方法。</p><p>总结一下：</p><ol><li><p>process_request(self, request)</p><ul><li>视图函数执行之前（在urls.py找对应关系之前）</li><li>注册顺序</li></ul></li><li><p>process_response(self, request, response)</p><ul><li>视图函数执行之后</li><li>注册顺序的倒序</li></ul></li><li><p>process_view(self, view_func, view_args, view_kwargs)</p><ul><li>视图函数执行之前（在urls.py中找到对应关系之后）<br>此时view_func就是将要执行的视图函数对象！！！</li><li>注册顺序</li></ul></li><li><p>process_exception(self, request, exception)</p><ul><li>视图函数执行之后，只有在有异常的时候才执行</li><li>注册顺序的倒序</li></ul></li><li><p>process_template_response(self, request, response)</p><ul><li>视图函数执行之后，只有在响应对象有render方法的时候才执行</li><li>注册顺序的倒序</li></ul></li></ol><p><img data-src="img/C07AF1D7-539D-49E9-8F5F-EEDBE160C671.png" alt="C07AF1D7-539D-49E9-8F5F-EEDBE160C671"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中间件认证登陆</span></span><br><span class="line"><span class="comment"># 注：AuthMD中间件中需要session，所以AuthMD注册的位置要在session中间的下方。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AuthMD</span><span class="params">(MiddlewareMixin)</span>:</span></span><br><span class="line">    white_list = [<span class="string">'/login/'</span>, ]  <span class="comment"># 白名单</span></span><br><span class="line">    balck_list = [<span class="string">'/black/'</span>, ]  <span class="comment"># 黑名单</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_request</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> redirect, HttpResponse</span><br><span class="line"></span><br><span class="line">        next_url = request.path_info</span><br><span class="line">        print(request.path_info, request.get_full_path())</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> next_url <span class="keyword">in</span> self.white_list <span class="keyword">or</span> request.session.get(<span class="string">"user"</span>):</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">elif</span> next_url <span class="keyword">in</span> self.balck_list:</span><br><span class="line">            <span class="keyword">return</span> HttpResponse(<span class="string">'This is an illegal URL'</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> redirect(<span class="string">"/login/?next=&#123;&#125;"</span>.format(next_url))</span><br></pre></td></tr></table></figure><ul><li>设置header</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response[<span class="string">"Set-Token"</span>] = <span class="string">''</span></span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/django/05wsgi.html"/>
      <url>man/django/05wsgi.html</url>
      
        <content type="html"><![CDATA[<h4 id="WSGI"><a href="#WSGI" class="headerlink" title="WSGI"></a>WSGI</h4><p>WSGI是 Web Server Gateway Interface 的缩写。<br>它是 Python应用程序（application）或框架（如 Django）和 Web服务器之间的一种接口，已经被广泛接受。<br>它是一种协议，一种规范，其是在 PEP 333提出的，并在 PEP 3333 进行补充（主要是为了支持 Python3.x）。这个协议旨在解决众多 web 框架和web server软件的兼容问题。有了WSGI，你不用再因为你使用的web 框架而去选择特定的 web server软件。<br>常见的web应用框架有：Django，Flask等<br>常用的web服务器软件有：uWSGI，Gunicorn等</p><p>WSGI 接口有服务端和应用端两部分，服务端也可以叫网关端，应用端也叫框架端。服务端调用一个由应用端提供的可调用对象。如何提供这个对象，由服务端决定。例如某些服务器或者网关需要应用的部署者写一段脚本，以创建服务器或者网关的实例，并且为这个实例提供一个应用实例。另一些服务器或者网关则可能使用配置文件或其他方法以指定应用实例应该从哪里导入或获取。</p><p>WSGI 对于 application 对象有如下三点要求</p><ol><li>必须是一个可调用的对象</li><li>接收两个必选参数environ、start_response。</li><li>返回值必须是可迭代对象，用来表示http body。</li></ol><h5 id="HTTP请求是如何到应用程序的？"><a href="#HTTP请求是如何到应用程序的？" class="headerlink" title="HTTP请求是如何到应用程序的？"></a>HTTP请求是如何到应用程序的？</h5><p>1、两级结构 在这种结构里，uWSGI作为服务器，它用到了HTTP协议以及wsgi协议，flask应用作为application，实现了wsgi协议。当有客户端发来请求，uWSGI接受请求，调用flask app得到相应，之后相应给客户端。 这里说一点，通常来说，Flask等web框架会自己附带一个wsgi服务器(这就是flask应用可以直接启动的原因)，但是这只是在开发阶段用到的，在生产环境是不够用的，所以用到了uwsgi这个性能高的wsgi服务器。<br>2、三级结构 这种结构里，uWSGI作为中间件，它用到了uwsgi协议(与nginx通信)，wsgi协议(调用Flask app)。当有客户端发来请求，nginx先做处理(静态资源是nginx的强项)，无法处理的请求(uWSGI)，最后的相应也是nginx回复给客户端的。 多了一层反向代理有什么好处？<br>提高web server性能(uWSGI处理静态资源不如nginx；nginx会在收到一个完整的http请求后再转发给wWSGI)<br>nginx可以做负载均衡(前提是有多个服务器)，保护了实际的web服务器(客户端是和nginx交互而不是uWSGI)</p><h5 id="实现一个简单的-WSGI-Server"><a href="#实现一个简单的-WSGI-Server" class="headerlink" title="实现一个简单的 WSGI Server"></a>实现一个简单的 WSGI Server</h5><p>在上面的架构图里，不知道你发现没有，有个库叫做 wsgiref ，它是 Python 自带的一个 wsgi 服务器模块。<br>从其名字上就看出，它是用纯Python编写的WSGI服务器的参考实现。所谓“参考实现”是指该实现完全符合WSGI标准，但是不考虑任何运行效率，仅供开发和测试使用。<br>有了 wsgiref 这个模块，你就可以很快速的启动一个wsgi server。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pythonfrom wsgiref.simple_server <span class="keyword">import</span> make_server</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里的 appclass 暂且不说，后面会讲到</span></span><br><span class="line">app = appclass()</span><br><span class="line">server = make_server(<span class="string">''</span>, <span class="number">64570</span>, app)</span><br><span class="line">server.serve_forever()</span><br></pre></td></tr></table></figure><p>复制代码<br>当你运行这段代码后，就会开启一个 wsgi server，监听 0.0.0.0:64570 ，并接收请求。<br>使用 lsof 命令可以查到确实开启了这个端口<br>以上使用 wsgiref 写了一个demo，让你对wsgi有个初步的了解。其由于只适合在学习测试使用，在生产环境中应该另寻他道。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/django/06%E6%B5%8B%E8%AF%95.html"/>
      <url>man/django/06%E6%B5%8B%E8%AF%95.html</url>
      
        <content type="html"><![CDATA[<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>django 应用的单元测试包括：</p><ul><li>测试 model，model 的方法是否返回了预期的数据，对数据库的操作是否正确。</li><li>测试表单，数据验证逻辑是否符合预期</li><li>测试视图，针对特定类型的请求，是否返回了预期的响应</li><li>其它的一些辅助方法或者类等</li></ul><p>使用 manage.py 的 test 命令将自动发现 django 应用下的 tests 文件或者模块，并且自动执行以 test_ 开头的方法。运行：pipenv run python manage.py test</p><ul><li>test_models.py 存放和模型有关的单元测试</li><li>test_views.py 测试视图函数</li><li>test_templatetags.py 测试自定义的模板标签</li><li>test_utils.py 测试一些辅助方法和类等</li></ul><p>tests 包中的各个模块必须以 test_ 开头，否则 django 无法发现这些测试文件的存在，从而不会运行里面的测试用例。</p><h5 id="测试模型"><a href="#测试模型" class="headerlink" title="测试模型"></a>测试模型</h5><p>模型需要测试的不多，因为基本上都是使用了 django 基类 models.Model 的特性，自己的逻辑很少。拿最为复杂的 Post 模型举例，它包括的逻辑功能主要有：</p><ul><li><strong>str</strong> 方法返回 title 用于模型实例的字符表示</li><li>save 方法中设置文章创建时间（created_time）和摘要（exerpt)</li><li>get_absolute_url 返回文章详情视图对应的 url 路径</li><li>increase_views 将 views 字段的值 +1</li></ul><h5 id="测试视图"><a href="#测试视图" class="headerlink" title="测试视图"></a>测试视图</h5><p>视图函数测试的基本思路是，向某个视图对应的 URL 发起请求，视图函数被调用并返回预期的响应，包括正确的 HTTP 响应码和 HTML 内容。<br>我们的博客应用包括以下类型的视图需要进行测试：</p><ul><li>首页视图 IndexView，访问它将返回全部文章列表。</li><li>标签视图，访问它将返回某个标签下的文章列表。如果访问的标签不存在，返回 404 响应。</li><li>分类视图，访问它将返回某个分类下的文章列表。如果访问的分类不存在，返回 404 响应。</li><li>归档视图，访问它将返回某个月份下的全部文章列表。</li><li>详情视图，访问它将返回某篇文章的详情，如果访问的文章不存在，返回 404。</li><li>自定义的 admin，添加文章后自动填充 author 字段的值。</li><li>RSS，返回全部文章的 RSS 内容。</li></ul><h4 id="实现“高并发”的-WSGI-Server"><a href="#实现“高并发”的-WSGI-Server" class="headerlink" title="实现“高并发”的 WSGI Server"></a>实现“高并发”的 WSGI Server</h4>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>编程时间</title>
      <link href="man/django/09%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html"/>
      <url>man/django/09%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1.html</url>
      
        <content type="html"><![CDATA[<h2 id="apscheduler"><a href="#apscheduler" class="headerlink" title="apscheduler"></a>apscheduler</h2><h2 id="celery结合"><a href="#celery结合" class="headerlink" title="celery结合"></a>celery结合</h2><p>首先在proj/proj/目录下新建一个celery.py文件，内容如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import, unicode_literals</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> celery <span class="keyword">import</span> Celery</span><br><span class="line"><span class="keyword">from</span> celery.schedules <span class="keyword">import</span> crontab</span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line"></span><br><span class="line">os.environ.setdefault(<span class="string">"DJANGO_SETTINGS_MODULE"</span>, <span class="string">"business_api_app.settings"</span>)</span><br><span class="line">app = Celery(<span class="string">"business_api_app"</span>)</span><br><span class="line">app.config_from_object(<span class="string">"django.conf:settings"</span>, namespace=<span class="string">"CELERY"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load task modules from all registered Django app configs.</span></span><br><span class="line">app.autodiscover_tasks(related_name=<span class="string">"tasks"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task(bind=True)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug_task</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">'Request: &#123;0!r&#125;'</span>.format(self.request))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置定时执行的任务</span></span><br><span class="line">app.conf.beat_schedule = &#123;</span><br><span class="line">    <span class="comment"># 活动倒计时，需要每分钟检查一次</span></span><br><span class="line">    <span class="string">"countdown"</span>: &#123;</span><br><span class="line">        <span class="string">"task"</span>: <span class="string">"activity.tasks.countdown"</span>,</span><br><span class="line">        <span class="string">"schedule"</span>: timedelta(seconds=(<span class="number">60</span>)),</span><br><span class="line">        <span class="string">"args"</span>: ()</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># 用户未投票数，每天23:30检查一次</span></span><br><span class="line">    <span class="string">"user_unvote_ticket"</span>: &#123;</span><br><span class="line">        <span class="string">"task"</span>: <span class="string">"activity.tasks.user_unvote_ticket"</span>,</span><br><span class="line">        <span class="string">"schedule"</span>: crontab(hour=<span class="number">23</span>, minute=<span class="number">30</span>),</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment"># pk艺人票数超过或者被赶超，每一小时检查一次</span></span><br><span class="line">    <span class="string">"artist_vote_ticket"</span>: &#123;</span><br><span class="line">        <span class="string">"task"</span>: <span class="string">"activity.tasks.artist_vote_ticket"</span>,</span><br><span class="line">        <span class="string">"schedule"</span>: timedelta(seconds=(<span class="number">60</span> * <span class="number">60</span>)),</span><br><span class="line">        <span class="string">"args"</span>: ()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在proj/proj/<strong>init</strong>.py文件内，写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> absolute_import</span><br><span class="line"></span><br><span class="line"><span class="comment"># This will make sure the app is always imported when</span></span><br><span class="line"><span class="comment"># Django starts so that shared_task will use this app.</span></span><br><span class="line"><span class="keyword">from</span> .celery <span class="keyword">import</span> app <span class="keyword">as</span> celery_app</span><br><span class="line"></span><br><span class="line">__all__ = [<span class="string">'celery_app'</span>]</span><br></pre></td></tr></table></figure></li><li><p>然后在settings.py文件内写入如下配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CELERY_BROKER_URL = <span class="string">"redis://:&#123;password&#125;@&#123;host&#125;/&#123;db&#125;"</span>.format(**conf_r)</span><br><span class="line">CELERY_RESULT_BACKEND = <span class="string">"redis://:&#123;password&#125;@&#123;host&#125;/&#123;db&#125;"</span>.format(**conf_r)</span><br><span class="line">CELERYD_MAX_TASKS_PER_CHILD = <span class="number">10</span></span><br><span class="line">CELERY_TIMEZONE = TIME_ZONE</span><br></pre></td></tr></table></figure></li><li><p>然后就是在每个app内，新建tasks.py文件就可以了。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@app.task</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countdown</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    倒计时推送</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    logging.info(<span class="string">f'starting countdown task.'</span>)</span><br><span class="line">    now = datetime.now()</span><br><span class="line"></span><br><span class="line">    logging.info(<span class="string">f'end countdown task.'</span>)</span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="man/docker/commands.html"/>
      <url>man/docker/commands.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ul><li><p>Management Commands:</p><ul><li><strong><code>config</code></strong>      Manage Docker configs</li><li><strong><code>container</code></strong>   Manage containers</li><li><strong><code>image</code></strong>       Manage images</li><li><strong><code>network</code></strong>     Manage networks</li><li><strong><code>node</code></strong>        Manage Swarm nodes</li><li><strong><code>plugin</code></strong>      Manage plugins</li><li><strong><code>secret</code></strong>      Manage Docker secrets</li><li><strong><code>service</code></strong>     Manage services</li><li><strong><code>stack</code></strong>       Manage Docker stacks</li><li><strong><code>swarm</code></strong>       Manage Swarm</li><li><strong><code>system</code></strong>      Manage Docker</li><li><strong><code>volume</code></strong>      Manage volumes<br></li></ul></li><li><p>Commands:</p><ul><li><strong><code>attach</code></strong>      Attach local standard input, output, and error streams to a running container</li><li><strong><code>build</code></strong>       Build an image from a Dockerfile</li><li><strong><code>commit</code></strong>      Create a new image from a container’s changes</li><li><strong><code>cp</code></strong>          Copy files/folders between a container and the local filesystem</li><li><strong><code>create</code></strong>      Create a new container</li><li><strong><code>diff</code></strong>        Inspect changes to files or directories on a container’s filesystem</li><li><strong><code>events</code></strong>      Get real time events from the server</li><li><strong><code>exec</code></strong>        Run a command in a running container</li><li><strong><code>export</code></strong>      Export a container’s filesystem as a tar archive</li><li><strong><code>history</code></strong>     Show the history of an image</li><li><strong><code>images</code></strong>      List images</li><li><strong><code>import</code></strong>      Import the contents from a tarball to create a filesystem image</li><li><strong><code>info</code></strong>        Display system-wide information</li><li><strong><code>inspect</code></strong>     Return low-level information on Docker objects</li><li><strong><code>kill</code></strong>        Kill one or more running containers</li><li><strong><code>load</code></strong>        Load an image from a tar archive or STDIN</li><li><strong><code>login</code></strong>       Log in to a Docker registry</li><li><strong><code>logout</code></strong>      Log out from a Docker registry</li><li><strong><code>logs</code></strong>        Fetch the logs of a container</li><li><strong><code>pause</code></strong>       Pause all processes within one or more containers</li><li><strong><code>port</code></strong>        List port mappings or a specific mapping for the container</li><li><strong><code>ps</code></strong>          List containers</li><li><strong><code>pull</code></strong>        Pull an image or a repository from a registry</li><li><strong><code>push</code></strong>        Push an image or a repository to a registry</li><li><strong><code>rename</code></strong>      Rename a container</li><li><strong><code>restart</code></strong>     Restart one or more containers</li><li><strong><code>rm</code></strong>          Remove one or more containers</li><li><strong><code>rmi</code></strong>         Remove one or more images</li><li><strong><code>run</code></strong>         Run a command in a new container</li><li><strong><code>save</code></strong>        Save one or more images to a tar archive (streamed to STDOUT by default)</li><li><strong><code>search</code></strong>      Search the Docker Hub for images</li><li><strong><code>start</code></strong>       Start one or more stopped containers</li><li><strong><code>stats</code></strong>       Display a live stream of container(s) resource usage statistics</li><li><strong><code>stop</code></strong>        Stop one or more running containers</li><li><strong><code>tag</code></strong>         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</li><li><strong><code>top</code></strong>         Display the running processes of a container</li><li><strong><code>unpause</code></strong>     Unpause all processes within one or more containers</li><li><strong><code>update</code></strong>      Update configuration of one or more containers</li><li><strong><code>version</code></strong>     Show the Docker version information</li><li><strong><code>wait</code></strong>        Block until one or more containers stop, then print their exit codes</li></ul></li></ul><br><ul><li><strong><code>docker images</code></strong>       // 查看存在多少镜像</li><li><strong><code>docker ps</code></strong>           // 查看镜像运行情况</li><li><strong><code>docker run -t -i</code></strong>    // 运行镜像。并进行交互模式。</li><li><strong><code>docker stop</code></strong>         // 停止运行镜像，后边跟镜像ID或name</li><li><strong><code>docker search</code></strong>       // 搜索镜像仓库</li><li><strong><code>docker pull</code></strong>         // 拉取镜像</li><li><strong><code>docker inspect</code></strong>      // 查看镜像的json文件，即全部详细信息</li><li><strong><code>docker port</code></strong>         // 查看docker与宿主机的端口映射关系</li><li><strong><code>docker commit</code></strong>       // 用来生成新的版本</li><li><strong><code>docker build</code></strong>        // 用docker file来创建镜像</li><li><strong><code>docker tag</code></strong>          // 设置镜像标签</li></ul><br><ul><li>容器生命周期管理<ul><li><strong><code>create</code></strong></li><li><strong><code>run</code></strong></li><li><strong><code>start/stop/restart</code></strong></li><li><strong><code>pause/unpause</code></strong></li><li><strong><code>exec</code></strong></li><li><strong><code>rm</code></strong></li><li><strong><code>kill</code></strong></li></ul></li></ul><ul><li><p>容器操作</p><ul><li><strong><code>ps</code></strong></li><li><strong><code>inspect</code></strong></li><li><strong><code>top</code></strong></li><li><strong><code>attach</code></strong></li><li><strong><code>events</code></strong></li><li><strong><code>logs</code></strong></li><li><strong><code>wait</code></strong></li><li><strong><code>export</code></strong></li><li><strong><code>port</code></strong></li></ul></li><li><p>容器rootfs命令</p><ul><li><strong><code>commit</code></strong></li><li><strong><code>cp</code></strong></li><li><strong><code>diff</code></strong></li></ul></li><li><p>镜像仓库</p><ul><li><strong><code>login</code></strong></li><li><strong><code>pull</code></strong></li><li><strong><code>push</code></strong></li><li><strong><code>search</code></strong></li></ul></li><li><p>本地镜像管理</p><ul><li><strong><code>images</code></strong></li><li><strong><code>rmi</code></strong></li><li><strong><code>tag</code></strong></li><li><strong><code>build</code></strong></li><li><strong><code>history</code></strong></li><li><strong><code>save</code></strong></li><li><strong><code>import</code></strong></li></ul></li><li><p>信息</p><ul><li><strong><code>info</code></strong></li><li><strong><code>version</code></strong></li></ul></li></ul><ul><li>查看容器重启次数<ul><li>docker inspect -f “ .RestartCount “ container_id</li></ul></li><li>查看容器最后一次的启动时间<ul><li>docker inspect -f “ .State.StartedAt ” container_id</li></ul></li><li>commit一个镜像<ul><li>docker run –name=”python_env_l” -it image_name /bin/bash</li><li>docker commit -m=”msg” -a=”user_name” 4631e1627784 image_name:2.1</li><li>docker tag  image_name:2.1 image_name:latest</li><li>docker push image_name</li></ul></li><li>Docker构建镜像<ul><li>docker build -t imageName .</li></ul></li><li>打标签<ul><li>Docker tag image user/newName:tag</li></ul></li><li>批量删除无用镜像<ul><li>docker image rm <code>docker images|grep none|awk {&#39;print $3&#39;}</code></li></ul></li><li>批量删除无用容器<ul><li>sudo docker rm <code>sudo docker ps -a |grep Exited| awk {&#39;print $1&#39;}</code></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/frontend/html.html"/>
      <url>man/frontend/html.html</url>
      
        <content type="html"><![CDATA[<p>HTML Basic Document</p><!DOCTYPE html><html><head><title>Title of document goes here</title><link rel="stylesheet" href="/css/prism-duotone-dark.css" type="text/css"></head><body>Visible text goes here...</body></html>Basic Tags<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Largest Heading<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>Smallest Heading<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br></pre></td></tr></table></figure><p>This is a paragraph.</p><p> (line break)</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> (horizontal rule)</span><br><span class="line"><span class="comment">&lt;!-- This is a comment --&gt;</span></span><br><span class="line">Formatting</span><br></pre></td></tr></table></figure><p><b>Bold text</b><br><code>Computer code</code><br><em>Emphasized text</em><br><i>Italic text</i><br><kbd>Keyboard input</kbd></p><pre>Preformatted text</pre><p><small>Smaller text</small><br><strong>Important text</strong></p><p><abbr> (abbreviation)</p><address> (contact information)<bdo> (text direction)<blockquote> (a section quoted from another source)<cite> (title of a work)<del> (deleted text)<ins> (inserted text)<sub> (subscripted text)<sup> (superscripted text)LinksOrdinary link: <a href="http://www.example.com/" target="_blank" rel="noopener">Link-text goes here</a>Image-link: <a href="http://www.example.com/" target="_blank" rel="noopener"><img data-src="URL" alt="Alternate Text"></a>Mailto link: <a href="mailto:webmaster@example.com">Send e-mail</a>Bookmark:<a id="tips">Tips Section</a><a href="#tips">Jump to the Tips Section</a>Images<img data-src="URL" alt="Alternate Text" height="42" width="42">Styles/Sections<style type="text/css">  h1 {color:red;}  p {color:blue;}</style><div>A block-level section in a document</div><span>An inline section in a document</span>Unordered list<ul>  <li>Item</li>  <li>Item</li></ul>Ordered list<ol>  <li>First item</li>  <li>Second item</li></ol>Definition list<dl>  <dt>Item 1</dt>    <dd>Describe item 1</dd>  <dt>Item 2</dt>    <dd>Describe item 2</dd></dl>Tables<table border="1">  <tr>    <th>table header</th>    <th>table header</th>  </tr>  <tr>    <td>table data</td>    <td>table data</td>  </tr></table>Iframe<iframe src="demo_iframe.htm"></iframe>Forms<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"demo_form.asp"</span> <span class="attr">method</span>=<span class="string">"post/get"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"email"</span> <span class="attr">size</span>=<span class="string">"40"</span> <span class="attr">maxlength</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">checked</span>=<span class="string">"checked"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Send"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"reset"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>Apples<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">"selected"</span>&gt;</span>Bananas<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>Cherries<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">"comment"</span> <span class="attr">rows</span>=<span class="string">"60"</span> <span class="attr">cols</span>=<span class="string">"20"</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/frontend/es6%E6%A6%82%E8%A7%88.html"/>
      <url>man/frontend/es6%E6%A6%82%E8%A7%88.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h3><blockquote><p>新增两个关键字：let、const</p></blockquote><ul><li><p>let与var的区别</p><pre><code>- 作用域不同()- 变量是否可以提升不</code></pre></li><li><p>contst：只读不可改，声明即赋值</p><pre><code>其所声明的对象的属性是可以改变的。</code></pre></li></ul><h3 id="二、箭头函数"><a href="#二、箭头函数" class="headerlink" title="二、箭头函数"></a>二、箭头函数</h3><h3 id="三、字符串"><a href="#三、字符串" class="headerlink" title="三、字符串"></a>三、字符串</h3><ul><li><p>模版字符串(``)</p></li><li><p>新增几个方法</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="string">'my string'</span>.startsWith(<span class="string">'my'</span>); <span class="comment">//true</span></span><br><span class="line"><span class="string">'my string'</span>.endsWith(<span class="string">'my'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="string">'my string'</span>.includes(<span class="string">'str'</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">'my '</span>.repeat(<span class="number">3</span>); <span class="comment">// 'my my my '</span></span><br></pre></td></tr></table></figure><h3 id="四、数组"><a href="#四、数组" class="headerlink" title="四、数组"></a>四、数组</h3><blockquote><p> Array 对象增加了一些新的静态方法，Array 原型上也增加了一些新方法</p></blockquote><ul><li><p>from 从类数组和可遍历对象中创建 Array 的实例</p></li><li><p>find  返回回调返回 true 的第一个元素。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[9, 2, 10, 8].find(n &#x3D;&gt; n &#x3D;&#x3D;&#x3D; 10) &#x2F;&#x2F; 10</span><br></pre></td></tr></table></figure><ul><li>findIndex  返回回调函数返回 true的第一个元素的下标。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[5, 1, 10, 8].findIndex(n &#x3D;&gt; n &#x3D;&#x3D;&#x3D; 10) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure><ul><li>fill  用所给参数“覆盖”数组的元素。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[0, 0, 0].fill(7) &#x2F;&#x2F; [7, 7, 7]</span><br><span class="line">[0, 0, 0, 0, 0].fill(7, 1, 3) &#x2F;&#x2F; [0, 7, 7, 7, 0]</span><br></pre></td></tr></table></figure><h3 id="五、新增Map和Set结构"><a href="#五、新增Map和Set结构" class="headerlink" title="五、新增Map和Set结构"></a>五、新增Map和Set结构</h3><h3 id="六、Math新增几个方法"><a href="#六、Math新增几个方法" class="headerlink" title="六、Math新增几个方法"></a>六、Math新增几个方法</h3><ul><li><p>Math.sign 返回数字的符号，结果为 1、-1 或 0。</p></li><li><p>Math.trunc 返回无小数位的数字</p></li><li><p>Math.cbrt 返回数字的立方根。</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Math.sign(5); &#x2F;&#x2F; 1</span><br><span class="line">Math.sign(-9); &#x2F;&#x2F; -1</span><br><span class="line"></span><br><span class="line">Math.trunc(5.9); &#x2F;&#x2F; 5</span><br><span class="line">Math.trunc(5.123); &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">Math.cbrt(64); &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure><h3 id="七、扩展运算符-…"><a href="#七、扩展运算符-…" class="headerlink" title="七、扩展运算符(…)"></a>七、扩展运算符(…)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let values &#x3D; [1, 2, 4];</span><br><span class="line">let some &#x3D; [...values, 8]; &#x2F;&#x2F; [1, 2, 4, 8]</span><br><span class="line">let more &#x3D; [...values, 8, ...values]; &#x2F;&#x2F; [1, 2, 4, 8, 1, 2, 4]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 equivalent:</span><br><span class="line">let values &#x3D; [1, 2, 4];</span><br><span class="line">&#x2F;&#x2F; Iterate, push, sweat, repeat...</span><br><span class="line">&#x2F;&#x2F; Iterate, push, sweat, repeat...</span><br></pre></td></tr></table></figure><p>扩展语法在传参数调用函数时也非常有用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let values &#x3D; [1, 2, 4];</span><br><span class="line"></span><br><span class="line">doSomething(...values);</span><br><span class="line"></span><br><span class="line">function doSomething(x, y, z) &#123;</span><br><span class="line">   &#x2F;&#x2F; x &#x3D; 1, y &#x3D; 2, z &#x3D; 4</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 equivalent:</span><br><span class="line">doSomething.apply(null, values);</span><br></pre></td></tr></table></figure><h3 id="八、解构赋值"><a href="#八、解构赋值" class="headerlink" title="八、解构赋值"></a>八、解构赋值</h3><ul><li><p>1.解构赋值可以是数组、对象、复合结构</p></li><li><p>2.数组是按照顺序；对象是按照键，必须一致，也可以起别名，但对应但键就不会有值</p></li><li><p>3.可以作为参数对象结构</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">let [x, y] &#x3D; [1, 2]; &#x2F;&#x2F; x &#x3D; 1, y &#x3D; 2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; ES5 equivalent:</span><br><span class="line">var arr &#x3D; [1, 2];</span><br><span class="line">var x &#x3D; arr[0];</span><br><span class="line">var y &#x3D; arr[1];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;使用这个语法，可以一次性给多个变量赋值。一个很好的附加用处是可以很简单地交换变量值：</span><br><span class="line">let x &#x3D; 1,</span><br><span class="line">    y &#x3D; 2;</span><br><span class="line"></span><br><span class="line">[x, y] &#x3D; [y, x]; &#x2F;&#x2F; x &#x3D; 2, y &#x3D; 1</span><br><span class="line">&#x2F;&#x2F;解构也可以用于对象。注意对象中必须存在对应的键：</span><br><span class="line">let obj &#x3D; &#123;x: 1, y: 2&#125;;</span><br><span class="line">let &#123;x, y&#125; &#x3D; obj; &#x2F;&#x2F; x &#x3D; 1, y &#x3D; 2</span><br><span class="line">&#x2F;&#x2F;你也可以使用该机制来修改变量名：</span><br><span class="line">let obj &#x3D; &#123;x: 1, y: 2&#125;;</span><br><span class="line">let &#123;x: a, y: b&#125; &#x3D; obj; &#x2F;&#x2F; a &#x3D; 1, b &#x3D; 2</span><br><span class="line">&#x2F;&#x2F;另一个有趣的模式是模拟多个返回值：</span><br><span class="line">function doSomething() &#123;</span><br><span class="line">   return [1, 2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let [x, y] &#x3D; doSomething(); &#x2F;&#x2F; x &#x3D; 1, y &#x3D; 2</span><br><span class="line">&#x2F;&#x2F;解构可以用来为参数对象赋默认值。通过对象字面量，可以模拟命名参数：</span><br><span class="line">function doSomething(&#123;y &#x3D; 1, z &#x3D; 0&#125;) &#123;</span><br><span class="line">   console.log(y, z);</span><br><span class="line">&#125;</span><br><span class="line">doSomething(&#123;y: 2&#125;);</span><br></pre></td></tr></table></figure><h3 id="九、参数"><a href="#九、参数" class="headerlink" title="九、参数"></a>九、参数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&#x2F;&#x2F;可以设置默认参数</span><br><span class="line">function doSomething(x, y &#x3D; 2) &#123;</span><br><span class="line">   return x * y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">doSomething(5); &#x2F;&#x2F; 10</span><br><span class="line">doSomething(5, undefined); &#x2F;&#x2F; 10</span><br><span class="line">doSomething(5, 3); &#x2F;&#x2F; 15</span><br><span class="line">&#x2F;&#x2F;看起来很简洁，对吧？ 我肯定你之前在 ES5 中曾经需要给某些参数赋默认值：</span><br><span class="line">function doSomething(x, y) &#123;</span><br><span class="line">   y &#x3D; y &#x3D;&#x3D;&#x3D; undefined ? 2 : y;</span><br><span class="line">   return x * y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十、模块"><a href="#十、模块" class="headerlink" title="十、模块"></a>十、模块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">类的创建围绕 class 和 constructor 关键词。以下是个简短的示例：</span><br><span class="line">class Vehicle &#123;</span><br><span class="line">   constructor(name) &#123;</span><br><span class="line">      this.name &#x3D; name;</span><br><span class="line">      this.kind &#x3D; &#39;vehicle&#39;;</span><br><span class="line">   &#125;</span><br><span class="line">   getName() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Create an instance</span><br><span class="line">let myVehicle &#x3D; new Vehicle(&#39;rocky&#39;);</span><br></pre></td></tr></table></figure><p>注意类的定义不是一般的对象，因此，类的成员间没有逗号。<br>创造一个类的对象时，需要使用 new 关键词。继承一个基类时，使用 extends：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">class Car extends Vehicle &#123;</span><br><span class="line">   constructor(name) &#123;</span><br><span class="line">      super(name);</span><br><span class="line">      this.kind &#x3D; &#39;car&#39;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let myCar &#x3D; new Car(&#39;bumpy&#39;);</span><br><span class="line"></span><br><span class="line">myCar.getName(); &#x2F;&#x2F; &#39;bumpy&#39;</span><br><span class="line">myCar instanceof Car; &#x2F;&#x2F; true</span><br><span class="line">myCar instanceof Vehicle; &#x2F;&#x2F;true</span><br></pre></td></tr></table></figure><p>从衍生类中，你可以使用从任何构造函数或方法中使用 super 来获取它的基类：</p><blockquote><p>使用 super() 调用父类构造函数。<br>调用其它成员，举个例子，使用 super.getName() 。</p></blockquote><h3 id="十二、记号"><a href="#十二、记号" class="headerlink" title="十二、记号"></a>十二、记号</h3><blockquote><p>记号是一个新的原生数据类型，像 Number 和 String 一样。你可以使用记号为对象属性创建唯一标识或创建唯一的常量。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const MY_CONSTANT &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;&#125;;</span><br><span class="line">obj[MY_CONSTANT] &#x3D; 1;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;记号与 const 配合很合适，因为它们都有不可改变的特性。</span><br><span class="line">const CHINESE &#x3D; Symbol();</span><br><span class="line">const ENGLISH &#x3D; Symbol();</span><br><span class="line">const SPANISH &#x3D; Symbol();</span><br><span class="line"></span><br><span class="line">switch(language) &#123;</span><br><span class="line">   case CHINESE:</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">      break;</span><br><span class="line">   case ENGLISH:</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">      break;</span><br><span class="line">   case SPANISH:</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">      break;</span><br><span class="line">   default:</span><br><span class="line">      &#x2F;&#x2F;</span><br><span class="line">      break;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;你可以为 symbol 添加描述。虽然不可以通过描述获取 symbol，但是可用于代码调试。</span><br><span class="line">const CONST_1 &#x3D; Symbol(&#39;my symbol&#39;);</span><br><span class="line">const CONST_2 &#x3D; Symbol(&#39;my symbol&#39;);</span><br><span class="line"></span><br><span class="line">typeof CONST_1 &#x3D;&#x3D;&#x3D; &#39;symbol&#39;; &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">CONST_1 &#x3D;&#x3D;&#x3D; CONST_2; &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/frontend/vue.html"/>
      <url>man/frontend/vue.html</url>
      
        <content type="html"><![CDATA[<h1 id="vue文档"><a href="#vue文档" class="headerlink" title="vue文档"></a>vue文档</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-23 11:53:35</li></ul><ul><li><p>组建样式渲染问题</p><ul><li>scoped是必不可少的, 但是我写了这个样式为何无法生效? 原因很简单, 因为当前样式仅适用于当前Vue模板的, 而模板中引入的其他组件其实是无法被渲染的.</li></ul></li><li><p>如何去掉路由的#号</p><ul><li>vue的route设置 mode: ‘history’,</li></ul></li></ul><h2 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h2><p>1、Vuetify<br>Star 数为 11K，提供了 80 多个 Vue.js 组件，这些组件是根据谷歌 Material Design 指南实现的。Vuetify 支持所有平台上的浏览器，包括 IE11 和 Safari 9+（使用 polyfill），并提供了 8 个 vue-cli 模板。<br>地址： <a href="https://github.com/vuetifyjs/vuetify" target="_blank" rel="noopener">https://github.com/vuetifyjs/vuetify</a><br>2、Quasar<br>Star 数超过 6K，是构建 Vue.js 响应式网站、PWA、混合移动应用和 Electron 应用的流行框架。Quasar 还支持诸如 HTML/CSS/JS 压缩、缓存清除、摇树优化（tree shaking）、源映射、代码分割和延迟加载、ES6 转码等功能。<br>地址：<a href="https://github.com/quasarframework/quasar" target="_blank" rel="noopener">https://github.com/quasarframework/quasar</a><br>3、Element<br>Star 数将近 28K，是一款面向 Web 的 Vue.js 2.0 UI 工具包。它拥有一个强大的社区和 350 个贡献者，提供了丰富的可定制组件，以及完整的样式指南和更多的资源。 地址：<a href="https://github.com/ElemeFE/element" target="_blank" rel="noopener">https://github.com/ElemeFE/element</a><br>4、Vue Material<br>Star 数差不多 6K，是一个实了谷歌 Material Design 的简单库。该库还提供了一个 webpack 样板、用于 Nuxt.js 的 SSR 模板和一个单独的 HTML 文件（通过这个文件开始使用框架）。这里有一些入门的例子<a href="https://codesandbox.io/s/github/vuematerial/examples/tree/master/examples/quick-start。" target="_blank" rel="noopener">https://codesandbox.io/s/github/vuematerial/examples/tree/master/examples/quick-start。</a><br>地址： <a href="https://github.com/vuematerial/vue-material" target="_blank" rel="noopener">https://github.com/vuematerial/vue-material</a><br>5、Keen-UI<br>Star 数将近 3.5 K，一组 Vue 组件的集合，在设计上受到了谷歌 Material Design 的启发。Keen-UI 并不是一个 CSS 框架，它不包含网格系统、排版样式等。相反，它关注的是基于 Javascript 的交互式组件。<br>地址：<a href="https://github.com/JosephusPaye/Keen-UI" target="_blank" rel="noopener">https://github.com/JosephusPaye/Keen-UI</a><br>6、Buefy<br>Star 数 3K 左右，基于 Bulma（<a href="https://bulma.io）提供了一组轻量级的" target="_blank" rel="noopener">https://bulma.io）提供了一组轻量级的</a> UI 组件。Vue.js 和 Bulma 是这个库唯一的两个内部依赖。它的大小约为 60KB（压缩后的大小，并且包含了 Bulma）。你可以查看实时文档网站（<a href="https://buefy.github.io/#/documentation/start）并在" target="_blank" rel="noopener">https://buefy.github.io/#/documentation/start）并在</a> Codepen 上运行代码。<br>地址： <a href="https://github.com/buefy/buefy" target="_blank" rel="noopener">https://github.com/buefy/buefy</a><br>7、Bootstrap Vue<br>Star 数超过 5K，为 Vue.js 提供了 Bootstrap 4 组件和网格系统的实现，并提供了自动 WAI-ARIA 可访问性标记。<br>地址： <a href="https://github.com/bootstrap-vue/bootstrap-vue" target="_blank" rel="noopener">https://github.com/bootstrap-vue/bootstrap-vue</a><br>8、Muse-UI<br>Star 数超过 6K，是另一个 Vue 2.0 MD 库，提供了 40 多个 UI 组件和可定制主题。文档主要使用中文撰写，不过大多数组件是自解释的，文档只起到辅助作用。该项目在积极的开发和维护当中。 地址：<a href="https://github.com/museui/muse-ui" target="_blank" rel="noopener">https://github.com/museui/muse-ui</a><br>9、AT-UI<br>Star 数接近 1.5 K，一个模块化的前端 UI 框架，用于开发基于 Vue.js 的 Web 界面，适用于桌面应用程序。它提供了 NPM+Webpack+Babel 的前端开发工作流和独立的 CSS 样式，值得一试。<br>地址： <a href="https://github.com/at-ui/at-ui" target="_blank" rel="noopener">https://github.com/at-ui/at-ui</a><br>10、Vux<br>Star 数超过 13K，是一个流行的社区库，基于 WeUI 和 Vue 2.0。该库还支持 webpack+vue-loader+vux 的工作流。它的文档也是中文的。<br>地址： <a href="https://github.com/airyland/vux" target="_blank" rel="noopener">https://github.com/airyland/vux</a><br>11、iView<br>Star 数将近 16K，提供了数十种用 Vue.js 构建的 UI 组件和小部件，并采用了干净而优雅的设计。iView 被广泛采用，社区也在积极维护，并提供了 CLI 工具用于以可视化的方式创建项目。这个也值得一试。<br>地址： <a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a><br>12、Uiv<br>Star 数“仅”550 左右，用于 Vue 2 的 Bootstrap 3 组件库。所有组件加起来差不多 20KB，唯一的外部依赖是 Vue 和 Bootstrap CSS，支持基于 Webpack 的工作流。 地址：<a href="https://github.com/wxsms/uiv" target="_blank" rel="noopener">https://github.com/wxsms/uiv</a><br>13、Vuikit<br>Star 数 1K 左右，一个用于网站界面的响应式的 Vue UI 库，设计风格干净而统一。该库作为由 Yarn 工作区管理的“monorepo”而构建，但图标和主题可作为单独的包发布。<br>地址： <a href="https://github.com/vuikit/vuikit" target="_blank" rel="noopener">https://github.com/vuikit/vuikit</a><br>14、Onsen UI+Vue<br>基于流行的 Onsen-UI 框架，封装了核心 Web 组件并暴露了 Vue 风格的 API。Onsen UI 组件也被设计为能够主动对 prop 做出反应。<br>地址： <a href="https://onsen.io/v2/guide/vue/" target="_blank" rel="noopener">https://onsen.io/v2/guide/vue/</a><br>15、Semantic UI+Vue<br>这个项目基本上是 Semantic-UI 框架与 Vue.js 的集成。该库仍在开发当中，提供了一个类似于 Semantic-UI 的 API 以及一组可定制的主题。<br>地址： <a href="https://semantic-ui-vue.github.io/" target="_blank" rel="noopener">https://semantic-ui-vue.github.io/</a><br>16、Fish-UI<br>Star 数“仅”为 500 左右，贡献者也只有 3 个，但 fish-ui 提供了一个基于 Vue 的 Web 工具包，其中包含整洁干净的组件。该库支持 ES2015+Webpack 工作流。它的文档不是很全，但它的设计不容忽视。<br>地址： <a href="https://github.com/myliang/fish-ui" target="_blank" rel="noopener">https://github.com/myliang/fish-ui</a><br>17、Mint UI<br>Star 数超过 11K，为 Vue.js 提供 UI 元素，提供了用于构建移动应用程序的 CSS 和 JS 组件。当全部导入时，压缩后的代码只有月 30KB（JS+CSS），当然它也支持单个组件的导入。<br>地址： <a href="https://github.com/ElemeFE/mint-ui/" target="_blank" rel="noopener">https://github.com/ElemeFE/mint-ui/</a><br>18、Framework7 Vue<br>这个集成提供了几乎所有的 Framework7 元素和组件，并集成了 Framework7 Router，按照 Vue 的方式来渲染页面。该库正处于积极的开发和维护当中。 地址：<a href="https://framework7.io/vue/" target="_blank" rel="noopener">https://framework7.io/vue/</a><br>19、Cube UI<br>Star 数超过 3K，是用于 Vue.js 移动应用程序的 UI 组件库。所有组件都经过了单元测试，并且该库还支持按需进行后期编译和组件导入。这个库仍在积极开发中。<br>地址： <a href="https://github.com/didi/cube-ui" target="_blank" rel="noopener">https://github.com/didi/cube-ui</a><br>20、Vueblu<br>Star 数约 1.5K，是基于 Vue 2.0 和 Bulma 的 UI 组件库，用于构建中台和后台办公产品。它支持 ES2015 和 NPM+Webpack+Babel 工作流，并提供可自定义主题。<br>地址： <a href="https://github.com/chenz24/vue-blu" target="_blank" rel="noopener">https://github.com/chenz24/vue-blu</a><br>21、Ant Design Vue<br>Star 数约 1.5K，用于开发具有数十个 Ant Design 实现组件的企业级后端产品，并支持基于 Webpack 调试的构建解决方案（支持 ES6）。请注意，它的开发已经停止了一段时间。<br>地址： <a href="https://github.com/okoala/vue-antd" target="_blank" rel="noopener">https://github.com/okoala/vue-antd</a><br>特别推荐<br>n3-components ：<br><a href="https://github.com/N3-components/N3-components" target="_blank" rel="noopener">https://github.com/N3-components/N3-components</a><br>vuikit：<br><a href="https://vuikit.js.org/" target="_blank" rel="noopener">https://vuikit.js.org/</a><br>Kendu UI Vue<br><a href="https://www.telerik.com/kendo-vue-ui" target="_blank" rel="noopener">https://www.telerik.com/kendo-vue-ui</a><br>Office Fabric-Vue<br><a href="https://github.com/aidewoode/office-ui-fabric-vue" target="_blank" rel="noopener">https://github.com/aidewoode/office-ui-fabric-vue</a><br>vuestrap<br><a href="http://kzima.github.io/vuestrap-base-components/#/" target="_blank" rel="noopener">http://kzima.github.io/vuestrap-base-components/#/</a><br>vueboot<br><a href="http://morgul.github.io/vueboot/" target="_blank" rel="noopener">http://morgul.github.io/vueboot/</a><br>framevuerk<br><a href="http://framevuerk.com/" target="_blank" rel="noopener">http://framevuerk.com/</a><br>Vue WeUI<br><a href="http://aidenzou.github.io/vue-weui/#!/" target="_blank" rel="noopener">http://aidenzou.github.io/vue-weui/#!/</a><br>Vue-MDC<br><a href="https://github.com/posva/vue-mdc" target="_blank" rel="noopener">https://github.com/posva/vue-mdc</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="man/git/commands.html"/>
      <url>man/git/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li><strong><code>git init</code></strong>                                #git 初始化仓库</li><li><strong><code>git clone remote_url</code></strong>                    #git 克隆远程库</li><li><strong><code>git add .</code></strong>                               #git  添加所有文件</li><li><strong><code>git commit -m &quot;批注&quot;</code></strong>                     #git 提交</li><li><strong><code>git push &lt;remoteName&gt; &lt;localName&gt;</code></strong>       #git推送至远程</li><li><strong><code>git remote add origin &lt;server&gt;</code></strong>          #远程没有创建仓库，将本地推送到远程仓库</li><li><strong><code>git checkout -b branch_name</code></strong>             #创建分支，并切换到分支</li><li><strong><code>git checkout master</code></strong>                     #切换到主分支</li><li><strong><code>git branch -d &lt;branch_name&gt;</code></strong>             #删除分支</li><li><strong><code>git pull &lt;remoteName&gt; &lt;localName&gt;</code></strong>        #将本地仓库更新至最新</li><li><strong><code>git merge branch_name</code></strong>                    #将其他分支合并到本地主分支</li><li><strong><code>git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</code></strong> #比对分支</li><li><strong><code>git tag &lt;tag_name&gt;</code></strong>                      #创建标签</li><li><strong><code>git show</code></strong></li><li><strong><code>git status</code></strong>                              #查看当前状态</li><li><strong><code>git fetch</code></strong>                               #合并</li><li><strong><code>git config --list</code></strong>                       #查看配置信息</li><li><strong><code>git rm &lt;file_name&gt;</code></strong>                      #删除文件</li><li><strong><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code></strong>            #重命名文件</li><li><strong><code>git log</code></strong>                                 #查看日志</li><li><strong><code>git rebase HEAD &lt;file_name&gt;</code></strong>             #重置</li><li><strong><code>git remote -v</code></strong>                           #查看远程仓库</li><li><strong><code>git remote rm &lt;file_name&gt;</code></strong>               #删除远程仓库</li><li><strong><code>git branch</code></strong>                              #查看本地分支</li><li><strong><code>git branch -r</code></strong>                           #查看远程分支</li><li><strong><code>git branch &lt;branch_name&gt;</code></strong>                #创建本地分支</li><li><strong><code>git config --global user.name NEWNAME</code></strong>   #修改用户名</li><li><strong><code>git config --global user.email NEWEMAIL</code></strong> #修改用户邮箱</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/hadoop/hdfs.html"/>
      <url>man/hadoop/hdfs.html</url>
      
        <content type="html"><![CDATA[<h1 id="hdfs操作"><a href="#hdfs操作" class="headerlink" title="hdfs操作"></a>hdfs操作</h1><p>1.列出HDFS文件<br>hdfs dfs -ls <path></p><p>2.上传文件到hdfs<br>hdfs dfs -put <local file> <hdfs file></p><p>example:<br> hdfs dfs -put test1 /input/test<br> 把当前本地目录下的test1文件上传到HDFS /input目录下，并命名为test</p><p>3.将HDFS中的文件复制到本地系统中<br>hdfs dfs -get <hdfs file> <local file or dir></p><p>local file不能和 hdfs file名字不能相同，否则会提示文件已存在，没有重名的文件会复制到本地</p><p>hdfs dfs -get <hdfs file or dir> … <local  dir></p><p>拷贝多个文件或目录到本地时，本地要为文件夹路径</p><p>4.删除文件<br>hdfs dfs -rm <hdfs file><br>hdfs dfs -rm -r <hdfs dir></p><p>5.查看HDFS下的某个文件<br>hdfs dfs -cat <hdfs file></p><p>6.创建HDFS目录<br>hdfs dfs -mkdir <hdfs path></p><p>只能一级一级的建目录，父目录不存在的话使用这个命令会报错</p><p>hdfs dfs -mkdir -p <hdfs path></p><p>所创建的目录如果父目录不存在就创建该父目录</p><p>7.复制文件<br>hdfs dfs -cp  <hdfs file>  <hdfs file></p><p>8.移动文件<br>hdfs dfs -mv <hdfs file>  <hdfs file></p><p>当两个文件的父路径相同时，　作用相当于文件重命名</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/kubernetes/commands.html"/>
      <url>man/kubernetes/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>查看所有资源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure></li><li><p>获取所有的服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure></li><li><p>获取所有的pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure></li><li><p>集群部署生成服务</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f &lt;app-yaml-name&gt;.yaml</span><br></pre></td></tr></table></figure></li><li><p>集群删除一个pod</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure></li><li><p>查看pod详情</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/kubernetes/basic.html"/>
      <url>man/kubernetes/basic.html</url>
      
        <content type="html"><![CDATA[<ul><li>yaml基本文件格式<ul><li>kind类型：pod、deployment、job、service</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">—--</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">rss-site</span></span><br><span class="line"> <span class="attr">labels:</span></span><br><span class="line">   <span class="attr">app:</span> <span class="string">web</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"> <span class="attr">containers:</span></span><br><span class="line">   <span class="string">–</span> <span class="attr">name:</span> <span class="string">front-end</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="string">–</span> <span class="attr">containerPort:</span> <span class="number">80</span></span><br><span class="line">   <span class="string">–</span> <span class="attr">name:</span> <span class="string">rss-reader</span></span><br><span class="line">     <span class="attr">image:</span> <span class="string">nickchase/rss-php-nginx:v1</span></span><br><span class="line">     <span class="attr">ports:</span></span><br><span class="line">       <span class="string">–</span> <span class="attr">containerPort:</span> <span class="number">88</span></span><br></pre></td></tr></table></figure><ul><li>container属性值<ul><li>name</li><li>image</li><li>command</li><li>args</li><li>workingDir</li><li>ports</li><li>env</li><li>resources</li><li>volumeMounts</li><li>livenessProbe</li><li>readinessProbe</li><li>lifecycle</li><li>terminationMessagePath</li><li>imagePullPolicy</li><li>securityContext</li><li>stdin</li><li>stdinOnce</li><li>tty</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>linux终端命令</title>
      <link href="man/linux/commands.html"/>
      <url>man/linux/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li>autojump</li><li><ul><li>自动跳转文件夹，不用cd</li></ul></li><li>tree</li><li><ul><li>以树状图列出当前目录结构</li></ul></li><li>you-get</li><li><ul><li>视频下载</li></ul></li><li>tldr</li><li><ul><li>命令示例文档</li></ul></li><li>htop</li><li><ul><li>更强大的top</li></ul></li><li>git</li><li><ul><li>版本控制工具</li></ul></li><li>vim</li><li><ul><li>编辑器</li></ul></li><li>tmux</li><li><ul><li>终端复用神器</li></ul></li><li>thefuck<ul><li>命令出错自动完善</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6.html"/>
      <url>man/linux/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6.html</url>
      
        <content type="html"><![CDATA[<p>9 8 7 6 5 4 3 2 1 0</p><ul><li>r w x r - x r - x</li></ul><ul><li><p>第9位表示文件类型,可以为p、d、l、s、c、b和-：</p><ul><li>p表示命名管道文件</li><li>d表示目录文件</li><li>l表示符号连接文件</li><li>-表示普通文件</li><li>s表示socket文件</li><li>c表示字符设备文件</li><li>b表示块设备文件</li></ul></li><li><p>第8-6位、5-3位、2-0位分别表示文件所有者的权限，同组用户的权限，其他用户的权限，其形式为rwx：</p><ul><li>r表示可读，可以读出文件的内容</li><li>w表示可写，可以修改文件的内容</li><li>x表示可执行，可运行这个程序</li><li>没有权限的位置用-表示</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>crontab表示法</title>
      <link href="man/linux/crontab.html"/>
      <url>man/linux/crontab.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>crontab是linux上的定时任务工具，用来做定时管理服务。其常用的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l <span class="comment"># 罗列出当前用户的所有定时任务列表</span></span><br><span class="line">crontab -e <span class="comment"># 编辑定时任务</span></span><br><span class="line">crontab -r <span class="comment"># 删除定时任务</span></span><br></pre></td></tr></table></figure><p>当然，最重要的还是如何使用cron来表示什么时候什么频次来执行任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *  * *  *   <span class="built_in">command</span></span><br><span class="line">分 时 日 月 周   命令</span><br></pre></td></tr></table></figure><a id="more"></a><p>如上表示，有5个位置符来表示，后边跟需要执行的命令。</p><ul><li>第一列：分(0-59)</li><li>第二列：时(0-23)</li><li>第三列：日(1-31)</li><li>第四列：月(1-12)</li><li>第五列：周(0-6,0为星期天)</li></ul><p>除了以上的表示方法，还可以结合一些特殊的符号来表示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* ：   表示任何时刻</span><br><span class="line">, ：   表示在这几个选项内</span><br><span class="line">－ ：  表示一个范围，如第二列里： 3-5，就表示3到5点</span><br><span class="line">/n ：  表示每个n的单位执行一次，如第二列里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.</span><br></pre></td></tr></table></figure><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* * * * *                           每分钟执行一次</span><br><span class="line">0 */1 * * *                         每分钟执行一次</span><br><span class="line">43 21 * * *                         21:43 执行</span><br><span class="line">15 05 * * *                         05:15 执行</span><br><span class="line">0 17 * * *                          17:00 执行</span><br><span class="line">0 17 * * 1                          每周一的 17:00 执行</span><br><span class="line">0,10 17 * * 0,2,3                   每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="line">0-10 17 1 * *                       毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="line">0 0 1,15 * 1                        毎月1日和 15日和 一日的 0:00 执行</span><br><span class="line">42 4 1 * *                          毎月1日的 4:42分 执行</span><br><span class="line">0 21 * * 1-6                        周一到周六 21:00 执行</span><br><span class="line">0,10,20,30,40,50 * * * *            每隔10分 执行</span><br><span class="line">*/10 * * * *                        每隔10分 执行</span><br><span class="line">* 1 * * *                           从1:0到1:59 每隔1分钟 执行</span><br><span class="line">0 1 * * *                           1:00 执行</span><br><span class="line">0 * * * *                           毎时0分 每隔1小时 执行</span><br><span class="line">2 8-20/3 * * *                      8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="line">30 5 1,15 * *                       1日 和 15日的 5:30 执行</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql架构介绍</title>
      <link href="man/mysql/basic.html"/>
      <url>man/mysql/basic.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql编码</title>
      <link href="man/mysql/character.html"/>
      <url>man/mysql/character.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html"/>
      <url>man/linux/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<p>一、x进程控制：<br>fork创建一个新进程<br>clone按指定条件创建子进程<br>execve运行可执行文件<br>exit中止进程<br>_exit立即中止当前进程<br>getdtablesize进程所能打开的最大文件数<br>getpgid获取指定进程组标识号<br>setpgid设置指定进程组标志号<br>getpgrp获取当前进程组标识号<br>setpgrp设置当前进程组标志号<br>getpid获取进程标识号<br>getppid获取父进程标识号<br>getpriority获取调度优先级<br>setpriority设置调度优先级<br>modify_ldt读写进程的本地描述表<br>nanosleep使进程睡眠指定的时间<br>nice改变分时进程的优先级<br>pause挂起进程，等待信号<br>personality设置进程运行域<br>prctl对进程进行特定操作<br>ptrace进程跟踪<br>sched_get_priority_max取得静态优先级的上限<br>sched_get_priority_min取得静态优先级的下限<br>sched_getparam取得进程的调度参数<br>sched_getscheduler取得指定进程的调度策略<br>sched_rr_get_interval取得按RR算法调度的实时进程的时间片长度<br>sched_setparam设置进程的调度参数<br>sched_setscheduler设置指定进程的调度策略和参数<br>sched_yield进程主动让出处理器,并将自己等候调度队列队尾vfork创建一个子进程，以供执行新程序，常与execve等同时使用<br>wait等待子进程终止<br>wait3参见wait<br>waitpid等待指定子进程终止<br>wait4参见waitpid<br>capget获取进程权限<br>capset设置进程权限<br>getsid获取会晤标识号<br>setsid设置会晤标识号</p><p>二、文件系统控制<br>1、文件读写操作<br>fcntl文件控制<br>open打开文件<br>creat创建新文件<br>close关闭文件描述字<br>read读文件<br>write写文件<br>readv从文件读入数据到缓冲数组中<br>writev将缓冲数组里的数据写入文件<br>pread对文件随机读<br>pwrite对文件随机写<br>lseek移动文件指针<br>_llseek在64位地址空间里移动文件指针<br>dup复制已打开的文件描述字<br>dup2按指定条件复制文件描述字<br>flock文件加/解锁<br>pollI/O多路转换<br>truncate截断文件<br>ftruncate参见truncate<br>umask设置文件权限掩码<br>fsync把文件在内存中的部分写回磁盘<br>2、文件系统操作<br>access确定文件的可存取性<br>chdir改变当前工作目录<br>fchdir参见<br>chdirchmod改变文件方式<br>fchmod参见<br>chmodchown改变文件的属主或用户组<br>fchown参见chown<br>lchown参见chown<br>chroot改变根目录<br>stat取文件状态信息<br>lstat参见stat<br>fstat参见statstatfs取文件系统信息<br>fstatfs参见statfs<br>readdir读取目录项<br>getdents读取目录项<br>mkdir创建目录<br>mknod创建索引节点<br>rmdir删除目录<br>rename文件改名<br>link创建链接<br>symlink创建符号链接<br>unlink删除链接<br>readlink读符号链接的值<br>mount安装文件系统<br>umount卸下文件系统<br>ustat取文件系统信息<br>utime改变文件的访问修改时间<br>utimes参见utime<br>quotactl控制磁盘配额</p><p>三、系统控制<br>ioctlI/O总控制函数<br>_sysctl读/写系统参数<br>acct启用或禁止进程记账<br>getrlimit获取系统资源上限<br>setrlimit设置系统资源上限<br>getrusage获取系统资源使用情况<br>uselib选择要使用的二进制函数库<br>ioperm设置端口I/O权限<br>iopl改变进程I/O权限级别<br>outb低级端口操作<br>reboot重新启动<br>swapon打开交换文件和设备<br>swapoff关闭交换文件和设备<br>bdflush控制bdflush守护进程<br>sysfs取核心支持的文件系统类型<br>sysinfo取得系统信息<br>adjtimex调整系统时钟<br>alarm设置进程的闹钟<br>getitimer获取计时器值<br>setitimer设置计时器值<br>gettimeofday取时间和时区<br>settimeofday设置时间和时区<br>stime设置系统日期和时间<br>time取得系统时间<br>times取进程运行时间<br>uname获取当前UNIX系统的名称、版本和主机等信息<br>vhangup挂起当前终端<br>nfsservctl对NFS守护进程进行控制<br>vm86进入模拟8086模式<br>create_module创建可装载的模块项<br>delete_module删除可装载的模块项<br>init_module初始化模块<br>query_module查询模块信息<br>*get_kernel_syms取得核心符号,已被query_module代替</p><p>四、内存管理<br>brk改变数据段空间的分配<br>sbrk参见brkmlock内存页面加锁<br>munlock内存页面解锁<br>mlockall调用进程所有内存页面加锁<br>munlockall调用进程所有内存页面解锁<br>mmap映射虚拟内存页<br>munmap去除内存页映射<br>mremap重新映射虚拟内存地址<br>msync将映射内存中的数据写回磁盘<br>mprotect设置内存映像保护<br>getpagesize获取页面大小<br>sync将内存缓冲区数据写回硬盘<br>cacheflush将指定缓冲区中的内容写回磁盘</p><p>五、网络管理<br>getdomainname取域名<br>setdomainname设置域名<br>gethostid获取主机标识号<br>sethostid设置主机标识号<br>gethostname获取本主机名称<br>sethostname设置主机名称</p><p>六、socket控制<br>socketcallsocket系统调用<br>socket建立<br>socketbind绑定socket到端口<br>connect连接远程主机<br>accept响应socket连接请求<br>send通过socket发送信息<br>sendto发送UDP信息<br>sendmsg参见sendrecv通过socket接收信息<br>recvfrom接收UDP信息<br>recvmsg参见recvlisten监听socket端口<br>select对多路同步I/O进行轮询<br>shutdown关闭socket上的连接<br>getsockname取得本地socket名字<br>getpeername获取通信对方的socket名字<br>getsockopt取端口设置<br>setsockopt设置端口参数<br>sendfile在文件或端口间传输数据<br>socketpair创建一对已联接的无名socket</p><p>七、用户管理<br>getuid获取用户标识号<br>setuid设置用户标志号<br>getgid获取组标识号<br>setgid设置组标志号<br>getegid获取有效组标识号<br>setegid设置有效组标识号<br>geteuid获取有效用户标识号<br>seteuid设置有效用户标识号<br>setregid分别设置真实和有效的的组标识号<br>setreuid分别设置真实和有效的用户标识号<br>getresgid分别获取真实的,有效的和保存过的组标识号<br>setresgid分别设置真实的,有效的和保存过的组标识号<br>getresuid分别获取真实的,有效的和保存过的用户标识号<br>setresuid分别设置真实的,有效的和保存过的用户标识号<br>setfsgid设置文件系统检查时使用的组标识号<br>setfsuid设置文件系统检查时使用的用户标识号<br>getgroups获取后补组标志清单<br>setgroups设置后补组标志清单</p><p>八、进程间通信<br>ipc进程间通信总控制调用<br>1、信号<br>sigaction设置对指定信号的处理方法<br>sigprocmask根据参数对信号集中的信号执行阻塞/解除阻塞等操作<br>sigpending为指定的被阻塞信号设置队列<br>sigsuspend挂起进程等待特定信号<br>signal参见signalkill向进程或进程组发信号<br>*sigblock向被阻塞信号掩码中添加信号,已被sigprocmask代替<br>*siggetmask取得现有阻塞信号掩码,已被sigprocmask代替<br>*sigsetmask用给定信号掩码替换现有阻塞信号掩码,已被sigprocmask代替<br>*sigmask将给定的信号转化为掩码,已被sigprocmask代替<br>*sigpause作用同sigsuspend,已被sigsuspend代替<br>sigvec为兼容BSD而设的信号处理函数,作用类似sigactionssetmaskANSI C的信号处理函数,作用类似sigaction<br>2、消息<br>msgctl消息控制操作<br>msgget获取消息队列<br>msgsnd发消息<br>msgrcv取消息<br>3、管道<br>pipe创建管道<br>4、信号量<br>semctl信号量控制<br>semget获取一组信号量<br>semop信号量操作<br>5、共享内存<br>shmctl控制共享内存<br>shmget获取共享内存<br>shmat连接共享内存<br>shmdt拆卸共享内存</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql字段类型</title>
      <link href="man/mysql/column_type.html"/>
      <url>man/mysql/column_type.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>char</li><li>varchar</li><li>text</li></ul><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul><li>int</li><li>smallint</li><li>bigint</li></ul><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ul><li>json</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引介绍</title>
      <link href="man/mysql/indexed.html"/>
      <url>man/mysql/indexed.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常用手册</title>
      <link href="man/mysql/index.html"/>
      <url>man/mysql/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>1.<a href="basic.html">架构介绍</a></li><li>2.<a href="commands.html">常用命令</a></li><li>3.<a href="character.html">编码类型</a></li><li>4.<a href="column_type.html">字段类型</a></li><li>5.<a href="transaction.html">事务处理</a></li><li>6.<a href="indexed.html">索引介绍</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务</title>
      <link href="man/mysql/transaction.html"/>
      <url>man/mysql/transaction.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%95%B0%E6%8D%AE%E5%BA%93/nosql.html"/>
      <url>interview/%E6%95%B0%E6%8D%AE%E5%BA%93/nosql.html</url>
      
        <content type="html"><![CDATA[<h3 id="RDBMS-vs-NoSQL"><a href="#RDBMS-vs-NoSQL" class="headerlink" title="RDBMS vs NoSQL"></a>RDBMS vs NoSQL</h3><ul><li>RDBMS<ul><li>高度组织化结构化数据</li><li>结构化查询语言（SQL） (SQL)</li><li>数据和关系都存储在单独的表中。</li><li>数据操纵语言，数据定义语言</li><li>严格的一致性</li><li>基础事务</li></ul></li><li>NoSQL<ul><li>代表着不仅仅是SQL</li><li>没有声明性查询语言</li><li>没有预定义的模式</li><li>键 - 值对存储，列存储，文档存储，图形数据库</li><li>最终一致性，而非ACID属性</li><li>非结构化和不可预知的数据</li><li>CAP定理</li><li>高性能，高可用性和可伸缩性</li></ul></li></ul><h3 id="NoSQL的优点-缺点"><a href="#NoSQL的优点-缺点" class="headerlink" title="NoSQL的优点/缺点"></a>NoSQL的优点/缺点</h3><ul><li><p>优点:</p><ul><li>高可扩展性</li><li>分布式计算</li><li>低成本</li><li>架构的灵活性，半结构化数据</li><li>没有复杂的关系</li></ul></li><li><p>缺点:</p><ul><li>没有标准化</li><li>有限的查询功能（到目前为止）</li><li>最终一致是不直观的程序</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/net/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html"/>
      <url>man/net/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>osi七层协议，从上到下依次是：</p><ul><li>应用层</li><li>表示层</li><li>会话层</li><li>传输层</li><li>网络层</li><li>数据链路层</li><li>物理层</li></ul></li><li><p>应用层协议</p><ul><li>POP(3)(邮局协议第三个版本)</li><li>SSH(22)</li><li>FTP(21)</li><li>Telnet(23)</li><li>SMTP(25)</li><li>Http(80)</li><li>HTTPS(433)</li><li>DHCP(是用UDP协议工作)</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html"/>
      <url>man/php/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h3 id="mac配置"><a href="#mac配置" class="headerlink" title="mac配置"></a>mac配置</h3><ul><li>1.安装PHP</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install php</span><br></pre></td></tr></table></figure><ul><li>2.安装nginx</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure><ul><li>3.nginx配置php解析</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    server_name <span class="built_in">local</span>-pintu.corp.36kr.com;</span><br><span class="line"></span><br><span class="line">    error_log  /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/nginx/pintu_error.log debug;</span><br><span class="line">    access_log /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/nginx/pintu_access.log;</span><br><span class="line"></span><br><span class="line">    root /Users/zxc/www/pintu/public;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">       index index.php index.html;</span><br><span class="line">       try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php$ &#123;</span><br><span class="line">        fastcgi_param SCRIPT_FILENAME <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        fastcgi_index index.php;</span><br><span class="line">        fastcgi_pass var_fastcgi;</span><br><span class="line">        include fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~* \.(js|css|png|jpg|jpeg|gif|ico)$ &#123;</span><br><span class="line">        expires max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常用语句</title>
      <link href="man/mysql/commands.html"/>
      <url>man/mysql/commands.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、权限登录类"><a href="#一、权限登录类" class="headerlink" title="一、权限登录类"></a>一、权限登录类</h2><ul><li><p>1.授权用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授权用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某个用户的权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> username;</span><br></pre></td></tr></table></figure></li><li><p>2.远程连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.1.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure></li><li><p>3.导出数据库</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.1.1-P3306 -uroot -p db_name &gt; db_name.sql</span><br></pre></td></tr></table></figure></li><li><p>4.导入数据库</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p db_name &lt; db_name.sql</span><br></pre></td></tr></table></figure></li><li><p>5.分析查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>6.查询所有的进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> procelist;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> procelist;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、DDL"><a href="#二、DDL" class="headerlink" title="二、DDL"></a>二、DDL</h2><blockquote><p>数据库</p></blockquote><ul><li><p>1.建数据库语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>3.删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_name;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>表操作</p></blockquote><ul><li><p>2.创建数据表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_user`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC <span class="keyword">COMMENT</span>=<span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure></li><li><p>3.查看数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"><span class="comment">-- 查看表字段及描述</span></span><br><span class="line">desc table_name;</span><br></pre></td></tr></table></figure></li><li><p>4.查看字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>5.查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>6.删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表结构，表结构和数据全部删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>7.新增字段</p></li><li><p>8.修改字段</p></li><li><p>9.删除字段</p></li><li><p>10.添加索引</p></li><li><p>11.删除索引</p></li></ul><h2 id="三、DML"><a href="#三、DML" class="headerlink" title="三、DML"></a>三、DML</h2><ul><li><p>1.查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>2.新增</p></li><li><p>3.修改</p></li></ul><ul><li><p>4.删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全部删除数据，不删表结构。不做表优化</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件限制删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据，并优化表空间</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>5.重建引擎</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table table_name engine&#x3D;InnoDB</span><br></pre></td></tr></table></figure><h2 id="四、参数状态"><a href="#四、参数状态" class="headerlink" title="四、参数状态"></a>四、参数状态</h2><ul><li><p>1.查看参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span>;</span><br><span class="line"><span class="comment">-- 过滤参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sql%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>2.查看事件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">events</span>;</span><br></pre></td></tr></table></figure></li><li><p>3.查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure></li><li><p>4.查看所有状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>5.查看打开表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li><p>6.查看表状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在某个db下执行</span></span><br><span class="line"><span class="comment">-- 可以查看表的存储引擎，表空间，自增主键，创建和更新时间等</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>7.查看数据库状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看主库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- 查看从库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>8.查看函数状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">function</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>9.查看插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure></li><li><p>10.查看错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span>;</span><br></pre></td></tr></table></figure></li><li><p>11.查看存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure></li><li><p>12.查询数据存储空间</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(table_schema,<span class="string">'.'</span>,table_name) <span class="keyword">AS</span> <span class="string">'Table Name'</span>, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(table_rows/<span class="number">1000000</span>,<span class="number">4</span>),<span class="string">'M'</span>) <span class="keyword">AS</span> <span class="string">'Number of Rows'</span>, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(data_length/(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>),<span class="number">4</span>),<span class="string">'G'</span>) <span class="keyword">AS</span> <span class="string">'Data Size'</span>, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>(index_length/(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>),<span class="number">4</span>),<span class="string">'G'</span>) <span class="keyword">AS</span> <span class="string">'Index Size'</span>, <span class="keyword">CONCAT</span>(<span class="keyword">ROUND</span>((data_length+index_length)/(<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">1024</span>),<span class="number">4</span>),<span class="string">'G'</span>) <span class="keyword">AS</span><span class="string">'Total'</span><span class="keyword">FROM</span> information_schema.TABLES <span class="keyword">WHERE</span> table_schema = <span class="string">'mainsite'</span> <span class="keyword">order</span> <span class="keyword">by</span> Total <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-collection</title>
      <link href="man/python/lib-collection.html"/>
      <url>man/python/lib-collection.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>OrderedDict类：排序字典，是字典的子类。引入自2.7。</p></li><li><p>namedtuple()函数：命名元组，是一个工厂函数。引入自2.6。</p></li><li><p>Counter类：为hashable对象计数，是字典的子类。引入自2.7。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c = Counter()  <span class="comment"># 创建一个空的Counter类</span></span><br><span class="line">c = Counter(<span class="string">'gallahad'</span>)  <span class="comment"># 从一个可iterable对象（list、tuple、dict、字符串等）创建</span></span><br><span class="line">c = Counter(&#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)  <span class="comment"># 从一个字典对象创建</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>)  <span class="comment"># 从一组键值对创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### update方法</span></span><br><span class="line">c = Counter(<span class="string">'which'</span>)</span><br><span class="line">c.update(<span class="string">'witch'</span>)  <span class="comment"># 使用另一个iterable对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">d = Counter(<span class="string">'watch'</span>)</span><br><span class="line">c.update(d)  <span class="comment"># 使用另一个Counter对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## subtract</span></span><br><span class="line">c = Counter(<span class="string">'which'</span>)</span><br><span class="line">c.subtract(<span class="string">'witch'</span>)  <span class="comment"># 使用另一个iterable对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">d = Counter(<span class="string">'watch'</span>)</span><br><span class="line">c.subtract(d)  <span class="comment"># 使用另一个Counter对象更新</span></span><br><span class="line">c[<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 键的删除</span></span><br><span class="line">c = Counter(<span class="string">"abcdcba"</span>)</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 2, 'c': 2, 'b': 2, 'd': 1&#125;)</span></span><br><span class="line">c[<span class="string">"b"</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># Counter(&#123;'a': 2, 'c': 2, 'd': 1, 'b': 0&#125;)</span></span><br><span class="line"><span class="keyword">del</span> c[<span class="string">"a"</span>]</span><br><span class="line"><span class="comment"># Counter(&#123;'c': 2, 'b': 2, 'd': 1&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## elements</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=<span class="number">-2</span>)</span><br><span class="line">list(c.elements())</span><br><span class="line"><span class="comment"># ['a', 'a', 'a', 'a', 'b', 'b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## most_common</span></span><br><span class="line">c = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line">c.most_common()</span><br><span class="line"><span class="comment"># [('a', 5), ('r', 2), ('b', 2), ('c', 1), ('d', 1)]</span></span><br><span class="line">c.most_common(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># [('a', 5), ('r', 2), ('b', 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 算术操作</span></span><br><span class="line">c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>)</span><br><span class="line">d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">c + d  <span class="comment"># c[x] + d[x]</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">c - d  <span class="comment"># subtract（只保留正数计数的元素）</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">c &amp; d  <span class="comment"># 交集:  min(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">c | d  <span class="comment"># 并集:  max(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 常用操作</span></span><br><span class="line">sum(c.values())  <span class="comment"># 所有计数的总数</span></span><br><span class="line">c.clear()  <span class="comment"># 重置Counter对象，注意不是删除</span></span><br><span class="line">list(c)  <span class="comment"># 将c中的键转为列表</span></span><br><span class="line">set(c)  <span class="comment"># 将c中的键转为set</span></span><br><span class="line">dict(c)  <span class="comment"># 将c中的键值对转为字典</span></span><br><span class="line">c.items()  <span class="comment"># 转为(elem, cnt)格式的列表</span></span><br><span class="line">Counter(dict(list_of_pairs))  <span class="comment"># 从(elem, cnt)格式的列表转换为Counter类对象</span></span><br><span class="line">c.most_common()[:-n:<span class="number">-1</span>]  <span class="comment"># 取出计数最少的n个元素</span></span><br><span class="line">c += Counter()  <span class="comment"># 移除0和负值</span></span><br></pre></td></tr></table></figure></li><li><p>deque：双向队列。引入自2.4。</p></li><li><p>defaultdict：使用工厂函数创建字典，使不用考虑缺失的字典键。引入自2.5。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-DBUtils</title>
      <link href="man/python/lib-dbutils.html"/>
      <url>man/python/lib-dbutils.html</url>
      
        <content type="html"><![CDATA[<p>有两个类型：PooledDB, PersistentDB<br>如果是多线程，可以用PooledDB<br>如果是单线程，可以用PersistentDB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">数据库连接工具类</span></span><br><span class="line"><span class="string"># """</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB, SharedDBConnection</span><br><span class="line"><span class="keyword">from</span> DBUtils.PersistentDB <span class="keyword">import</span> PersistentDB, PersistentDBError, NotSupportedError</span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'192.168.0.101'</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">'database'</span>: <span class="string">'wedo'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'wedo'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'xxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db_pool</span><span class="params">(is_mult_thread)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_mult_thread:</span><br><span class="line">        poolDB = PooledDB(</span><br><span class="line">            <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            creator=pymysql,</span><br><span class="line">            <span class="comment"># 连接池允许的最大连接数,0和None表示没有限制</span></span><br><span class="line">            maxconnections=<span class="number">3</span>,</span><br><span class="line">            <span class="comment"># 初始化时,连接池至少创建的空闲连接,0表示不创建</span></span><br><span class="line">            mincached=<span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 连接池中空闲的最多连接数,0和None表示没有限制</span></span><br><span class="line">            maxcached=<span class="number">5</span>,</span><br><span class="line">            <span class="comment"># 连接池中最多共享的连接数量,0和None表示全部共享(其实没什么卵用)</span></span><br><span class="line">            maxshared=<span class="number">3</span>,</span><br><span class="line">            <span class="comment"># 连接池中如果没有可用共享连接后,是否阻塞等待,True表示等等,</span></span><br><span class="line">            <span class="comment"># False表示不等待然后报错</span></span><br><span class="line">            blocking=<span class="literal">True</span>,</span><br><span class="line">            <span class="comment"># 开始会话前执行的命令列表</span></span><br><span class="line">            setsession=[],</span><br><span class="line">            <span class="comment"># ping Mysql服务器检查服务是否可用</span></span><br><span class="line">            ping=<span class="number">0</span>,</span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        poolDB = PersistentDB(</span><br><span class="line">            <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            creator=pymysql,</span><br><span class="line">            <span class="comment"># 一个连接最大复用次数,0或者None表示没有限制,默认为0</span></span><br><span class="line">            maxusage=<span class="number">1000</span>,</span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> poolDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 以单线程的方式初始化数据库连接池</span></span><br><span class="line">    db_pool = get_db_pool(<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 从数据库连接池中取出一条连接</span></span><br><span class="line">    conn = db_pool.connection()</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 随便查一下吧</span></span><br><span class="line">    cursor.execute(<span class="string">'select * from books'</span>)</span><br><span class="line">    <span class="comment"># 随便取一条查询结果</span></span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 把连接返还给连接池</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>nameko使用</title>
      <link href="man/python/lib-nameko.html"/>
      <url>man/python/lib-nameko.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python常用库</title>
      <link href="man/python/lib.html"/>
      <url>man/python/lib.html</url>
      
        <content type="html"><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.random()</span><br><span class="line"></span><br><span class="line">random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">random.uniform(<span class="number">2.5</span>, <span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line">random.choice()</span><br><span class="line"></span><br><span class="line">random.shuffle()</span><br></pre></td></tr></table></figure><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">requests</a></li></ul><h3 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h3><ul><li><a href="https://docs.djangoproject.com/en/3.0/" target="_blank" rel="noopener">django</a></li><li><a href="https://palletsprojects.com/p/flask/" target="_blank" rel="noopener">flask</a></li><li><a href="https://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">torando</a></li><li><a href="https://gunicorn.org/" target="_blank" rel="noopener">gunicorn</a>-Gunicorn ‘Green Unicorn’ is a Python WSGI HTTP Server for UNIX<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3></li><li><a href="https://nameko.readthedocs.io/en/stable/" target="_blank" rel="noopener">nameko</a></li></ul><h3 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h3><ul><li><a href="https://psutil.readthedocs.io/en/latest/" target="_blank" rel="noopener">psutil</a> - 一个跨平台的第三方库，能够轻松实现获取系统运行的进程和系统利用率（包扩CPU、内存、磁盘、网络等）信息。它主要用于系统监控、分析、限制系统资源和进程的管理。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><a href="https://eventlet.net/" target="_blank" rel="noopener">eventlet</a></li></ul><h3 id="压缩及解压缩"><a href="#压缩及解压缩" class="headerlink" title="压缩及解压缩"></a>压缩及解压缩</h3><ul><li>zipfile</li></ul><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><ul><li>几种uuid<br>1、uuid1()——基于时间戳<br>  由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，<br>  但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。<br>2、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）<br>  算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。<br>  实际中很少用到该方法。<br>3、uuid3()——基于名字的MD5散列值<br>  通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，<br>  和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。<br>4、uuid4()——基于随机数<br>  由伪随机数得到，有一定的重复概率，该概率可以计算出来。<br>5、uuid5()——基于名字的SHA-1散列值<br>  算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID based on the host ID and current time</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using an MD5 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid3(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a random UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid5(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a string of hex digits (braces and hyphens ignored)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = uuid.UUID(<span class="string">'&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># convert a UUID to a string of hex digits in standard form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(x)</span><br><span class="line"><span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get the raw 16 bytes of the UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.bytes</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a 16-byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.UUID(bytes=x.bytes)</span><br><span class="line">UUID(<span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line"><span class="string">'36a98670-d9bb-458d-8670-da24e545ca64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除-</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4().hex</span><br><span class="line"><span class="string">'2b15216124ae4476a96bd7707c9e1a34'</span></span><br></pre></td></tr></table></figure></li><li>uuid的常用只读方法<ul><li>UUID.hex The UUID as a 32-character hexadecimal string</li><li>UUID.int The UUID as a 128-bit integer.</li></ul></li><li>生成全局唯一id，可以依据MAC地址、网卡、时间戳、随机数</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python系统操作</title>
      <link href="man/python/os.html"/>
      <url>man/python/os.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h3 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = imput()</span><br></pre></td></tr></table></figure><h3 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">filename = sys.argv[<span class="number">0</span>]</span><br><span class="line">argv1 = sys.argv[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="命令参数化"><a href="#命令参数化" class="headerlink" title="命令参数化"></a>命令参数化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取系统环境变量"><a href="#获取系统环境变量" class="headerlink" title="获取系统环境变量"></a>获取系统环境变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.environ)</span><br></pre></td></tr></table></figure><h3 id="获取硬件信息"><a href="#获取硬件信息" class="headerlink" title="获取硬件信息"></a>获取硬件信息</h3><ul><li>用psutil库可以获取系统很多信息<h3 id="可以取代操作系统特定的路径分割符。"><a href="#可以取代操作系统特定的路径分割符。" class="headerlink" title="可以取代操作系统特定的路径分割符。"></a>可以取代操作系统特定的路径分割符。</h3></li><li>os.sep<h3 id="返回但前目录（’-’"><a href="#返回但前目录（’-’" class="headerlink" title="返回但前目录（’.’)"></a>返回但前目录（’.’)</h3></li><li>os.curdir<h3 id="字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux-Unix用户，它是’posix’。"><a href="#字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux-Unix用户，它是’posix’。" class="headerlink" title="字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。"></a>字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。</h3></li><li>os.name<h3 id="函数分别用来读取和设置环境变量。"><a href="#函数分别用来读取和设置环境变量。" class="headerlink" title="函数分别用来读取和设置环境变量。"></a>函数分别用来读取和设置环境变量。</h3></li><li>os.getenv()</li><li>os.putenv()<h3 id="函数用来运行shell命令。"><a href="#函数用来运行shell命令。" class="headerlink" title="函数用来运行shell命令。"></a>函数用来运行shell命令。</h3></li><li>os.system()<h3 id="实现从程序外部向程序传递参数。"><a href="#实现从程序外部向程序传递参数。" class="headerlink" title="实现从程序外部向程序传递参数。"></a>实现从程序外部向程序传递参数。</h3></li><li>sys.argv<h3 id="程序中间的退出"><a href="#程序中间的退出" class="headerlink" title="程序中间的退出"></a>程序中间的退出</h3></li><li>sys.exit([arg])</li><li>arg=0为正常退出。<h3 id="获取系统当前编码，一般默认为ascii。"><a href="#获取系统当前编码，一般默认为ascii。" class="headerlink" title="获取系统当前编码，一般默认为ascii。"></a>获取系统当前编码，一般默认为ascii。</h3></li><li>sys.getdefaultencoding()<h3 id="设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload-sys-，在执行-setdefaultencoding-‘utf8’-，此时将系统默认编码设置为utf8。（见设置系统默认编码-）"><a href="#设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload-sys-，在执行-setdefaultencoding-‘utf8’-，此时将系统默认编码设置为utf8。（见设置系统默认编码-）" class="headerlink" title="设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）"></a>设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</h3></li><li>sys.setdefaultencoding()<h3 id="获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’"><a href="#获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’" class="headerlink" title="获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’."></a>获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’.</h3></li><li>sys.getfilesystemencoding()<h3 id="获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。"><a href="#获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。" class="headerlink" title="获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。"></a>获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</h3></li><li>sys.path<h3 id="获取当前系统平台。"><a href="#获取当前系统平台。" class="headerlink" title="获取当前系统平台。"></a>获取当前系统平台。</h3></li><li>sys.platform<h3 id="包含与标准I-O-流对应的流对象-如果需要更好地控制输出-而print-不能满足你的要求-它们就是你所需要的-你也可以替换它们-这时候你就可以重定向输出和输入到其它设备-device-或者以非标准的方式处理它们"><a href="#包含与标准I-O-流对应的流对象-如果需要更好地控制输出-而print-不能满足你的要求-它们就是你所需要的-你也可以替换它们-这时候你就可以重定向输出和输入到其它设备-device-或者以非标准的方式处理它们" class="headerlink" title="包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们"></a>包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</h3></li><li>sys.stdin,sys.stdout,sys.stderr<h3 id="获取操作系统类型，windows、linux等"><a href="#获取操作系统类型，windows、linux等" class="headerlink" title="获取操作系统类型，windows、linux等"></a>获取操作系统类型，windows、linux等</h3></li><li>platform.system()<h3 id="获取操作系统，Darwin-9-8-0-i386-32bit"><a href="#获取操作系统，Darwin-9-8-0-i386-32bit" class="headerlink" title="获取操作系统，Darwin-9.8.0-i386-32bit"></a>获取操作系统，Darwin-9.8.0-i386-32bit</h3></li><li>platform.platform()<h3 id="获取系统版本信息-6-2-0"><a href="#获取系统版本信息-6-2-0" class="headerlink" title="获取系统版本信息 6.2.0"></a>获取系统版本信息 6.2.0</h3></li><li>platform.version()</li><li>platform.mac_ver()</li><li>platform.win32_ver() (‘post2008Server’, ‘6.2.9200’, ”, u’Multiprocessor Free’)</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/re/xpath.html"/>
      <url>man/re/xpath.html</url>
      
        <content type="html"><![CDATA[<ul><li>XPath轴(XPath Axes)可定义某个相对于当前节点的节点集：<ul><li>1、child  选取当前节点的所有子元素</li><li>2、parent  选取当前节点的父节点</li><li>3、descendant 选取当前节点的所有后代元素（子、孙等）</li><li>4、ancestor  选取当前节点的所有先辈（父、祖父等）</li><li>5、descendant-or-self 选取当前节点的所有后代元素（子、孙等）以及当前节点本身</li><li>6、ancestor-or-self  选取当前节点的所有先辈（父、祖父等）以及当前节点本身</li><li>7、preceding-sibling 选取当前节点之前的所有同级节点</li><li>8、following-sibling 选取当前节点之后的所有同级节点</li><li>9、preceding   选取文档中当前节点的开始标签之前的所有节点</li><li>10、following   选取文档中当前节点的结束标签之后的所有节点</li><li>11、self  选取当前节点</li><li>12、attribute  选取当前节点的所有属性</li><li>13、namespace 选取当前节点的所有命名空间节点</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust的ffi使用</title>
      <link href="man/rust/ffi.html"/>
      <url>man/rust/ffi.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/re/%E6%AD%A3%E5%88%99%E8%A7%84%E5%88%99.html"/>
      <url>man/re/%E6%AD%A3%E5%88%99%E8%A7%84%E5%88%99.html</url>
      
        <content type="html"><![CDATA[<h2 id="表达式规则"><a href="#表达式规则" class="headerlink" title="表达式规则"></a>表达式规则</h2><table><thead><tr><th align="left">字符</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">\</td><td align="left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “&quot; 而 “(“ 则匹配 “(“。</td></tr><tr><td align="left">^</td><td align="left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td align="left">$</td><td align="left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td align="left">*</td><td align="left">匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。</td></tr><tr><td align="left">+</td><td align="left">匹配前面的子表达式一次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{1,}。</td></tr><tr><td align="left">?</td><td align="left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td></tr><tr><td align="left">n</td><td align="left">是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td align="left">{n,}</td><td align="left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td align="left">{n,m}</td><td align="left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td align="left">?</td><td align="left">当该字符紧跟在任何一个其他限制符 (*+, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td align="left">.</td><td align="left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td align="left">(pattern)</td><td align="left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td align="left">(?:pattern)</td><td align="left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (</td></tr><tr><td align="left">(?=pattern)</td><td align="left">正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95</td></tr><tr><td align="left">(?!pattern)</td><td align="left">负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95</td></tr><tr><td align="left">x|y</td><td align="left">匹配 x 或 y。例如，’z</td></tr><tr><td align="left">[xyz]</td><td align="left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td align="left">[^xyz]</td><td align="left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td></tr><tr><td align="left">[a-z]</td><td align="left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td align="left">\b</td><td align="left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td align="left">\B</td><td align="left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td align="left">\cx</td><td align="left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td align="left">\d</td><td align="left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td align="left">\D</td><td align="left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td align="left">\f</td><td align="left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td align="left">\n</td><td align="left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td align="left">\r</td><td align="left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td align="left">\s</td><td align="left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td align="left">\S</td><td align="left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td align="left">\t</td><td align="left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td align="left">\v</td><td align="left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td align="left">\w</td><td align="left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td align="left">\W</td><td align="left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td align="left">\xn</td><td align="left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。.</td></tr><tr><td align="left">\num</td><td align="left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td align="left">n</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td align="left">nm</td><td align="left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td align="left">nml</td><td align="left">如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</td></tr><tr><td align="left">un</td><td align="left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">javascript正则文档</a></p><p><a href="http://www.pcre.org/pcre.txt" target="_blank" rel="noopener">Perl-compatible regular expressions</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust手册</title>
      <link href="man/rust/index.html"/>
      <url>man/rust/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust的基础</title>
      <link href="man/rust/basic.html"/>
      <url>man/rust/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust中的闭包, 按照对捕获变量的使用方式, 将闭包分为三个类型: Fn, FnMut, FnOnce. 其中Fn类型的闭包, 在闭包内部以共享借用的方式使用环境变量; FnMut类型的闭包, 在闭包内部以独占借用的方式使用环境变量; 而FnOnce类型的闭包, 在闭包内部以所有者的身份使用环境变量. 由此可见, 根据闭包内使用环境变量的方式, 即可判断创建出来的闭包的类型.</p><p>注意, 对于Copy类型的环境变量, 如果以传值的方式使用, 其默认的闭包类型是Fn, 而非FnOnce, 而对非Copy的环境变量, 其闭包类型只能是FnOnce.</p><p>闭包中环境变量最终的捕获方式 (即, 是借用, 是复制, 还是转移所有权), 还与环境变量本身的语义, 以及闭包是否强制获取环境变量的所有权有关.</p><p>在闭包的管道符前面加上move关键字, 会强制以传值的方式捕获变量. 至于是复制还是移动, 则与环境变量类型的语义有关. 我们知道, 一个类型实现Copy, 即为复制语义. 在作为右值使用时会将值按位复制. 而未实现Copy的类型即为移动语义, 作右值使用时会转移所有权.</p><p>move 闭包，其经常与 thread::spawn 一起使用，因为它允许我们在一个线程中使用另一个线程的数据。可以在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权。这个技巧在创建新线程将值的所有权从一个线程移动到另一个线程时最为实用。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust与llvm</title>
      <link href="man/rust/llvm.html"/>
      <url>man/rust/llvm.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/rust/%E5%91%BD%E4%BB%A4.html"/>
      <url>man/rust/%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<p>可以用rustup update来升级rust，用rustup self uninstall来卸载rust</p><p>所以对于rust来说，有三个工具，cargo、rustc、rustup。那么这三个各有什么作用呢？<br>cargo是用来管理项目及依赖的，并且可以对项目进行打包<br>rustc是rust的编译器，用来编译运营rust文件。<br>rustup是The Rust toolchain installer</p><ul><li><p><strong><code>cargo</code></strong> – 项目管理器</p><ul><li>options<ul><li><code>-V, --version</code>       Print version info and exit</li><li><code>--list</code>              List installed commands</li><li><code>--explain &lt;CODE&gt;</code>    Run <code>rustc --explain CODE</code></li><li><code>-v, --verbose</code>       Use verbose output (-vv very verbose/build.rs output)</li><li><code>-q, --quiet</code>         No output printed to stdout</li><li><code>--color &lt;WHEN&gt;</code>      Coloring: auto, always, never</li><li><code>--frozen</code>            Require Cargo.lock and cache are up to date</li><li><code>--locked</code>            Require Cargo.lock is up to date</li><li><code>--offline</code>           Run without accessing the network</li><li><code>-Z &lt;FLAG&gt;...</code>        Unstable (nightly-only) flags to Cargo, see ‘cargo -Z help’ for details</li><li><code>-h, --help</code>          Prints help information</li></ul></li><li>commands<ul><li><code>build</code>       Compile the current package</li><li><code>check</code>       Analyze the current package and report errors, but don’t build object files</li><li><code>clean</code>       Remove the target directory</li><li><code>doc</code>         Build this package’s and its dependencies’ documentation</li><li><code>new</code>         Create a new cargo package</li><li><code>init</code>        Create a new cargo package in an existing directory</li><li><code>run</code>         Run a binary or example of the local package</li><li><code>test</code>        Run the tests</li><li><code>bench</code>       Run the benchmarks</li><li><code>update</code>      Update dependencies listed in Cargo.lock</li><li><code>search</code>      Search registry for crates</li><li><code>publish</code>     Package and upload this package to the registry</li><li><code>install</code>     Install a Rust binary. Default location is $HOME/.cargo/bin</li><li><code>uninstall</code>   Uninstall a Rust binary</li></ul></li></ul></li><li><p><strong><code>rustc</code></strong></p></li><li><p><strong><code>rustup</code></strong></p><ul><li>options<ul><li><code>-v, --verbose</code>    Enable verbose output</li><li><code>-q, --quiet</code>      Disable progress output</li><li><code>-h, --help</code>       Prints help information</li><li><code>-V, --version</code>    Prints version information</li></ul></li><li>commands<ul><li><code>show</code>           Show the active and installed toolchains or profiles</li><li><code>update</code>         Update Rust toolchains and rustup</li><li><code>check</code>          Check for updates to Rust toolchains</li><li><code>default</code>        Set the default toolchain</li><li><code>toolchain</code>      Modify or query the installed toolchains</li><li><code>target</code>         Modify a toolchain’s supported targets</li><li><code>component</code>      Modify a toolchain’s installed components</li><li><code>override</code>       Modify directory toolchain overrides</li><li><code>run</code>            Run a command with an environment configured for a given toolchain</li><li><code>which</code>          Display which binary will be run for a given command</li><li><code>doc</code>            Open the documentation for the current toolchain</li><li><code>man</code>            View the man page for a given command</li><li><code>self</code>           Modify the rustup installation</li><li><code>set</code>            Alter rustup settings</li><li><code>completions</code>    Generate tab-completion scripts for your shell</li><li><code>help</code>           Prints this message or the help of the given subcommand(s)<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rustup toolchain install nightly</span><br><span class="line">rustup toolchain list</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>手册</title>
      <link href="man/storeage/index.html"/>
      <url>man/storeage/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h2><ul><li><a href="./hbase/hbae简介.html">hbase简介</a></li></ul><h2 id="Mongodb"><a href="#Mongodb" class="headerlink" title="Mongodb"></a>Mongodb</h2><ul><li><a href="./mongodb/操作文档.html">mongodb操作文档</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/server/nginx.html"/>
      <url>man/server/nginx.html</url>
      
        <content type="html"><![CDATA[<p>一、配置参数</p><ol><li>语法规则： location [=|<del>|</del>*|^~] /uri/ { … }</li><li>= 开头表示精确匹配</li><li>^~ 开头表示uri以某个常规字符串开头，理解为匹配 url路径即可。nginx不对url做编码，因此请求为/static/20%/aa，可以被规则^~  /static/ /aa匹配到（注意是空格）。</li><li>~ 开头表示区分大小写的正则匹配</li><li>~*  开头表示不区分大小写的正则匹配</li><li>!<del>和!</del>*分别为区分大小写不匹配及不区分大小写不匹配 的正则</li><li>/ 通用匹配，任何请求都会匹配到。</li><li>多个location配置的情况下匹配顺序为（参考资料而来，还未实际验证，试试就知道了，不必拘泥，仅供参考）：</li><li>首先匹配 =，其次匹配^~, 其次是按文件中顺序的正则匹配，最后是交给 / 通用匹配。当有匹配成功时候，停止匹配，按当前匹配规则处理请求。</li></ol><p>二、日志</p><p>三、nginx配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#user  nobody;</span></span><br><span class="line">worker_processes  1;</span><br><span class="line"><span class="comment">#error_log  logs/error.log;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  notice;</span></span><br><span class="line"><span class="comment">#error_log  logs/error.log  info;</span></span><br><span class="line">error_log  /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/nginx/error.log debug;</span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line">pid        /usr/<span class="built_in">local</span>/var/run/nginx.pid;</span><br><span class="line">events &#123;</span><br><span class="line">    worker_connections  256;</span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    include      mime.types;</span><br><span class="line">    default_type  application/octet-stream;</span><br><span class="line">    log_format  main  <span class="string">'$remote_addr - $remote_user [$time_local] "$request" '</span></span><br><span class="line">                      <span class="string">'$status $body_bytes_sent "$http_referer" '</span></span><br><span class="line">                      <span class="string">'"$http_user_agent" "$http_x_forwarded_for"'</span>;</span><br><span class="line">    access_log  /usr/<span class="built_in">local</span>/var/<span class="built_in">log</span>/nginx/access.log main;</span><br><span class="line">    sendfile        on;</span><br><span class="line">    keepalive_timeout  65;</span><br><span class="line">    port_in_redirect off;</span><br><span class="line">    gzip  on;</span><br><span class="line">    server &#123;</span><br><span class="line">        listen      80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line">        <span class="comment">#charset koi8-r;</span></span><br><span class="line">        <span class="comment">#access_log  logs/host.access.log  main;</span></span><br><span class="line">        root /Users/zxc/www;</span><br><span class="line">        location / &#123;</span><br><span class="line">            index index.php index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">#error_page  404              /404.html;</span></span><br><span class="line">        <span class="comment"># redirect server error pages to the static page /50x.html</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        error_page  500 502 503 504  /50x.html;</span><br><span class="line">        <span class="comment">#location = /50x.html &#123;</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment"># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        <span class="comment">#location ~ \.php$ &#123;</span></span><br><span class="line">        <span class="comment">#    proxy_pass  http://127.0.0.1;</span></span><br><span class="line">        <span class="comment">#&#125;</span></span><br><span class="line">        <span class="comment"># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        location ~ \.php$ &#123;</span><br><span class="line">            fastcgi_pass  127.0.0.1:9000;</span><br><span class="line">            fastcgi_index  index.php;</span><br><span class="line">            fastcgi_param  SCRIPT_FILENAME  <span class="variable">$document_root</span><span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">            include        fastcgi_params;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment"># deny access to .htaccess files, if Apache's document root</span></span><br><span class="line">        <span class="comment"># concurs with nginx's one</span></span><br><span class="line">        <span class="comment">#</span></span><br><span class="line">        location ~ /\.ht &#123;</span><br><span class="line">            deny  all;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    upstream var_fastcgi&#123;</span><br><span class="line">      server 127.0.0.1:9000;</span><br><span class="line">      <span class="comment">#server local.audit.36kr.com;</span></span><br><span class="line">      <span class="comment">#server rongtest04.36kr.com;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">#include servers/*;</span></span><br><span class="line">    <span class="comment">#include /usr/local/etc/nginx/sites-enabled/*.conf;</span></span><br><span class="line">    include conf.d/*.conf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象</title>
      <link href="man/python/class.html"/>
      <url>man/python/class.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>继承</li><li>多态</li><li>封装</li><li>对象序列化传输，反序列化执行</li><li>判断某个实例是不是属于某个类</li></ul><ul><li>1.类本身就是对象   <ul><li>2.global    nonlocal   </li><li>3._ _ init_ _ 类在实例化时调用该函数   </li><li>4.继承：isinstance()检查实例类型  issubclass()检查类的关系     可以多重继承   </li><li>5.私有变量<br>  #1.以 _  _开头   </li><li><ol start="6"><li>_ <em>del</em> _ 析构方法 删除内存</li></ol></li></ul></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h3><h3 id="类的应用"><a href="#类的应用" class="headerlink" title="类的应用"></a>类的应用</h3><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><ul><li><p>Python不像C++、Java、C#等有明确的公共、私有或受保护的关键字来定义成员函数或属性，它使用约定的单下划线“<em>“和”_</em>“双下划线作为函数或属性的前缀来标识。使用单下划线还是双下划线，是有很大的区别的。</p><ul><li><ol><li>单下划线的函数或属性，在类定义中可以调用和访问，类的实例可以直接访问，子类中可以访问；</li></ol></li><li><ol start="2"><li>双下划线的函数或属性，在类定义中可以调用和访问，类的实例不可以直接访问，子类不可访问。</li></ol></li><li><p>注意：对于双下划线的函数或属性，Python解释器使用了名字混淆的方法， 将私有的方法”<strong>method”变成了”_classname</strong>method”了，具体看下文示例。</p></li></ul></li><li><p>不要定义Python的混淆类方法名称</p><ul><li><p>Python解释器对于类（ClassName）双下划线的私有方法（<strong>method），会进行名称混淆（Name Mangle），规则为 _ClassName</strong>method。所以不要在类方法中同时存在<strong>method和 _ClassName</strong>method。</p></li><li><p>可以看出 <strong>hide 已经被 _Base</strong>hide方法替换掉了。外部也可以直接通过 Base()._Base__hide()方式调用（但千万别用这种方式实现，比较混乱！）。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_secret</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Base secret"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hide</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Normal __hide"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_Base__hide</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Special _Base__hide"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"From public method"</span>)</span><br><span class="line">        self.__hide()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(Base())</span><br><span class="line">print(<span class="string">"="</span>*<span class="number">80</span>)</span><br><span class="line">Base().public()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[&lt;span style="color:#FF0000;"&gt;'_Base__hide'&lt;/span&gt;, '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_secret', 'public']</span></span><br><span class="line"><span class="string">================================================================================</span></span><br><span class="line"><span class="string">From public method</span></span><br><span class="line"><span class="string">&lt;span style="color:#FF0000;"&gt;Special _Base__hide&lt;/span&gt; """</span></span><br></pre></td></tr></table></figure><h3 id="self、cls、staticmethod，classmethod-区别"><a href="#self、cls、staticmethod，classmethod-区别" class="headerlink" title="self、cls、staticmethod，classmethod 区别"></a>self、cls、staticmethod，classmethod 区别</h3><ul><li><p>类的方法有三种</p><ul><li><p>一是通过def定义的 普通的一般的，需要至少传递一个参数，一般用self，这样的方法必须通过一个类的实例去访问，类似于c++中通过对象去访问；</p></li><li><p>二是在def前面加上@classmethod，这种类方法的一个特点就是可以通过类名去调用，但是也必须传递一个参数，一般用cls表示class，表示可以通过类直接调用；</p></li><li><p>三是在def前面加上@staticmethod，这种类方法是静态的类方法，类似于c++的静态函数，他的一个特点是参数可以为空，同样支持类名和对象两种调用方式；</p></li></ul></li><li><p>三种方法解释</p><ul><li>普通的方法，第一个参数需要是self，它表示一个具体的实例本身。</li><li>如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。</li><li>而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="keyword">print</span> A.bar</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="keyword">print</span> cls.bar</span><br><span class="line">        cls().foo()</span><br><span class="line"></span><br><span class="line">A.static_foo()</span><br><span class="line">A.class_foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static_foo</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">class_foo</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>其实self，cls不是关键字，例如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    member = <span class="string">"this is a test."</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print1</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"print 1: "</span>, cls.membe)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"print 2: "</span>, self.member)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print3</span><span class="params">(paraTest)</span>:</span></span><br><span class="line">        print(<span class="string">"print 3: "</span>, paraTest.member)</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/git/git%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html"/>
      <url>tools/git/git%E4%B8%AD%E6%96%87%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>不会对0×80以上的字符进行quote。中文显示正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global core.quotepath <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>或者手动更改配置文件~/.gitconfig，编辑添加如下内容即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[core]</span><br><span class="line">quotepath &#x3D; false</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="snippet/devops/ops.html"/>
      <url>snippet/devops/ops.html</url>
      
        <content type="html"><![CDATA[<p>判断是否是一个目录</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">dir = <span class="string">"/var/www/html/EnjoyCarApi/"</span></span><br><span class="line"><span class="keyword">if</span> os.path.isdir(dir):</span><br><span class="line">    print(<span class="string">'%s is a dir'</span> % dir)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'%s is not a dir'</span> % dir)</span><br></pre></td></tr></table></figure><p>系统内存与磁盘检测</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> psutil</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memissue</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'内存信息：'</span>)</span><br><span class="line">    mem = psutil.virtual_memory()</span><br><span class="line">    <span class="comment"># 单位换算为MB</span></span><br><span class="line">    memtotal = mem.total/<span class="number">1024</span>/<span class="number">1024</span></span><br><span class="line">    memused = mem.used/<span class="number">1024</span>/<span class="number">1024</span></span><br><span class="line">    membaifen = str(mem.used/mem.total*<span class="number">100</span>) + <span class="string">'%'</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">'%.2fMB'</span> % memused)</span><br><span class="line">    print(<span class="string">'%.2fMB'</span> % memtotal)</span><br><span class="line">    print(membaifen)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cuplist</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'磁盘信息：'</span>)</span><br><span class="line">    disk = psutil.disk_partitions()</span><br><span class="line">    diskuse = psutil.disk_usage(<span class="string">'/'</span>)</span><br><span class="line">    <span class="comment">#单位换算为GB</span></span><br><span class="line">    diskused = diskuse.used / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line">    disktotal = diskuse.total / <span class="number">1024</span> / <span class="number">1024</span> / <span class="number">1024</span></span><br><span class="line">    diskbaifen = diskused / disktotal * <span class="number">100</span></span><br><span class="line">    print(<span class="string">'%.2fGB'</span> % diskused)</span><br><span class="line">    print(<span class="string">'%.2fGB'</span> % disktotal)</span><br><span class="line">    print(<span class="string">'%.2f'</span> % diskbaifen)</span><br><span class="line"></span><br><span class="line">memissue()</span><br><span class="line">print(<span class="string">'*******************'</span>)</span><br><span class="line">cuplist()</span><br></pre></td></tr></table></figure><p>统计nginx日志前十ip访问量并以柱状图显示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#</span></span><br><span class="line">nginx_file = <span class="string">'nginx2018-12-18_07:45:26'</span></span><br><span class="line"></span><br><span class="line">ip = &#123;&#125;</span><br><span class="line"><span class="comment"># 筛选nginx日志文件中的ip</span></span><br><span class="line"><span class="keyword">with</span> open(nginx_file) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> f.readlines():</span><br><span class="line">        s = i.strip().split()[<span class="number">0</span>]</span><br><span class="line">        lengh = len(ip.keys())</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 统计每个ip的访问量以字典存储</span></span><br><span class="line">        <span class="keyword">if</span> s <span class="keyword">in</span> ip.keys():</span><br><span class="line">            ip[s] = ip[s] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            ip[s] = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以ip出现的次数排序返回对象为list</span></span><br><span class="line">ip = sorted(ip.items(), key=<span class="keyword">lambda</span> e:e[<span class="number">1</span>], reverse=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#取列表前十</span></span><br><span class="line">newip = ip[<span class="number">0</span>:<span class="number">10</span>:<span class="number">1</span>]</span><br><span class="line">tu = dict(newip)</span><br><span class="line"></span><br><span class="line">x = []</span><br><span class="line">y = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> tu:</span><br><span class="line">    x.append(k)</span><br><span class="line">    y.append(tu[k])</span><br><span class="line">plt.title(<span class="string">'ip access'</span>)</span><br><span class="line">plt.xlabel(<span class="string">'ip address'</span>)</span><br><span class="line">plt.ylabel(<span class="string">'PV'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#x轴项的翻转角度</span></span><br><span class="line">plt.xticks(rotation=<span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示每个柱状图的值</span></span><br><span class="line"><span class="keyword">for</span> a,b <span class="keyword">in</span> zip(x,y):</span><br><span class="line">    plt.text(a, b, <span class="string">'%.0f'</span> % b, ha=<span class="string">'center'</span>, va= <span class="string">'bottom'</span>,fontsize=<span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">plt.bar(x,y)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>查看网段里有多少ip地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> IPy</span><br><span class="line"></span><br><span class="line">ip = IPy.IP(<span class="string">'172.16.0.0/26'</span>)</span><br><span class="line"></span><br><span class="line">print(ip.len())</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> ip:</span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure><p>gitlab钩子脚本，实现简单自动化操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask,request,render_template,make_response,Response</span><br><span class="line"><span class="keyword">import</span> json,os,re,requests</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">null = <span class="string">""</span></span><br><span class="line">cmd = <span class="string">"/var/www/html/ladmin-devel/"</span></span><br><span class="line"><span class="meta">@app.route('/test',methods=['POST'])</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    json_dict = json.loads(request.data)</span><br><span class="line"></span><br><span class="line">    name = json_dict[<span class="string">'event_name'</span>]</span><br><span class="line">    ref = json_dict[<span class="string">'ref'</span>][<span class="number">11</span>:]</span><br><span class="line">    project = json_dict[<span class="string">'project'</span>][<span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">'push'</span> <span class="keyword">and</span> ref == <span class="string">'master'</span>:</span><br><span class="line">        os.chdir(cmd)</span><br><span class="line">        s = subprocess.getoutput(<span class="string">'sudo -u nginx composer install'</span>)</span><br><span class="line">        <span class="keyword">return</span> Response(s)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> Response(<span class="string">'none'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    app.run(host=<span class="string">'0.0.0.0'</span>,port=<span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>解析一组域名的ip地址</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.resolver</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line">hosts = [<span class="string">'baidu.com'</span>,<span class="string">'weibo.com'</span>]</span><br><span class="line">s = defaultdict(list)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">query</span><span class="params">(hosts)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> host <span class="keyword">in</span> hosts:</span><br><span class="line">        ip = dns.resolver.query(host,<span class="string">"A"</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> ip:</span><br><span class="line">            s[host].append(i)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> query(hosts):</span><br><span class="line"></span><br><span class="line">    print(i,s[i])</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/vim/vim%E5%BF%AB%E6%8D%B7%E9%94%AE.html"/>
      <url>tools/vim/vim%E5%BF%AB%E6%8D%B7%E9%94%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="VIM使用文档总结"><a href="#VIM使用文档总结" class="headerlink" title="VIM使用文档总结"></a>VIM使用文档总结</h1><ul><li>作者:<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间: 2017-03-02 13:10:12</li></ul><blockquote><h2 id="0x00、快捷键"><a href="#0x00、快捷键" class="headerlink" title="0x00、快捷键"></a>0x00、快捷键</h2><ul><li>向下添加一行<ul><li>o</li></ul></li><li>向下翻页<ul><li>ctrl+f</li></ul></li><li>向上翻页<ul><li>ctrl+b</li></ul></li><li>下一个词<ul><li>w</li></ul></li><li>行尾<ul><li>$</li></ul></li><li>第一个字符行首<ul><li>^</li></ul></li><li>行首<ul><li>0</li></ul></li><li>撤销<ul><li>u</li></ul></li><li>文件首<ul><li>gg</li></ul></li><li>文件尾<ul><li>G</li></ul></li><li>屏首<ul><li>ctrl+h</li></ul></li><li>屏中<ul><li>ctrl+m</li></ul></li><li>屏尾<ul><li>ctrl+l</li></ul></li></ul></blockquote>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html"/>
      <url>tools/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4.html</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2016-12-24 19:08:57</li></ul><p>[TOC]</p><p><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">gitbook</a></p><h2 id="一、基础功能"><a href="#一、基础功能" class="headerlink" title="一、基础功能"></a>一、基础功能</h2><h3 id="1-1、基本用法"><a href="#1-1、基本用法" class="headerlink" title="1.1、基本用法"></a>1.1、基本用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> git初始化仓库。</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git克隆远程库</span></span><br><span class="line">git clone remote_url</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有修改。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：ga</span></span><br><span class="line">git add .</span><br><span class="line">git add *</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加某个文件.</span></span><br><span class="line">git add [file_name]</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除文件。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名: grm</span></span><br><span class="line">git rm &lt;file_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> //删除追踪，不删除文件</span></span><br><span class="line">git rm --cached readme1.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">   删除readme1.txt的跟踪，并且删除本地文件</span></span><br><span class="line">git rm --f readme1.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名文件</span></span><br><span class="line">git mv &lt;old_name&gt; &lt;new_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git 提交到本地仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gcmsg <span class="string">'批注'</span></span></span><br><span class="line">git commit -m "批注"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> git推送至远程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gp</span></span><br><span class="line">git push &lt;remoteName&gt; &lt;localName&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 远程没有创建仓库，将本地推送到远程仓库</span></span><br><span class="line">git remote add origin &lt;server&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看最新一次修改</span></span><br><span class="line">git show</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看某次修改</span></span><br><span class="line">git show &lt;356f6def9d3fb7f3b9032ff5aa4b9110d4cca87e&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gs</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><h3 id="1-2、分支管理"><a href="#1-2、分支管理" class="headerlink" title="1.2、分支管理"></a>1.2、分支管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建分支，并切换到分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gco -b</span></span><br><span class="line">git checkout -b branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到主分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别民：gcm</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  删除分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gbd</span></span><br><span class="line">git branch -d &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地仓库更新至最新</span></span><br><span class="line">git pull &lt;remoteName&gt; &lt;localName&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将其他分支合并到本地主分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别民：gm</span></span><br><span class="line">git merge branch_name</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比对分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gd</span></span><br><span class="line">git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内的别名：gb</span></span><br><span class="line">git branch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建分支</span></span><br><span class="line">git branch &lt;new_branch&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看本地和远程分支。zsh内的别名：gba</span></span><br><span class="line">git branch -a</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看远程分支</span></span><br><span class="line">git branch -r</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line">git branch -d &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  切换分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gco</span></span><br><span class="line">git checkout &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  创建并切换分支</span></span><br><span class="line">git checkout -b &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程某个分支</span></span><br><span class="line">git push --delete origin &lt;branch_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取分支</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：gf</span></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> zsh内别名：grb</span></span><br><span class="line">git rebase HEAD &lt;file_name&gt;</span><br></pre></td></tr></table></figure><h3 id="1-3、标签管理"><a href="#1-3、标签管理" class="headerlink" title="1.3、标签管理"></a>1.3、标签管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* 创建标签</span><br><span class="line">git tag &lt;tag_name&gt;</span><br></pre></td></tr></table></figure><h3 id="1-4、日志"><a href="#1-4、日志" class="headerlink" title="1.4、日志"></a>1.4、日志</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看日志</span></span><br><span class="line">git log</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  选项来查看历史记录的紧凑简洁的版本。</span></span><br><span class="line">git log  --oneline</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只寻找某个特定作者的提交</span></span><br><span class="line">git log –author</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 选项，以限制结果为最近 [number] 次的提交。</span></span><br><span class="line">git log  -[number]</span><br><span class="line">git log --oneline --before=&#123;3.weeks.ago&#125; --after=&#123;2010-04-18&#125; --no-merges</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">  根据提交注释过滤提交记录</span></span><br><span class="line">git log –grep</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示每个提交引入的补丁</span></span><br><span class="line">git log -p</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示每个提交引入的改动的差值统计</span></span><br><span class="line">git log –stat</span><br></pre></td></tr></table></figure><h3 id="1-5、远程分支管理"><a href="#1-5、远程分支管理" class="headerlink" title="1.5、远程分支管理"></a>1.5、远程分支管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 罗列、添加和删除远端仓库别名</span></span><br><span class="line">git remote</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 为你的项目添加一个新的远端仓库</span></span><br><span class="line">git remote add</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除现存的某个别名</span></span><br><span class="line">git remote rm</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看远程信息</span></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程仓库</span></span><br><span class="line">git remote rm &lt;file_name&gt;</span><br></pre></td></tr></table></figure><h3 id="1-6、对比提交"><a href="#1-6、对比提交" class="headerlink" title="1.6、对比提交"></a>1.6、对比提交</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">git diff --cache</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span></span><br><span class="line">git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示摘要而非整个 diff</span></span><br><span class="line">git diff -stat</span><br></pre></td></tr></table></figure><h3 id="1-7、拉取合并"><a href="#1-7、拉取合并" class="headerlink" title="1.7、拉取合并"></a>1.7、拉取合并</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 拉取并合并</span></span><br><span class="line">git fetch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取</span></span><br><span class="line">git pull</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并</span></span><br><span class="line">git merge</span><br></pre></td></tr></table></figure><h3 id="1-8、配置"><a href="#1-8、配置" class="headerlink" title="1.8、配置"></a>1.8、配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置信息</span></span><br><span class="line">git config --list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改用户名</span></span><br><span class="line">git config --global user.name  &lt;new_name&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改用户邮箱</span></span><br><span class="line">git config --global user.email &lt;new_eamil&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置别名</span></span><br><span class="line">git config --global alias.unstage &lt;"reset HEAD"&gt;</span><br></pre></td></tr></table></figure><h2 id="二、业务场景"><a href="#二、业务场景" class="headerlink" title="二、业务场景"></a>二、业务场景</h2><h3 id="2-1、正常仓库体检流程"><a href="#2-1、正常仓库体检流程" class="headerlink" title="2.1、正常仓库体检流程"></a>2.1、正常仓库体检流程</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.添加本地修改文件</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.把添加的修改文件提交到本地仓库，并填写提交信息</span></span><br><span class="line">git commit -m "提交信息"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3.把本地仓库推送至远程仓库</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><h3 id="2-2、暂存不提交"><a href="#2-2、暂存不提交" class="headerlink" title="2.2、暂存不提交"></a>2.2、暂存不提交</h3><p>当在编辑文件时，遇到需要紧急修改的bug，需要切换分支，但是又不想把当前的修改提交到仓库，那么就可以使用这个命令，把当前的修改暂存起来，切换分支修改bug后，在切回本分支恢复即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂存文件</span></span><br><span class="line">git stash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 罗列暂存</span></span><br><span class="line">git stash list</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 弹出最近一次暂存</span></span><br><span class="line">git stash pop</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 弹出指定暂存</span></span><br><span class="line">git stash pop stash@&#123;1&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3、新建项目提交仓库"><a href="#2-3、新建项目提交仓库" class="headerlink" title="2.3、新建项目提交仓库"></a>2.3、新建项目提交仓库</h3><p>创建一个新仓库流程，当然，需要先在远程创建一个空仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库初始化</span></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加修改文件</span></span><br><span class="line">git add README.md</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交修改文件到本地仓库</span></span><br><span class="line">git commit -m "first commit"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地仓库和远程仓库做关联</span></span><br><span class="line">git remote add origin git@github.com:xsoer/artyang.git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地仓库推送至远程仓库</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="tools/vim/vim%E9%85%8D%E7%BD%AE.html"/>
      <url>tools/vim/vim%E9%85%8D%E7%BD%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="VIM配置"><a href="#VIM配置" class="headerlink" title="VIM配置"></a>VIM配置</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-04-22 17:35:23</li></ul><blockquote><h3 id="0x00、常用插件"><a href="#0x00、常用插件" class="headerlink" title="0x00、常用插件"></a>0x00、常用插件</h3></blockquote><ul><li>nerdtree</li><li>YouCompleteMe</li><li>Ctags</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/php/%E8%A7%84%E8%8C%83.html"/>
      <url>man/php/%E8%A7%84%E8%8C%83.html</url>
      
        <content type="html"><![CDATA[<h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><ul><li>1.箭头函数优化<ul><li>在上层判断是否满足条件，不满足直接返回，禁止嵌套</li></ul></li><li>2.模块合理性<ul><li>随着业务发展，最初的设计不符合需求，要及早修改</li></ul></li><li>3.规范性校验<ul><li>提交强制规范性</li></ul></li><li>4.前端数据联动<ul><li>有时需要摆脱数据的强制关联，需要用JSON.parse(JSON.strifty(data))来处理，而且尽量去除没有必要的数据关联</li></ul></li><li>5.LOG链接跳转<ul><li>不应该在后段处理，而应该该前端处理。接口返回原数据，页面来做各种处理。</li></ul></li><li>6.公司详情tab页【TODO】<ul><li>每个tab页可以标记是否请求过，如果请求过，就不在请求</li></ul></li><li>7.tag-tree;tag-label接口<ul><li>做缓存，否则这两个接口耗时过长</li></ul></li><li>8.IF—ELSE过多，用in_array来代替【TODO】e.g index的pagePrams选择排序</li><li>9.永远直接返回code=0应该是不正确的，应该根据具体操作的结果来返回【TODO】e.g controller的数据操作</li><li>10.循环语句里查库应该是被杜绝的！</li><li>11.传参<ul><li>a.带有默认值的参数应该写在最后！</li><li>b.没有用的参数不要传递</li></ul></li><li>12.当只知道ID不知道具体对应的url时，添加跳转页面做统一跳转  e.g    redirect.vue</li><li>13.代码公用的部分，应该抽取处理做复用方法.  e.g reuse.js</li><li>14.页面尽量给用户适当的响应，做到系统的透明化！<ul><li>特别是加载中，刷新中，提交中等操作</li></ul></li><li>15.刷数据脚本原则。<ul><li>数据正确，格式兼容，内存够用，效率够高，易回滚，可断续，高容错</li></ul></li><li>16.提交时清理所有的log信息</li><li>17.vue模版里的节点统一用template，而不是有用div的，有用span的</li><li>18.刷数据问题<ul><li>可能问题：<ul><li>a.脚本中断</li><li>b.数据重复</li><li>c.数据错误</li></ul></li><li>注意项：<ul><li>a.脚本应该存在断刷后，传参依然可以继续刷</li><li>b.脚本刷错后，有函数可以一键恢复或删除已刷数据，不用重复修改上线</li><li>c.对于可能出现的重复数据，可以传参刷制定数据</li></ul></li></ul></li><li>19.返回值<ul><li>a.函数最后返回值，不要在赋给一个变量，然后返回变量，尽量直接返回调用。</li></ul></li><li>20.变量<ul><li>a.and or用 &amp;&amp; ||来代替</li><li>b.函数最后调用不需要的变量，就不要在赋值</li><li>c.同一个变量使用多次，可以考虑使用const来定义</li></ul></li><li>21.清理代码<ul><li>a.清理代码就像做卫生，需要经常来做，而不是偶尔才搞一次</li></ul></li><li>22.前端重新请求数据问题。<ul><li>a.数据重新请求需要把对应的字段置空！</li></ul></li><li>23.前端循环。<ul><li>a.尽量用for of 循环，而不是用forEach</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python手册</title>
      <link href="man/python/index.html"/>
      <url>man/python/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="basic.html">基础</a></li><li><a href="os.html">操作系统</a></li><li><a href="thread.html">线程与进程</a></li><li><a href="net.html">网络</a></li><li><a href="class.html">面向对象</a></li><li><a href="async.html">异步</a></li><li><a href="lib.html">库</a></li><li><a href="lib-collection.html">库-集合</a></li><li><a href="lib-dbutils.html">库-DBUtils</a></li><li><a href="lib-nameko.html">库-nameko</a></li><li><a href="lib-pymysql.html">库-pymysql</a></li><li><a href="lib-redis.html">库-redis</a></li><li><a href="lib-sqlalchemy.html">库-sqlalchemy</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python异步</title>
      <link href="man/python/async.html"/>
      <url>man/python/async.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> loop.run_until_complete(hello())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line"> run()</span><br></pre></td></tr></table></figure><p>如果需要并发http请求怎么办呢，通常是用requests，但requests是同步的库，如果想异步的话需要引入aiohttp。这里引入一个类，from aiohttp import ClientSession，首先要建立一个session对象，然后用session对象去打开网页。session可以进行多项操作，比如post, get, put, head等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> response = <span class="keyword">await</span> response.read()</span><br><span class="line"> print(response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> loop.run_until_complete(hello(url))</span><br></pre></td></tr></table></figure><p>首先async def 关键字定义了这是个异步函数，await 关键字加在需要等待的操作前面，response.read()等待request响应，是个耗IO操作。然后使用ClientSession类发起http请求。<br>多链接异步访问<br>如果我们需要请求多个URL该怎么办呢，同步的做法访问多个URL只需要加个for循环就可以了。但异步的实现方式并没那么容易，在之前的基础上需要将hello()包装在asyncio的Future对象中，然后将Future对象列表作为任务传递给事件循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> response = <span class="keyword">await</span> response.read()</span><br><span class="line"><span class="comment"># print(response)</span></span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> task = asyncio.ensure_future(hello(url.format(i)))</span><br><span class="line"> tasks.append(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> run()</span><br><span class="line"> loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>好了，上面介绍了访问不同链接的异步实现方式，但是我们只是发出了请求，如果要把响应一一收集到一个列表中，最后保存到本地或者打印出来要怎么实现呢，可通过asyncio.gather(*tasks)将响应全部收集起来，具体通过下面实例来演示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"><span class="comment"># print(response)</span></span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> task = asyncio.ensure_future(hello(url.format(i)))</span><br><span class="line"> tasks.append(task)</span><br><span class="line"> result = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line"> print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> run()</span><br></pre></td></tr></table></figure><p>异常解决<br>假如你的并发达到2000个，程序会报错：ValueError: too many file descriptors in select()。报错的原因字面上看是 Python 调取的 select 对打开的文件有最大数量的限制，这个其实是操作系统的限制，linux打开文件的最大数默认是1024，windows默认是509，超过了这个值，程序就开始报错。这里我们有三种方法解决这个问题：<br>1.限制并发数量。（一次不要塞那么多任务，或者限制最大并发数量）<br>2.使用回调的方式。<br>3.修改操作系统打开文件数的最大限制，在系统里有个配置文件可以修改默认值，具体步骤不再说明了。<br>不修改系统默认配置的话，个人推荐限制并发数的方法，设置并发数为500，处理速度更快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> time,asyncio,aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.baidu.com/'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url,semaphore)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> semaphore = asyncio.Semaphore(<span class="number">500</span>) <span class="comment"># 限制并发量为500</span></span><br><span class="line"> to_get = [hello(url.format(),semaphore) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)] <span class="comment">#总共1000任务</span></span><br><span class="line"> <span class="keyword">await</span> asyncio.wait(to_get)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># now=lambda :time.time()</span></span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> loop.run_until_complete(run())</span><br><span class="line"> loop.close()</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-reids</title>
      <link href="man/python/lib-redis.html"/>
      <url>man/python/lib-redis.html</url>
      
        <content type="html"><![CDATA[<ul><li>批量删除Keys</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = redis_conn.keys(<span class="string">'iproxy:*'</span>)</span><br><span class="line">redis_conn.delete(*keys)</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="algorithms/basic.html"/>
      <url>algorithms/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础概念"><a href="#一、基础概念" class="headerlink" title="一、基础概念"></a>一、基础概念</h2><h3 id="1-复杂度"><a href="#1-复杂度" class="headerlink" title="1. 复杂度"></a>1. 复杂度</h3><p>时间和空间复杂度</p><p>认识对数器</p><p>如何分析递归过程的时间复杂度</p><h2 id="二、基本数据结构"><a href="#二、基本数据结构" class="headerlink" title="二、基本数据结构"></a>二、基本数据结构</h2><h3 id="2-1-链表"><a href="#2-1-链表" class="headerlink" title="2.1 链表"></a>2.1 链表</h3><p>插入和删除节点</p><p>反转</p><p>随机选择一个节点</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h4><p>1）哈希函数与哈希表<br>2）布隆过滤器详解<br>3）一致性哈希结构<br>4）并查集结构与应用（岛问题）</p><h2 id="三、树"><a href="#三、树" class="headerlink" title="三、树"></a>三、树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树结构</p><p>二叉树的递归与非递归遍历</p><p>搜索二叉树</p><p>平衡二叉树</p><p>二叉树节点的前驱节点与后继节点</p><h3 id="前缀树"><a href="#前缀树" class="headerlink" title="前缀树"></a>前缀树</h3><h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><h2 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h2><p>无环图、有环图</p><p>有向图、无向图</p><p>图结构的表示方法<br>图的深度优先遍历与宽度优先遍历</p><h2 id="五、基本算法"><a href="#五、基本算法" class="headerlink" title="五、基本算法"></a>五、基本算法</h2><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>选择</p><p>插入</p><p>归并</p><p>桶排序</p><p>计数排序</p><p>基数排序</p><p>堆结构与堆排序</p><h3 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h3><p>二分查找</p><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><h2 id="图算法"><a href="#图算法" class="headerlink" title="图算法"></a>图算法</h2><p>拓扑排序问题<br>最小生成树问题<br>单源最短路径问题</p><ul><li>A* 搜索算法<ul><li>图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。</li></ul></li><li>Dijkstra算法</li></ul><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h2 id="高低算法"><a href="#高低算法" class="headerlink" title="高低算法"></a>高低算法</h2><h3 id="KMP算法和Manacher算法"><a href="#KMP算法和Manacher算法" class="headerlink" title="KMP算法和Manacher算法"></a>KMP算法和Manacher算法</h3><p>1）KMP算法及其扩展面试题目<br>2）Manacher算法及其扩展面试题目</p><h3 id="窗口内最大值的更新结构和单调栈结构"><a href="#窗口内最大值的更新结构和单调栈结构" class="headerlink" title="窗口内最大值的更新结构和单调栈结构"></a>窗口内最大值的更新结构和单调栈结构</h3><p>1）窗口内最大值的更新结构<br>2）单调栈结构</p><h3 id="Morris遍历和sortedMap"><a href="#Morris遍历和sortedMap" class="headerlink" title="Morris遍历和sortedMap"></a>Morris遍历和sortedMap</h3><p>1）二叉树的Morris遍历<br>2）跳表结构<br>3）AVL树和红黑树结构</p><h2 id="分类算法"><a href="#分类算法" class="headerlink" title="分类算法"></a>分类算法</h2><ul><li>决策树的原理</li><li>支持向量机</li><li>逻辑斯蒂回归<br>聚类算法的理解</li><li>均值聚类，可选的参数，如果确定聚类个数</li><li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li></ul><h2 id="分布式算法"><a href="#分布式算法" class="headerlink" title="分布式算法"></a>分布式算法</h2><p>raft</p><p>paxos</p><p>文本相关</p><h2 id="加密安全算法"><a href="#加密安全算法" class="headerlink" title="加密安全算法"></a>加密安全算法</h2><ul><li>sha256</li><li>md5</li><li>RSA非对称加密算法</li><li>哈希安全算法(Secure Hash Algorithm)</li><li>整数质因子分解算法(Integer factorization)</li><li>Diffie-Hellman密钥交换算法<ul><li>一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。</li></ul></li><li>RSA<ul><li>公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。</li></ul></li></ul><h2 id="人工智能算法"><a href="#人工智能算法" class="headerlink" title="人工智能算法"></a>人工智能算法</h2><h4 id="C4-5算法。"><a href="#C4-5算法。" class="headerlink" title="C4.5算法。"></a>C4.5算法。</h4><ul><li>C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42395865" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42395865</a></li></ul><h4 id="CART算法。"><a href="#CART算法。" class="headerlink" title="CART算法。"></a>CART算法。</h4><ul><li>CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42558235" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42558235</a></li></ul><h4 id="KNN-K最近邻-算法。"><a href="#KNN-K最近邻-算法。" class="headerlink" title="KNN(K最近邻)算法。"></a>KNN(K最近邻)算法。</h4><ul><li>给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42613011" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42613011</a></li></ul><h4 id="Naive-Bayes-朴素贝叶斯-算法。"><a href="#Naive-Bayes-朴素贝叶斯-算法。" class="headerlink" title="Naive Bayes(朴素贝叶斯)算法。"></a>Naive Bayes(朴素贝叶斯)算法。</h4><ul><li>朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。</a></li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42680161" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42680161</a></li></ul><h4 id="SVM-支持向量机-算法。"><a href="#SVM-支持向量机-算法。" class="headerlink" title="SVM(支持向量机)算法。"></a>SVM(支持向量机)算法。</h4><ul><li>支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42780439" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42780439</a></li></ul><h4 id="EM-期望最大化-算法。"><a href="#EM-期望最大化-算法。" class="headerlink" title="EM(期望最大化)算法。"></a>EM(期望最大化)算法。</h4><ul><li>期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42921789" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42921789</a></li></ul><h4 id="Apriori算法。"><a href="#Apriori算法。" class="headerlink" title="Apriori算法。"></a>Apriori算法。</h4><ul><li>Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43059211" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43059211</a></li></ul><h4 id="FP-Tree-频繁模式树-算法。"><a href="#FP-Tree-频繁模式树-算法。" class="headerlink" title="FP-Tree(频繁模式树)算法。"></a>FP-Tree(频繁模式树)算法。</h4><ul><li>这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43234309" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43234309</a></li></ul><h4 id="PageRank-网页重要性-排名-算法。"><a href="#PageRank-网页重要性-排名-算法。" class="headerlink" title="PageRank(网页重要性/排名)算法。"></a>PageRank(网页重要性/排名)算法。</h4><ul><li>PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link Span攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li></ul><h4 id="HITS算法。"><a href="#HITS算法。" class="headerlink" title="HITS算法。"></a>HITS算法。</h4><ul><li>HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li></ul><h4 id="K-Means-K均值-算法。"><a href="#K-Means-K均值-算法。" class="headerlink" title="K-Means(K均值)算法。"></a>K-Means(K均值)算法。</h4><ul><li>K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43373159" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43373159</a></li></ul><h4 id="BIRCH算法。"><a href="#BIRCH算法。" class="headerlink" title="BIRCH算法。"></a>BIRCH算法。</h4><ul><li>BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43532111" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43532111</a></li></ul><h4 id="AdaBoost算法。"><a href="#AdaBoost算法。" class="headerlink" title="AdaBoost算法。"></a>AdaBoost算法。</h4><ul><li>AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43635115" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43635115</a></li></ul><h4 id="GSP算法。"><a href="#GSP算法。" class="headerlink" title="GSP算法。"></a>GSP算法。</h4><ul><li>GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43699083" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43699083</a></li></ul><h4 id="PreFixSpan算法。"><a href="#PreFixSpan算法。" class="headerlink" title="PreFixSpan算法。"></a>PreFixSpan算法。</h4><ul><li>PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43766253" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43766253</a></li></ul><h4 id="CBA-基于关联规则分类-算法。"><a href="#CBA-基于关联规则分类-算法。" class="headerlink" title="CBA(基于关联规则分类)算法。"></a>CBA(基于关联规则分类)算法。</h4><ul><li>CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43818787" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43818787</a></li></ul><h4 id="RoughSets-粗糙集-算法。"><a href="#RoughSets-粗糙集-算法。" class="headerlink" title="RoughSets(粗糙集)算法。"></a>RoughSets(粗糙集)算法。</h4><ul><li>粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43876001" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43876001</a></li></ul><h4 id="gSpan算法。"><a href="#gSpan算法。" class="headerlink" title="gSpan算法。"></a>gSpan算法。</h4><ul><li>gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/4392427" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/4392427</a></li></ul><h3 id="textrank"><a href="#textrank" class="headerlink" title="textrank"></a>textrank</h3><ul><li>自动提取文本摘要</li></ul><h2 id="其他算法"><a href="#其他算法" class="headerlink" title="其他算法"></a>其他算法</h2><ul><li>傅立叶变换<ul><li>实现时间域函数与频率域函数之间的相互转化</li></ul></li><li>快速傅立叶变换</li><li>代克思托演算法 (Dijkstra’s algorithm)<ul><li>解决最短路径问题</li></ul></li><li>集束搜索（又名定向搜索，Beam Search）<ul><li>最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。</li></ul></li><li>分支界定算法（Branch and Bound）<ul><li>在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。</li></ul></li><li>Buchberger算法<ul><li>一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化</li></ul></li><li>离散微分算法（Discrete differentiation）</li><li>欧几里得算法（Euclidean algorithm）<ul><li>计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。</li></ul></li><li>期望-最大算法（Expectation-maximization algorithm，又名EM-Training）<ul><li>在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。</li></ul></li><li>梯度下降（Gradient descent）<ul><li>一种数学上的最优化算法。</li></ul></li><li>Karatsuba乘法<ul><li>需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。</li></ul></li><li>LLL算法（Lenstra-Lenstra-Lovasz  lattice reduction）<ul><li>以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。</li></ul></li><li>最大流量算法（Maximum flow）<ul><li>该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。</li></ul></li><li>牛顿法（Newton’s method）<ul><li>求非线性方程（组）零点的一种重要的迭代法。</li></ul></li><li>Q-learning学习算法<ul><li>这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。</li></ul></li><li>两次筛法（Quadratic Sieve）<ul><li>现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。</li></ul></li><li>RANSAC<ul><li>是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。</li></ul></li><li>Schönhage-Strassen算法<ul><li>在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。</li></ul></li><li>单纯型算法（Simplex Algorithm）<ul><li>在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。</li></ul></li><li>奇异值分解（Singular value decomposition，简称SVD）<ul><li>在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。</li></ul></li><li>求解线性方程组（Solving a system of linear equations）<ul><li>线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</li></ul></li><li>Strukturtensor算法<ul><li>应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。</li></ul></li><li>合并查找算法（Union-find）<ul><li>给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：<ul><li>查找：判断某特定元素属于哪个组。</li><li>合并：联合或合并两个组为一个组。</li></ul></li></ul></li><li>维特比算法（Viterbi algorithm）<ul><li>寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。</li></ul></li><li>链接分析算法(Link Analysis)</li><li>比例微积分算法(Proportional Integral Derivative Algorithm)</li><li>数据压缩算法</li><li>随机数生成算法</li><li>推荐算法</li><li>决策树算法</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础面试</title>
      <link href="interview/cs/basic.html"/>
      <url>interview/cs/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-对于软件运行机制的理解。"><a href="#1-对于软件运行机制的理解。" class="headerlink" title="1.对于软件运行机制的理解。"></a>1.对于软件运行机制的理解。</h3><ul><li>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。</li><li>冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</li><li>具体的工作流程是<ul><li>1.在控制器指挥下，从存储器上取出指令；</li><li>2.分析指令，得到计算命令和待操作的数；</li><li>3.从存储器上取出待计算的数放入运算器；</li><li>4.运算器计算结果；</li><li>5.输出到存储器或输出设备。</li></ul></li></ul><h3 id="2-对于好的代码架构的理解？或者好的代码结构是怎样的？"><a href="#2-对于好的代码架构的理解？或者好的代码结构是怎样的？" class="headerlink" title="2.对于好的代码架构的理解？或者好的代码结构是怎样的？"></a>2.对于好的代码架构的理解？或者好的代码结构是怎样的？</h3><ul><li>高内聚、低耦合</li><li>易扩展，维护方便</li><li>避免过度设计</li><li>可读性高，结构清晰</li><li>代码风格统一</li><li>低复杂性，简练</li></ul><h3 id="3-对于编码规范的理解，有哪些好的编程规范"><a href="#3-对于编码规范的理解，有哪些好的编程规范" class="headerlink" title="3.对于编码规范的理解，有哪些好的编程规范"></a>3.对于编码规范的理解，有哪些好的编程规范</h3><ul><li>变量命名规范</li><li>代码缩进规范</li><li>大小写规范</li><li>注释规范</li><li>可读性强</li></ul><h3 id="4-编程安全应该注意哪些问题"><a href="#4-编程安全应该注意哪些问题" class="headerlink" title="4.编程安全应该注意哪些问题"></a>4.编程安全应该注意哪些问题</h3><ul><li>表单数据验证</li><li>防范SQL语句注入攻击</li><li>程序资源的释放。例如内存泄漏、数据库连接、文件句柄等资源</li><li>线程安全性</li><li>数据类型校验</li></ul><h3 id="5-如何提升开发效率？提升开发效率的方法有哪些？"><a href="#5-如何提升开发效率？提升开发效率的方法有哪些？" class="headerlink" title="5.如何提升开发效率？提升开发效率的方法有哪些？"></a>5.如何提升开发效率？提升开发效率的方法有哪些？</h3><ul><li>大显示器</li><li>机械键盘</li><li>编辑器快捷键</li><li>快速文档查询能力</li><li>需求的准确理解，防止可能的返工</li></ul><h3 id="6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"><a href="#6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？" class="headerlink" title="6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"></a>6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</h3><ul><li>保证开发结果与需求相符</li><li>保证代码的正确性、可靠性</li><li>新的功能是否影响旧有的功能</li></ul><h3 id="7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"><a href="#7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？" class="headerlink" title="7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"></a>7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</h3><p>对于软件运行机制的理解。</p><ul><li><p>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</p></li><li><p>具体的工作流程是</p><ul><li>1在控制器指挥下，从存储器上取出指令；</li><li>2分析指令，得到计算命令和待操作的数；</li><li>3从存储器上取出待计算的数放入运算器；</li><li>4运算器计算结果；</li><li>5输出到存储器或输出设备。</li></ul></li><li><p>因此存储器是关键。存储器分为：寄存器（CPU内部，用于存放待操作数和结果）；高速缓存（通常在CPU内部，用做数据缓冲区）；内存；外存。</p></li><li><p>接下来是具体的命令执行，这需要预先定义好CPU能执行的命令，即CPU的指令集，用来计算和控制计算机系统的一套指令的集合，典型的有Intel X86指令集和ARM指令集。具体的指令以二进制码表示，包含一个或多个字节，也包含指令码（具体命令）和操作数（要操作的数或地址）。在具体的执行中，把宏观层次的命令转换为满足指令集要求的二进制代码，然后才能在计算机上运行；参见CPU的具体组成成分运算器 ALU和寄存器和控制器的工作流程。</p></li><li><p>最后程序的执行就是在以上基础进行的，一开始使用机器语言的时候，具体的命令形式是1001010101010011 00011110这样的。这个虽然足够底层能够直接与计算机进行交互，但不是一般人能够搞得定的，于是就有更高层次的抽象，汇编语言，变成add 0 1这种相对来说比较友好的语言；接着就是高级语言了，更加抽象，但接近我们一般人的思维习惯，如d = a*b+c;当然，这是前人的工作成果，他们把很多的细节封装起来，我们这些后人之间调用就行，不用管其具体的转换即具体的编译，不然一句程序有可能转换为多句指令，而且其执行的次序和次数之类的细节，各种内存地址和数据的调用足够使人发疯。</p></li></ul><pre><code>### 8.对于设计模式的理解，为什么要有设计模式，用过什么设计模式，每个的应用场景是怎样的？设计模式主要分三个类型:创建型、结构型和行为型。* 创建型：  * 一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 。应用场景：一个无状态的类使用单例模式节省内存资源。  * 二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。 应用场景：一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。  * 三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。     应用场景：由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义 一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟  *  四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。  * 五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。    应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限* 行为型：  * 六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。 应用场景：迭代。  * 七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。应用场景： 某个实例的变化将影响其他多个对象。  *  八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。    应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类  *  九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。    应用场景：将命令者与执行者完全解耦。  *  十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。    应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。  * 十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。       应用场景：  * 十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关  *  十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。  * 十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。  * 十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。  * 十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。* 结构型：  * 十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。  * 十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。  * 十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问  * 二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。  * 二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。  * 二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化  * 二十三、Flyweight，享元模式</code></pre><h3 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h3>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>负载平衡</title>
      <link href="architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E6%96%87%E6%A1%A3.html"/>
      <url>architecture/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/%E6%96%87%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[<p>概念</p><ul><li>不能狭义地理解为分配给所有实际服务器一样多的工作量，因为多台服务器的承载能力各不相同，这可能体现在硬件配置、网络带宽的差异，也可能因为某台服务器身兼多职，我们所说的“均衡”，也就是希望所有服务器都不要过载，并且能够最大程序地发挥作用。</li></ul><p>实现方式<br>一、http重定向</p><p>当http代理（比如浏览器）向web服务器请求某个URL后，web服务器可以通过http响应头信息中的Location标记来返回一个新的URL。这意味着HTTP代理需要继续请求这个新的URL，完成自动跳转。</p><p>性能缺陷：</p><ul><li>1、吞吐率限制<ul><li>主站点服务器的吞吐率平均分配到了被转移的服务器。现假设使用RR（Round Robin）调度策略，子服务器的最大吞吐率为1000reqs/s，那么主服务器的吞吐率要达到3000reqs/s才能完全发挥三台子服务器的作用，那么如果有100台子服务器，那么主服务器的吞吐率可想而知得有大？相反，如果主服务的最大吞吐率为6000reqs/s，那么平均分配到子服务器的吞吐率为2000reqs/s，而现子服务器的最大吞吐率为1000reqs/s，因此就得增加子服务器的数量，增加到6个才能满足。</li></ul></li><li>2、重定向访问深度不同<ul><li>有的重定向一个静态页面，有的重定向相比复杂的动态页面，那么实际服务器的负载差异是不可预料的，而主站服务器却一无所知。因此整站使用重定向方法做负载均衡不太好。</li></ul></li></ul><p>我们需要权衡转移请求的开销和处理实际请求的开销，前者相对于后者越小，那么重定向的意义就越大，例如下载。你可以去很多镜像下载网站试下，会发现基本下载都使用了Location做了重定向。</p><p>二、DNS负载均衡</p><p>DNS负责提供域名解析服务，当访问某个站点时，实际上首先需要通过该站点域名的DNS服务器来获取域名指向的IP地址，在这一过程中，DNS服务器完成了域名到IP地址的映射，同样，这样映射也可以是一对多的，这时候，DNS服务器便充当了负载均衡调度器，它就像http重定向转换策略一样，将用户的请求分散到多台服务器上，但是它的实现机制完全不同。</p><p>相比http重定向，基于DNS的负载均衡完全节省了所谓的主站点，或者说DNS服务器已经充当了主站点的职能。但不同的是，作为调度器，DNS服务器本身的性能几乎不用担心。因为DNS记录可以被用户浏览器或者互联网接入服务商的各级DNS服务器缓存，只有当缓存过期后才会重新向域名的DNS服务器请求解析。也说是DNS不存在http的吞吐率限制，理论上可以无限增加实际服务器的数量。</p><p>特性:</p><ul><li>1、可以根据用户IP来进行智能解析。DNS服务器可以在所有可用的A记录中寻找离用记最近的一台服务器。</li><li>2、动态DNS：在每次IP地址变更时，及时更新DNS服务器。当然，因为缓存，一定的延迟不可避免。</li></ul><p>不足：</p><ul><li>1、没有用户能直接看到DNS解析到了哪一台实际服务器，加服务器运维人员的调试带来了不便。</li><li>2、策略的局限性。例如你无法将HTTP请求的上下文引入到调度策略中，而在前面介绍的基于HTTP重定向的负载均衡系统中，调度器工作在HTTP层面，它可以充分理解HTTP请求后根据站点的应用逻辑来设计调度策略，比如根据请求不同的URL来进行合理的过滤和转移。</li><li>3、如果要根据实际服务器的实时负载差异来调整调度策略，这需要DNS服务器在每次解析操作时分析各服务器的健康状态，对于DNS服务器来说，这种自定义开发存在较高的门槛，更何况大多数站点只是使用第三方DNS服务。</li><li>4、DNS记录缓存，各级节点的DNS服务器不同程序的缓存会让你晕头转向。</li><li>5、基于以上几点，DNS服务器并不能很好地完成工作量均衡分配，最后，是否选择基于DNS的负载均衡方式完全取决于你的需要。</li></ul><p>三、反向代理负载均衡</p><p>这个肯定大家都有所接触，因为几乎所有主流的Web服务器都热衷于支持基于反向代理的负载均衡。它的核心工作就是转发HTTP请求。</p><p>相比前面的HTTP重定向和DNS解析，反向代理的调度器扮演的是用户和实际服务器中间人的角色：</p><ul><li>1、任何对于实际服务器的HTTP请求都必须经过调度器</li><li>2、调度器必须等待实际服务器的HTTP响应，并将它反馈给用户（前两种方式不需要经过调度反馈，是实际服务器直接发送给用户）</li></ul><p>特性：</p><ul><li>1、调度策略丰富。例如可以为不同的实际服务器设置不同的权重，以达到能者多劳的效果。</li><li>2、对反向代理服务器的并发处理能力要求高，因为它工作在HTTP层面。</li><li>3、反向代理服务器进行转发操作本身是需要一定开销的，比如创建线程、与后端服务器建立TCP连接、接收后端服务器返回的处理结果、分析HTTP头部信息、用户空间和内核空间的频繁切换等，虽然这部分时间并不长，但是当后端服务器处理请求的时间非常短时，转发的开销就显得尤为突出。例如请求静态文件，更适合使用前面介绍的基于DNS的负载均衡方式。</li><li>4、反向代理服务器可以监控后端服务器，比如系统负载、响应时间、是否可用、TCP连接数、流量等，从而根据这些数据调整负载均衡的策略。</li><li>5、反射代理服务器可以让用户在一次会话周期内的所有请求始终转发到一台特定的后端服务器上（粘滞会话），这样的好处一是保持session的本地访问，二是防止后端服务器的动态内存缓存的资源浪费。</li></ul><p>四、IP负载均衡(LVS-NAT)</p><p>因为反向代理服务器工作在HTTP层，其本身的开销就已经严重制约了可扩展性，从而也限制了它的性能极限。那能否在HTTP层面以下实现负载均衡呢？</p><p>NAT服务器:它工作在传输层，它可以修改发送来的IP数据包，将数据包的目标地址修改为实际服务器地址。</p><p>从Linux2.4内核开始，其内置的Neftilter模块在内核中维护着一些数据包过滤表，这些表包含了用于控制数据包过滤的规则。可喜的是，Linux提供了iptables来对过滤表进行插入、修改和删除等操作。更加令人振奋的是，Linux2.6.x内核中内置了IPVS模块，它的工作性质类型于Netfilter模块，不过它更专注于实现IP负载均衡。</p><p>想知道你的服务器内核是否已经安装了IPVS模块，可以</p><p>有输出意味着IPVS已经安装了。IPVS的管理工具是ipvsadm，它为提供了基于命令行的配置界面，可以通过它快速实现负载均衡系统。这就是大名鼎鼎的LVS(Linux Virtual Server，Linux虚拟服务器)。</p><p>1、打开调度器的数据包转发选项</p><p>echo 1 &gt; /proc/sys/net/ipv4/ip_forward</p><p>2、检查实际服务器是否已经将NAT服务器作为自己的默认网关，如果不是，如添加</p><p>route add default gw xx.xx.xx.xx</p><p>3、使用ipvsadm配置</p><p>ipvsadm -A -t 111.11.11.11:80 -s rr</p><p>添加一台虚拟服务器，-t 后面是服务器的外网ip和端口，-s rr是指采用简单轮询的RR调度策略（这属于静态调度策略，除此之外，LVS还提供了系列的动态调度策略，比如最小连接（LC）、带权重的最小连接（WLC），最短期望时间延迟（SED）等）</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.210:8000 -m</p><p>ipvsadm -a -t 111.11.11.11:80 -r 10.10.120.211:8000 -m</p><p>添加两台实际服务器（不需要有外网ip），-r后面是实际服务器的内网ip和端口，-m表示采用NAT方式来转发数据包<br>运行ipvsadm -L -n可以查看实际服务器的状态。这样就大功告成了。</p><p>实验证明使用基于NAT的负载均衡系统。作为调度器的NAT服务器可以将吞吐率提升到一个新的高度，几乎是反向代理服务器的两倍以上，这大多归功于在内核中进行请求转发的较低开销。但是一旦请求的内容过大时，不论是基于反向代理还是NAT，负载均衡的整体吞吐量都差距不大，这说明对于一睦开销较大的内容，使用简单的反向代理来搭建负载均衡系统是值考虑的。</p><p>这么强大的系统还是有它的瓶颈，那就是NAT服务器的网络带宽，包括内部网络和外部网络。当然如果你不差钱，可以去花钱去购买千兆交换机或万兆交换机，甚至负载均衡硬件设备，但如果你是个屌丝，咋办？</p><p>一个简单有效的办法就是将基于NAT的集群和前面的DNS混合使用，比如５个100Mbps出口宽带的集群，然后通过DNS来将用户请求均衡地指向这些集群，同时，你还可以利用DNS智能解析实现地域就近访问。这样的配置对于大多数业务是足够了，但是对于提供下载或视频等服务的大规模站点，NAT服务器还是不够出色。</p><p>五、直接路由(LVS-DR)</p><p>NAT是工作在网络分层模型的传输层（第四层），而直接路由是工作在数据链路层（第二层），貌似更屌些。它通过修改数据包的目标MAC地址（没有修改目标IP），将数据包转发到实际服务器上，不同的是，实际服务器的响应数据包将直接发送给客户羰，而不经过调度器。</p><p>1、网络设置</p><p>这里假设一台负载均衡调度器，两台实际服务器，购买三个外网ip，一台机一个，三台机的默认网关需要相同，最后再设置同样的ip别名，这里假设别名为10.10.120.193。这样一来，将通过10.10.120.193这个IP别名来访问调度器，你可以将站点的域名指向这个IP别名。</p><p>2、将ip别名添加到回环接口lo上<br>这是为了让实际服务器不要去寻找其他拥有这个IP别名的服务器，在实际服务器中运行：</p><p>另外还要防止实际服务器响应来自网络中针对IP别名的ARP广播，为此还要执行：</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/lo/arp_ignore</p><p>echo “2” &gt; /proc/sys/net/ipv4/conf/lo/arp_announce</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_ignore</p><p>echo “1” &gt; /proc/sys/net/ipv4/conf/all/arp_announce</p><p>配置完了就可以使用ipvsadm配置LVS-DR集群了</p><p>ipvsadm -A -t 10.10.120.193:80 -s rr</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.210:8000 -g</p><p>ipvsadm -a -t 10.10.120.193:80 -r 10.10.120.211:8000 -g</p><p>-g 就意味着使用直接路由的方式转发数据包</p><p>LVS-DR 相较于LVS-NAT的最大优势在于LVS-DR不受调度器宽带的限制，例如假设三台服务器在WAN交换机出口宽带都限制为10Mbps，只要对于连接调度器和两台实际服务器的LAN交换机没有限速，那么，使用LVS-DR理论上可以达到20Mbps的最大出口宽带，因为它的实际服务器的响应数据包可以不经过调度器而直接发往用户端啊，所以它与调度器的出口宽带没有关系，只能自身的有关系。而如果使用LVS-NAT，集群只能最大使用10Mbps的宽带。所以，越是响应数据包远远超过请求数据包的服务，就越应该降低调度器转移请求的开销，也就越能提高整体的扩展能力，最终也就越依赖于WAN出口宽带。</p><p>总的来说，LVS-DR适合搭建可扩展的负载均衡系统，不论是Web服务器还是文件服务器，以及视频服务器，它都拥有出色的性能。前提是你必须为实际器购买一系列的合法IP地址。</p><p>六、IP隧道(LVS-TUN)</p><p>基于IP隧道的请求转发机制：将调度器收到的IP数据包封装在一个新的IP数据包中，转交给实际服务器，然后实际服务器的响应数据包可以直接到达用户端。目前Linux大多支持，可以用LVS来实现，称为LVS-TUN，与LVS-DR不同的是，实际服务器可以和调度器不在同一个WANt网段，调度器通过IP隧道技术来转发请求到实际服务器，所以实际服务器也必须拥有合法的IP地址。</p><p>总体来说，LVS-DR和LVS-TUN都适合响应和请求不对称的Web服务器，如何从它们中做出选择，取决于你的网络部署需要，因为LVS-TUN可以将实际服务器根据需要部署在不同的地域，并且根据就近访问的原则来转移请求，所以有类似这种需求的，就应该选择LVS-TUN</p><p>案例<br>1.haproxy负载TiDB</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="interview/cs/os.html"/>
      <url>interview/cs/os.html</url>
      
        <content type="html"><![CDATA[<h3 id="core文件是什么，有什么用？"><a href="#core文件是什么，有什么用？" class="headerlink" title="core文件是什么，有什么用？"></a>core文件是什么，有什么用？</h3><ul><li>core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</li></ul><h3 id="什么是core-dump"><a href="#什么是core-dump" class="headerlink" title="什么是core dump"></a>什么是core dump</h3><ul><li>Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容出来生成的，它可以做为调试程序的参考.</li><li>core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。</li><li>如何使用core文件<ul><li>gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 哪个函数中.</li></ul></li></ul><h3 id="为什么没有core文件生成呢"><a href="#为什么没有core文件生成呢" class="headerlink" title="为什么没有core文件生成呢?"></a>为什么没有core文件生成呢?</h3><ul><li>core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.</li><li>ulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号</li></ul><h3 id="不用core文件，程序出了问题产生信号是否知道？"><a href="#不用core文件，程序出了问题产生信号是否知道？" class="headerlink" title="不用core文件，程序出了问题产生信号是否知道？"></a>不用core文件，程序出了问题产生信号是否知道？</h3><ul><li>内核向进程发信号嘛。</li></ul><h3 id="共享内存除了文件映射还有什么方式？二者有什么区别"><a href="#共享内存除了文件映射还有什么方式？二者有什么区别" class="headerlink" title="共享内存除了文件映射还有什么方式？二者有什么区别"></a>共享内存除了文件映射还有什么方式？二者有什么区别</h3><ul><li>共享内存对象映射。</li><li>区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</li></ul><h3 id="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"><a href="#请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc" class="headerlink" title="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"></a>请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc</h3><ul><li>top：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</li><li>ps：查看进程</li><li>mv：移动或者更改文件</li><li>find：在子目录中搜索匹配的文件</li><li>df：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。</li><li>cat：把一个或多个文件内容显示到标准输出</li><li>chmod：改变文件属性</li><li>chgrp：改变用户分组</li><li>grep：在文件内进行搜索</li><li>wc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</li></ul><h3 id="Linux文件属性有哪些？（共十位）"><a href="#Linux文件属性有哪些？（共十位）" class="headerlink" title="Linux文件属性有哪些？（共十位）"></a>Linux文件属性有哪些？（共十位）</h3><ul><li>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</li><li>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录 （directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</li><li>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</li><li>一个文件aaa具有完全空的权限- — — —。<ul><li>chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</li><li>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</li><li>chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</li></ul></li><li>如果aaa具有满权限- rwx rwx rwx。<ul><li>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</li></ul></li><li>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<ul><li>chmod u=rwx，go=rx aaa</li></ul></li></ul><h3 id="linux查询命令"><a href="#linux查询命令" class="headerlink" title="linux查询命令"></a>linux查询命令</h3><ul><li>find / -name “文件名”    在目录结构中搜索文件，并执行指定的操作。</li><li>grep</li><li>local 文件名  —他是 ‘find -name’ 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</li><li>whereis —是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li><li>which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li></ul><h3 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h3><ul><li>select<ul><li>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</li><li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</li><li>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</li><li>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</li></ul></li><li>poll<ul><li>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</li><li>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li><li>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</li></ul></li><li>epoll<ul><li>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</li><li>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</li><li>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术这样  彻底省掉了 这些文件描述符在系统调用时复制的开销。</li><li>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callbac的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li></ul></li></ul><h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h3><ul><li><ol><li>内存的页面置换算法</li></ol></li><li><ol start="2"><li>进程调度算法</li></ol></li><li><ol start="3"><li>进程间通信方式</li></ol></li><li><ol start="4"><li>进程和线程定义，区别和联系</li></ol></li><li><ol start="5"><li>进程之间的通信</li></ol></li><li><ol start="6"><li>父子进程、孤儿进程</li></ol></li><li><ol start="7"><li>fork进程时的操作，</li></ol></li><li><ol start="11"><li>硬链接和软连接区别</li></ol></li><li><ol start="12"><li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li></ol></li><li><ol start="13"><li>linux用过的命令</li></ol></li><li><ol start="14"><li>系统管理命令（如查看内存使用、网络情况）</li></ol></li><li><ol start="15"><li>管道的使用 |</li></ol></li><li><ol start="16"><li>grep的使用，一定要掌握，每次都会问在文件中查找</li></ol></li><li><ol start="17"><li>shell脚本</li></ol></li><li><ol start="19"><li>awk使用</li></ol></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题</title>
      <link href="interview/frontend/js.html"/>
      <url>interview/frontend/js.html</url>
      
        <content type="html"><![CDATA[<ul><li>基本数据类型？<ul><li>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li></ul></li><li>介绍js有哪些内置对象？<ul><li>Object 是 JavaScript 中所有对象的父对象</li><li>数据封装类对象：Object、Array、Boolean、Number 和 String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li></ul></li><li>null，undefined 的区别？<ul><li>null         表示一个对象是“没有值”的值，也就是值为“空”；</li><li>undefined     表示一个变量声明了没有初始化(赋值)；</li><li>undefined不是一个有效的JSON，而null是；</li><li>undefined的类型(typeof)是undefined；</li><li>null的类型(typeof)是object；</li><li>Javascript将未赋值的变量默认值设为undefined；</li><li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</li><li>注意：<ul><li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li><li>null == undefined // true</li><li>null === undefined // false</li></ul></li></ul></li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>//使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：<br>let obj = {};<br>let arr = [];<br>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>//从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br>let obj = {};<br>let arr = [];<br>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]<br>//而 [] === false 是返回 false 的。</li><li></li></ul><ul><li><h4 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h4><ul><li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li><li>两种类型的区别是：存储位置不同；<ul><li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li></ul></li></ul></li><li><h4 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h4><ul><li>parseFloat(‘12.3b’);</li><li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li><li>如何验证非空</li></ul></li><li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li><li><h4 id="异步与同步请求如何实现？"><a href="#异步与同步请求如何实现？" class="headerlink" title="异步与同步请求如何实现？"></a>异步与同步请求如何实现？</h4></li><li><h4 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h4><ul><li>window对象是指浏览器打开的窗口。</li><li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</li></ul></li><li><h4 id="cookie-和session-的区别？"><a href="#cookie-和session-的区别？" class="headerlink" title="cookie 和session 的区别？"></a>cookie 和session 的区别？</h4><ul><li>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li><li>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>5.所以个人建议：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li></ul></li><li><h4 id="cookie、sessionStorage、localStorage区别？"><a href="#cookie、sessionStorage、localStorage区别？" class="headerlink" title="cookie、sessionStorage、localStorage区别？"></a>cookie、sessionStorage、localStorage区别？</h4><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li><h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><ul><li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</li><li>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</li><li>指一段脚本只能读取来自同一来源的窗口和文档的属性。</li></ul></li><li><h4 id="如何判断在数组中是否存在"><a href="#如何判断在数组中是否存在" class="headerlink" title="如何判断在数组中是否存在"></a>如何判断在数组中是否存在</h4>indexOf</li><li><h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><ul><li>使用instanceof</li></ul></li><li><h4 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h4></li><li><h4 id="数组转字符串-join-；字符串转数组-split-‘’"><a href="#数组转字符串-join-；字符串转数组-split-‘’" class="headerlink" title="数组转字符串(join)；字符串转数组(split(‘’))"></a>数组转字符串(join)；字符串转数组(split(‘’))</h4></li><li><h4 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h4>*(1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>*（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>*（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>*（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>*（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>*（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>*（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br>*（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<ul><li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</li></ul></li><li><h4 id="jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4></li><li><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><ul><li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li></ul></li><li><h4 id="axios有哪些方法、参数？"><a href="#axios有哪些方法、参数？" class="headerlink" title="axios有哪些方法、参数？"></a>axios有哪些方法、参数？</h4></li><li><h4 id="ajax请求头部携带cookie"><a href="#ajax请求头部携带cookie" class="headerlink" title="ajax请求头部携带cookie"></a>ajax请求头部携带cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">axios.defaults.withCredentials&#x3D;true;&#x2F;&#x2F;让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios &#x3D; axios;</span><br></pre></td></tr></table></figure></li></ul><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ul><li><h4 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h4></li><li><h4 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h4><ul><li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</li></ul></li><li><h4 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h4><ul><li>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</li></ul></li><li><h4 id="组件的生命周期有哪些？"><a href="#组件的生命周期有哪些？" class="headerlink" title="组件的生命周期有哪些？"></a>组件的生命周期有哪些？</h4><ul><li>组件的声明周期有三种阶段，一种是初始化阶段（Mounting），一种是更新阶段（Updating）最后一种是析构阶段（Unmounting）。而这两个阶段的声明周期函数都是相似且有一一对应的关系的</li></ul></li><li><h4 id="什么时候使用-Class-Component-而非-Functional-Component"><a href="#什么时候使用-Class-Component-而非-Functional-Component" class="headerlink" title="什么时候使用 Class Component 而非 Functional Component?"></a>什么时候使用 Class Component 而非 Functional Component?</h4><ul><li>如果你的组件有state或者使用了生命周期函数，那么请使用Class component。 否则，使用Functional component。</li></ul></li><li>什么是keys 而且为什么他们很重要<ul><li>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li></ul></li></ul><ul><li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul><li>1）创建新节点<ul><li>createDocumentFragment() //创建一个DOM</li><li>createElement() //创建一个具体的</li><li>createTextNode() //创建一个文本节点</li></ul></li><li>2）添加、移除、替换、插入<ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //并没有insertAfter()</li></ul></li><li>3）查找<ul><li>getElementsByTagName() //通过标签名</li><li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li><li>getElementById() //通过元素Id，唯一性</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%89%8D%E7%AB%AF/js.html"/>
      <url>interview/%E5%89%8D%E7%AB%AF/js.html</url>
      
        <content type="html"><![CDATA[<ul><li>基本数据类型？<ul><li>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li></ul></li><li>介绍js有哪些内置对象？<ul><li>Object 是 JavaScript 中所有对象的父对象</li><li>数据封装类对象：Object、Array、Boolean、Number 和 String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li></ul></li><li>null，undefined 的区别？<ul><li>null         表示一个对象是“没有值”的值，也就是值为“空”；</li><li>undefined     表示一个变量声明了没有初始化(赋值)；</li><li>undefined不是一个有效的JSON，而null是；</li><li>undefined的类型(typeof)是undefined；</li><li>null的类型(typeof)是object；</li><li>Javascript将未赋值的变量默认值设为undefined；</li><li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</li><li>注意：<ul><li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li><li>null == undefined // true</li><li>null === undefined // false</li></ul></li></ul></li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>//使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：<br>let obj = {};<br>let arr = [];<br>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>//从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br>let obj = {};<br>let arr = [];<br>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]<br>//而 [] === false 是返回 false 的。</li><li></li></ul><ul><li><h4 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h4><ul><li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li><li>两种类型的区别是：存储位置不同；<ul><li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li></ul></li></ul></li><li><h4 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h4><ul><li>parseFloat(‘12.3b’);</li><li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li><li>如何验证非空</li></ul></li><li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li><li><h4 id="异步与同步请求如何实现？"><a href="#异步与同步请求如何实现？" class="headerlink" title="异步与同步请求如何实现？"></a>异步与同步请求如何实现？</h4></li><li><h4 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h4><ul><li>window对象是指浏览器打开的窗口。</li><li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</li></ul></li><li><h4 id="cookie-和session-的区别？"><a href="#cookie-和session-的区别？" class="headerlink" title="cookie 和session 的区别？"></a>cookie 和session 的区别？</h4><ul><li>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li><li>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>5.所以个人建议：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li></ul></li><li><h4 id="cookie、sessionStorage、localStorage区别？"><a href="#cookie、sessionStorage、localStorage区别？" class="headerlink" title="cookie、sessionStorage、localStorage区别？"></a>cookie、sessionStorage、localStorage区别？</h4><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li><h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><ul><li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</li><li>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</li><li>指一段脚本只能读取来自同一来源的窗口和文档的属性。</li></ul></li><li><h4 id="如何判断在数组中是否存在"><a href="#如何判断在数组中是否存在" class="headerlink" title="如何判断在数组中是否存在"></a>如何判断在数组中是否存在</h4>indexOf</li><li><h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><ul><li>使用instanceof</li></ul></li><li><h4 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h4></li><li><h4 id="数组转字符串-join-；字符串转数组-split-‘’"><a href="#数组转字符串-join-；字符串转数组-split-‘’" class="headerlink" title="数组转字符串(join)；字符串转数组(split(‘’))"></a>数组转字符串(join)；字符串转数组(split(‘’))</h4></li><li><h4 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h4>*(1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>*（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>*（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>*（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>*（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>*（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>*（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br>*（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<ul><li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</li></ul></li><li><h4 id="jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4></li><li><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><ul><li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li></ul></li><li><h4 id="axios有哪些方法、参数？"><a href="#axios有哪些方法、参数？" class="headerlink" title="axios有哪些方法、参数？"></a>axios有哪些方法、参数？</h4></li><li><h4 id="ajax请求头部携带cookie"><a href="#ajax请求头部携带cookie" class="headerlink" title="ajax请求头部携带cookie"></a>ajax请求头部携带cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &#39;axios&#39;</span><br><span class="line">axios.defaults.withCredentials&#x3D;true;&#x2F;&#x2F;让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios &#x3D; axios;</span><br></pre></td></tr></table></figure></li></ul><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ul><li><h4 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h4></li><li><h4 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h4><ul><li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</li></ul></li><li><h4 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h4><ul><li>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</li></ul></li><li><h4 id="组件的生命周期有哪些？"><a href="#组件的生命周期有哪些？" class="headerlink" title="组件的生命周期有哪些？"></a>组件的生命周期有哪些？</h4><ul><li>组件的声明周期有三种阶段，一种是初始化阶段（Mounting），一种是更新阶段（Updating）最后一种是析构阶段（Unmounting）。而这两个阶段的声明周期函数都是相似且有一一对应的关系的</li></ul></li><li><h4 id="什么时候使用-Class-Component-而非-Functional-Component"><a href="#什么时候使用-Class-Component-而非-Functional-Component" class="headerlink" title="什么时候使用 Class Component 而非 Functional Component?"></a>什么时候使用 Class Component 而非 Functional Component?</h4><ul><li>如果你的组件有state或者使用了生命周期函数，那么请使用Class component。 否则，使用Functional component。</li></ul></li><li>什么是keys 而且为什么他们很重要<ul><li>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li></ul></li></ul><h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul><li><p>####1.请谈谈Vue中的MVVM模式</p><ul><li>MVVM全称是Model-View-ViewModel</li><li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</li><li>DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li></ul></li><li><p>####2.v-show和v-if指令的共同点和不同点?</p><ul><li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li><li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li></ul></li><li><p>####3.如何让CSS只在当前组件中起作用?</p><ul><li>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></li></ul></li><li><p>####4.Vue中引入组件的步骤?</p><ul><li>1.采用ES6的import … from …语法或CommonJS的require()方法引入组件</li><li>2.对组件进行注册,代码如下</li><li>3.使用组件<my-component></my-component><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="组件间如何传递值或调用"><a href="#组件间如何传递值或调用" class="headerlink" title="组件间如何传递值或调用"></a>组件间如何传递值或调用</h4></li><li><p>####5.在Vue中使用插件的步骤</p><ul><li>采用ES6的import … from …语法或CommonJS的require()方法引入插件</li><li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li></ul></li><li><p>####6.请列举出3个Vue中常用的生命周期钩子函数?</p><ul><li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li><li>mounted:  el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li><li>activated: keep-alive组件激活时调用</li></ul></li><li><p>####7.请简述下Vuex的原理和使用方法</p><ul><li><p>数据单向流动</p></li><li><p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</p></li><li><p>Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</p></li><li><p>上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p><ul><li>state中保存着共有数据</li><li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li><li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li></ul></li></ul></li></ul><ul><li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul><li>1）创建新节点<ul><li>createDocumentFragment() //创建一个DOM</li><li>createElement() //创建一个具体的</li><li>createTextNode() //创建一个文本节点</li></ul></li><li>2）添加、移除、替换、插入<ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //并没有insertAfter()</li></ul></li><li>3）查找<ul><li>getElementsByTagName() //通过标签名</li><li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li><li>getElementById() //通过元素Id，唯一性</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html"/>
      <url>interview/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.html</url>
      
        <content type="html"><![CDATA[<h3 id="core文件是什么，有什么用？"><a href="#core文件是什么，有什么用？" class="headerlink" title="core文件是什么，有什么用？"></a>core文件是什么，有什么用？</h3><ul><li>core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</li></ul><h3 id="什么是core-dump"><a href="#什么是core-dump" class="headerlink" title="什么是core dump"></a>什么是core dump</h3><ul><li>Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容出来生成的，它可以做为调试程序的参考.</li><li>core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。</li><li>如何使用core文件<ul><li>gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 哪个函数中.</li></ul></li></ul><h3 id="为什么没有core文件生成呢"><a href="#为什么没有core文件生成呢" class="headerlink" title="为什么没有core文件生成呢?"></a>为什么没有core文件生成呢?</h3><ul><li>core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.</li><li>ulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号</li></ul><h3 id="不用core文件，程序出了问题产生信号是否知道？"><a href="#不用core文件，程序出了问题产生信号是否知道？" class="headerlink" title="不用core文件，程序出了问题产生信号是否知道？"></a>不用core文件，程序出了问题产生信号是否知道？</h3><ul><li>内核向进程发信号嘛。</li></ul><h3 id="共享内存除了文件映射还有什么方式？二者有什么区别"><a href="#共享内存除了文件映射还有什么方式？二者有什么区别" class="headerlink" title="共享内存除了文件映射还有什么方式？二者有什么区别"></a>共享内存除了文件映射还有什么方式？二者有什么区别</h3><ul><li>共享内存对象映射。</li><li>区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</li></ul><h3 id="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"><a href="#请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc" class="headerlink" title="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"></a>请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc</h3><ul><li>top：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</li><li>ps：查看进程</li><li>mv：移动或者更改文件</li><li>find：在子目录中搜索匹配的文件</li><li>df：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。</li><li>cat：把一个或多个文件内容显示到标准输出</li><li>chmod：改变文件属性</li><li>chgrp：改变用户分组</li><li>grep：在文件内进行搜索</li><li>wc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</li></ul><h3 id="Linux文件属性有哪些？（共十位）"><a href="#Linux文件属性有哪些？（共十位）" class="headerlink" title="Linux文件属性有哪些？（共十位）"></a>Linux文件属性有哪些？（共十位）</h3><ul><li>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</li><li>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录 （directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</li><li>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</li><li>一个文件aaa具有完全空的权限- — — —。<ul><li>chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</li><li>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</li><li>chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</li></ul></li><li>如果aaa具有满权限- rwx rwx rwx。<ul><li>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</li></ul></li><li>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<ul><li>chmod u=rwx，go=rx aaa</li></ul></li></ul><h3 id="linux查询命令"><a href="#linux查询命令" class="headerlink" title="linux查询命令"></a>linux查询命令</h3><ul><li>find / -name “文件名”    在目录结构中搜索文件，并执行指定的操作。</li><li>grep</li><li>local 文件名  —他是 ‘find -name’ 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</li><li>whereis —是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li><li>which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li></ul><h3 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h3><ul><li>select<ul><li>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</li><li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</li><li>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</li><li>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</li></ul></li><li>poll<ul><li>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</li><li>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li><li>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</li></ul></li><li>epoll<ul><li>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</li><li>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</li><li>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术这样  彻底省掉了 这些文件描述符在系统调用时复制的开销。</li><li>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callbac的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li></ul></li></ul><h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h3><ul><li><ol><li>内存的页面置换算法</li></ol></li><li><ol start="2"><li>进程调度算法</li></ol></li><li><ol start="3"><li>进程间通信方式</li></ol></li><li><ol start="4"><li>进程和线程定义，区别和联系</li></ol></li><li><ol start="5"><li>进程之间的通信</li></ol></li><li><ol start="6"><li>父子进程、孤儿进程</li></ol></li><li><ol start="7"><li>fork进程时的操作，</li></ol></li><li><ol start="11"><li>硬链接和软连接区别</li></ol></li><li><ol start="12"><li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li></ol></li><li><ol start="13"><li>linux用过的命令</li></ol></li><li><ol start="14"><li>系统管理命令（如查看内存使用、网络情况）</li></ol></li><li><ol start="15"><li>管道的使用 |</li></ol></li><li><ol start="16"><li>grep的使用，一定要掌握，每次都会问在文件中查找</li></ol></li><li><ol start="17"><li>shell脚本</li></ol></li><li><ol start="19"><li>awk使用</li></ol></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.html"/>
      <url>interview/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95.html</url>
      
        <content type="html"><![CDATA[<ul><li>第一：复杂度估算和排序算法（上）<ul><li>1) 时间复杂度和空间复杂度</li><li>2）认识对数器</li><li>3）冒泡排序</li><li>4）选择排序</li><li>5）插入排序</li><li>6）如何分析递归过程的时间复杂度</li><li>7）归并排序</li><li>8）小和问题</li></ul></li><li>第二：复杂度估算和排序算法（下）<ul><li>1）荷兰国旗问题</li><li>2）随机快速排序</li><li>3）堆结构与堆排序</li><li>4）认识排序算法的稳定性</li><li>5）认识比较器</li><li>6）桶排序</li><li>7）计数排序</li><li>8）基数排序</li><li>9）数组排序后的最大差值问题</li><li>10）排序算法在工程中的应用</li></ul></li><li>第三：章栈、队列、链表、数组和矩阵结构<br>  1）栈结构<br>  2）队列结构<br>  3）链表结构<br>  4）数组结构<br>  5）矩阵结构<br>  6）二分搜索的扩展</li><li>第四：二叉树结构<ul><li>1）二叉树结构</li><li>2）二叉树的递归与非递归遍历</li><li>3）打印二叉树</li><li>4）判断搜索二叉树</li><li>5）判断完全二叉树</li><li>6）判断平衡二叉树</li><li>7）折纸问题</li><li>8）二叉树节点的前驱节点与后继节点</li><li>9）二叉树的序列化和反序列化</li></ul></li><li>第五：和哈希函数有关的三个结构与并查集<br>  1）哈希函数与哈希表<br>  2）布隆过滤器详解<br>  3）一致性哈希结构<br>  4）并查集结构与应用（岛问题）</li><li>第六：章图算法<br>  1）图结构的表示方法<br>  2）图的深度优先遍历与宽度优先遍历<br>  3）拓扑排序问题<br>  4）最小生成树问题<br>  5）单源最短路径问题</li><li>第七：前缀树、堆结构和贪心算法<br>  1）前缀树<br>  2）堆结构的扩展与应用<br>  3）介绍贪心算法及其相关题目<br>  4）在面试中如何快速的尝试出贪心策略</li><li>第八：暴力递归到动态规划<br>  1）递归<br>  2）动态规划<br>  3）如何把暴力递归套路的变成动态规划<br>算法高级：<br>第一：KMP算法和Manacher算法<br>  1）KMP算法及其扩展面试题目<br>  2）Manacher算法及其扩展面试题目<br>第二：窗口内最大值的更新结构和单调栈结构<br>  1）窗口内最大值的更新结构<br>  2）单调栈结构<br>第三：Morris遍历和sortedMap<br>  1）二叉树的Morris遍历<br>  2）跳表结构<br>  3）AVL树和红黑树结构<br>【今日头条、拼多多题目】<br>分类算法的理解<ul><li>决策树的原理</li><li>支持向量机</li><li>逻辑斯蒂回归<br>聚类算法的理解</li><li>均值聚类，可选的参数，如果确定聚类个数</li><li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li><li>xgboost</li><li>gbdt<br>【面试题目】</li><li><ol><li>二叉树前序递归遍历算法（手写代码）</li></ol></li><li><ol start="2"><li>二叉树的前中后遍历</li></ol></li><li><ol start="3"><li>二叉树的文件存储，也就是序列化。</li></ol></li><li><ol start="4"><li>二叉树遍历，描述下层序遍历。</li></ol></li><li><ol start="5"><li>二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。</li></ol></li><li><ol start="6"><li>二维数组，每行递增，每列递增，实现查找。</li></ol></li><li><ol start="7"><li>二维数组，每行递增，每列递增，求第k大的数。</li></ol></li><li><ol start="8"><li>什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。</li></ol></li><li><ol start="9"><li>介绍二叉树前序遍历非递归遍历算法（手写代码）</li></ol></li><li><ol start="10"><li>介绍大顶堆和小顶堆</li></ol></li><li><ol start="11"><li>从一组数中找出和为sum的三个数（leetcode）</li></ol></li><li><ol start="12"><li>冒泡排序(手写代码)</li></ol></li><li><ol start="13"><li>写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）</li></ol></li><li><ol start="14"><li>写一个二叉树的非递归的后续遍历</li></ol></li><li><ol start="15"><li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)</li></ol></li><li><ol start="16"><li>写个动态规划，最长公共子序列</li></ol></li><li><ol start="17"><li>判断一个字符串是否为另外一个字符串旋转之后的字符串</li></ol></li><li><ol start="18"><li>前k大的数</li></ol></li><li><ol start="19"><li>单链表的翻转</li></ol></li><li><ol start="20"><li>去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。</li></ol></li><li><ol start="21"><li>去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’。（Code）</li></ol></li><li><ol start="22"><li>合法括号匹配</li></ol></li><li><ol start="23"><li>在一个字符串中，找出最长的无重复字符的字串</li></ol></li><li><ol start="24"><li>在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）</li></ol></li><li><ol start="25"><li>堆排序(手写代码)</li></ol></li><li><ol start="26"><li>堆是怎么调整的。</li></ol></li><li><ol start="27"><li>复杂链表的复制<br>【大数据题目】</li></ol></li><li><ol><li>100亿数字，怎么统计前100大的？</li></ol></li><li><ol start="2"><li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li></ol></li><li><ol start="3"><li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li></ol></li><li><ol start="4"><li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li></ol></li><li><ol start="5"><li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li></ol></li><li><ol start="6"><li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li></ol></li><li><ol start="7"><li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li></ol></li><li><ol start="8"><li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li></ol></li><li><ol start="9"><li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li></ol></li><li><ol start="10"><li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li></ol></li><li><ol start="11"><li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li></ol></li><li><ol start="12"><li>海量数据的topk问题。</li></ol></li></ul></li></ul><ul><li><ol start="2"><li>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</li></ol><ul><li><ol start="3"><li>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</li></ol></li><li><ol start="4"><li>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</li></ol></li><li><ol start="5"><li>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</li></ol></li><li><ol start="6"><li>二分查找（一般会深入，如寻找数组总和为K的两个数字）</li></ol></li><li><ol start="7"><li>两个栈实现队列。</li></ol></li><li><ol start="8"><li>图（深度广度优先遍历、单源最短路径、最小生成树）</li></ol></li><li><ol start="9"><li>动态规划问题。</li></ol></li><li><ol start="10"><li>深入</li></ol></li><li><ol start="11"><li>红黑树性质</li></ol></li><li><ol start="12"><li>分治法和动态规划的区别</li></ol></li><li><ol start="13"><li>计算时间复杂度</li></ol></li><li><ol start="14"><li>二叉树和哈希表查找的时间复杂度</li></ol></li></ul></li></ul><ul><li><p>常用的数据结构有哪些？</p><ul><li>Arrays</li><li>Binary Trees</li><li>Graphs</li><li>Linked Lists</li><li>Matrixes</li><li>Stacks</li><li>Queues</li><li>Heaps</li><li>Hash Tables</li></ul></li><li><p>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。<br>&lt;？php<br>function fuhuan($allnum, $ti){<br>   $arr = array();<br>   for($i = 0; $i &lt; $allnum; $i++){</p><pre><code>$arr[$i] = $i;</code></pre><p>   }</p><p>   $nums = 1;<br>   while(count($arr) &gt; 1){</p><pre><code> foreach ($arr as $key =&gt; $value) {     if($nums == $ti){         unset($arr[$key]);         $nums = 1;     }else{         $nums++;     }}</code></pre><p>   }<br>   $new_arr = array_values($arr);<br>   var_dump($new_arr[0] + 1);<br>}<br>fuhuan(10,10);</p></li></ul><ul><li>常用的数据结构有哪些？</li><li>Graph Data Structure Interview Questions<ul><li>Breadth First Search</li><li>Depth First Search</li><li>A* Search</li><li>Dijkstra Algorithm</li><li>Comparing BFS, DFS, A* and Dijkstra</li></ul></li><li>Linked List Interview Questions (coming soon)<ul><li>Inserting and Removing nodes</li><li>Comparing Strings</li><li>Reversing a List</li><li>Selecting a Random Node</li></ul></li><li>Dynamic Programming Interview Questions (coming soon)<ul><li>Fibonacci Number Sequence</li><li>Longest Common Subsequence</li></ul></li><li>Sorting an Searching Interview Questions (coming soon)<ul><li>Binary Search</li><li>Bubble Sort</li><li>Insertion Sort</li><li>Merge Sort</li><li>Heap Sort</li><li>Quick Sort</li><li>Interpolation</li><li>Tree/Binary Search Tree</li><li>Minimum Depth</li><li>Maximum Path Sum</li></ul></li><li>Number Theory Interview Questions (coming soon)<ul><li>Euclid’s GCD Algorithm</li><li>Extending Euclid’s GCD Algorithm</li><li>Diophantine Equation</li><li>Chinese Remainder Theorem</li><li>Modular Inverse</li><li>Semi-Perfect Numbers</li></ul></li><li>String Interview Questions (coming soon)<ul><li>Reversing a String</li><li>Checking if String contains only digits</li><li>Finding Duplicate Characters in a String</li><li>How to Convert a String to Integer</li><li>Removing Duplicate Characters in a String</li><li>Finding the Maximum Occuring Character in a String</li><li>Find the First Non-Repeating Character in a String</li><li>Checking if Two Strings are Anagrams of Each Other</li><li>Counting the Number of Words in a String</li></ul></li><li>Array Interview Questions (coming soon)<ul><li>Finding the Missing Number from Array</li><li>Finding Duplicate Integers in an Array</li><li>Finding the Largest and Smallest Number in Unsorted Array</li><li>Removing Duplicates from an Array</li><li>Reversing an Array</li><li>Finding the k-th Smallest Integer in an Unsorted Array</li><li>Finding Common Elements Between Multiple Arrays</li></ul></li><li>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>芯片简介</title>
      <link href="man/chip/basic.html"/>
      <url>man/chip/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="芯片分类"><a href="#芯片分类" class="headerlink" title="芯片分类"></a>芯片分类</h3><ul><li><p>按照功能分类</p><ul><li>计算的</li><li>控制的</li><li>存储的</li></ul></li><li><p>按照集成电路规模</p><ul><li>有超大规模</li><li>大规模</li><li>中规模</li><li>小规模</li></ul></li><li><p>具体到了类型</p><ul><li>CPU</li><li>SoC</li><li>DSP</li></ul></li></ul><h3 id="CPU结构和功能"><a href="#CPU结构和功能" class="headerlink" title="CPU结构和功能"></a>CPU结构和功能</h3><p>结构：</p><ul><li>1) 控制器：完成指令的读入、寄存、译码和执行。</li><li>2) 寄存器：暂存用于寻址和计算过程的产生的地址和数据。</li><li>3) I/O控制逻辑：负责CPU中与输入/输出操作有关的逻辑。</li><li>4) 算数逻辑运算单元（Arithmetic &amp; Logic Unit, ALU）：运算器核心，负责进行算术运算、逻辑运算和移位操作，用来进行数值计算和产生存储器访问地址。</li></ul><p>功能：</p><ul><li>1) 与存储器之间交换信息。</li><li>2) 和I/O设备之间交换信息。</li><li>3) 为了使系统正常工作而接收和输出必要的信号，如复位信号、电源、输入时钟脉冲等。</li></ul><h3 id="微处理系统"><a href="#微处理系统" class="headerlink" title="微处理系统"></a>微处理系统</h3><p>1) CPU的外部特征就是数量有限的输入输出引脚。<br>2) 数据总线：用于CPU和存储器或I/O接口之间传送数据，双向通信；数据总线的条数决定了CPU和存储器或I/O设备一次最多能交换数据的位数，是微处理器的位数的判据，例如：Intel 386DX、ARM Cortex-M3是32位微处理器；Intel采用了IA-64架构的处理器、PowerPC 970是64位处理器；类似地，还有更加古老的8位、16位处理器等。<br>3) 地址总线：CPU通过地址总线输出地址码用以选择某一存储单元或某一成为I/O端口的寄存器，单向通信；地址总线的条数决定了地址码的位数，进而决定了存储空间的大小，例如：地址总线宽度（条数）为8，则可以标记2^8 = 256个存储单元，若每个存储单元的字长为8 bit，则最大可以接入系统的存储空间为256kB。<br>4) 控制总线：用来传送自CPU发出的控制信息或外设送到CPU的状态信息，双向通信；</p><h3 id="专用集成电路"><a href="#专用集成电路" class="headerlink" title="专用集成电路"></a>专用集成电路</h3><p>专用的集成电路（Application Specific Integrated Circuit, ASIC）是一种为专门目的而设计的集成电路。是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路<br>ASIC的特点是面向特定用户的需求，ASIC在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点</p><h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>可编程逻辑器件（Programmable Logic Device, PLD）是一种通用集成电路，它是ASIC的一个子集，逻辑功能可以按照用户对器件编程来确定。<br>PLD与一般数字芯片不同的是：PLD内部的数字电路可以在出厂后才规划决定，甚至可以无限制改变，而一般数字芯片在出厂前就已经决定其内部电路，无法在出厂后再次改变，事实上一般的模拟芯片、通信芯片、微控制器也都一样，出厂后就无法再对其内部电路进行更改。</p><blockquote><p>可编程逻辑器件的发展历程</p></blockquote><ul><li>最早的可编程逻辑器件（PLD）是1970年制成的可编程只读存储器（PROM），它由固定的与阵列和可编程的或阵列组成</li><li>可编程逻辑阵列（PLA）于20世纪70年代中期出现，它是由可编程的与阵列和可编程的或阵列组成，但由于器件的价格比较贵、编程复杂、资源利用率低，因而没有得到广泛应用。</li><li>可编程阵列逻辑（PAL）是1977年美国MMI公司率先推出的，它采用熔丝编程方式，由可编程的与阵列和固定的或阵列组成，采用双极性工艺制造，器件的工作速度很高。由于它的设计很灵活，输出结构种类很多，因而成为第一个得到普遍应用的可编程逻辑器件</li><li>通用阵列逻辑（GAL）是1985年Lattice公司最先发明的可电擦写、可重复编程、可设置加密位的PLD。GAL在PAL的基础上，采用了输出逻辑宏单元形式（EECMOS）工艺结构。在实际应用中，GAL对PAL仿真具有百分之百的兼容性，所以GAL几乎完全代替了PAL，并可以取代大部分标准SSI、MSI集成芯片，因而获得广泛应用</li><li>可擦除可编程逻辑器件（EPLD）是20世纪80年代中期Altera公司推出的基于UVEPROM和CMOS技术的PLD，后来发展到采用EECMOS工艺制作的PLD，EPLD的基本逻辑单元是宏单元，宏单元是由可编程的与阵列、可编程寄存器和可编程I/O三部分组成的</li><li>复杂可编程逻辑器件（CPLD）是20世纪80年代末Lattice公司提出了在线可编程技术（SP）以后于20世纪90年代初推出的。CPLD至少包含三种结构：可编程逻辑宏单元可编程I/O单元和可编程内部连线，它是在EPLD的基础上发展起来的，采用EECMOS工艺制作，与EPLD相比，增加了内部连线，对逻辑宏单元和I/O单元也有很大改进。</li><li>现场可编程门阵列（FPGA）器件是Xilinx公司1985年首家推出的，它是一种新型的高密度PLD，采用CMOS-SRAM工艺制作。FPGA的结构与门阵列PLD不同，其内部由许多独立的可编程逻辑模块（CLB）组成，逻辑块之间可以灵活地相互连接，CLB的功能很强，不仅能够实现逻辑函数，还可以配置成RAM等复杂的形式。配置数据存放在芯片内的SRAM中，设计人员可现场修改器件的逻辑功能，即所谓的现场可编程。FPGA出现后受到电子设计工程师的普遍欢迎，发展十分迅速。</li></ul><h3 id="硬件描述语言"><a href="#硬件描述语言" class="headerlink" title="硬件描述语言"></a>硬件描述语言</h3><p>硬件描述语言（Hardware Deion Language, HDL）是一种用形式化方法描述逻辑电路和系统的语言。利用这种语言，逻辑电路系统的设计可以从上层到下层（从抽象到具体）逐层描述自己的设计思想，用一系列分层次的模块来表示极其复杂的逻辑系统。然后，利用电子设计自动化（EDA）工具，逐层进行仿真验证，再把其中需要变为实际电路的模块组合，经过自动综合工具转换到门级电路网表。接下来，再用专用集成电路（ASIC）或现场可编程门阵列（FPGA）自动布局布线工具，把网表转换为要实现的具体电路布线结构。</p><ul><li>VHDL</li><li>Verilog HDL</li><li>System C</li></ul><h3 id="常见的数据处理芯片"><a href="#常见的数据处理芯片" class="headerlink" title="常见的数据处理芯片"></a>常见的数据处理芯片</h3><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p>日常生活中最常见得到的微处理器系统就是我们身边的微型计算机，也就是个人电脑<br>MCU是应用最广泛的一种电子控制芯片，其控制程序可以由特殊的烧录工具下载到ROM中，行使系统的功能。这些ROM可以使以是PROM、UVEPROM、EEPROM等，若MCU上没有集成ROM，也可以外接ROM。按照系统结构，微处理器系统可以分为冯·诺依曼结构（也称普雷斯顿结构）和哈佛结构，其区别是程序与数据的存放方式不同，同样地，MCU芯片也可以分为这两种结构，灵活地满足需要。</p><h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><p>微处理器单元（Micro Processor Unit, MPU），就是把很多CPU集成在一起并行处理数据的芯片。通俗来说，MCU集成了RAM，ROM等设备；MPU则不集成这些设备，是高度集成的通用结构的中央处理器矩阵，也可以认为是去除了集成外设的MCU。</p><h4 id="PLD（CPLD-FPGA）"><a href="#PLD（CPLD-FPGA）" class="headerlink" title="PLD（CPLD/FPGA）"></a>PLD（CPLD/FPGA）</h4><p>因为目前广泛使用的PLD是CPLD和FPGA。<br>CPLD/FPGA的内部结构和CPU完全不同，内部电路可以被多次修改，可以按照用户的编程形成不同的组合逻辑电路、时序逻辑电路结构，是一种“万能”的芯片，CPLD/FPGA看起来像一个CPU，其实不然，因为使用CPLD/FPGA实现控制是纯硬件实现，实质上和使用成千上万基本逻辑门搭建的数字逻辑电路没有区别。</p><h4 id="ADC、DAC"><a href="#ADC、DAC" class="headerlink" title="ADC、DAC"></a>ADC、DAC</h4><p>这就是模数转换电路（Analog Digital Circuit, ADC）,相应的也有数模转换（D/A）和数模转换电路（Digital Analog Circuit, DAC）芯片，进行D/A的时候同样要在数学和信息论上满足相关定理。</p><h4 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h4><p>数字信号处理器（Digital Signal Processor, DSP）是用来高速处理数字信号的专用芯片。<br>常常采用专用的电路来处理数字信号，如数字滤波、快速傅里叶变换、时频分析、语音信号和图像信号的处理加工等。这些运算往往很复杂，很多涉及复数的累加、累乘运算，举个例子：离散傅里叶变换的计算就十分复杂，但是运用时域抽取或频域抽取的快速傅里叶变换算法后就可以大大减少运算量，但是电路较为复杂。将能完成这些复杂运算的电路集成在一块芯片上，能在一个时钟周期完成一次乘加运算，使其能完成如基2-FFT蝶形运算、音频滤波、图像处理等复杂运算，这样的芯片叫做DSP。DSP也是一种特殊的CPU，特别适合信号的处理</p><h4 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h4><p>SoC的全称是System on a Chip，顾名思义，就是在一块芯片上集成一整个信息处理系统，称为片上系统或系统级芯片。<br>SoC也代表着一种技术，是一种以确定系统功能为目标，各个模块的软硬件协同开发，最后把开发成果集成为一块芯片的技术。由于功能丰富，又要求有不俗的性能发挥，SoC已然是功能最为丰富的硬件，其上集成了CPU、GPU、RAM、ADC/DAC、Modem、高速DSP等各种芯片，有的SoC上还必须集成电源管理模块，各种外部设备的控制模块，充分考虑各总线的分布利用……现如今，智能手机里的SoC上就集成了以上的部件和基带处理器等很多相关的通信模块。<br>SoC在无人机技术、自动驾驶，深度学习等行业也有越来越多的应用，用一块单芯片就能实现完整的电子系统，是半导体行业、IC产业未来的发展方向</p><h3 id="半导体IP核"><a href="#半导体IP核" class="headerlink" title="半导体IP核"></a>半导体IP核</h3><p>IP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。[1]IP核可以通过协议由一方提供给另一方，或由一方独自占有。IP核的概念源于产品设计的专利证书和源代码的版权等。设计人员能够以IP核为基础进行专用集成电路或现场可编程逻辑门阵列的逻辑设计，以减少设计周期。</p><p>IP核分为软核、硬核和固核。</p><ul><li>软核通常是与工艺无关、具有寄存器传输级硬件描述语言描述的设计代码，可以进行后续设计；</li><li>硬核是前者通过逻辑综合、布局、布线之后的一系列表征文件，具有特定的工艺形式、物理实现方式；</li><li>固核则通常介于上面两者之间，它已经通过功能验证、时序分析等过程，设计人员可以以逻辑门级网表的形式获取。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/django/model.html"/>
      <url>man/django/model.html</url>
      
        <content type="html"><![CDATA[<p>django model operate</p><h2 id="0x02、model"><a href="#0x02、model" class="headerlink" title="0x02、model"></a>0x02、model</h2><ul><li><p>model模型</p><ul><li>每个一个model都是要继承model.Model类的。</li><li>Model类封装了</li></ul></li><li><p>进行group_by并且做Max聚合，此时用的Max函数是下面引用的</p><ul><li>前边的values是要group_by的字段，annotate是需要聚合的字段，后续进行order_by。</li><li>没有group_by函数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.aggregates <span class="keyword">import</span> Max</span><br><span class="line"></span><br><span class="line">item = MetaJson.objects.filter(is_deleted=<span class="number">0</span>).values(<span class="string">'project_name'</span>,<span class="string">'item_type'</span>).annotate(max_id=Max(<span class="string">'id'</span>))</span><br><span class="line">model = MetaJson.objects.filter(id__in=[item[<span class="string">'max_id'</span>] <span class="keyword">for</span> item <span class="keyword">in</span> items]).values(<span class="string">"id"</span>,</span><br><span class="line">    <span class="string">'table_id'</span>, <span class="string">'table__name'</span>, <span class="string">'table__db__name'</span>, <span class="string">'table__db__type'</span>, <span class="string">'project_name'</span>).order_by(<span class="string">'-id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为null</span></span><br><span class="line">ResourceModel.objects.filter(parent__isnull=<span class="literal">False</span>).values(<span class="string">''</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算数量</span></span><br><span class="line">Book.objects.count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">Book.objects.filter(date_published__gte=datetime.now() - timedelta(days=<span class="number">90</span>)).count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">Book.objects.exclude(date_published__gte=datetime.now() - timedelta(days=<span class="number">90</span>)).count()</span><br><span class="line"></span><br><span class="line">Book.objects.filter(author__isnull=<span class="literal">True</span>).count()</span><br><span class="line">Book.objects.filter(title__exact=<span class="string">''</span>).count()</span><br><span class="line"></span><br><span class="line">Book.objects.exclude(author__isnull=<span class="literal">True</span>).exclude(title__exact=<span class="string">''</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序排列</span></span><br><span class="line">ActivityHelp.objects.values(<span class="string">'user_id'</span>).filter(share_id=share_id).order_by(<span class="string">'-create_time'</span>).get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># limit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生sql</span></span><br><span class="line">Person.objects.raw(<span class="string">'SELECT * FROM myapp_person'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># django.db.models.query_utils.InvalidQuery: Raw query must include the primary key</span></span><br></pre></td></tr></table></figure><h4 id="2-字段查询"><a href="#2-字段查询" class="headerlink" title="2.字段查询"></a>2.字段查询</h4><p>相当于sql语句中where子句，它可以为filter、exclude和get方法提供参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名称__比较运算符&#x3D;值   #是两个下划线</span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p8508" alt="e159615aeedcafe4a55a073a7196afac.png"></p><h4 id="3-字段类型"><a href="#3-字段类型" class="headerlink" title="3.字段类型"></a>3.字段类型</h4><ul><li><p><code>AutoField</code>：一个自动递增的整型字段，添加记录时它会自动增长。你通常不需要直接使用这个字段；如果你不指定主键的话，系统会自动添加一个主键字段到你的model。(参阅自动主键字段)</p></li><li><p><code>BooleanField</code>：布尔字段,管理工具里会自动将其描述为checkbox。</p></li><li><p><code>CharField</code>：字符串字段，单行输入，用于较短的字符串，如要保存大量文本, 使用 TextField，CharField有一个必填参数：CharField.max_length：字符的最大长度，django会根据这个参数在数据库层和校验层限制该字段所允许的最大字符数。</p></li><li><p><code>TextField</code>：一个容量很大的文本字段， admin 管理界面用 <textarea>多行编辑框表示该字段数据。</p></li><li><p><code>CommaSeparatedIntegerField</code>：用于存放逗号分隔的整数值。类似 CharField，必须maxlength 参数。</p></li><li><p><code>DateField</code>：日期字段，admin 用一个文本框 <input type=”text”> 来表示该字段数据(附带一个 JavaScript 日历和一个”Today”快捷按键。有下列额外的可选参数：</p><ul><li>auto_now：当对象被保存时,自动将该字段的值设置为当前时间.通常用于表示 “last-modified” 时间戳；</li><li>auto_now_add：当对象首次被创建时,自动将该字段的值设置为当前时间.通常用于表示对象创建时间。</li></ul></li><li><p><code>DateTimeField</code>：类似 DateField 支持同样的附加选项。</p></li><li><p><code>EmailField</code>：一个带有检查 Email 合法性的 CharField，不接受 maxlength 参数。</p></li><li><p><code>FileField</code>：一个文件上传字段。 要求一个必须有的参数： upload_to， 一个用于保存上载文件的本地文件系统路径。 这个路径必须包含 strftime formatting， 该格式将被上载文件的 date/time 替换(so that uploaded files don’t fill up the given directory)。在一个 model 中使用 FileField 或 ImageField 需要以下步骤：在你的 settings 文件中， 定义一个完整路径给 MEDIA_ROOT 以便让 Django在此处保存上传文件。 (出于性能考虑，这些文件并不保存到数据库。) 定义 MEDIA_URL 作为该目录的公共 URL。 要确保该目录对 WEB 服务器用户帐号是可写的。在你的 model 中添加 FileField 或 ImageField， 并确保定义了 upload_to 选项，以告诉 Django 使用 MEDIA_ROOT 的哪个子目录保存上传文件。你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT)。 出于习惯你一定很想使用 Django 提供的 get_&lt;fieldname_url 函数。举例来说，如果你的 ImageField 叫作 mug_shot， 你就可以在模板中以  这样的方式得到图像的绝对路径。</p></li><li><p><code>FilePathField</code>：选择指定目录按限制规则选择文件，有三个参数可选， 其中”path”必需的，这三个参数可以同时使用， 参数描述：</p><ul><li><code>path</code>：必需参数，一个目录的绝对文件系统路径。 FilePathField 据此得到可选项目。 Example： “/home/images”；</li><li><code>match</code>：可选参数， 一个正则表达式， 作为一个字符串， FilePathField 将使用它过滤文件名。 注意这个正则表达式只会应用到 base filename 而不是路径全名。 Example： “foo。*\。txt^”， 将匹配文件 foo23.txt 却不匹配 bar.txt 或 foo23.gif；</li><li><code>recursive</code>：可选参数， 是否包括 path 下全部子目录，True 或 False，默认值为 False。</li><li><code>match</code> 仅应用于 base filename， 而不是路径全名。 如：FilePathField(path=”/home/images”， match=”foo.”， recursive=True)…会匹配 /home/images/foo.gif 而不匹配 /home/images/foo/bar.gif</li></ul></li><li><p><code>FloatField</code>：浮点型字段。 必须提供两个 参数， 参数描述：</p><ul><li><code>max_digits</code>：总位数(不包括小数点和符号)</li><li><code>decimal_places</code>：小数位数。如：要保存最大值为 999 (小数点后保存2位)，你要这样定义字段：models.FloatField(…，max_digits=5， decimal_places=2)，要保存最大值一百万(小数点后保存10位)的话，你要这样定义：models.FloatField(…，max_digits=19， decimal_places=10)</li></ul></li><li><p><code>ImageField</code>：类似 FileField， 不过要校验上传对象是否是一个合法图片。它有两个可选参数：height_field 和 width_field，如果提供这两个参数，则图片将按提供的高度和宽度规格保存。 该字段要求 Python Imaging 库。</p></li><li><p><code>IntegerField</code>：用于保存一个整数。</p></li><li><p><code>IPAddressField</code>：一个字符串形式的 IP 地址， (如 “202.1241.30″)。</p></li><li><p><code>NullBooleanField</code>：类似 BooleanField， 不过允许 NULL 作为其中一个选项。 推荐使用这个字段而不要用 BooleanField 加 null=True 选项。 admin 用一个选择框 <select> (三个可选择的值： “Unknown”， “Yes” 和 “No” ) 来表示这种字段数据。</p></li><li><p><code>PhoneNumberField</code>：一个带有合法美国风格电话号码校验的 CharField(格式：XXX-XXX-XXXX)。</p></li><li><p><code>PositiveIntegerField</code>：类似 IntegerField， 但取值范围为非负整数（这个字段应该是允许0值的…可以理解为无符号整数）</p></li><li><p><code>PositiveSmallIntegerField</code>：正小整型字段，类似 PositiveIntegerField， 取值范围较小(数据库相关)SlugField“Slug” 是一个报纸术语。 slug 是某个东西的小小标记(短签)， 只包含字母，数字，下划线和连字符。它们通常用于URLs。 若你使用 Django 开发版本，你可以指定 maxlength。 若 maxlength 未指定， Django 会使用默认长度： 50，它接受一个额外的参数：</p><ul><li><code>prepopulate_from</code>: 来源于slug的自动预置列表</li></ul></li><li><p><code>SlugField</code>：是一个报纸术语. slug 是某个东西的小小标记(短签), 只包含字母,数字,下划线和连字符.它们通常用于URLs。</p></li><li><p><code>SmallIntegerField</code>：类似 IntegerField， 不过只允许某个取值范围内的整数。(依赖数据库)</p></li><li><p><code>TimeField</code>：时间字段，类似于 DateField 和 DateTimeField。</p></li><li><p><code>URLField</code>：用于保存 URL。 若 verify_exists 参数为 True (默认)， 给定的 URL 会预先检查是否存在(即URL是否被有效装入且没有返回404响应)。</p></li><li><p><code>USStateField</code>：美国州名缩写，由两个字母组成（天朝人民无视）。</p></li><li><p><code>XMLField</code>：XML字符字段，校验值是否为合法XML的 TextField，必须提供参数：</p></li><li><p>schema_path：校验文本的 RelaxNG schema 的文件系统路径。</p></li><li><p><code>Field 选项</code></p><ul><li>null ：缺省设置为false.通常不将其用于字符型字段上，比如CharField,TextField上.字符型字段如果没有值会返回空字符串。</li><li>blank：该字段是否可以为空。如果为假，则必须有值</li><li>choices：一个用来选择值的2维元组。第一个值是实际存储的值，第二个用来方便进行选择。如SEX_CHOICES= ((‘F’,’Female’),(‘M’,’Male’),)</li><li>core：db_column，db_index 如果为真将为此字段创建索引</li><li>default：设定缺省值</li><li>editable：如果为假，admin模式下将不能改写。缺省为真</li><li>help_text：admin模式下帮助文档</li><li>primary_key：设置主键，如果没有设置django创建表时会自动加上：</li></ul><p>id = meta.AutoField(‘ID’, primary_key=True)<br>primary_key=True implies blank=False, null=False and unique=True. Only one primary key is allowed on an object.</p><ul><li>radio_admin：用于admin模式下将select转换为radio显示。只用于ForeignKey或者设置了choices</li><li>unique：数据唯一</li><li>unique_for_date：日期唯一，如下例中系统将不允许title和pub_date两个都相同的数据重复出现</li><li>title = meta.CharField(maxlength=30,unique_for_date=’pub_date’)</li><li>unique_for_month / unique_for_year：用法同上</li><li>validator_list：有效性检查。非有效产生 django.core.validators.ValidationError 错误</li></ul></li></ul><h4 id="4-关联数据"><a href="#4-关联数据" class="headerlink" title="4.关联数据"></a>4.关联数据</h4><p>on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为<br>on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除<br>on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做<br>on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError<br>models.ForeignKey(‘关联表’, on_delete=models.SET_NULL, blank=True, null=True)<br>on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）<br>models.ForeignKey(‘关联表’, on_delete=models.SET_DEFAULT, default=’默认值’)<br>on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）<br>on_delete=models.SET,         # 删除关联数据,<br> a. 与之关联的值设置为指定值,设置：models.SET(值)<br> b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/frontend/flex%E5%B8%83%E5%B1%80.html"/>
      <url>man/frontend/flex%E5%B8%83%E5%B1%80.html</url>
      
        <content type="html"><![CDATA[<h1 id="flex布局初探"><a href="#flex布局初探" class="headerlink" title="flex布局初探"></a>flex布局初探</h1><h2 id="一、由来"><a href="#一、由来" class="headerlink" title="一、由来"></a>一、由来</h2><p>flex布局是2009年提出的新式前端布局。在此之前，布局是依赖盒模型，用display+position+float来进行的，这种模式有些比较难以实现的地方，比如垂直居中，由于这个需要提前知晓高度与宽度，需要各种计算，非常不方便。但是用flex布局就可以很简单的来解决。</p><p>flex布局，也即是flex box，其实就是弹性盒子的意思。在这个终端屏幕多样化，前端样式多样化的大背景下，前端的布局也需要更加的具有弹性和简便性。在flex布局内，将css里边的元素，放置在一个个具有弹性的盒子内，定义好元素的排序顺序、位置方向等，让其自适应布局即可。这样即方便布局书写，又能让元素自适应屏幕，多么好的选择。</p><h2 id="二、简介"><a href="#二、简介" class="headerlink" title="二、简介"></a>二、简介</h2><p>先以几个例子来让大家常常鲜，有个大致的感觉</p><h4 id="1-声明flex布局"><a href="#1-声明flex布局" class="headerlink" title="1.声明flex布局"></a>1.声明flex布局</h4><p>flex布局在设置时，先要进行声明一下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 这个dispaly:flex这声明了这个div元素内是进行flex布局 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-方向排列"><a href="#2-方向排列" class="headerlink" title="2.方向排列"></a>2.方向排列</h4><ul><li>flex默认是进行横向排列的元素的<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.block</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:1200px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:800px</span>;</span></span><br><span class="line">        background-color: grey</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.item</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">font-weight</span><span class="selector-pseudo">:800</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">width</span><span class="selector-pseudo">:300px</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">height</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.one</span> &#123;</span></span><br><span class="line">        background-color: blueviolet;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.two</span> &#123;</span></span><br><span class="line">        background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.three</span> &#123;</span></span><br><span class="line">        background-color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><!-- ![e4582c9a4fc7646d4bff12e84290a11c.png](evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10987) --></li></ul><ul><li>也可以设置竖向排列。把上面的外层div做调整,添加<code>flex-direction:column</code>属性<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;flex-direction:column"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10989" alt="25a4d24c5306f8421b044b21046c3f02.png"></li></ul><h4 id="3-元素位置"><a href="#3-元素位置" class="headerlink" title="3.元素位置"></a>3.元素位置</h4><ul><li>默认在左上角，例如上面例子的one、two、three这几个词，默认在块的左上角。</li><li>设置上下居中，给每个子div设置flex布局，并添加<code>align-items: center</code>属性。</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10992" alt="3e813e40563ba966c246d1427807b4de.png"></p><ul><li>设置元素左右居中，给每个子div设置flex布局，并添加<code>justify-content: center</code>属性<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10993" alt="a6f23f1fd75170793b8ee27a88cd7ad3.png"></li></ul><ul><li>设置元素整体居中，那么就需要同时设置上面两个属性即可<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10995" alt="d9c8f697b67aebe0ac8800afbc1c8dc5.png"></li></ul><h4 id="4-元素间隔"><a href="#4-元素间隔" class="headerlink" title="4.元素间隔"></a>4.元素间隔</h4><ul><li><p>默认是在左边横向紧密排列在一起，没有间隙的</p></li><li><p>设置都在右边紧密排列。给最外层的div添加<code>justify-content: flex-end;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: flex-end;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10997" alt="b8dfc658235d87343b5e9aeac7160af5.png"></p></li><li><p>设置两边元素靠边，中间元素居中。给最外层的div添加<code>justify-content: space-between;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: space-between;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10999" alt="38e1dd5d8a53b3cc83a78393c320f171.png"></p></li><li><p>设置两边元素不靠边，中间元素居中。给最外层的div添加<code>justify-content: space-around;</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;justify-content: space-around;"</span> <span class="attr">class</span>=<span class="string">"block"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item one"</span>&gt;</span>one<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item two"</span>&gt;</span>two<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display:flex;align-items: center;justify-content: center"</span> <span class="attr">class</span>=<span class="string">"item three"</span>&gt;</span>threee<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p11000" alt="7c84df8f2d7d5f92308e7e03c2dba59a.png"></p></li></ul><h2 id="三、常用属性"><a href="#三、常用属性" class="headerlink" title="三、常用属性"></a>三、常用属性</h2><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>1.设置弹性盒子的子元素超出父容器时是否换行</p><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>属性指定了内部元素是如何在 flex 容器中布局的，定义了主轴的方向(正方向或反方向)。<br>2.可选择的属性值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* The direction text is laid out in a line */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like &lt;row&gt;, but reversed */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">row-reverse</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* The direction in which lines of text are stacked */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">column</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Like &lt;column&gt;, but reversed */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">column-reverse</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">flex-direction</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>会对齐当前 grid 或 flex 行中的元素，并覆盖已有的 align-items 的值</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Keyword values */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">auto</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">normal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Positional alignment */</span></span><br><span class="line"><span class="comment">/* align-self does not take left and right values */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">center</span>; <span class="comment">/* Put the item around the center */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">start</span>;  <span class="comment">/* Put the item at the start */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">end</span>;    <span class="comment">/* Put the item at the end */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">self-start</span>; <span class="comment">/* Align the item flush at the start */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">self-end</span>;   <span class="comment">/* Align the item flush at the end */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">flex-start</span>; <span class="comment">/* Put the flex item at the start */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">flex-end</span>;   <span class="comment">/* Put the flex item at the end */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Baseline alignment */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">first</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">last</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">stretch</span>; <span class="comment">/* Stretch 'auto'-sized items to fit the container */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overflow alignment */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">safe</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">unsafe</span> <span class="selector-tag">center</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">align-self</span>: <span class="selector-tag">unset</span>;</span><br><span class="line">值</span><br></pre></td></tr></table></figure><h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p>1.设置弹性盒子元素在侧轴（纵轴）方向上的对齐方式。<br>2.可选择的属性值有：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Basic keywords */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">normal</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">stretch</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Positional alignment */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">center</span>; <span class="comment">/* Pack items around the center */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">start</span>; <span class="comment">/* Pack items from the start */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">end</span>; <span class="comment">/* Pack items from the end */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">flex-start</span>; <span class="comment">/* Pack flex items from the start */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">flex-end</span>; <span class="comment">/* Pack flex items from the end */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">self-start</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">self-end</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Baseline alignment */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">first</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">last</span> <span class="selector-tag">baseline</span>; <span class="comment">/* Overflow alignment (for positional alignment only) */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">safe</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">unsafe</span> <span class="selector-tag">center</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">align-items</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>设置弹性盒子元素在横轴方向上的对齐方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Positional alignment */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">center</span>;     <span class="comment">/* 居中排列 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">start</span>;      <span class="comment">/* Pack items from the start */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">end</span>;        <span class="comment">/* Pack items from the end */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">flex-start</span>; <span class="comment">/* 从行首起始位置开始排列 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">flex-end</span>;   <span class="comment">/* 从行尾位置开始排列 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">left</span>;       <span class="comment">/* Pack items from the left */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">right</span>;      <span class="comment">/* Pack items from the right */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Baseline alignment */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">first</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">last</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Distributed alignment */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-between</span>;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   首个元素放置于起点，末尾元素放置于终点 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-around</span>;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   每个元素周围分配相同的空间 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">space-evenly</span>;  <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   每个元素之间的间隔相等 */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">stretch</span>;       <span class="comment">/* 均匀排列每个元素</span></span><br><span class="line"><span class="comment">                                   'auto'-sized 的元素会被拉伸以适应容器的大小 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Overflow alignment */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">safe</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">unsafe</span> <span class="selector-tag">center</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Global values */</span></span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">inherit</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">initial</span>;</span><br><span class="line"><span class="selector-tag">justify-content</span>: <span class="selector-tag">unset</span>;</span><br></pre></td></tr></table></figure><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>设置了浏览器如何沿着弹性盒子布局的纵轴和网格布局的主轴在内容项之间和周围分配空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 基本位置对齐 */</span></span><br><span class="line"><span class="comment">/*align-content不采用左右值 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">center</span>;     <span class="comment">/* 将项目放置在中点 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">start</span>;      <span class="comment">/* 最先放置项目 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">end</span>;        <span class="comment">/* 最后放置项目 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">flex-start</span>; <span class="comment">/* 从起始点开始放置flex元素 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">flex-end</span>;   <span class="comment">/* 从终止点开始放置flex元素 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 默认对齐 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">normal</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*基线对齐*/</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">first</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">last</span> <span class="selector-tag">baseline</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分布式对齐 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">space-between</span>; <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 第一项与起始点齐平，</span></span><br><span class="line"><span class="comment">                                 最后一项与终止点齐平 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">space-around</span>;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目在两端有一半大小的空间*/</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">space-evenly</span>;  <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 项目周围有相等的空间 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">stretch</span>;       <span class="comment">/* 均匀分布项目</span></span><br><span class="line"><span class="comment">                                 拉伸‘自动’-大小的项目以充满容器 */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 溢出对齐 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">safe</span> <span class="selector-tag">center</span>;</span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">unsafe</span> <span class="selector-tag">center</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 全局属性 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">inherit</span>; <span class="comment">/* 继承 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">initial</span>;  <span class="comment">/* 初始值 */</span></span><br><span class="line"><span class="selector-tag">align-content</span>: <span class="selector-tag">unset</span>; <span class="comment">/* 未设置 */</span></span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/docker/%E6%96%87%E6%A1%A3.html"/>
      <url>man/docker/%E6%96%87%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="Docker文档"><a href="#Docker文档" class="headerlink" title="Docker文档"></a>Docker文档</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-30 14:16:23</li></ul><blockquote><h3 id="0x00、整体介绍"><a href="#0x00、整体介绍" class="headerlink" title="0x00、整体介绍"></a>0x00、整体介绍</h3></blockquote><blockquote><h3 id="0x01、镜像"><a href="#0x01、镜像" class="headerlink" title="0x01、镜像"></a>0x01、镜像</h3></blockquote><blockquote><h3 id="0x02、Dockfile"><a href="#0x02、Dockfile" class="headerlink" title="0x02、Dockfile"></a>0x02、Dockfile</h3></blockquote><ul><li>docker用来制作镜像</li><li>必须要from开头</li></ul><blockquote><h3 id="0x03、Docker-compose"><a href="#0x03、Docker-compose" class="headerlink" title="0x03、Docker-compose"></a>0x03、Docker-compose</h3></blockquote><ul><li><p>docker-compose用来管理多个镜像</p></li><li><p>分为version、services、networks几部分。其中前两个是必须要有的。</p></li><li><p>version</p><ul><li>定义版本 3.7</li></ul></li><li><p>services里，可以包含很多的服务，可以定义</p><ul><li><p>build</p></li><li><p>ports</p><ul><li>ports暴露容器端口到主机的任意端口或指定端口</li></ul></li><li><p>exports</p><ul><li>expose暴露容器给link到当前容器的容器</li></ul></li><li><p>image</p></li><li><p>networks</p></li><li><p>voluems</p><ul><li><ol><li>默认情况不使用:rw :ro选项，Mode的值就是空字符串”“。</li></ol></li><li><ol start="2"><li>使用:rw选项，Mode的值就是”rw”。</li></ol></li><li><ol start="3"><li>使用:ro选项，Mode的值就是”ro”</li></ol></li><li>我们知道docker -v不仅可以挂载映射目录，也可以只挂载映射一个文件。<ul><li><ol><li>如果我们按照1，2设置来挂载目录，宿主主机和docker互相都可以读写同步，如果我们按照1，2设置来挂载文件，这个时候只有docker的写可以同步到宿主主机上面去，宿主主机写不同步到docker。而且一旦宿主主机上写了修改了映射文件，那么docker里面再怎么写都不再同步到宿主主机了。</li></ol></li><li>注意：这里有一个特殊的玩法，假如docker1和docker2都映射了主机上同一个文件到自己的目录，在docker1里面改了文件，docker2内也是同时改变的，就算你在主机上改了文件导致主机和docker1，docker2不再同步了，这个操作还是可以。</li><li><ol start="2"><li>如果我们按照3来挂载目录或者挂载文件，这个时候docker内也不能写，宿主主机写了也不同步进去了，相当于创建的时候拷贝一份不可改变的配置进来而已。</li></ol></li></ul></li></ul></li><li><p>exteral_hosts</p></li><li><p>depends_on</p><ul><li>depends_on 来定义服务之间的依赖关系时会造成下面的影响</li><li>depends_on 不会等到 db 和 redis 容器 ready 再启动，web 容器仅仅等到 redis 和 db 容器启动就开始启动</li></ul></li><li><p>links</p><ul><li>使用 links 来保证每一次都能够连接数据库，而不需要知道具体端口是什么</li></ul></li><li><p>init</p></li><li><p>working_dir</p></li><li><p>command</p></li><li><p>environment</p></li></ul></li></ul><ul><li>举例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> ports:</span><br><span class="line">   - &quot;80:80&quot;         # 绑定容器的80端口到主机的80端口</span><br><span class="line">   - &quot;9000:8080&quot;     # 绑定容器的8080端口到主机的9000端口</span><br><span class="line">   - &quot;443&quot;           # 绑定容器的443端口到主机的任意端口，容器启动时随机分配绑定的主机端口号</span><br><span class="line"></span><br><span class="line">expose:</span><br><span class="line">  - &quot;3000&quot;</span><br><span class="line">  - &quot;8000&quot;</span><br><span class="line"># 和ports的区别是，expose不会将端口暴露给主机。</span><br></pre></td></tr></table></figure></li></ul><ul><li>networks</li></ul><ul><li>链接外部容器的几种方式<ul><li>在同一个docker-compose里写入depends_on或者links，docker会自动解决依赖，并依据service名称来访问即可</li><li>如果不在docker-compose里解决依赖，那就需要公用一个外部网络：external</li></ul></li></ul><ul><li>容器技术<ul><li>容器就是将软件打包成标准化单元，以用于开发、交付和部署</li><li>特性<ul><li>容器镜像是轻量的、可执行的独立软件包 ，包含软件运行所需的所有内容：代码、运行时环境、系统工具、系统库和设置。</li><li>容器化软件适用于基于Linux和Windows的应用，在任何环境中都能够始终如一地运行。</li><li>容器赋予了软件独立性，使其免受外在环境差异（例如，开发和预演环境的差异）的影响，从而有助于减少团队间在相同基础设施上运行不同软件时的冲突。</li><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6252" alt="25c4c7294b60e95791da993cda05b76a.jpeg"></li></ul></li></ul></li><li>docker简介<ul><li>特点<ul><li>作用是虚拟运行</li><li>包含镜像和容器两块</li><li>架构有客户端和服务端</li><li>镜像有层的概念，最多128层</li><li>容器可以进行端口映射，磁盘挂载，添加host</li><li>与传统虚拟技术的区别<ul><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6253" alt="e65fcb6a94984509cefac489893ab09b.jpeg"></li></ul></li></ul></li></ul></li><li>docker特性<ul><li>轻量级</li><li>高效的部署和扩容</li><li>更高的资源利用率</li><li>更简单的管理</li></ul></li><li>docker基本架构<ul><li>几部分组成：<ul><li><ol><li>Docker Client 客户端</li></ol></li><li><ol start="2"><li>Docker daemon 守护进程</li></ol></li><li><ol start="3"><li>Docker Image 镜像</li></ol></li><li><ol start="4"><li>Docker Container 容器</li></ol></li><li><ol start="5"><li>Docker Registry 仓库</li></ol></li></ul></li><li>客户端和守护进程：<ul><li>Docker是C/S（客户端client-服务器server）架构模式。</li><li>Docker通过客户端连接守护进程，通过命令向守护进程发出请求，守护进程通过一系列的操作返回结果。</li><li>docker客户端可以连接本地或者远程的守护进程。</li><li>docker客户端和服务器通过socket或RESTful API进行通信。</li><li>Docker 容器通过 Docker 镜像来创建，容器与镜像的关系类似于面向对象编程中的对象与类<img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6254" alt="c209c9f282cc29a87444b3157cdbdfe7.jpeg"></li></ul></li><li>Docker 镜像(Images)<ul><li>Docker 镜像是用于创建 Docker 容器的模板。</li></ul></li><li>Docker 容器(Container)<ul><li>容器是独立运行的一个或一组应用。</li></ul></li><li>Docker 客户端(Client)<ul><li>Docker 客户端通过命令行或者其他工具使用</li></ul></li><li>Docker APIDocker 主机(Host)<ul><li>一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。</li></ul></li><li>Docker 仓库(Registry)<ul><li>Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。</li></ul></li><li>Docker Hub<ul><li>提供了庞大的镜像集合供使用。</li></ul></li><li>Docker MachineDocker<ul><li>Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。</li></ul></li></ul></li></ul><ul><li>镜像<ul><li>仓库</li></ul></li><li>容器</li><li>docker网络<ul><li><ul><li>当 Docker daemon 启动时需要做以下操作：</li></ul></li><li>creates the docker0 bridge if not present 如果 docker0 不存在则创建</li><li>searches for an IP address range which doesn’t overlap with an existing route 搜索一个与当前路由不冲突的 ip 段</li><li>picks an IP in the selected range 在确定的范围中选择 ip</li><li>assigns this IP to the docker0 bridge  绑定 ip 到 docker0</li><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6255" alt="aa2047f3e08edb95f019c73cce48d564.jpeg"></li><li>4 种网络模式：<ul><li>host 模式，使用 –net=host 指定。</li><li>container 模式，使用 –net=container:NAMEorID 指定。</li><li>none 模式，使用 –net=none 指定。</li><li>bridge 模式，使用 –net=bridge 指定，默认设置。</li></ul></li><li>host 模式<ul><li>如果启动容器的时候使用 host 模式，那么这个容器将不会获得一个独立的 Network Namespace，而是和宿主机共用一个 Network Namespace。容器将不会虚拟出自己的网卡，配置自己的 IP 等，而是使用宿主机的 IP 和端口。</li></ul></li><li>container 模式<ul><li>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</li></ul></li><li>none模式<ul><li>这个模式和前两个不同。在这种模式下，Docker 容器拥有自己的 Network Namespace，但是，并不为 Docker容器进行任何网络配置。也就是说，这个 Docker 容器没有网卡、IP、路由等信息。需要我们自己为 Docker 容器添加网卡、配置 IP 等。</li></ul></li><li>bridge模式<ul><li><img data-src="evernotecid://E62A088B-AD42-4A98-B548-75BFC62A59C2/appyinxiangcom/19062149/ENResource/p7163" alt="56ad5155b0cb39e2e58b74776b38ad07.jpeg"></li></ul></li><li>The Container World | Part 2 Networking</li><li>bridge 模式是 Docker 默认的网络设置，此模式会为每一个容器分配 Network namespace、设置 IP 等，并将一个主机上的 Docker 容器连接到一个虚拟网桥上。当 Docker server 启动时，会在主机上创建一个名为 docker0 的虚拟网桥，此主机上启动的 Docker 容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。接下来就要为容器分配 IP 了，Docker 会从 RFC1918 所定义的私有 IP 网段中，选择一个和宿主机不同的IP地址和子网分配给 docker0，连接到 docker0 的容器就从这个子网中选择一个未占用的 IP 使用。如一般 Docker 会使用 172.17.0.0/16 这个网段，并将 172.17.42.1/16 分配给 docker0 网桥（在主机上使用 ifconfig 命令是可以看到 docker0 的，可以认为它是网桥的管理接口，在宿主机上作为一块虚拟网卡使用）</li></ul></li><li>docker常用命令及参数<ul><li>镜像类<ul><li>docker image ls</li><li>docker image rm</li><li>docker image</li><li>docker pull</li></ul></li><li>容器类<ul><li>docker container ls -a</li><li>docker container rm -f</li><li>docker ps</li><li>docker rm</li><li>docker run</li><li>docker start</li><li>docker restart</li><li>docker stop</li></ul></li><li>服务类<ul><li>docker</li></ul></li><li>参数说明<ul><li>-p</li><li>-v</li><li>-i</li><li>-t</li><li>—add-host</li></ul></li></ul></li><li>容器卷</li><li>docker api</li><li>docker 安全</li><li>lib container</li><li>docker集群管理</li><li>docker生态圈</li><li>docker 测试</li><li>应用场景<ul><li>作为云主机使用</li><li>作为服务使用：Web应用服务、持续集成和持续部署</li><li>微服务架构使用</li></ul></li><li>Dockerfile<ul><li>docker build -t tmp .</li><li>创建一个dockerfile文件，进行构建</li></ul></li><li>docker login<ul><li>user是用户名不是邮箱；</li></ul></li><li>docker tag文件<ul><li>重新标记一个镜像出来</li></ul></li><li>情况下提供 Unix Domain Socket 连接</li><li>底层依赖<ul><li>Group</li><li>Chroot</li><li>Namespace</li><li>Runc</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/frontend/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8.html"/>
      <url>man/frontend/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%AD%98%E5%82%A8.html</url>
      
        <content type="html"><![CDATA[<p>发展历史：从刚开始的Cookie，到localStorage，sessionStorage，再到IndexedDB，再到现在的Web SQL<br>1.cookie<br>    &gt;是用户访问网站的票根<br>    &gt;过服务端使用Set-Cookie Http header来设置和修改，当然也可以使用javascript的document.cookie去操作。<br>    浏览器操作</p><p>//读取网站下所有的cookie信息，获取的结果是一个以分号;作为分割的一个字符串<br>var allCookies = document.cookie;<br>//例如：在百度首页，获取的如下<br>// “BAIDUID=B32F2BF6BCB66D5559E199F5B1908F4C:FG=1; PSTM=1444711125; BIDUPSID=9DE77BD4B191F421CA54DB11C954067A; ispeed_lsm=0; MCITY=-289%3A; BDSFRCVID=hWtsJeC62Ag8XZc4Nvqo2MixJD2vkWoTH6aoB7vKuwGS_LREoJS6EG0PtvlQpYD-KiV2ogKK0eOTHvvP; H_BDCLCKID_SF=JbADoDD-JCvbfP0kKtr_MJQH-UnLq-vUbT7Z0l8KtqjJbMnL-TOF5R_eD4c0hUTRtjcW-b7mWIQHDp_65xRh5U-9BPvN04RZLbc4KKJxbPQSVtJXQKcvMq5XhUJiB5O-Ban7LtQxfJOKHICRe5-ajxK; BD_CK_SAM=1; locale=zh; BD_HOME=0; H_PS_PSSID=1455_18241_18559_17000_15227_11651; BD_UPN=123253”<br>//往原来的已经存在的cookie中加入新的cookie<br>document.cookie =”test=yui”;<br>//当然也可以在后面加上可选择的选项键值对，例如domain，以及其他path，expires<br>document.cookie=”test=yui;domain=.baidu.com”<br>//删除cookie，就是让这个cookie值得expires过，就是设置这个expires为0<br>document.cookie=”test=yui;domain=.baidu.com;expires=0”);<br>    注意：<br>       1) 通过上面的代码，可以看到document.cookie是个可访问的属性，但是它有内置的setter和getter的function，而不是一个简单的字符串数据，你的get和set都会调用这些原生内置的函数；<br>       2) Cookie支持跨域，可以通过在根域名设置cookie，共享多个子域名的数据。<br>2.WebStorage<br>    分为两部分：localStorage和sessionStorage<br>    sessionStorage:本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage是一种半持久化的本地存储（会话级别的存储<br>   localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。</p><p>var username = ‘helloworld’;<br>var storageUsername;<br>var randomArr = [Math.random()，Math.random()，Math.random()，Math.random()];<br>var storageRandomArr;<br>//storage username，key值区分大小写，存入的内容为这个变量调用toString方法的结果<br>localStorage.setItem(“username”，username);<br>//获取<br>storageUserName  = localstorage.getItem(“username”);<br>//“helloworld”<br>//删除<br>localStorage.removeItem(“username”);<br>storageUserName  =  localstorage.getItem(“username”);<br>// null<br>//存储对象时，可以先调用JSON.stringify方法，然后取出的时候再调用JSON.parse方法获取结果<br>localStorage.setItem(“randomarr”，JSON.stringify(randomArrr));<br>storageRandomArr = JSON.parse(localStorage.getItem(“randomarr”));<br>Object.prototype.toString.call(storageRandomArr);<br>// “object Array”</p><p>3.IndexDB<br>   IndexedDB是一个为了能够在客户端存储可观数量的结构化数据，并且在这些数据上使用索引进行高性能检索的API。<br>   IndexedDB分别为同步和异步访问提供了单独的API，异步API方法调用完后会立即返回，而不会阻塞调用线程。<br>   异步访问数据库，要调用Window对象IndexedDB属性的open()方法。该方法返回一个IDBRequest对象(IDBOpenDBRequest)；异步操作通过在IDBRequest对象上触发事件来和调用程序进行通信。<br>   IndexDb是NoSQL数据库，是一种支持事务的浏览器数据库，基本操作就是，打开数据库，增删改查各种。<br>    1) 打开数据库</p><p>//处理浏览器兼容性<br>window.indexedDB = window.indexedDB || window.webkitIndexedDB || window.mozIndexedDB || window.msIndexedDB;<br>//如果该数据库MyDatabase不存在，则会被创建；如果已经存在，则被打开。<br>var request = window.indexedDB.open(“MyDatabase”);<br>//打开数据库失败的回调<br>request.onerror = function(event) {<br>  console.log(“failure”);<br>};<br>//代开数据成功的回调<br>request.onsuccess = function(event) {<br>  console.log(“success”);<br>};<br>    2) 初始化数据库</p><p>var dbName = “MyDatabase”;<br>var dbVersion = 2;//整数<br>// open函数接受的第二个参数，代表数据的版本，当打开的版本号比当前的版本号大时，会触发onupgradeneeded这个回调<br>var request = window.indexedDB.open(dbName，dbVersion);<br>var studentsData = [{<br>    id:”001”，name:”xiaoming”，email:0<br>}，{<br>    id:”002”，name:”xiaoxiang”，email:1<br>}];<br>var tableName = ‘students’;<br>request.onerror = function (event) {<br>    //错误处理<br>};<br>request.onupgradeneeded = function (event) {<br>    var db = event.target.result;<br>    //创建表，以id字段作为主键来确保唯一，使用keyPath表示<br>    var objectStore = db.createObjectStore(tableName， { keyPath: “id” });<br>    //给表添加索引<br>    objectStore.createIndex(“name”，”name”，{unique:false});//非unique索引<br>    objectStore.createIndex(“email”，”email”，{unique:true});//email字段作为unique索引<br>    for(var i in studentsData){<br>        //插入数据<br>        objectStore.add(studentsData[i]);<br>    }<br>    console.log(“—init db success—“);<br>}<br>    3) 使用事务添加、删除数据<br>       transaction()方法接受两个参数并返回一个事务对象。第一个参数是事务希望跨越的对象存储空间的列表，即数据库中的表名称。如果你希望事务能够跨越所有的对象存储空间你可以传入一个空数组。第二个参数如果你没有为第二个参数指定任何内容，默认只读。</p><p>var dbName = “MyDatabase”;<br>var request = window.indexedDB.open(dbName);<br>var addData = [{<br>    id:”003”，name:”xiaofang1”，email:”<a href="mailto:3@qq.com">3@qq.com</a>“<br>}，{<br>    id:”004”，name:”xiaofang2”，email:”<a href="mailto:4@qq.com">4@qq.com</a>“<br>}，{<br>    id:”005”，name:”xiaofang3”，email:”<a href="mailto:5@qq.com">5@qq.com</a>“<br>}];<br>var tableName = ‘students’;<br>//打开数据库失败的回调<br>request.onerror = function(event) {<br>    console.log(“open indexDb database failure”);<br>};<br>//代开数据成功的回调<br>request.onsuccess = function(event) {<br>    var db = event.target.result;<br>    var transaction = db.transaction([tableName]，’readwrite’);<br>    var objectStore;<br>    var i;<br>    //事务主要有三个回调，error，abort，success<br>    transaction.onerror = function (event) {<br>        //处理错误<br>        console.log(event);<br>    }<br>    transaction.onbort = function () {<br>        //事务中断处理<br>    }<br>    transaction.oncomplete = function () {<br>        console.log(“添加数据成功”);<br>    }<br>    objectStore  = transaction.objectStore(tableName);<br>    for(i  in addData){<br>        var request = objectStore.add(addData[i]);<br>        request.onsuccess = function (event) {<br>            console.log(“add one success”);<br>        }<br>    }<br>};<br>//删除001学生<br>var dbName = “MyDatabase”;<br>var request = window.indexedDB.open(dbName);<br>var db;<br>var tableName = ‘students’;<br>request.onerror = function () {<br>};<br>request.onsuccess  = function (event) {<br>    var objectStore;<br>    var transaction;<br>    db =  event.target.result;<br>    transaction= db.transaction([tableName]，’readwrite’);<br>    transaction.onerror = function (event) {<br>        //处理错误<br>        console.log(“error when delete 001 “+ event.target.errorCode);<br>    }<br>    transaction.onbort = function () {<br>        //事务中断处理<br>    }<br>    transaction.oncomplete = function () {<br>        console.log(“删除学生001成功”);<br>    }<br>    objectStore = transaction.objectStore(tableName);<br>    objectStore.delete(“001”);<br>};<br>4) 使用索引查找数据<br>主要调用IDBObjectStore示例对象的index方法：<br>var dbName = “MyDatabase”;<br>var request = window.indexedDB.open(dbName);<br>var db;<br>var tableName = ‘students’;<br>request.onerror = function () {<br>};<br>request.onsuccess  = function (event) {<br>    var index;<br>    var objectStore;<br>    db =  event.target.result;<br>    objectStore = db.transaction([tableName]).objectStore(tableName);<br>    //根据索引字段email朝找<a href="mailto:3@qq.com">3@qq.com</a>的学生<br>    index = objectStore.index(“email”).get(“<a href="mailto:3@qq.com">3@qq.com</a>“);<br>    index.onsuccess = function(event) {<br>        console.log(event.target.result);<br>    };<br>    index.onerror = function (event) {<br>        console.log(“error when find  by index “+ event.target.errorCode);<br>    }<br>};</p><ol start="5"><li>其他<br>Application Cache<br>Application Cache翻译成中文为应用程序缓存，是html5中为实现离线浏览所提供的API。结合Manifest文件使用，使用编程方式，更新浏览器缓存内容。主要调用update与swapCache去更新浏览缓存，目前该技术已经被最新的规范所废弃，转而使用了Service Workers。<br>Service Workers<br>一个service worker是一段运行在浏览器后台进程里的脚本，它独立于当前页面，提供了一些不需要与web页面交互的功能，即那种在网页背后悄悄执行的能力。在将来，基于它可以实现消息推送，静默更新等服务，但是目前它首先要具备的功能是拦截和处理网络请求，包括可编程的响应缓存管理。</li></ol>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/hadoop/spark.html"/>
      <url>man/hadoop/spark.html</url>
      
        <content type="html"><![CDATA[<p>基本概念</p><ul><li>Application：提交到Spark集群的应用程序，简称App。</li><li>Driver：执行应用程序中创建SparkContext的main函数的进程，一般在集群的任何节点向集群提交应用程序，就可以将该节点称做Driver节点。</li><li>Cluster manager：即集群管理器，作为Spark集群的“神经中枢”，统筹管理Spark集群的各种资源，包括CPU和内存等，并分配不同服务所需的资源（例如standalone manager即Master、Mesos和Yarn）。</li><li>Master节点：即部署Cluster manager的节点，是一个物理层的概念。</li><li>worker节点：任何在集群中运行应用程序的节点，其接收集群管理器的调度安排，为应用程序分配必需的资源，生成Executor，起到桥梁作用</li><li>Slave节点：即部署Worker的机器节点，每个Slave节点可以有多个Worker进程，是一个物理层的概念。</li><li>Executor：表示应用在Worker节点中进行实际计算的继承，进程会接收切分好的Task任务，并将结果缓存在节点内存和磁盘上</li><li>Task：被分配到各个Executor的单位工作内容，它是Spark中的最小执行单位，一般来说有多少个Paritition（物理层面的概念，即分支可以理解为将数据划分成不同部分并行处理），就会有多少个Task，每个Task只会处理单一分支上的数据。</li><li>Job：由多个Task的并行计算部分，一般Spark中的action操作（如save、collect，下一章会进一步说明），会生成一个Job。</li><li>Stage：是Job的组成单位，一个Job会切分成多个Stage, Stage彼此之间相互依赖顺序执行，而每个Stage是多个Task的集合，类似map和reduce stage。</li></ul><p>RDD存储结构</p><p>DataFream没有flatMap方法.需要转换成RDD<br>    r = df_artist_profile.rdd.map(lambda x: {x[‘id’]:x[‘name’]}).collection() # 返回一个list<br>    print(r[:10]<br>‘PipelinedRDD’ object has no attribute ‘show’只能用take<br>show() is only for spark DataFrame.</p><ul><li>dbtable可以是一个表名，也可以是一个查询语句创建的临时表<ul><li>df_artist_profile = self.ss.read.format(‘jdbc’).options(url=self.mainsite_url,dbtable=”(select id, name from artist_profile) artist_profile”,useSSL=’false’).load()</li><li>df_artist_profile = self.ss.read.format(‘jdbc’).options(url=self.mainsite_url,dbtable=”artist_profile”,useSSL=’false’).load()</li></ul></li></ul><p>spark dataframe派生于RDD类，但是提供了非常强大的数据操作功能。当然主要对类SQL的支持<br>DataFrame 的函数<br>Action 操作<br>1、 collect() ,返回值是一个数组，返回dataframe集合所有的行<br>2、 collectAsList() 返回值是一个java类型的数组，返回dataframe集合所有的行<br>3、 count() 返回一个number类型的，返回dataframe集合的行数<br>4、 describe(cols: String*) 返回一个通过数学计算的类表值(count, mean, stddev, min, and max)，这个可以传多个参数，中间用逗号分隔，如果有字段为空，那么不参与运算，只这对数值类型的字段。例如df.describe(“age”, “height”).show()<br>5、 first() 返回第一行 ，类型是row类型<br>6、 head() 返回第一行 ，类型是row类型<br>7、 head(n:Int)返回n行  ，类型是row 类型<br>8、 show()返回dataframe集合的值 默认是20行，返回类型是unit<br>9、 show(n:Int)返回n行，，返回值类型是unit<br>10、 table(n:Int) 返回n行  ，类型是row 类型</p><p>dataframe的基本操作<br>1、 cache()同步数据的内存<br>2、 columns 返回一个string类型的数组，返回值是所有列的名字<br>3、 dtypes返回一个string类型的二维数组，返回值是所有列的名字以及类型<br>4、 explan()打印执行计划  物理的<br>5、 explain(n:Boolean) 输入值为 false 或者true ，返回值是unit  默认是false ，如果输入true 将会打印 逻辑的和物理的<br>6、 isLocal 返回值是Boolean类型，如果允许模式是local返回true 否则返回false<br>7、 persist(newlevel:StorageLevel) 返回一个dataframe.this.type 输入存储模型类型<br>8、 printSchema() 打印出字段名称和类型 按照树状结构来打印<br>9、 registerTempTable(tablename:String) 返回Unit ，将df的对象只放在一张表里面，这个表随着对象的删除而删除了<br>10、 schema 返回structType 类型，将字段名称和类型按照结构体类型返回<br>11、 toDF()返回一个新的dataframe类型的<br>12、 toDF(colnames：String*)将参数中的几个字段返回一个新的dataframe类型的，<br>13、 unpersist() 返回dataframe.this.type 类型，去除模式中的数据<br>14、 unpersist(blocking:Boolean)返回dataframe.this.type类型 true 和unpersist是一样的作用false 是去除RDD</p><p>集成查询：<br>1、 agg(expers:column<em>) 返回dataframe类型 ，同数学计算求值<br>df.agg(max(“age”), avg(“salary”))<br>df.groupBy().agg(max(“age”), avg(“salary”))<br>2、 agg(exprs: Map[String, String])  返回dataframe类型 ，同数学计算求值 map类型的<br>df.agg(Map(“age” -&gt; “max”, “salary” -&gt; “avg”))<br>df.groupBy().agg(Map(“age” -&gt; “max”, “salary” -&gt; “avg”))<br>3、 agg(aggExpr: (String, String), aggExprs: (String, String)</em>)  返回dataframe类型 ，同数学计算求值<br>df.agg(Map(“age” -&gt; “max”, “salary” -&gt; “avg”))<br>df.groupBy().agg(Map(“age” -&gt; “max”, “salary” -&gt; “avg”))<br>4、 apply(colName: String) 返回column类型，捕获输入进去列的对象<br>5、 as(alias: String) 返回一个新的dataframe类型，就是原来的一个别名<br>6、 col(colName: String)  返回column类型，捕获输入进去列的对象<br>7、 cube(col1: String, cols: String<em>) 返回一个GroupedData类型，根据某些字段来汇总<br>8、 distinct 去重 返回一个dataframe类型<br>9、 drop(col: Column) 删除某列 返回dataframe类型<br>10、 dropDuplicates(colNames: Array[String]) 删除相同的列 返回一个dataframe<br>11、 except(other: DataFrame) 返回一个dataframe，返回在当前集合存在的在其他集合不存在的<br>12、 explode[A, B](inputColumn: String, outputColumn: String)(f: (A) ⇒ TraversableOnce[B])(implicit arg0: scala.reflect.api.JavaUniverse.TypeTag[B]) 返回值是dataframe类型，这个 将一个字段进行更多行的拆分<br>df.explode(“name”,”names”) {name :String=&gt; name.split(“ “)}.show();<br>将name字段根据空格来拆分，拆分的字段放在names里面<br>13、 filter(conditionExpr: String): 刷选部分数据，返回dataframe类型 df.filter(“age&gt;10”).show();  df.filter(df(“age”)&gt;10).show();   df.where(df(“age”)&gt;10).show(); 都可以<br>14、 groupBy(col1: String, cols: String</em>) 根据某写字段来汇总返回groupedate类型   df.groupBy(“age”).agg(Map(“age” -&gt;”count”)).show();df.groupBy(“age”).avg().show();都可以<br>15、 intersect(other: DataFrame) 返回一个dataframe，在2个dataframe都存在的元素<br>16、 join(right: DataFrame, joinExprs: Column, joinType: String)<br>一个是关联的dataframe，第二个关联的条件，第三个关联的类型：inner, outer, left_outer, right_outer, leftsemi<br>df.join(ds,df(“name”)===ds(“name”) and  df(“age”)===ds(“age”),”outer”).show();<br>17、 limit(n: Int) 返回dataframe类型  去n 条数据出来<br>18、 na: DataFrameNaFunctions ，可以调用dataframenafunctions的功能区做过滤 df.na.drop().show(); 删除为空的行<br>19、 orderBy(sortExprs: Column<em>) 做alise排序<br>20、 select(cols:string</em>) dataframe 做字段的刷选 df.select($”colA”, $”colB” + 1)<br>21、 selectExpr(exprs: String<em>) 做字段的刷选 df.selectExpr(“name”,”name as names”,”upper(name)”,”age+1”).show();<br>22、 sort(sortExprs: Column</em>) 排序 df.sort(df(“age”).desc).show(); 默认是asc<br>23、 unionAll(other:Dataframe) 合并 df.unionAll(ds).show();<br>24、 withColumnRenamed(existingName: String, newName: String) 修改列表 df.withColumnRenamed(“name”,”names”).show();<br>25、 withColumn(colName: String, col: Column) 增加一列 df.withColumn(“aa”,df(“name”)).show();</p><p><a href="https://images.168seo.cn/blog/2018-09-07-014124.png" target="_blank" rel="noopener">https://images.168seo.cn/blog/2018-09-07-014124.png</a></p><p>Directed Acyclic Graph，DAG</p><p>在处理一些数据的时候会遇到不想要的前n行，该怎么处理？<br>    使用 rdd 的 zipWithIndex 算子<br>    rdd.zipWithIndex().filter(<em>.</em>2&gt;=n).keys  // n换成对应的第几列即可</p><ul><li>scala中map和foreach的区别<ul><li>map：用于遍历RDD,将函数f应用于每一个元素，返回新的RDD(transformation算子)。</li><li>foreach:用于遍历RDD,将函数f应用于每一个元素，无返回值(action算子)。</li><li>mapPartitions:用于遍历操作RDD中的每一个分区，返回生成一个新的RDD（transformation算子）。</li><li>foreachPartition: 用于遍历操作RDD中的每一个分区。无返回值(action算子)。</li><li>总结：一般使用mapPartitions或者foreachPartition算子比map和foreach更加高效，推荐使用。</li></ul></li><li>pyspark添加行索引<ul><li>df_resou_day = df_resou_day.withColumn(‘index’, monotonically_increasing_id())</li></ul></li><li>pyspark df添加一列默认值<ul><li>community = self.artist_profile.withColumn(‘community_num’, lit(0))</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/php/laravel.html"/>
      <url>man/php/laravel.html</url>
      
        <content type="html"><![CDATA[<p>php  artistan tinker</p><p>ROM分为两种类型：<br>1.ActiveRecord  模型和数据表对应<br>2.DataMapper    模型和数据表分离</p><p>Eloquent  ORM使用的是AR模型<br>一个类对应一个数据表，一个模型类的方法实现CUID操作</p><p>创建模型命令：php artisan make:model Models/Po</p><p>所以model都继承自Illuminate\Database\Eloquent\Model类</p><p>如果不手动指定，Post默认对应的数据表为posts表<br>也可以手动指定，public  $table = ‘posts_another’;</p><p>默认主键为id，也可手动指定<br>public  $primaryKey =’id_another’;</p><p>支持聚合函数<br>-&gt;where()<br>-&gt;orderBy()<br>-&gt;join()<br>-&gt;limit()<br>-&gt;count()<br>-&gt;sum()<br>-&gt;max()</p><p>关联关系：<br>一对一           hasOne()<br>一对多           hasMany()<br>多对多           belongsToMany()<br>远层一对多<br>多台关联<br>多对多的多态关联</p><p>hasManyThrough()</p><p>一个模型关联另外一个模型,默认主键(id)<br>belongsTo()<br>对象表  关系表  枚举表</p><p>//创建table<br>php artisan make:migration create_user_accounts_table –create=user_accounts<br>//执行创建表<br>php artisan migrate<br>//创建一个model<br>php artisan make:model Models/UserAccount</p><p>方法链</p><p>Eloquent集合继承自集合类</p><p>集合方法<br>all()：返回底层数组<br>chunk():分割集合为几个集合<br>collapse():将一个多维数组集合成一个数组<br>contains():判断集合是否包含一个给定项<br>count():返回集合中所有项的数目<br>diff():将集合和另外一个集合或原生php数组进行比较<br>each():迭代集合中的数据项并传递每个数据项到给定回调<br>filter():通过给定回调过滤集和(相反的方法为 reject() )<br>first():返回通过测试的集合的第一个元素<br>flatten():将多维度的集合变成一个维<br>flip():将集合的键值交换<br>forget():通过键从集合中移除数据项<br>forPage(page,nums):返回新的包含给定页数数据项的集合<br>get():返回给定键值的数据项，如果不存在就返回null<br>groupBy():通过给定键分组集合数据项<br>has():判断给定键是否在集合中存在<br>impode():链接集合中的数据项<br>intersect():返回两个集合的交际<br>isEmpty():判断是否为空<br>keyBy():将指定键的值作为集合的件<br>keys():返回集合所有的键<br>last():返回通过测试的最后一个元素<br>map():遍历集合并传递每一个值给指定回调，回调可以修改数据项并返回，生成新集合，而不是修改原实例<br>merge():合并给定数组到集合<br>pluck():为给定键获取所有集合值<br>pop():移除并返回集合最后的数据项<br>perpend():添加数据项到集合开头<br>pull():通过键从集合中移除并返回数据项<br>push():附加数据项到集合尾<br>put():在集合中设置给定键和值<br>random():从集合中返回随机数据项<br>reduce():用于减少集合到单个值，传递每个迭代结果到随后的迭代<br>reject():<br>reverse():将集合数据项的顺序颠倒<br>search():为给定值查询集合，如果找到返回对应的键，否则返回false<br>shift():移除并返回第一个数据项<br>shuffle():随机打乱集合中的数据项<br>slice():从给定索引开始返回集合的一个切片<br>sort():对集合进行排序<br>sortBy():通过给定键对集合进行排序   sortByDesc():倒叙排列<br>splice():从给定位置移除并返回数据项切片<br>sum():返回所有数据项的和<br>take():使用指定数目的数据项返回一个新的集合<br>toArray():将集合转化为一个原生的php数组<br>toJson():将集合转化为json<br>transform():迭代集合并对集合中每个数据项调用给定回调，原集合被替代<br>unique():返回集合中所有唯一数据项<br>values():重置为连续整型数字的键并返回<br>where():通过给定键值对过滤集合<br>whereLoose():同where()，不过在比较值的时候使用松散约束<br>zip():在于集合的值对应的索引处合并给定数组的值</p><p>访问器&amp;修饰器</p><p>授权&amp;认证<br>社会化登陆认证</p><p>artisan命令<br>1.php artisan list<br>2.php artisan help migrate<br>3.php artisan make:console SendEmails<br>4.php artisan make:console SendEmails –command-emails:send<br>5.php artisan make:middleware TestMiddleware<br>6.php artisan make:controller<br>7.php artisan make:model<br>8.php artisan make:command<br>9.php artisan make:console<br>10.php artisan make:event<br>11.php artisan make:job<br>12.php artisan make:listener<br>13.php artisan make:migration<br>14.php artisan make:provider<br>15.php artisan make:request         //创建表单验证规则和授权验证<br>16.php artisan make:seeder<br>17.php artisan app:name         //批量修改命名空间</p><p>缓存</p><p>gulp服务<br>需要node.js</p><p>加密<br>crypt  decrypt</p><p>错误&amp;日志<br>所有异常都是App\Exceptions\Handler处理(report和render)</p><p>事件</p><p>文件系统/云存储</p><p>3/24—————————————————–</p><p>/<strong><strong><strong>****</strong></strong></strong>路由<strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong>/<br>所有的路由都定义在/app/Http/routes.php文件中<br>Homestead虚拟机可以作为开发环境<br>路由定义方式<br>Route::get(‘route’,’func’)<br>Route::post(‘route’,’func’)<br>Route::match([‘get’,’post’],’route’,’func’)<br>Route::any(‘route’,’func’)<br>路由亦可定义必选参数<br>Route::get(‘/hello/{name}’,’func’)<br>Route::get(‘/hello/{name}/by/{user}’,’func’)<br>可以定义可选参数<br>Route::get(‘/hello/{name?}’,’func’)<br>可以进行正则约束<br>Route::get(‘/hello/{name}’,’func’)-&gt;where(‘name’,’[A-Z]+’)<br>如果想要全局约束，需要在RouteServiceProvider的boot方法中定义<br>public function boot(Router $router){<br>    $router-&gt;pattern(‘name’,’[A-Za-z]+’);<br>    parent::boot($router);<br>}</p><p>可以给路由起个别名(as),可以结合route()使用<br>Route::get(‘/hello/laravelacademy’,[‘as’=&gt;’academy’,’func’])</p><p>路由分组<br>将一组拥有相同属性(中间件、命名空间、子域名、路由前缀等)的路由<br>使用Route门面的group方法聚合起来</p><p>中间件作用<br>处理请求过来的数据，做中间处理，然后做后续处理</p><p>命名空间<br>routes.php定义的控制默认位于App\Http\Controllers命名空间下，<br>所以如果要指定命名空间，只需指定App\Http\Controllers之后的部分即可<br>Route::group([‘namespace’=&gt;’laravelacademy’],function(){<br>    //控制器在App\Http\Controllers\laraveladademy下</p><pre><code>Route::group([&apos;namespace&apos;=&gt;&apos;DDOS&apos;],function(){    //控制器在App\Http\Controllers\laraveladademy\DDOS下});</code></pre><p>});</p><p>子域名<br>通过domain关键字来设置<br>Route::get([‘domain’=&gt;’{service}.laravel.app’],function(){</p><pre><code>Route::get(&apos;/write/laravelacademy&apos;,function($service){    return &quot;wirte from {$service}.laravel.app&quot;;});Route::get(&apos;update/laravelacademy&apos;,function($service){    return &quot;update from {$service}.laravel.app&quot;;});</code></pre><p>});</p><p>路由前缀<br>可以在group中设置prefix属性来指定前缀<br>Route::group([‘prefix’=&gt;’laravelacademy’],function(){</p><pre><code>Route::get(&apos;write&apos;,function(){    return &apos;write laravelacademy&apos;;});Route::get(&apos;update&apos;,function(){    return &apos;update laravelacademy&apos;;});</code></pre><p>});<br>也可以在路由前缀中添加参数<br>Route::group([‘prefix’=&gt;’laravelacademy/{version}’],function(){</p><pre><code>Route::get(&apos;write&apos;,function($version){    return &quot;write laravelacademy $version&quot;;});Route::get(&apos;update&apos;,function($version){    return &quot;update laravelacademy {$version}&quot;;});</code></pre><p>});</p><p>CSRF防御原理<br>Laravel自动为每个用户session生成要给CSRF Token，可以验证登陆用户和<br>发起请求是否是同一个人，如果不是则请求失败</p><p>一个全局帮助函数csrf_token来获取该token<br><input type="hidden" name="_token" value="<?php echo csrf_token(); ?>"><br>等同于 <?php echo csrf_field(); ?><br>在blade模板中可以使用如下方式 {!! csrf_field() !!}</p><p>并不是所有请求都需要避免CSRF攻击，比如去第三方api请求数据<br>可以通过VerifyCsrfToken中间件将要排除的请求url添加到$except属性数组中<br>X-CSRF-TOKEN   X-XSRF-TOKEN<br>/<strong><strong><strong><strong><strong>*****</strong></strong></strong></strong></strong>路由<strong><strong><strong>*****</strong></strong></strong>/</p><p>/<strong><strong><strong><strong>***</strong></strong></strong></strong>中间件<strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong>/<br>中间件<br>在请求到达最终动作之前对请求过滤和处理<br>可以进行用户认证、日志、维护模式、开启session、从session获取信息、CSRF验证<br>只需要定义一个handle方法即可<br>请求处理前执行业务逻辑，在$next闭包执行前执行业务逻辑<br>请求处理后执行业务逻辑，在$next闭包执行后执行业务逻辑<br>中间件也可以定义参数<br>定义可终止的中间件，指定义了terminate方法的中间件</p><p>HTTP请求<br>获取请求路径url<br>Request $request;<br>$request-&gt;path();   //相对路径<br>$request-&gt;url();    //绝对路径<br>$request-&gt;method();   //获取请求方法<br>$request-&gt;input();    //获取参数值<br>$request-&gt;all();    //获取所有输入<br>$request-&gt;has();    //判断是否存在此参数<br>$request-&gt;only();   //获取部分输入<br>$request-&gt;isMethod(); //判断传入方法<br>$request-&gt;is();       //判断路径<br>$request-&gt;except();   //排除部分输入参数值</p><p>获取上次请求数据<br>在获取上次数据时，用flash()把数据保存到session中，然后再当前请求中用old方法<br>从session中获取，然后把session中的数据销毁<br>$request-&gt;flush();<br>$request-&gt;old();</p><p>获取cookie数据<br>$request-&gt;cookie();<br>//新增cookie，第一个是名，第二个参数是值，第三个参数是有效期(分钟)<br>$request-&gt;withCookie();</p><p>文件上传<br>$request-&gt;hasFile();<br>$file = $request-&gt;file();<br>$file-&gt;isValid();<br>$file-&gt;move($destPath,$fileName)</p><p>文件下载<br>response()-&gt;download();</p><p>重定向<br>redirect()-&gt;route();<br>redirect()-&gt;action();   //重定向到控制器动作<br>redirect()-&gt;with();     //带一次性session数据到重定向请求页面</p><p>/<strong><strong><strong>***</strong></strong></strong>视图共享数据 begin<strong><strong><strong><strong>****</strong></strong></strong></strong>/<br>全局帮助函数:view();<br>在视图间共享数据，需要用share()方法<br>在服务提供者的boot方法中加入<br>view()-&gt;share(‘sitename’,’Laravel学院’);</p><p>有时每次渲染视图需要绑定一些数据，比如用户登陆信息<br>composer<br>view()-&gt;composer(‘hello’,function($view){<br>    $view-&gt;with(‘user’,array(‘name’=&gt;’test’));<br>})<br>传递多个试图<br>view()-&gt;composer([‘hello’,’home’],function($view){<br>    $view-&gt;with(‘user’,array(‘name’=&gt;’test’));<br>})<br>传递所有试图<br>view()-&gt;composer(‘*’,function($view){<br>    $view-&gt;with(‘user’,array(‘name’=&gt;’test’));<br>})</p><p>/<strong><strong><strong><strong>*****</strong></strong></strong></strong>视图分享 end<strong><strong><strong><strong>****</strong></strong></strong></strong>/</p><p>/<strong><strong><strong>***</strong></strong></strong>启动分析 begin<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong>/<br>1.初始化Application<br>1.1 注册基本绑定<br>  app -&gt; Application实例（Illuminate\Foundation\Application）<br>  Illuminate\Container\Container -&gt; Application实例<br>  （Illuminate\Foundation\Application）<br>1.2注册基本服务提供者并启动<br>1.3 注册核心服务容器别名<br>1.4设置根路径<br>2.注册共享的Kernel和异常处理器<br>Illuminate\Contracts\Http\Kernel -&gt; App\Http\Kernel<br>Illuminate\Contracts\Console\Kernel -&gt; App\Console\Kernel<br>Illuminate\Contracts\Debug\ExceptionHandler -&gt; App\Exceptions\Handler<br>3.处理请求和响应<br>3.1web请求</p><p>/<strong><strong><strong><strong>*****</strong></strong></strong></strong>/启动分析 end<strong><strong><strong><strong>****</strong></strong></strong></strong>/</p><p>/<strong><strong><strong>****</strong></strong></strong>Ioc和DI  begin<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/</p><p>/<strong><strong><strong>****</strong></strong></strong>Ioc和DI end<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>/</p><p>接口是一种锲约和规范</p><p>3/28</p><p>model字段类型<br>1.$table-&gt;increments(‘id’);<br>2.$table-&gt;string();<br>3.$table-&gt;text();<br>4.$table-&gt;timestamps(); //laravel自动完成时间插入更新<br>5.$table-&gt;timestamp();</p><p>3／29</p><p>1.laravel的静态文件存放在public文件夹下，在assets下存放的应该是编译的源文件<br>2.两种表单验证，Request和Validation<br>    创建Request类，有author和rule验证，然后在controller里对应的方法引用验证，如果有错误，可以在页面进行显示<br>    Validation是用make方法写入规则，然后用fail方法验证<br>3.修改时区是把utc改为prc即可<br>4.save()方法默认添加created_at和updated_at两个字段</p><p>3/30<br>homebrew用法<br>1.brew install wget<br>2.brew info wget<br>3.brew search wget<br>4.brew list<br>5.brew remove wget<br>6.brew clearup<br>7.brew update<br>8.brew deps wget<br>9.brew tap some         //添加源</p><p>搭建LNMP环境<br>开始<br>1.安装brew<br>    /usr/bin/ruby -e “$(curl -fsSL <a href="https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;" target="_blank" rel="noopener">https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</a><br>一、安装mysql<br>1.查看mysql版本<br>    brew  info mysql<br>    brew  search  mysql<br>2.安装mysql<br>    brew  install mysql<br>3.设定mysql开机启动<br>    ln -sfv /usr/local/opt/mysql/*.plist ~/Library/LaunchAgents<br>4.启动mysql<br>    mysql -uroot -p<br>5.第一次进入没有密码，设置新密码<br>    alter user ‘root’@’localhost’ identified by ‘password’;</p><p>二、安装php<br>1.加入brew的几个官方源<br>    brew tap homebrew/dupes<br>    brew tap homebrew/versions<br>    brew tap homebrew/php<br>2.查看php版本信息<br>    brew info php56<br>3.开始编译安装<br>    brew install php56 <br>    –without-snmp <br>    –without-apache <br>    –with-fpm <br>    –with-intl <br>    –with-homebrew-curl <br>    –with-homebrew-libxslt <br>    –with-homebrew-openssl <br>    –with-imap <br>    –with-mysql <br>    –with-tidy<br>4.把php环境添加到path里，覆盖掉机内自带的php<br>    export PATH=”/usr/local/bin:/usr/local/sbin:$PATH”<br>5.查看php扩展<br>    brew search php56<br>6.安装php扩展<br>    brew install php56-mcrypt php56-gearman php56-msgpack php56-memcache php56-memcached php56-mongo php56-phalcon php56-redis php56-debug<br>7.把php加入开机启动<br>    ln -sfv /usr/local/opt/php56/*.plist ~/Library/LaunchAgents<br>    launchctl load   ~/Library/LaunchAgents/homebrew.mxcl.php56.plist<br>8.php操作<br>    启动  php-fpm -D<br>    关闭  killall php-fpm</p><p>三.安装nginx<br>1.查看nginx版本<br>    brew info nginx<br>2.安装nginx<br>    brew install nginx<br>3.nginx安装后默认监听8080端口，要想监听80端口，需要root权限<br>    sudo chown root:wheel /usr/lcoal/Cellar/nginx/1.8.1/bin/nginx<br>    sudo chmod u+s /usr/local/Cellar/Nginx1.8.1/bin/nginx<br>4.开机启动<br>    ln -sfv /usr/local/opt/ningx/*.plist   ~/Library/LaunchAgents<br>    launchctl load  ~/Library/LaunchAgents/homebrew.mxcl.nginx.plist<br>5.nginx操作<br>    启动  nginx<br>    nginx  -s reload|reopen|stop|quit<br>6.nginx配置</p><p>php的hashTable<br>1.采用拉链法解决冲突<br>2.采用DJBX33A算法来实现<br>解决冲突的方法<br>1.开放定址法<br>    开放地执法有一个公式:Hi=(H(key)+di) MOD m i=1,2,…,k(k&lt;=m-1)<br>    其中，m为哈希表的表长。di 是产生冲突的时候的增量序列。如果di值可能为1,2,3,…m-1，称线性探测再散列。<br>2.拉链法<br>    将所有关键字为同义词的记录存储在同一个线性链表中<br>3.在哈希法<br>    当发生冲突时用第二个、第三个哈希函数计算地址，直到无冲突为止。缺点是计算时间过长<br>4.建立公共溢出区</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="man/python/basic.html"/>
      <url>man/python/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-语言设计原则"><a href="#1-语言设计原则" class="headerlink" title="1.语言设计原则"></a>1.语言设计原则</h3><ul><li>python设计之蝉<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure></li></ul><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">官方pep8规范</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">google规范文档</a></li></ul><h3 id="注释、文档"><a href="#注释、文档" class="headerlink" title="注释、文档"></a>注释、文档</h3><ul><li>用#号进行单行注释</li><li>文档注释用“”“ ”“”来进行</li></ul><h3 id="关键字有哪些，有什么作用"><a href="#关键字有哪些，有什么作用" class="headerlink" title="关键字有哪些，有什么作用"></a>关键字有哪些，有什么作用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">help&gt; keywords</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> a list of the Python keywords.  Enter any keyword to get more help.</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span>               <span class="class"><span class="keyword">class</span>               <span class="title">from</span>                <span class="title">or</span></span></span><br><span class="line"><span class="class"><span class="title">None</span>                <span class="title">continue</span>            <span class="title">global</span>              <span class="title">pass</span></span></span><br><span class="line"><span class="class"><span class="title">True</span>                <span class="title">def</span>                 <span class="title">if</span>                  <span class="title">raise</span></span></span><br><span class="line"><span class="class"><span class="title">and</span>                 <span class="title">del</span>                 <span class="title">import</span>              <span class="title">return</span></span></span><br><span class="line"><span class="class"><span class="title">as</span>                  <span class="title">elif</span>                <span class="title">in</span>                  <span class="title">try</span></span></span><br><span class="line"><span class="class"><span class="title">assert</span>              <span class="title">else</span>                <span class="title">is</span>                  <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">async</span>               <span class="title">except</span>              <span class="title">lambda</span>              <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">await</span>               <span class="title">finally</span>             <span class="title">nonlocal</span>            <span class="title">yield</span></span></span><br><span class="line"><span class="class"><span class="title">break</span>               <span class="title">for</span>                 <span class="title">not</span></span></span><br></pre></td></tr></table></figure><h3 id="关键字赋值"><a href="#关键字赋值" class="headerlink" title="关键字赋值"></a>关键字赋值</h3><ul><li><p>关键字不可以赋值，会报<code>invalid syntax</code>错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span>=<span class="number">123</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>=<span class="number">123</span></span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span>=<span class="string">'abc'</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>=<span class="string">'abc'</span></span><br><span class="line">         ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></li><li><p>但是内部的函数名是可以当作变量来赋值的，但是这样的话，就不能当作内部函数来使用了。只有把这个变量删除，然后才能正常使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(id)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(id))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">del</span> <span class="title">id</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">id</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">function</span> <span class="title">id</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li>Numbers（数字）<ul><li>int（有符号整型）</li><li>long（长整型[也可以代表八进制和十六进制]）</li><li>float（浮点型）</li><li>complex（复数）</li><li>小整数对象——小整型对象池<ul><li>在实际编程中，数值比较小的整数，比如1,2,29等，可能会非常频繁的出现。而在python中，所有的对象都存在于系统堆上。想想？如果某个小整数出现的次数非常多，那么Python将会出现大量的malloc/free操作，这样大大降低了运行效率，而且会造成大量的内存碎片，严重影响Python的整体性能。</li></ul></li></ul></li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>一共有四种<ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域</li></ul></li><li>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找</li><li>除了def/class/lambda 外，其他如: if/elif/else/ try/except for/while并不能改变其作用域。定义在他们之内的变量，外部还是可以访问。</li><li>在 def/class/lambda内进行赋值，就变成了其局部的作用域，局部作用域会覆盖全局作用域，但不会影响全局作用域</li><li>闭包的定义：如果在一个内部函数里，对在外部函数内（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)</li><li>global 和 globals() 是不同的，global 是关键字用来声明一个局部变量为全局变量。globals() 和 locals() 提供了基于字典的访问全局和局部变量的方式</li></ul><h3 id="普通打印"><a href="#普通打印" class="headerlink" title="普通打印"></a>普通打印</h3><ul><li>数字、字符串、函数、类、结构体、枚举值、关键字、未定义值</li><li>多个变量同时打印</li><li>换行打印，同行打印</li><li>以不同的结尾符打印<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">123</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'aaa'</span>)</span><br><span class="line">aaa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line"><span class="number">123</span> <span class="number">456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"abc"</span>,<span class="number">123</span>)</span><br><span class="line">abc <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="keyword">print</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="keyword">print</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dir)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function dir&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(print())</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dir())</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>]</span><br></pre></td></tr></table></figure><h3 id="结构化打印"><a href="#结构化打印" class="headerlink" title="结构化打印"></a>结构化打印</h3></li><li>把数据按照可读的方式打印出来<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(&#123;<span class="string">'a'</span>:<span class="number">123</span>,<span class="string">'b'</span>:[<span class="string">'abc'</span>,<span class="string">'def'</span>],<span class="string">'c'</span>:&#123;<span class="string">'x'</span>:<span class="number">456</span>,<span class="string">'y'</span>:<span class="number">789</span>&#125;&#125;,width=<span class="number">30</span>)</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="string">'b'</span>: [<span class="string">'abc'</span>, <span class="string">'def'</span>],</span><br><span class="line"> <span class="string">'c'</span>: &#123;<span class="string">'x'</span>: <span class="number">456</span>, <span class="string">'y'</span>: <span class="number">789</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何区别可变数据类型和不可变数据类型"><a href="#如何区别可变数据类型和不可变数据类型" class="headerlink" title="如何区别可变数据类型和不可变数据类型"></a>如何区别可变数据类型和不可变数据类型</h3><ul><li>数字、字符串、元组是不可变的<ul><li>对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象</li><li>对于不可变类型int，无论创建多少个不可变类型，只要值相同，都指向同个内存地址。同样情况的还有比较短的字符串。</li></ul></li><li>列表、字典是可变的<ul><li>以list为例。list在append之后，还是指向同个内存地址，因为list是可变类型，可以在原处修改。</li><li>当存在多个值相同的不可变类型变量时，看看它们是不是跟可变类型一样指向同个内存地址</li></ul></li></ul><h3 id="如何判断变量是否相等"><a href="#如何判断变量是否相等" class="headerlink" title="如何判断变量是否相等"></a>如何判断变量是否相等</h3><ul><li>is:比较对象地址是否相同</li><li>== 用来判断两个对象的值是否相等</li></ul><h3 id="变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？"><a href="#变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？" class="headerlink" title="变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？"></a>变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？</h3><ul><li>python的变量可以分为基本类型和集合类型<ul><li>基本类型为：int、float、bool、str</li><li>集合类型为：set、list、dict</li></ul></li><li>基本类型在进行赋值为同一个值时，其指向的内存是一样的<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">12345678</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473808</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">12345678</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4376446400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串</span></span><br><span class="line"></span><br><span class="line">* 常用操作</span><br><span class="line">```python</span><br><span class="line">site = <span class="string">"www.abc.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有字符中的小写字母转换成大写字母</span></span><br><span class="line">print(site.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有字符中的大写字母转换成小写字母</span></span><br><span class="line">print(site.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把第一个字母转化为大写字母，其余小写</span></span><br><span class="line">print(site.capitalize())</span><br><span class="line"></span><br><span class="line"><span class="comment">#  把每个单词的第一个字母转化为大写，其余小写</span></span><br><span class="line">print(site.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除空格</span></span><br><span class="line">print(site.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取。开头包含，结尾不包含</span></span><br><span class="line">print(site[<span class="number">5</span>:])</span><br><span class="line">print(site[:<span class="number">-3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">print(site.replace(<span class="string">'w'</span>,<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切割为数组</span></span><br><span class="line">print(site.split(<span class="string">'.'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否包含</span></span><br><span class="line">print(<span class="string">'www'</span> <span class="keyword">in</span> site)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以什么开头</span></span><br><span class="line">print(site.startswith(<span class="string">'www'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以什么结尾</span></span><br><span class="line">print(site.endswith(<span class="string">'com'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">print(site+<span class="string">'/s=aaa'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">print(len(site))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转</span></span><br><span class="line">print(site[::<span class="number">-1</span>])</span><br><span class="line">print(site[::<span class="number">100</span>]) <span class="comment"># 不会报错，正常打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，返回元素位置.未找到返回-1</span></span><br><span class="line">print(site.find(<span class="string">'w'</span>)) <span class="comment"># 0</span></span><br><span class="line">print(site.find(<span class="string">'.'</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>声明<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><ul><li>定义<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个元素需要以逗号结尾</span></span><br><span class="line">a = (<span class="number">1</span>,)</span><br><span class="line"><span class="comment"># 包含多个元素</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 允许重复</span></span><br><span class="line">c = (<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 以逗号结尾的都是tuple</span></span><br><span class="line">d = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br></pre></td></tr></table></figure></li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul><li><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2到5个元素</span></span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印倒数元素</span></span><br><span class="line">print(a[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转</span></span><br><span class="line">print(a.reverse()) <span class="comment"># 原地翻转，改变原数组的值</span></span><br><span class="line">print(a[::<span class="number">-1</span>]) <span class="comment"># 返回新的翻转后的值，原数组不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组某元素的数量</span></span><br><span class="line">a.count(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含元素个数</span></span><br><span class="line">len(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组的排序</span></span><br><span class="line">list.sort(keys=)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a.extend([<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure></li><li><p>取差集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">print(list(set(a).difference(set(b))))</span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li><p>dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a = dict()</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'k'</span>] = <span class="string">'v'</span></span><br><span class="line">a.update(&#123;<span class="string">'k'</span>:<span class="string">'v'</span>&#125;) <span class="comment"># 没有返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 条件判断有哪些</span></span><br><span class="line">* <span class="keyword">if</span></span><br><span class="line">* <span class="keyword">elif</span></span><br><span class="line">* <span class="keyword">else</span></span><br><span class="line">* <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line">* || &amp;&amp;</span><br><span class="line">* 条件优先级</span><br><span class="line">    * <span class="keyword">not</span> &gt; <span class="keyword">and</span> &gt; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 循环遍历有哪些？各有什么好用处？循环遍历时如何改变遍历对象的值</span></span><br><span class="line">* <span class="keyword">for</span></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 遍历range</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line">rows = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历对象</span></span><br><span class="line">dict_rows = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>,<span class="string">'d'</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict_rows.items():</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure></li><li><p>while</p></li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul><li>round<ul><li>保留几位小数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.245</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 1.24</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="操作符可否重载？哪些情况可以重载？为什么要有重载？"><a href="#操作符可否重载？哪些情况可以重载？为什么要有重载？" class="headerlink" title="操作符可否重载？哪些情况可以重载？为什么要有重载？"></a>操作符可否重载？哪些情况可以重载？为什么要有重载？</h3><ul><li>运算符重载就是通过重写这些Python内置魔法方法实现的。这些魔法方法都是以双下划线开头和结尾的，类似于<strong>X</strong>的形式，python通过这种特殊的命名方式来拦截操作符，以实现重载。当Python的内置操作运用于类对象时，Python会去搜索并调用对象中指定的方法完成操作。</li></ul><table><thead><tr><th>方法</th><th>重载</th><th>调用</th></tr></thead><tbody><tr><td><code>__init__</code></td><td>构造函数</td><td>对象建立：X = Class(args)</td></tr><tr><td><code>__del__</code></td><td>析构函数</td><td>X对象收回</td></tr><tr><td><code>__add__</code></td><td>运算符+</td><td>如果没有<em>iadd</em>,X+Y,X+=Y</td></tr><tr><td><code>__or__</code></td><td>运算符</td><td>(位OR)</td></tr><tr><td><code>__repr__,__str__</code></td><td>打印、转换</td><td>print（X）、repr(X),str(X)</td></tr><tr><td><code>__call__</code></td><td>函数调用</td><td>X(*args,**kargs)</td></tr><tr><td><code>__getattr__</code></td><td>点号运算</td><td>X.undefined</td></tr><tr><td><code>__setattr__</code></td><td>属性赋值语句</td><td>X.any = value</td></tr><tr><td><code>__delattr__</code></td><td>属性删除</td><td>del X.any</td></tr><tr><td><code>__getattribute__</code></td><td>属性获取</td><td>X.any</td></tr><tr><td><code>__getitem__</code></td><td>索引运算</td><td>X[key],X[i:j],没<strong>iter</strong>时的for循环和其他迭代器</td></tr><tr><td><code>__setitem__</code></td><td>索引赋值语句</td><td>X[key] = value,X[i:j] = sequence</td></tr><tr><td><code>__delitem__</code></td><td>索引和分片删除</td><td>del X[key],del X[i:j]</td></tr><tr><td><code>__len__</code></td><td>长度</td><td>len(X),如果没有<strong>bool</strong>,真值测试</td></tr><tr><td><code>__bool__</code></td><td>布尔测试</td><td>bool(X),真测试</td></tr><tr><td><code>__lt__,__gt__</code></td><td>特定的比较</td><td>X &lt; Y,X &gt; Y</td></tr><tr><td><code>__le__,__ge__</code></td><td></td><td>X&lt;=Y,X &gt;= Y</td></tr><tr><td><code>__eq__,__ne__</code></td><td></td><td>X == Y,X != Y</td></tr><tr><td><code>__radd__</code></td><td>右侧加法</td><td>Other+X</td></tr><tr><td><code>__iadd__</code></td><td>实地（增强的）加法</td><td>X += Y （or else __add__）</td></tr><tr><td><code>__iter__,__next__</code></td><td>迭代环境</td><td>I = iter(X),next(I)</td></tr><tr><td><code>__contains__</code></td><td>成员关系测试</td><td>item in X （任何可迭代的）</td></tr><tr><td><code>__index__</code></td><td>整数值</td><td>hex(X),bin(X),oct(X),O[X],O[X:]</td></tr><tr><td><code>__enter__,__exit__</code></td><td>环境管理器</td><td>with obj as var:</td></tr><tr><td><code>__get__,__set__</code></td><td>描述符属性</td><td>X.attr,X.attr = value,del X.attr</td></tr><tr><td><code>__new__</code></td><td>创建</td><td>在<strong>init</strong>之前创建对象</td></tr></tbody></table><ul><li>构造函数和析构函数：<code>__init__</code>和<code>__del__</code><ul><li>主要作用是进行对象的创建和回收，当实例创建时，就会调用<strong>init</strong>构造方法。当实例对象被收回时，析构函数<strong>del</strong>会自动执行</li></ul></li><li>加减运算：<code>__add__</code>、<code>__sub__</code>、<code>__mul__</code>、<code>__truediv__</code>、<code>__mod__</code>、<code>__pow__</code><ul><li>重载这四个方法就可以在普通的对象上添加＋－ * / 求余 乘方运算符操作</li></ul></li><li>对象的字符串表达形式：<code>__repr__</code>和<code>__str__</code><ul><li>这两个方法都是用来表示对象的字符串表达形式：print()、str()方法会调用到<strong>str</strong>方法，print()、str()和repr()方法会调用<code>__repr__</code>方法</li></ul></li><li>索引取值和赋值：<code>__getitem__</code>,<code>__setitem__</code><ul><li>通过实现这两个方法，可以通过诸如 X[i] 的形式对对象进行取值和赋值，还可以对对象使用切片操作</li></ul></li><li>设置和访问属性：<code>__getattr__</code>、<code>__setattr__</code><ul><li>通过重载<strong>getattr</strong>和<strong>setattr</strong>来拦截对对象成员的访问。<strong>getattr</strong>在访问对象中不存在的成员时会自动调用。<strong>setattr</strong>方法用于在初始化对象成员的时候调用，即在设置<strong>dict</strong>的item时就会调用<strong>setattr</strong>方法</li></ul></li><li>迭代器对象: <code>__iter__</code>, <code>__next__</code><ul><li>迭代，可以直接通过重载<strong>getitem</strong>方法来实现</li><li>Python的迭代操作会优先尝试调用<code>__iter_</code>_方法，再尝试<code>__getitem__</code>。迭代环境是通过iter去尝试寻找<code>__iter__</code>方法来实现，而这种方法返回一个迭代器对象。如果这个方法已经提供，Python会重复调用迭代器对象的next()方法，直到发生StopIteration异常。如果没有找到<code>__iter__</code>，Python才会尝试使用<code>__getitem__</code>机制</li><li>可见实现了<code>__iter__</code>和<code>__next__</code>方法后，可以通过for in的方式迭代遍历对象，也可以通过iter()和next()方法迭代遍历对象。<ul><li><a href="https://github.com/11dimension/SukieTalk/issues/9" target="_blank" rel="noopener">python运算符重载</a></li><li><a href="https://blog.csdn.net/gavin_john/article/details/50717695" target="_blank" rel="noopener">Python——运算符重载(1)</a></li><li><a href="https://blog.csdn.net/gavin_john/article/details/50725572" target="_blank" rel="noopener">Python——运算符重载(2)</a></li></ul></li></ul></li></ul><h3 id="是否有深浅拷贝，都是做什么的，适用场景是什么？"><a href="#是否有深浅拷贝，都是做什么的，适用场景是什么？" class="headerlink" title="是否有深浅拷贝，都是做什么的，适用场景是什么？"></a>是否有深浅拷贝，都是做什么的，适用场景是什么？</h3><ul><li>浅拷贝：不管多么复杂的数据结构，只copy对象最外层本身，该对象引用的其他对象不copy， 内存里两个变量的地址是一样的，一个改变另一个也改变。</li><li>深拷贝：完全复制原变量的所有数据，内存中生成一套完全一样的内容；只是值一样，内存地址不一样，一方修改另一方不受影响</li><li><a href="https://www.cnblogs.com/eva-j/p/5534037.html" target="_blank" rel="noopener">python——赋值与深浅拷贝</a></li></ul><h3 id="查看所有已定义的变量"><a href="#查看所有已定义的变量" class="headerlink" title="查看所有已定义的变量"></a>查看所有已定义的变量</h3><ul><li>locals()方法可以查看截止当前定义的变量、导入的包</li><li>globals()</li><li>vars()</li><li>dir()</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python函数</title>
      <link href="man/python/func.html"/>
      <url>man/python/func.html</url>
      
        <content type="html"><![CDATA[<h4 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h4><ul><li><p>all</p><ul><li>判断其内所有值都为真<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all([<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#列表list，存在一个为0的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all((<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">#元组tuple，存在一个为0的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all([]) <span class="comment"># 空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all(()) <span class="comment"># 空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>any</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any([<span class="number">0</span>, <span class="string">''</span>, <span class="literal">False</span>]) <span class="comment">#列表list,元素全为0,'',false</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any((<span class="number">0</span>, <span class="string">''</span>, <span class="literal">False</span>)) <span class="comment">#元组tuple，元素全为0,'',false</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any([]) <span class="comment"># 空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any(()) <span class="comment"># 空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>bool</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool(<span class="number">0</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool(<span class="string">"abc"</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">bool(<span class="string">""</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool([]) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool() <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">issubclass(bool, int) <span class="comment">#bool是一个subclass int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><p>len</p><ul><li>求数据长度。</li><li>数组为所包含的元素个数</li></ul></li><li><p>sorted</p><ul><li>排序</li></ul></li><li><p>print</p></li><li><p>type</p><ul><li>判断一个对象是否是一个已知的类型</li></ul></li><li><p>dir</p></li><li><p>isinstance</p><ul><li>判断一个对象是否是一个已知的类型</li></ul></li><li><p>callable函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">callable(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">callable(<span class="string">"mystring"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">callable(add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">callable(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">callable(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">callable(B)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">callable(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p>chr和ord函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chr(<span class="number">97</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">chr(<span class="number">98</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'b'</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">97</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">98</span></span><br></pre></td></tr></table></figure></li><li><p>classmethod</p><ul><li>类方法既可以直接类调用(C.f())，也可以进行实例调用(C().f())。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is a class method"</span></span><br><span class="line">C.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">c = C()</span><br><span class="line">c.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">" This is not a class method "</span></span><br><span class="line">D.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Traceback (most recent call last):  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: unbound method f() must be called <span class="keyword">with</span> D instance <span class="keyword">as</span> first argument (got nothing instead)</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> <span class="keyword">not</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure><ul><li><p>complex</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">complex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">2j</span>)<span class="comment">#数字</span></span><br><span class="line"></span><br><span class="line">complex(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">0j</span>)<span class="comment">#当做字符串处理</span></span><br><span class="line"></span><br><span class="line">complex(<span class="string">"1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">0j</span>)</span><br><span class="line"></span><br><span class="line">complex(<span class="string">"1+2j"</span>) <span class="comment">#注意：这个地方在“+”号两边不能有空格，也就是不能写成"1 + 2j"，应该是"1+2j"，否则会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">2j</span>)</span><br></pre></td></tr></table></figure></li><li><p>dir函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dir()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">dir()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'struct'</span>]</span><br><span class="line"></span><br><span class="line">dir(struct)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Struct'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'_clearcache'</span>, <span class="string">'calcsize'</span>, <span class="string">'error'</span>, <span class="string">'pack'</span>, <span class="string">'pack_into'</span>, <span class="string">'unpack'</span>, <span class="string">'unpack_from'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"country"</span>]</span><br><span class="line">dir(Person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>,<span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>]</span><br><span class="line"></span><br><span class="line">tom = Person()</span><br><span class="line">dir(tom)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'age'</span>, <span class="string">'country'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li><li><p>delattr函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">tom = Person(<span class="string">"Tom"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(tom)[<span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">delattr(tom, <span class="string">"age"</span>)</span><br><span class="line">dir(tom)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li><li><p>divmod函数</p><ul><li>divmod(a,b)方法返回的是a//b（除法取整）以及a对b的余数；返回结果类型为tuple</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">divmod(<span class="number">9</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">divmod(<span class="number">11</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">divmod(<span class="number">1</span>+<span class="number">2j</span>,<span class="number">1</span>+<span class="number">0.5j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="number">1</span>+<span class="number">0j</span>), <span class="number">1.5j</span>)</span><br></pre></td></tr></table></figure><ul><li><p>id函数</p><ul><li>返回的是对象的“身份证号”，唯一且不变，但在不重合的生命周期里，可能会出现相同的id值。此处所说的对象应该特指复合类型的对象(如类、list等)，对于字符串、整数等类型，变量的id是随值的改变而改变的。</li><li>用is判断两个对象是否相等时，依据就是这个id值；is与==的区别就是，is是内存中的比较，而==是值的比较<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg)</span>:</span></span><br><span class="line">        self.x=arg  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:     </span><br><span class="line">    obj=Obj(<span class="number">1</span>)     </span><br><span class="line">    <span class="keyword">print</span> id(obj) <span class="comment">#32754432     </span></span><br><span class="line">    obj.x=<span class="number">2</span>     </span><br><span class="line">    <span class="keyword">print</span> id(obj) <span class="comment">#32754432     </span></span><br><span class="line">    s=<span class="string">"abc"</span>     </span><br><span class="line">    <span class="keyword">print</span> id(s) <span class="comment">#140190448953184     </span></span><br><span class="line">    s=<span class="string">"bcd"</span>     </span><br><span class="line">    <span class="keyword">print</span> id(s) <span class="comment">#32809848     </span></span><br><span class="line">    x=<span class="number">1</span>     </span><br><span class="line">    <span class="keyword">print</span> id(x) <span class="comment">#15760488     </span></span><br><span class="line">    x=<span class="number">2</span>     </span><br><span class="line">    <span class="keyword">print</span> id(x) <span class="comment">#15760464</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>int函数</p><ul><li>函数的作用是将一个数字或base类型的字符串转换成整数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. x 是数字的情况：</span></span><br><span class="line">int(<span class="number">3.14</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">int(<span class="number">2e2</span>) <span class="comment"># 200</span></span><br><span class="line">int(<span class="number">100</span>, <span class="number">2</span>) <span class="comment"># 出错，base 被赋值后函数只接收字符串# 2. x 是字符串的情况：int('23', 16) # 35int('Pythontab', 8) # 出错，Pythontab不是个8进制数# 3. base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)，十六进制中F表示15，那么G将在二十进制中表示16，依此类推....Z在三十六进制中表示35int('FZ', 16) # 出错，FZ不能用十六进制表示int('FZ', 36) # 575# 4. 字符串 0x 可以出现在十六进制中，视作十六进制的符号，同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 xint('0x10', 16) # 16，0x是十六进制的符号int('0x10', 17) # 出错，'0x10'中的 x 被视作英文字母 xint('0x10', 36) # 42804，36进制包含字母 x</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>enumerate函数<ul><li>enumerate(sequence, [start=0])</li><li>将可循环序列sequence以start开始分别列出序列数据和数据下标</li></ul></li></ul><ul><li>pow</li><li>abs</li><li>round</li><li>hex</li><li>bin</li><li>range</li><li>lambda</li><li>map</li><li>zip</li><li>getattr()　　获取对象的属性</li><li>globals()　　返回一个描述当前全局变量的字典</li><li>hasattr()</li><li>hash()　　哈希值</li><li>issubclass()　　检查一个类是否是另一个类的子类。返回True或False</li><li>iter()</li><li>locals()　　打印当前可用的局部变量的字典</li><li>max()　　返回给定元素里最大值</li><li>min()　　返回给定元素里最小值</li><li>meoryview()</li><li>next()　　返回一个可迭代数据结构（如列表）中的下一项</li><li>open()　　打开文件</li><li>pow()　　幂函数</li><li>print()</li><li>property()</li><li>repr()　　将任意值转换为字符串，供计时器读取的形式</li><li>reversed()　　　反转，逆序对象</li><li>round()</li><li>set()    class set([iterable])  返回一个新的set对象，可以选择从iterable取得的元素，set是一个内置的类</li><li>setattr()　　与getattr()相对应，setattr(object,name,value) 参数是一个对象，一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将赋值给该属性</li><li>slice()　　切片功能,  slice(start, stop[, step])</li><li>sorted()　　排序</li><li>vars()　vars([object])  使用<strong>dict</strong>属性返回模块，类，实例或任何其他对象的<strong>dict</strong>属性。</li><li>type()　　显示对象所属的类型</li><li>tuple()　　元组构造函数</li><li>super()　　调用父类的方法</li><li>str()</li><li>sum()</li><li>staticmethod()  在类中定义一个静态方法的函数，通常@staticmethod 下面接一个函数，如此使用</li><li>list()</li><li>len()</li><li>input()　　获取用户输入内容</li><li>id()</li><li>help()　　返回对象的帮助文档</li><li>frozenset()　　创建一个不可修改的集合。</li><li>format()</li><li>float()　　讲一个字符串或整数转换为浮点数。</li><li>filter()　　过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据</li><li>exec()　　执行字符串或complie方法编译过的字符串，没有返回值</li><li>evel()</li><li>enumerate()　　返回一个可以枚举的对象，该对象的next()方法将返回一个元组</li><li>delattr()　　删除对象的属性</li><li>classmethod()　　用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法。</li></ul><blockquote><h6 id="type和isinstance两个方法的异同点？"><a href="#type和isinstance两个方法的异同点？" class="headerlink" title="type和isinstance两个方法的异同点？"></a>type和isinstance两个方法的异同点？</h6></blockquote><ul><li>1.type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。</li><li>2.如果要判断两个类型是否相同推荐使用 isinstance()。</li><li>例如下面<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">isinstance (a,int) <span class="comment">#True</span></span><br><span class="line">isinstance (a,str) <span class="comment">#False</span></span><br><span class="line">isinstance (a,(str,int,list)) <span class="comment"># 是元组中的一个返回 TrueTrue</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span>   </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">isinstance(A(), A) <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A) <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure></li></ul><ul><li>1.参数赋值：按位置，键值传参，按位置和键值传参</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-sqlalchemy</title>
      <link href="man/python/lib-sqlalchemy.html"/>
      <url>man/python/lib-sqlalchemy.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h4 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h4><ul><li>整形.<ul><li>Integer/BigInteger/SmallInteger</li></ul></li><li>布尔类型. Python 中表现为 True/False , 数据库根据支持情况, 表现为 BOOLEAN 或SMALLINT . 实例化时可以指定是否创建约束(默认创建).<ul><li>Boolean</li></ul></li><li>日期类型, Time 和 DateTime 实例化时可以指定是否带时区信息.<ul><li>Date/DateTime/Time (timezone=False)</li></ul></li><li>时间偏差类型. 在 Python 中表现为 datetime.timedelta() , 数据库不支持此类型则存为日期.<ul><li>Interval</li></ul></li><li>枚举类型, 根据数据库支持情况, SQLAlchemy 会使用原生支持或者使用 VARCHAR 类型附加约束的方式实现. 原生支持中涉及新类型创建, 细节在实例化时控制.<ul><li>Enum</li></ul></li><li>浮点小数.<ul><li>Float</li></ul></li><li>定点小数, Python 中表现为 Decimal .<ul><li>Numeric (precision=None, scale=None, decimal_return_scale=None, …)</li></ul></li><li>字节数据. 根据数据库实现, 在实例化时可能需要指定大小.<ul><li>LargeBinary (length=None)</li></ul></li><li>Python 对象的序列化类型.<ul><li>PickleType</li></ul></li><li>字符串类型, Python 中表现为 Unicode , 数据库表现为 VARCHAR , 通常都需要指定长度.<ul><li>String (length=None, collation=None, …)</li></ul></li><li>类似与字符串类型, 在某些数据库实现下, 会明确表示支持非 ASCII 字符. 同时输入输出也强制是 Unicode 类型.<ul><li>Unicode</li></ul></li><li>长文本类型, Python 表现为 Unicode , 数据库表现为 TEXT .<ul><li>Text</li></ul></li><li>参考 Unicode .<ul><li>UnicodeText</li></ul></li></ul><h4 id="2-查询方式"><a href="#2-查询方式" class="headerlink" title="2.查询方式"></a>2.查询方式</h4><ul><li><p>建立表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, create_engine, Integer, DateTime</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    <span class="comment"># 数据库设置默认值 需是字符串</span></span><br><span class="line">    is_vip = Column(Integer, server_default=<span class="string">'0'</span>)</span><br><span class="line">    <span class="comment"># 默认值是创建时间 不自动更新</span></span><br><span class="line">    create_time = Column(DateTime, nullable=<span class="literal">False</span>, server_default=func.now())</span><br><span class="line">    <span class="comment"># 自动更新 需要设置nullable=False</span></span><br><span class="line">    update_time = Column(TIMESTAMP, nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:111111@localhost:3306/testdb'</span>)</span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer, DateTime, TIMESTAMP</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br></pre></td></tr></table></figure></li><li><p>常见查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_, or_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#简单查询</span></span><br><span class="line">print(session.query(User).all())</span><br><span class="line">print(session.query(User.name, User.fullname).all())</span><br><span class="line">print(session.query(User, User.name).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#带条件查询</span></span><br><span class="line">print(session.query(User).filter_by(name=<span class="string">'user1'</span>).all())</span><br><span class="line">print(session.query(User).filter(User.name == <span class="string">"user"</span>).all())</span><br><span class="line">print(session.query(User).filter(User.name.like(<span class="string">"user%"</span>)).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#多条件查询</span></span><br><span class="line">print(session.query(User).filter(and_(User.name.like(<span class="string">"user%"</span>), User.fullname.like(<span class="string">"first%"</span>))).all())</span><br><span class="line">print(session.query(User).filter(or_(User.name.like(<span class="string">"user%"</span>), User.password != <span class="literal">None</span>)).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#sql过滤</span></span><br><span class="line">print(session.query(User).filter(<span class="string">"id&gt;:id"</span>).params(id=<span class="number">1</span>).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#关联查询</span></span><br><span class="line">print(session.query(User, Address).filter(User.id == Address.user_id).all())</span><br><span class="line">print(session.query(User).join(User.addresses).all())</span><br><span class="line">print(session.query(User).outerjoin(User.addresses).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#聚合查询</span></span><br><span class="line">print(session.query(User.name, func.count(<span class="string">'*'</span>).label(<span class="string">"user_count"</span>)).group_by(User.name).all())</span><br><span class="line">print(session.query(User.name, func.sum(User.id).label(<span class="string">"user_id_sum"</span>)).group_by(User.name).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#子查询</span></span><br><span class="line">stmt = session.query(Address.user_id, func.count(<span class="string">'*'</span>).label(<span class="string">"address_count"</span>)).group_by(Address.user_id).subquery()</span><br><span class="line">print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#exists</span></span><br><span class="line">print(session.query(User).filter(exists().where(Address.user_id == User.id)))</span><br><span class="line">print(session.query(User).filter(User.addresses.any())</span><br><span class="line"></span><br><span class="line"><span class="comment"># in查询</span></span><br><span class="line">query = Account.query.filter(Account.id.in_(account_ids)).order_by(Account.date_created.desc())</span><br><span class="line"></span><br><span class="line"><span class="comment"># between and</span></span><br><span class="line">qry = DBSession.query(User).filter(User.birthday.between(<span class="string">'1985-01-17'</span>, <span class="string">'1988-01-17'</span>))</span><br><span class="line">qry = DBSession.query(User).filter(and_(User.birthday &lt;= <span class="string">'1988-01-17'</span>, User.birthday &gt;= <span class="string">'1985-01-17'</span>))</span><br></pre></td></tr></table></figure></li><li><p>限制返回字段查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = session.query(Person.name, Person.created_at,                 Person.updated_at).filter_by(name=<span class="string">"zhongwei"</span>).order_by(Person.created_at).first()</span><br></pre></td></tr></table></figure></li><li><p>记录总数查询</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># count User records, without</span></span><br><span class="line"><span class="comment"># using a subquery.</span></span><br><span class="line">session.query(func.count(User.id))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return count of user "id" grouped</span></span><br><span class="line"><span class="comment"># by "name"</span></span><br><span class="line">session.query(func.count(User.id)).group_by(User.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> distinct</span><br><span class="line"></span><br><span class="line"><span class="comment"># count distinct "name" values</span></span><br><span class="line">session.query(func.count(distinct(User.name)))</span><br></pre></td></tr></table></figure><ul><li><p>根据唯一键操作：有就不插入，没有有就插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert_stmt = insert(IpDisabled).values(disabled_ips) <span class="comment"># 可以list或dict</span></span><br><span class="line">on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(</span><br><span class="line">    site=insert_stmt.inserted.site,</span><br><span class="line">    ip=insert_stmt.inserted.ip)</span><br><span class="line">session.execute(on_duplicate_key_stmt)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></li><li><p>单个添加</p><ul><li>session.add()</li></ul></li><li><p>批量添加</p><ul><li>session.add_all()</li><li>如果有一个插入报错了，其他的都会插入吗?<ul><li>有一个报错，全部都不写入了。</li></ul></li></ul></li></ul><p>进阶<br>from sqlalchemy import create_engine<br>from sqlalchemy.orm import sessionmaker<br>DB_CONNECT_STRING = ‘mysql+mysqldb://root:123@localhost/ooxx?charset=utf8’<br>engine = create_engine(DB_CONNECT_STRING, echo=True)<br>DB_Session = sessionmaker(bind=engine)<br>session = DB_Session()<br>这里的 DB_CONNECT_STRING 就是连接数据库的路径。“mysql+mysqldb”指定了使用 MySQL-Python 来连接，“root”和“123”分别是用户名和密码，“localhost”是数据库的域名，“ooxx”是使用的数据库名（可省略），“charset”指定了连接时使用的字符集（可省略）。<br>create_engine() 会返回一个数据库引擎，echo 参数为 True 时，会显示每条执行的 SQL 语句，生产环境下可关闭。<br>sessionmaker() 会生成一个数据库会话类。这个类的实例可以当成一个数据库连接，它同时还记录了一些查询的数据，并决定什么时候执行 SQL 语句。由于 SQLAlchemy 自己维护了一个数据库连接池（默认 5 个连接），因此初始化一个会话的开销并不大。对 Tornado 而言，可以在 BaseHandler 的 initialize() 里初始化：<br>class BaseHandler(tornado.web.RequestHandler):<br>    def initialize(self):<br>        self.session = models.DB_Session()</p><pre><code>def on_finish(self):    self.session.close()</code></pre><p>对其他 Web 服务器来说，可以使用 sqlalchemy.orm.scoped_session，它能保证每个线程获得的 session 对象都是唯一的。不过 Tornado 本身就是单线程的，如果使用了异步方式，就可能会出现问题，因此并没使用它。</p><p>拿到 session 后，就可以执行 SQL 了：<br>session.execute(‘create database abc’)<br>print session.execute(‘show databases’).fetchall()<br>session.execute(‘use abc’)</p><h1 id="建-user-表的过程略"><a href="#建-user-表的过程略" class="headerlink" title="建 user 表的过程略"></a>建 user 表的过程略</h1><p>print session.execute(‘select * from user where id = 1’).first()<br>print session.execute(‘select * from user where id = :id’, {‘id’: 1}).first()<br>不过这和直接使用 MySQL-Python 没啥区别；ORM 的方式，这也是采用 SQLAlchemy 的唯一原因。</p><p>于是来定义一个表：<br>from sqlalchemy import Column<br>from sqlalchemy.types import CHAR, Integer, String<br>from sqlalchemy.ext.declarative import declarative_base</p><p>BaseModel = declarative_base()</p><p>def init_db():<br>    BaseModel.metadata.create_all(engine)</p><p>def drop_db():<br>    BaseModel.metadata.drop_all(engine)</p><p>class User(BaseModel):<br>    <strong>tablename</strong> = ‘user’</p><pre><code>id = Column(Integer, primary_key=True)name = Column(CHAR(30)) # or Column(String(30))</code></pre><p>init_db()<br>declarative_base() 创建了一个 BaseModel 类，这个类的子类可以自动与一个表关联。<br>以 User 类为例，它的 <strong>tablename</strong> 属性就是数据库中该表的名称，它有 id 和 name 这两个字段，分别为整型和 30 个定长字符。Column 还有一些其他的参数，我就不解释了。<br>最后，BaseModel.metadata.create_all(engine) 会找到 BaseModel 的所有子类，并在数据库中建立这些表；drop_all() 则是删除这些表。</p><p>接着就开始使用这个表吧：<br>from sqlalchemy import func, or_, not_</p><p>user = User(name=’a’)<br>session.add(user)<br>user = User(name=’b’)<br>session.add(user)<br>user = User(name=’a’)<br>session.add(user)<br>user = User()<br>session.add(user)<br>session.commit()</p><p>query = session.query(User)<br>print query # 显示SQL 语句<br>print query.statement # 同上<br>for user in query: # 遍历时查询<br>    print user.name<br>print query.all() # 返回的是一个类似列表的对象<br>print query.first().name # 记录不存在时，first() 会返回 None<br>print query.one().name # 不存在，或有多行记录时会抛出异常<br>print query.filter(User.id == 2).first().name<br>print query.get(2).name # 以主键获取，等效于上句<br>print query.filter(‘id = 2’).first().name # 支持字符串</p><p>query2 = session.query(User.name)<br>print query2.all() # 每行是个元组<br>print query2.limit(1).all() # 最多返回 1 条记录<br>print query2.offset(1).all() # 从第 2 条记录开始返回<br>print query2.order_by(User.name).all()<br>print query2.order_by(‘name’).all()<br>print query2.order_by(User.name.desc()).all()<br>print query2.order_by(‘name desc’).all()<br>print session.query(User.id).order_by(User.name.desc(), User.id).all()</p><p>print query2.filter(User.id == 1).scalar() # 如果有记录，返回第一条记录的第一个元素<br>print session.query(‘id’).select_from(User).filter(‘id = 1’).scalar()<br>print query2.filter(User.id &gt; 1, User.name != ‘a’).scalar() # and<br>query3 = query2.filter(User.id &gt; 1) # 多次拼接的 filter 也是 and<br>query3 = query3.filter(User.name != ‘a’)<br>print query3.scalar()<br>print query2.filter(or_(User.id == 1, User.id == 2)).all() # or<br>print query2.filter(User.id.in_((1, 2))).all() # in</p><p>query4 = session.query(User.id)<br>print query4.filter(User.name == None).scalar()<br>print query4.filter(‘name is null’).scalar()<br>print query4.filter(not_(User.name == None)).all() # not<br>print query4.filter(User.name != None).all()</p><p>print query4.count()<br>print session.query(func.count(‘<em>‘)).select_from(User).scalar()<br>print session.query(func.count(‘1’)).select_from(User).scalar()<br>print session.query(func.count(User.id)).scalar()<br>print session.query(func.count(‘</em>‘)).filter(User.id &gt; 0).scalar() # filter() 中包含 User，因此不需要指定表<br>print session.query(func.count(‘*’)).filter(User.name == ‘a’).limit(1).scalar() == 1 # 可以用 limit() 限制 count() 的返回数<br>print session.query(func.sum(User.id)).scalar()<br>print session.query(func.now()).scalar() # func 后可以跟任意函数名，只要该数据库支持<br>print session.query(func.current_timestamp()).scalar()<br>print session.query(func.md5(User.name)).filter(User.id == 1).scalar()</p><p>query.filter(User.id == 1).update({User.name: ‘c’})<br>user = query.get(1)<br>print user.name</p><p>user.name = ‘d’<br>session.flush() # 写数据库，但并不提交<br>print query.get(1).name</p><p>session.delete(user)<br>session.flush()<br>print query.get(1)</p><p>session.rollback()<br>print query.get(1).name<br>query.filter(User.id == 1).delete()<br>session.commit()<br>print query.get(1)</p><p>二、进阶的知识。<br>1）如何批量插入大批数据？<br>可以使用非 ORM 的方式：<br>session.execute(<br>    User.<strong>table</strong>.insert(),<br>    [{‘name’: <code>randint(1, 100)</code>,’age’: randint(1, 100)} for i in xrange(10000)]<br>)<br>session.commit()</p><p>如何批量插入大批数据？<br>可以使用非 ORM 的方式：<br>session.execute(<br>    User.<strong>table</strong>.insert(),<br>    [{‘name’: <code>randint(1, 100)</code>,’age’: randint(1, 100)} for i in xrange(10000)]<br>)<br>session.commit()<br>上面批量插入了 10000 条记录，半秒内就执行完了；而 ORM 方式会花掉很长时间。</p><p>2）如何让执行的 SQL 语句增加前缀？<br>使用 query 对象的 prefix_with() 方法：<br>session.query(User.name).prefix_with(‘HIGH_PRIORITY’).all()<br>session.execute(User.<strong>table</strong>.insert().prefix_with(‘IGNORE’), {‘id’: 1, ‘name’: ‘1’})</p><p>3）如何替换一个已有主键的记录？<br>使用 session.merge() 方法替代 session.add()，其实就是 SELECT + UPDATE：<br>user = User(id=1, name=’ooxx’)<br>session.merge(user)<br>session.commit()<br>或者使用 MySQL 的 INSERT … ON DUPLICATE KEY UPDATE，需要用到 @compiles 装饰器，有点难懂，自己看吧：《SQLAlchemy ON DUPLICATE KEY UPDATE》 和 sqlalchemy_mysql_ext。</p><p>4）如何使用无符号整数？<br>可以使用 MySQL 的方言：<br>from sqlalchemy.dialects.mysql import INTEGER</p><p>id = Column(INTEGER(unsigned=True), primary_key=True)</p><p>5）模型的属性名需要和表的字段名不一样怎么办？<br>开发时遇到过一个奇怪的需求，有个其他系统的表里包含了一个“from”字段，这在 Python 里是关键字，于是只能这样处理了：<br>from_ = Column(‘from’, CHAR(10))</p><p>6）如何获取字段的长度？<br>Column 会生成一个很复杂的对象，想获取长度比较麻烦，这里以 User.name 为例：<br>User.name.property.columns[0].type.length</p><p>7）如何指定使用 InnoDB，以及使用 UTF-8 编码？<br>最简单的方式就是修改数据库的默认配置。如果非要在代码里指定的话，可以这样：<br>class User(BaseModel):<br>    <strong>table_args</strong> = {<br>        ‘mysql_engine’: ‘InnoDB’,<br>        ‘mysql_charset’: ‘utf8’<br>    }<br>MySQL 5.5 开始支持存储 4 字节的 UTF-8 编码的字符了，iOS 里自带的 emoji（如</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python网络操作</title>
      <link href="man/python/net.html"/>
      <url>man/python/net.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><ul><li>http请求</li><li>socket编程</li></ul><h2 id="IO多路复用之epoll"><a href="#IO多路复用之epoll" class="headerlink" title="IO多路复用之epoll"></a>IO多路复用之epoll</h2><h4 id="1、内核EPOLL模型讲解"><a href="#1、内核EPOLL模型讲解" class="headerlink" title="1、内核EPOLL模型讲解"></a>1、内核EPOLL模型讲解</h4><p>首先我们来定义流的概念，一个流可以是文件，socket，pipe等可以进行I/O操作的内核对象。不管是文件，还是套接字(socket)，还是管道(pipe)，我们都可以把他们看作流。</p><p>之后我们来讨论I/O操作，通过read，我们可以从流中读入数据；通过write，我们可以往流中写入数据。现在假定1种情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读数据，但是服务器端还没有把数据传回来），这时候该怎么办？</p><p>阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你还不知道快递什么时候过来，而且你也没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打电话（假定一定能叫醒你）。</p><p>非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他打个电话：“你到了没？”</p><p>很明显一般人不会用第二种做法，不仅显得无脑，浪费话费不说，还占用了快递员大量的时间。</p><p>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片。</p><p>为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也<br>需要缓冲区。</p><p>假设有一个管道，进程A为管道的写入方，B为管道的读出方。假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉B该醒来了，这个事件姑且称之为“缓冲区非空”。但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”。也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</p><p>这四种情形涵盖了四个I/O事件，内核缓冲区满，内核缓冲区空，内核缓冲区非空，内核缓冲区非满。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p><p>然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。于是再来考虑非阻塞忙轮询的I/O方式，我们发现可以同时处理多个流（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p><p>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</p><p>为了避免CPU空转，可以引进一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。</p><p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p><p>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了。</p><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll只会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的（复杂度降低到了O(1)）。</p><p>linux下的多路复用<br>(1)select<br>    select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>    select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。<br>    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>    另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大 量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。<br>(2)poll<br>    poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>    poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>    另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候 将 再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。<br>(3)epoll<br>    直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。<br>    epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>    epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描 述符数量的 值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在 系统调用时复制的开销。<br>    另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某 个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><p>python下的<br>Python中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll从而实现IO多路复用。<br>    Windows Python：提供： select<br>    Mac Python：提供： select<br>    Linux Python：提供： select、poll、epoll</p><h4 id="2-python中的epoll"><a href="#2-python中的epoll" class="headerlink" title="2. python中的epoll"></a>2. python中的epoll</h4><p>从以上可知，epoll是对select、poll模型的改进，提高了网络编程的性能，广泛应用于大规模并发请求的C/S架构中。<br>1、触发方式：<br>边缘触发/水平触发，只适用于Unix/Linux操作系统</p><p>2、原理图<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10811" alt="cf9f373f3bfe59a5cd0c7ef35c562f4b.jpeg"></p><p>3、一般步骤<br>    1. Create an epoll object——创建1个epoll对象<br>    2. Tell the epoll object to monitor specific events on specific sockets——告诉epoll对象，在指定的socket上监听指定的事件<br>    3. Ask the epoll object which sockets may have had the specified event since the last query——询问epoll对象，从上次查询以来，哪些socket发生了哪些指定的事件<br>    4. Perform some action on those sockets——在这些socket上执行一些操作<br>    5. Tell the epoll object to modify the list of sockets and/or events to monitor——告诉epoll对象，修改socket列表和（或）事件，并监控<br>    6. Repeat steps 3 through 5 until finished——重复步骤3-5，直到完成<br>    7. Destroy the epoll object——销毁epoll对象</p><p>4.相关用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> select 导入select模块</span><br><span class="line"></span><br><span class="line">epoll = select.epoll() 创建一个epoll对象</span><br><span class="line"></span><br><span class="line">epoll.register(文件句柄,事件类型) 注册要监控的文件句柄和事件</span><br><span class="line"></span><br><span class="line">事件类型:</span><br><span class="line"></span><br><span class="line">　　select.EPOLLIN    可读事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLOUT   可写事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLERR   错误事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLHUP   客户端断开事件</span><br><span class="line"></span><br><span class="line">epoll.unregister(文件句柄)   销毁文件句柄</span><br><span class="line"></span><br><span class="line">epoll.poll(timeout)  当文件句柄发生变化，则会以列表的形式主动报告给用户进程,timeout</span><br><span class="line"></span><br><span class="line">                     为超时时间，默认为<span class="number">-1</span>，即一直等待直到文件句柄发生变化，如果指定为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                     那么epoll每<span class="number">1</span>秒汇报一次当前文件句柄的变化情况，如果无变化则返回空</span><br><span class="line"></span><br><span class="line">epoll.fileno() 返回epoll的控制文件描述符(Return the epoll control file descriptor)</span><br><span class="line"></span><br><span class="line">epoll.modfiy(fineno,event) fineno为文件描述符 event为事件类型  作用是修改文件描述符所对应的事件</span><br><span class="line"></span><br><span class="line">epoll.fromfd(fileno) 从<span class="number">1</span>个指定的文件描述符创建<span class="number">1</span>个epoll对象</span><br><span class="line"></span><br><span class="line">epoll.close()   关闭epoll对象的控制文件描述符</span><br></pre></td></tr></table></figure><p>5 实例：客户端发送数据 服务端将接收的数据返回给客户端</p><ul><li><p>服务端代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建socket对象</span></span><br><span class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#设置IP地址复用</span></span><br><span class="line">serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#ip地址和端口号</span></span><br><span class="line">server_address = (<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="comment">#绑定IP地址</span></span><br><span class="line">serversocket.bind(server_address)</span><br><span class="line"><span class="comment">#监听，并设置最大连接数</span></span><br><span class="line">serversocket.listen(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span>  <span class="string">"服务器启动成功，监听IP："</span> , server_address</span><br><span class="line"><span class="comment">#服务端设置非阻塞</span></span><br><span class="line">serversocket.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#超时时间</span></span><br><span class="line">timeout = <span class="number">10</span></span><br><span class="line"><span class="comment">#创建epoll事件对象，后续要监控的事件添加到其中</span></span><br><span class="line">epoll = select.epoll()</span><br><span class="line"><span class="comment">#注册服务器监听fd到等待读事件集合</span></span><br><span class="line">epoll.register(serversocket.fileno(), select.EPOLLIN)</span><br><span class="line"><span class="comment">#保存连接客户端消息的字典，格式为&#123;&#125;</span></span><br><span class="line">message_queues = &#123;&#125;</span><br><span class="line"><span class="comment">#文件句柄到所对应对象的字典，格式为&#123;句柄：对象&#125;</span></span><br><span class="line">fd_to_socket = &#123;serversocket.fileno():serversocket,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"等待活动连接......"</span></span><br><span class="line">  <span class="comment">#轮询注册的事件集合，返回值为[(文件句柄，对应的事件)，(...),....]</span></span><br><span class="line">  events = epoll.poll(timeout)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> events:</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"epoll超时无活动连接，重新轮询......"</span></span><br><span class="line">     <span class="keyword">continue</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"有"</span> , len(events), <span class="string">"个新事件，开始处理......"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> fd, event <span class="keyword">in</span> events:</span><br><span class="line">     socket = fd_to_socket[fd]</span><br><span class="line">     <span class="comment">#如果活动socket为当前服务器socket，表示有新连接</span></span><br><span class="line">     <span class="keyword">if</span> socket == serversocket:</span><br><span class="line">            connection, address = serversocket.accept()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"新连接："</span> , address</span><br><span class="line">            <span class="comment">#新连接socket设置为非阻塞</span></span><br><span class="line">            connection.setblocking(<span class="literal">False</span>)</span><br><span class="line">            <span class="comment">#注册新连接fd到待读事件集合</span></span><br><span class="line">            epoll.register(connection.fileno(), select.EPOLLIN)</span><br><span class="line">            <span class="comment">#把新连接的文件句柄以及对象保存到字典</span></span><br><span class="line">            fd_to_socket[connection.fileno()] = connection</span><br><span class="line">            <span class="comment">#以新连接的对象为键值，值存储在队列中，保存每个连接的信息</span></span><br><span class="line">            message_queues[connection]  = Queue.Queue()</span><br><span class="line">     <span class="comment">#关闭事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'client close'</span></span><br><span class="line">        <span class="comment">#在epoll中注销客户端的文件句柄</span></span><br><span class="line">        epoll.unregister(fd)</span><br><span class="line">        <span class="comment">#关闭客户端的文件句柄</span></span><br><span class="line">        fd_to_socket[fd].close()</span><br><span class="line">        <span class="comment">#在字典中删除与已关闭客户端相关的信息</span></span><br><span class="line">        <span class="keyword">del</span> fd_to_socket[fd]</span><br><span class="line">     <span class="comment">#可读事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">        <span class="comment">#接收数据</span></span><br><span class="line">        data = socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"收到数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername()</span><br><span class="line">           <span class="comment">#将数据放入对应客户端的字典</span></span><br><span class="line">           message_queues[socket].put(data)</span><br><span class="line">           <span class="comment">#修改读取到消息的连接到等待写事件集合(即对应客户端收到消息后，再将其fd修改并加入写事件集合)</span></span><br><span class="line">           epoll.modify(fd, select.EPOLLOUT)</span><br><span class="line">     <span class="comment">#可写事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">           <span class="comment">#从字典中获取对应客户端的信息</span></span><br><span class="line">           msg = message_queues[socket].get_nowait()</span><br><span class="line">        <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">           <span class="keyword">print</span> socket.getpeername() , <span class="string">" queue empty"</span></span><br><span class="line">           <span class="comment">#修改文件句柄为读事件</span></span><br><span class="line">           epoll.modify(fd, select.EPOLLIN)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"发送数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername()</span><br><span class="line">           <span class="comment">#发送数据</span></span><br><span class="line">           socket.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在epoll中注销服务端文件句柄</span></span><br><span class="line">epoll.unregister(serversocket.fileno())</span><br><span class="line"><span class="comment">#关闭epoll</span></span><br><span class="line">epoll.close()</span><br><span class="line"><span class="comment">#关闭服务器socket</span></span><br><span class="line">serversocket.close()</span><br></pre></td></tr></table></figure></li><li><p>客户端代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建客户端socket对象</span></span><br><span class="line">clientsocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#服务端IP地址和端口号元组</span></span><br><span class="line">server_address = (<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#客户端连接指定的IP地址和端口号</span></span><br><span class="line">clientsocket.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#输入数据</span></span><br><span class="line">    data = raw_input(<span class="string">'please input:'</span>)</span><br><span class="line">    <span class="comment">#客户端发送数据</span></span><br><span class="line">    clientsocket.sendall(data)</span><br><span class="line">    <span class="comment">#客户端接收数据</span></span><br><span class="line">    server_data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'客户端收到的数据：'</span>server_data</span><br><span class="line">    <span class="comment">#关闭客户端socket</span></span><br><span class="line">    clientsocket.close()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python线程与进程</title>
      <link href="man/python/thread.html"/>
      <url>man/python/thread.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h2><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>*</p><ul><li>多线程执行</li><li>多进程执行</li><li>多进程共享变量</li><li>多线程锁如何使用</li><li>GIL</li></ul><p>看到这里，也许你会疑惑。这很正常，所以让我们带着问题来阅读本文章吧。<br>问题：<br>1、Python 多线程为什么耗时更长？<br>2、为什么在 Python 里面推荐使用多进程而不是多线程？<br>1 基础知识</p><p>现在的 PC 都是多核的，使用多线程能充分利用 CPU 来提供程序的执行效率。<br>1.1 线程</p><p>线程是一个基本的 CPU 执行单元。它必须依托于进程存活。一个线程是一个execution context（执行上下文），即一个 CPU 执行时所需要的一串指令。<br>1.2 进程</p><p>进程是指一个程序在给定数据集合上的一次执行过程，是系统进行资源分配和运行调用的独立单位。可以简单地理解为操作系统中正在执行的程序。也就说，每个应用程序都有一个自己的进程。<br>每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。<br>1.3 两者的区别</p><ul><li>线程必须在某个进行中执行。</li><li>一个进程可包含多个线程，其中有且只有一个主线程。</li><li>多线程共享同个地址空间、打开的文件以及其他资源。</li><li>多进程共享物理内存、磁盘、打印机以及其他资源。</li></ul><p>1.4 线程的类型</p><p>线程的因作用可以划分为不同的类型。大致可分为：</p><ul><li>主线程</li><li>子线程</li><li>守护线程（后台线程）</li><li>前台线程<br>2 Python 多线程</li></ul><p>2.1 GIL</p><p>其他语言，CPU 是多核时是支持多个线程同时执行。但在 Python 中，无论是单核还是多核，同时只能由一个线程在执行。其根源是 GIL 的存在。<br>GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 Python 设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。<br>而目前 Python 的解释器有多种，例如：</p><ul><li>CPython：CPython 是用C语言实现的 Python 解释器。 作为官方实现，它是最广泛使用的 Python 解释器。</li><li>PyPy：PyPy 是用RPython实现的解释器。RPython 是 Python 的子集， 具有静态类型。这个解释器的特点是即时编译，支持多重后端（C, CLI, JVM）。PyPy 旨在提高性能，同时保持最大兼容性（参考 CPython 的实现）。</li><li>Jython：Jython 是一个将 Python 代码编译成 Java 字节码的实现，运行在JVM (Java Virtual Machine) 上。另外，它可以像是用 Python 模块一样，导入 并使用任何Java类。</li><li>IronPython：IronPython 是一个针对 .NET 框架的 Python 实现。它 可以用 Python 和 .NET framewor k的库，也能将 Python 代码暴露给 .NET 框架中的其他语言。<br>GIL 只在 CPython 中才有，而在 PyPy 和 Jython 中是没有 GIL 的。<br>每次释放 GIL锁，线程进行锁竞争、切换线程，会消耗资源。这就导致打印线程执行时长，会发现耗时更长的原因。<br>并且由于 GIL 锁存在，Python 里一个进程永远只能同时执行一个线程(拿到 GIL 的线程才能执行)，这就是为什么在多核CPU上，Python 的多线程效率并不高的根本原因。</li></ul><p>2.2 创建多线程</p><p>Python提供两个模块进行多线程的操作，分别是thread和threading，<br>前者是比较低级的模块，用于更底层的操作，一般应用级别的开发不常用。</p><ul><li>方法1：直接使用threading.Thread()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数名可随便定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="string">"thread 1"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="string">"thread 2"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">* 方法<span class="number">2</span>：继承threading.Thread来自定义线程类，重写run方法</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"thread 1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"thread 2"</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></li></ul><p>2.3 线程合并</p><p>Join函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行。主线程结束后，子线程还在运行，join函数使得主线程等到子线程结束时才退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 将 t1 和 t2 加入到主线程中</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>2.4 线程同步与互斥锁</p><p>线程之间数据共享的。当多个线程对某一个共享数据进行操作时，就需要考虑到线程安全问题。threading模块中定义了Lock 类，提供了互斥锁的功能来保证多线程情况下数据的正确性。<br>用法的基本步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment">#锁定</span></span><br><span class="line">mutex.acquire([timeout])</span><br><span class="line"><span class="comment">#释放</span></span><br><span class="line">mutex.release()</span><br><span class="line">其中，锁定方法acquire可以有一个超时时间的可选参数timeout。如果设定了timeout，则在超时后通过返回值可以判断是否得到了锁，从而可以进行一些其他的处理。</span><br><span class="line">具体用法见示例代码：</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):</span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            msg = self.name + <span class="string">': num value is '</span> + str(num)</span><br><span class="line">            print(msg)</span><br><span class="line">            mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>2.5 可重入锁（递归锁）</p><p>为了满足在同一线程中多次请求同一资源的需求，Python 提供了可重入锁（RLock）。<br> RLock内部维护着一个Lock和一个counter变量，counter 记录了 acquire 的次数，从而使得资源可以被多次 require。直到一个线程所有的 acquire 都被 release，其他的线程才能获得资源。<br>具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建 RLock</span></span><br><span class="line">mutex = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):</span><br><span class="line">            print(<span class="string">"thread "</span> + self.name + <span class="string">" get mutex"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            mutex.acquire()</span><br><span class="line">            mutex.release()</span><br><span class="line">            mutex.release()</span><br></pre></td></tr></table></figure><p>2.6 守护线程</p><p>如果希望主线程执行完毕之后，不管子线程是否执行完毕都随着主线程一起结束。我们可以使用setDaemon(bool)函数，它跟join函数是相反的。它的作用是设置子线程是否随主线程一起结束，必须在start() 之前调用，默认为False。<br>2.7 定时器</p><p>如果需要规定函数在多少秒后执行某个操作，需要用到Timer类。具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Pyhton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一秒钟之后执行 show 函数</span></span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>3 Python 多进程</p><p>3.1 创建多进程</p><p>Python 要进行多进程操作，需要用到muiltprocessing库，其中的Process类跟threading模块的Thread类很相似。所以直接看代码熟悉多进程。</p><ul><li>方法1：直接使用Process, 代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Process name is "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    proc = Process(target=show, args=(<span class="string">'subprocess'</span>,))</span><br><span class="line">    proc.start()</span><br><span class="line">    proc.join()</span><br><span class="line">* 方法<span class="number">2</span>：继承Process来自定义进程类，重写run方法, 代码如下：</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'process name :'</span> + str(self.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = MyProcess(i)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure></li></ul><p>3.2 多进程通信</p><p>进程之间不共享数据的。如果进程之间需要进行通信，则要用到Queue模块或者Pipi模块来实现。</p><ul><li>Queue<br>Queue 是多进程安全的队列，可以实现多进程之间的数据传递。它主要有两个函数,put和get。<br>put() 用以插入数据到队列中，put 还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常。<br>get()可以从队列读取并且删除一个元素。同样，get 有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常。<br>具体用法如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">'Queue 用法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    pro = Process(target=put, args=(queue,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(queue.get())</span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure></li><li>Pipe<br>Pipe的本质是进程之间的用管道数据传递，而不是数据共享，这和socket有点像。pipe() 返回两个连接对象分别表示管道的两端，每端都有send() 和recv()函数。<br>如果两个进程试图在同一时间的同一端进行读取和写入那么，这可能会损坏管道中的数据。<br>具体用法如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send(<span class="string">'Pipe 用法'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    pro = Process(target=show, args=(child_conn,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure></li></ul><p>3.3 进程池</p><p>创建多个进程，我们不用傻傻地一个个去创建。我们可以使用Pool模块来搞定。<br>Pool 常用的方法如下：<br>方法           含义<br>apply()       同步执行（串行）<br>apply_async()   异步执行（并行）<br>terminate()     立刻关闭进程池<br>join()         主进程等待所有子进程执行完毕。必须在close或terminate()之后使用<br>close()         等待所有进程结束后，才关闭进程池<br>具体用法见示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">'num : '</span> + str(num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    pool = Pool(processes = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去</span></span><br><span class="line">        pool.apply_async(show, args=(i, ))</span><br><span class="line">    print(<span class="string">'======  apply_async  ======'</span>)</span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment">#调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span></span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>4 选择多线程还是多进程？</p><p>在这个问题上，首先要看下你的程序是属于哪种类型的。一般分为两种 CPU 密集型 和 I/O 密集型。</p><ul><li>CPU 密集型：程序比较偏重于计算，需要经常使用 CPU 来运算。例如科学计算的程序，机器学习的程序等。</li><li>I/O 密集型：顾名思义就是程序需要频繁进行输入输出操作。爬虫程序就是典型的 I/O 密集型程序。<br>如果程序是属于 CPU 密集型，建议使用多进程。而多线程就更适合应用于 I/O 密集型程序。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/re/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html"/>
      <url>man/re/%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.html</url>
      
        <content type="html"><![CDATA[<h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><p>字符串仅能是中文。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[\\u4e00-\\u9fa5]&#123;0,&#125;$</span><br></pre></td></tr></table></figure></li><li><p>密码的强度必须是包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?&#x3D;.*\\d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure></li><li><p>由数字、26个英文字母或下划线组成的字符串</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\\w+$</span><br></pre></td></tr></table></figure></li><li><p>校验E-Mail 地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\\w!#$%&amp;&#39;*+&#x2F;&#x3D;?^_&#96;&#123;|&#125;~-]+(?:\\.[\\w!#$%&amp;&#39;*+&#x2F;&#x3D;?^_&#96;&#123;|&#125;~-]+)*@(?:[\\w](?:[\\w-]*[\\w])?\\.)+[\\w](?:[\\w-]*[\\w])?</span><br></pre></td></tr></table></figure></li><li><p>下面是身份证号码的正则校验。15 或 18位。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 15位</span><br><span class="line">^[1-9]\\d&#123;7&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;$</span><br><span class="line">&#x2F;&#x2F; 18位</span><br><span class="line">^[1-9]\\d&#123;5&#125;[1-9]\\d&#123;3&#125;((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d&#123;3&#125;([0-9]|X)$</span><br></pre></td></tr></table></figure></li><li><p>“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?:(?!0000)[0-9]&#123;4&#125;-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]&#123;2&#125;(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)$</span><br></pre></td></tr></table></figure></li><li><p>金额校验，精确到2位小数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure></li><li><p>下面是国内 13、15、18开头的手机号正则表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d&#123;8&#125;$</span><br></pre></td></tr></table></figure></li><li><p>IE目前还没被完全取代，很多页面还是需要做版本兼容，下面是IE版本检查的表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.*MSIE [5-8](?:\\.[0-9]+)?(?!.*Trident\\&#x2F;[5-9]\\.0).*$</span><br></pre></td></tr></table></figure></li><li><p>IP4 正则语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\b</span><br></pre></td></tr></table></figure></li><li><p>IP6 正则语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(([0-9a-fA-F]&#123;1,4&#125;:)&#123;7,7&#125;[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,7&#125;:|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,6&#125;:[0-9a-fA-F]&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,5&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,2&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,3&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,3&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,4&#125;|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,2&#125;(:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,5&#125;|[0-9a-fA-F]&#123;1,4&#125;:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,6&#125;)|:((:[0-9a-fA-F]&#123;1,4&#125;)&#123;1,7&#125;|:)|fe80:(:[0-9a-fA-F]&#123;0,4&#125;)&#123;0,4&#125;%[0-9a-zA-Z]&#123;1,&#125;|::(ffff(:0&#123;1,4&#125;)&#123;0,1&#125;:)&#123;0,1&#125;((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])|([0-9a-fA-F]&#123;1,4&#125;:)&#123;1,4&#125;:((25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9])\\.)&#123;3,3&#125;(25[0-5]|(2[0-4]|1&#123;0,1&#125;[0-9])&#123;0,1&#125;[0-9]))</span><br></pre></td></tr></table></figure></li><li><p>下面的这个表达式可以筛选出一段文本中的URL。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(f|ht)&#123;1&#125;(tp|tps):\\&#x2F;\\&#x2F;([\\w-]+\\.)+[\\w-]+(\\&#x2F;[\\w- .&#x2F;?%&amp;&#x3D;]*)?</span><br></pre></td></tr></table></figure></li><li><p>验证文件路径和扩展名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([a-zA-Z]\\:|\\\\)\\\\([^\\\\]+\\\\)*[^\\&#x2F;:*?&quot;&lt;&gt;|]+\\.txt(l)?$</span><br></pre></td></tr></table></figure></li><li><p>有时需要抽取网页中的颜色代码，可以使用下面的表达式。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\#([a-fA-F]|[0-9])&#123;3,6&#125;</span><br></pre></td></tr></table></figure></li><li><p>提取网页图片</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\\&lt; *[img][^\\&gt;]*[src] *&#x3D; *[\\&quot;\\&#39;]&#123;0,1&#125;([^\\&quot;\\&#39;\\ &gt;]*)</span><br></pre></td></tr></table></figure></li><li><p>提取html中的超链接。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(]*)(href&#x3D;&quot;https?:&#x2F;&#x2F;)((?!(?:(?:www\\.)?&#39;.implode(&#39;|(?:www\\.)?&#39;, $follow_list).&#39;))[^&quot;]+)&quot;((?!.*\\brel&#x3D;)[^&gt;]*)(?:[^&gt;]*)&gt;</span><br></pre></td></tr></table></figure></li><li><p>匹配中文字符的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[\u4e00-\u9fa5]</span><br></pre></td></tr></table></figure></li><li><p>匹配双字节字符(包括汉字在内)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^\x00-\xff]</span><br></pre></td></tr></table></figure></li><li><p>匹配空行的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\n[\s| ]*\r</span><br></pre></td></tr></table></figure></li><li><p>匹配HTML标记的正则表达式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&lt;(.*)&gt;.*&lt;\&#x2F;\1&gt;|&lt;(.*) \&#x2F;&gt;&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>匹配首尾空格的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(^\s*)|(\s*$)</span><br></pre></td></tr></table></figure></li><li><p>匹配Email地址的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*</span><br></pre></td></tr></table></figure></li><li><p>匹配网址URL的正则表达式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-z]+:&#x2F;&#x2F;(\\w+(-\\w+)*)(\\.(\\w+(-\\w+)*))*(\\?\\S*)?$</span><br></pre></td></tr></table></figure></li><li><p>匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br></pre></td></tr></table></figure></li><li><p>匹配国内电话号码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\d&#123;3&#125;-|\d&#123;4&#125;-)?(\d&#123;8&#125;|\d&#123;7&#125;)?</span><br></pre></td></tr></table></figure></li><li><p>匹配腾讯QQ号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]*[1-9][0-9]*$</span><br></pre></td></tr></table></figure></li></ul><h4 id="校验数字的表达式"><a href="#校验数字的表达式" class="headerlink" title="校验数字的表达式"></a>校验数字的表达式</h4><ol><li>数字</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]*$</span><br></pre></td></tr></table></figure><ol><li>n位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^d&#123;n&#125;$</span><br></pre></td></tr></table></figure><ol><li>至少n位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^d&#123;n,&#125;$</span><br></pre></td></tr></table></figure><ol><li>m-n位的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^d&#123;m,n&#125;$</span><br></pre></td></tr></table></figure><ol><li>零和非零开头的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0|[1-9][0-9]*)$</span><br></pre></td></tr></table></figure><ol><li>非零开头的最多带两位小数的数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^([1-9][0-9]*)+(.[0-9]&#123;1,2&#125;)?$</span><br></pre></td></tr></table></figure><ol><li>带1-2位小数的正数或负数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(-)?d+(.d&#123;1,2&#125;)?$</span><br></pre></td></tr></table></figure><ol><li>正数、负数、和小数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(-|+)?d+(.d+)?$</span><br></pre></td></tr></table></figure><ol><li>有两位小数的正实数</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;2&#125;)?$</span><br></pre></td></tr></table></figure><ol><li>有1~3位小数的正实数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[0-9]+(.[0-9]&#123;1,3&#125;)?$</span><br></pre></td></tr></table></figure><ol><li>非零的正整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]d*$</span><br><span class="line">^([1-9][0-9]*)&#123;1,3&#125;$</span><br><span class="line">^+?[1-9][0-9]*$</span><br></pre></td></tr></table></figure><ol><li>非零的负整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^-[1-9][]0-9&quot;*$ </span><br><span class="line">^-[1-9]d*$</span><br></pre></td></tr></table></figure><ol><li>非负整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^d+$ </span><br><span class="line">^[1-9]d*|0$</span><br></pre></td></tr></table></figure><ol><li>非正整数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^-[1-9]d*|0$</span><br><span class="line">^((-d+)|(0+))$</span><br></pre></td></tr></table></figure><ol><li>非负浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^d+(.d+)?$</span><br><span class="line">^[1-9]d*.d*|0.d*[1-9]d*|0?.0+|0$</span><br></pre></td></tr></table></figure><ol><li>非正浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((-d+(.d+)?)|(0+(.0+)?))$</span><br><span class="line">^(-([1-9]d*.d*|0.d*[1-9]d*))|0?.0+|0$</span><br></pre></td></tr></table></figure><ol><li>正浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^[1-9]d*.d*|0.d*[1-9]d*$ </span><br><span class="line">^(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*))$</span><br></pre></td></tr></table></figure><ol><li>负浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^-([1-9]d*.d*|0.d*[1-9]d*)$</span><br><span class="line">^(-(([0-9]+.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*.[0-9]+)|([0-9]*[1-9][0-9]*)))$</span><br></pre></td></tr></table></figure><ol><li>浮点数：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^(-?d+)(.d+)?$</span><br><span class="line">^-?([1-9]d*.d*|0.d*[1-9]d*|0?.0+|0)$</span><br></pre></td></tr></table></figure><h4 id="校验字符的表达式"><a href="#校验字符的表达式" class="headerlink" title="校验字符的表达式"></a>校验字符的表达式</h4><ol start="2"><li>英文和数字：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+$ </span><br><span class="line">^[A-Za-z0-9]&#123;4,40&#125;$</span><br></pre></td></tr></table></figure><ol><li>长度为3-20的所有字符：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^.&#123;3,20&#125;$</span><br></pre></td></tr></table></figure><ol><li>由26个英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z]+$</span><br></pre></td></tr></table></figure><ol><li>由26个大写英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Z]+$</span><br></pre></td></tr></table></figure><ol><li>由26个小写英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-z]+$</span><br></pre></td></tr></table></figure><ol><li>由数字和26个英文字母组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[A-Za-z0-9]+$</span><br></pre></td></tr></table></figure><ol><li>由数字、26个英文字母或者下划线组成的字符串：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^w+$ </span><br><span class="line">^w&#123;3,20&#125;$</span><br></pre></td></tr></table></figure><h4 id="特殊需求表达式"><a href="#特殊需求表达式" class="headerlink" title="特殊需求表达式"></a>特殊需求表达式</h4><ol><li>Email地址：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^w+([-+.]w+)*@w+([-.]w+)*.w+([-.]w+)*$</span><br></pre></td></tr></table></figure><ol><li>域名：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(&#x2F;.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+&#x2F;.?</span><br></pre></td></tr></table></figure><ol><li>InternetURL：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[a-zA-z]+:&#x2F;&#x2F;[^s]* 或 ^http:&#x2F;&#x2F;([w-]+.)+[w-]+(&#x2F;[w-.&#x2F;?%&amp;&#x3D;]*)?$</span><br></pre></td></tr></table></figure><ol><li>手机号码：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])d&#123;8&#125;$</span><br></pre></td></tr></table></figure><ol><li>国内电话号码(0511-4405222、021-87888822)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d&#123;3&#125;-d&#123;8&#125;|d&#123;4&#125;-d&#123;7&#125;</span><br></pre></td></tr></table></figure><ol><li>帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$</span><br></pre></td></tr></table></figure><ol><li>密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^[a-zA-Z]w&#123;5,17&#125;$</span><br></pre></td></tr></table></figure><ol><li>强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(?&#x3D;.*d)(?&#x3D;.*[a-z])(?&#x3D;.*[A-Z]).&#123;8,10&#125;$</span><br></pre></td></tr></table></figure><ol><li>日期格式：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^d&#123;4&#125;-d&#123;1,2&#125;-d&#123;1,2&#125;</span><br></pre></td></tr></table></figure><ol><li>一年的12个月(01～09和1～12)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(0?[1-9]|1[0-2])$</span><br></pre></td></tr></table></figure><ol><li>一个月的31天(01～09和1～31)：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^((0?[1-9])|((1|2)[0-9])|30|31)$</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="algorithms/code/basic/README.html"/>
      <url>algorithms/code/basic/README.html</url>
      
        <content type="html"><![CDATA[<h1 id="algorithms"><a href="#algorithms" class="headerlink" title="algorithms"></a>algorithms</h1><p>日常算法训练，先完成python版本，go版本后续完善。</p><h2 id="包含的内容"><a href="#包含的内容" class="headerlink" title="包含的内容"></a>包含的内容</h2><p><img data-src="../assets/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95.png" alt="结构图"></p><h2 id="01-排序类型"><a href="#01-排序类型" class="headerlink" title="01.排序类型"></a>01.排序类型</h2><ul><li>01.冒泡排序 <a href="(01-sort/01-bubblesort/bubble_sort.md)">算法分析</a>  <a href="01-sort/01-bubblesort/bubble_sort.py">python版本</a> <a href="01-sort/01-bubblesort/bubble_sort.go">go版本</a></li><li>02.插入排序 <a href="01-sort/02-insertsort/insert_sort.md">算法分析</a> <a href="01-sort/01-insertsort/insert_sort.gp">python版本</a> <a href="01-sort/01-insertsort/insert_sort.go">go版本</a></li><li>03.选择排序 <a href="01-sort/03-selectsort/select_sort.md">算法分析</a> <a href="01-sort/03-selectsort/select_sort.py">python版本</a> <a href="01-sort/03-selectsort/select_sort.go">go版本</a></li><li>04.希尔排序 <a href="01-sort/04-shellsort/shell_sort.md">算法分析</a> <a href="01-sort/04-shellsort/shell_sort.py">python版本</a> <a href="01-sort/04-shellsort/shell_sort.go">go版本</a></li><li>05.归并排序 <a href="01-sort/05-mergesort/merge_sort.md">算法分析</a> <a href="01-sort/05-mergesort/merge_sort.py">python版本</a> <a href="01-sort/05-mergesort/merge_sort.go">go版本</a></li><li>06.快速排序 <a href="01-sort/06-quicksort/quick_sort.md">算法分析</a> <a href="01-sort/06-quicksort/quick_sort.py">python版本</a> <a href="01-sort/06-quicksort/quick_sort.go">go版本</a></li><li>07.计数排序 <a href="01-sort/07-countsort/count_sort.md">算法分析</a> <a href="01-sort/07-countsort/count_sort.py">python版本</a> <a href="01-sort/07-countsort/count_sort.go">go版本</a></li><li>08.基数排序 <a href="01-sort/08-radixsort/radix_sort.md">算法分析</a> <a href="01-sort/08-radixsort/radix_sort.py">python版本</a> <a href="01-sort/08-radixsort/radix_sort.go">go版本</a></li><li>09.桶排序   <a href="01-sort/09-bucketsort/bucket_sort.md">算法分析</a> <a href="01-sort/09-bucketsort/bucket_sort.py">python版本</a> <a href="01-sort/09-bucketsort/bucket_sort.py">go版本</a></li><li>10.堆排序   <a href="01-sort/10-heapsort/heap_sort.md">算法分析</a> <a href="01-sort/10-heapsort/heap_sort.md">python版本</a> <a href="01-sort/10-heapsort/heap_sort.go">go版本</a></li></ul><h2 id="02-查找类型"><a href="#02-查找类型" class="headerlink" title="02.查找类型"></a>02.查找类型</h2><ul><li>01.顺序查找</li><li>02.二分查找</li><li>03.插值查找</li><li>04.斐波那契</li><li>05.树表查找</li><li>06.分块查找</li><li>07.哈希查找</li></ul><h2 id="03-搜索类型"><a href="#03-搜索类型" class="headerlink" title="03.搜索类型"></a>03.搜索类型</h2><ul><li>01.枚举算法</li><li>02.深度优先搜索</li><li>03.广度优先搜索</li><li>04.A*算法</li><li>05.回溯算法</li><li>06.蒙特卡洛树搜索</li><li>07.散列函数</li></ul><h2 id="04-字符串"><a href="#04-字符串" class="headerlink" title="04.字符串"></a>04.字符串</h2><ul><li>01.朴素算法</li><li>02.Rabin-Karp算法</li><li>03.有限状态自动机</li><li>04.kmp算法</li><li>05.Boyer-Moore算法</li><li>06.Sunday算法</li><li>07.Horspool算法</li><li>08.KR算法</li></ul><h2 id="05-加密算法"><a href="#05-加密算法" class="headerlink" title="05.加密算法"></a>05.加密算法</h2><blockquote><p>对称性加密</p></blockquote><ul><li><p>AES</p></li><li><p>DES</p></li><li><p>3DES</p><blockquote><p>非对称性</p></blockquote></li><li><p>RSA</p></li><li><p>DSA</p></li><li><p>ECC</p><blockquote><p>散列算法</p></blockquote></li><li><p>MD5</p></li><li><p>SHA1</p></li><li><p>HMAC</p><blockquote><p>其他常用</p></blockquote></li><li><p>Base64</p></li><li><p>HTTPS</p></li></ul><h2 id="06-推荐算法"><a href="#06-推荐算法" class="headerlink" title="06.推荐算法"></a>06.推荐算法</h2><blockquote><p>基于内容</p></blockquote><blockquote><p>基于知识</p></blockquote><blockquote><p>基于规则</p></blockquote><blockquote><p>基于效用</p></blockquote><blockquote><p>协同过滤</p></blockquote><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><ul><li>01.回归算法</li><li>02.基于实例的算法</li><li>03.正则化方法</li><li>04.决策树学习</li><li>05.贝叶斯方法</li><li>06.基于核的算法</li><li>07.聚类算法</li><li>08.关联规则学习</li><li>09.遗传算法（genetic algorithm）</li><li>10.人工神经网络</li><li>11.深度学习</li><li>12.降低维度算法</li><li>13.集成算法</li></ul><h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h2 id="树类型"><a href="#树类型" class="headerlink" title="树类型"></a>树类型</h2><h2 id="图类型"><a href="#图类型" class="headerlink" title="图类型"></a>图类型</h2>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-pymysql</title>
      <link href="man/python/lib-pymysql.html"/>
      <url>man/python/lib-pymysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>MysqlDB</li><li>pymysql</li><li>mysqlconnet<h3 id="MysqlDB"><a href="#MysqlDB" class="headerlink" title="MysqlDB"></a>MysqlDB</h3></li><li>(1) 什么是MySQLdb？<ul><li>MySQLdb 是用于 Python 连接 MySQL 数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。</li></ul></li><li>使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = MySQLdb.connect(<span class="string">"localhost"</span>,<span class="string">"hp"</span>,<span class="string">"Hp12345."</span>,<span class="string">"TESTDB"</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h3><ul><li>安装：pip install PyMysql</li><li>操作<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = pymysql.connect(<span class="string">"localhost"</span>,<span class="string">"hp"</span>,<span class="string">"Hp12345."</span>,<span class="string">"TESTDB"</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysql-connector-的使用"><a href="#mysql-connector-的使用" class="headerlink" title="mysql.connector 的使用"></a>mysql.connector 的使用</h3><ul><li>(1) 什么是 mysql.connector？<ul><li>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</li><li>目前，有两个 MySQL 驱动：<ul><li>mysql-connector-python：是 MySQL 官方的纯 Python 驱动；</li><li>MySQL-python ：是封装了 MySQL C驱动的 Python 驱动。</li></ul></li></ul></li><li>安装 mysql.connector:<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-connector-python</span><br><span class="line">pip install MySQL-python</span><br></pre></td></tr></table></figure></li><li>使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = mysql.connector.connect(user=<span class="string">"hp"</span>, passwd=<span class="string">"Hp12345."</span>, database=<span class="string">"TESTDB"</span>, use_unicode=<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> r:</span><br><span class="line">        r.get(url)</span><br><span class="line">ThreadPool(<span class="number">128</span>).map(my_func, open(<span class="string">'urls.txt'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/index.html"/>
      <url>man/linux/%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>vmstat–虚拟内存统计<ul><li>vmstat interval  times即每隔interval秒采样一次，共采样times次，如果省略times,则一直采集数据，直到用户手动停止为止</li></ul></li><li>iostat–用于报告中央处理器统计信息<ul><li>ostat用于报告中央处理器(CPU)统计信息和整个系统、适配器、tty 设备、磁盘和 CD-ROM  的输入/输出统计信息，默认显示了与vmstat相同的cpu使用信息</li></ul></li><li>dstat–系统监控工具<ul><li>dstat显示了cpu使用情况，磁盘io情况，网络发包情况和换页情况，输出是彩色的，可读性较强，相对于vmstat和iostat的输入更加详细且较为直观。在使用时，直接输入命令即可，当然也可以使用特定参数。</li></ul></li><li>iotop–LINUX进程实时监控工具<ul><li>iotop命令是专门显示硬盘IO的命令，界面风格类似top命令，可以显示IO负载具体是由哪个进程产生的。是一个用来监视磁盘I/O使用状况的top类工具，具有与top相似的UI，其中包括PID、用户、I/O、进程等相关信息。</li></ul></li><li>pidstat–监控系统资源情况<ul><li>pidstat主要用于监控全部或指定进程占用系统资源的情况,如CPU,内存、设备IO、任务切换、线程等。</li><li>使用方法：pidstat –d interval;pidstat还可以用以统计CPU使用信息：pidstat –u  interval;统计内存信息：Pidstat –r interval。</li></ul></li><li>top<ul><li>top命令的汇总区域显示了五个方面的系统性能信息：</li><li>负载：时间，登陆用户数，系统平均负载;</li><li>进程：运行，睡眠，停止，僵尸;</li><li>cpu:用户态，核心态，NICE,空闲，等待IO,中断等;</li><li>内存：总量，已用，空闲(系统角度)，缓冲，缓存;</li><li>交换分区：总量，已用，空闲</li><li>任务区域默认显示：进程ID,有效用户，进程优先级，NICE值，进程使用的虚拟内存，物理内存和共享内存，进程状态，CPU占用率，内存占用率，累计CPU时间，进程命令行信息。</li></ul></li><li>htop<ul><li>htop 是Linux系统中的一个互动的进程查看器,一个文本模式的应用程序(在控制台或者X终端中),需要ncurses。</li></ul></li><li>mpstat<ul><li>mpstat 是Multiprocessor  Statistics的缩写，是实时系统监控工具。其报告与CPU的一些统计信息，这些信息存放在/proc/stat文件中。在多CPUs系统里，其不但能查看所有CPU的平均状况信息，而且能够查看特定CPU的信息。常见用法：mpstat  –P ALL interval times。</li></ul></li><li>netstat<ul><li>Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况</li><li>netstat –npl 可以查看你要打开的端口是否已经打开。</li><li>netstat –rn 打印路由表信息。</li><li>netstat –in 提供系统上的接口信息，打印每个接口的MTU,输入分组数，输入错误，输出分组数，输出错误，冲突以及当前的输出队列的长度。</li></ul></li><li>ps–显示当前进程的状态</li><li>strace<ul><li>跟踪程序执行过程中产生的系统调用及接收到的信号，帮助分析程序或命令执行中遇到的异常情况。</li></ul></li><li>uptime<ul><li>能够打印系统总共运行了多长时间和系统的平均负载，uptime命令最后输出的三个数字的含义分别是1分钟，5分钟，15分钟内系统的平均负荷。</li></ul></li><li>lsof<ul><li>lsof(list open files)是一个列出当前系统打开文件的工具。通过lsof工具能够查看这个列表对系统检测及排错</li></ul></li><li>perf<ul><li>perf是Linux kernel自带的系统性能优化工具。优势在于与Linux Kernel的紧密结合，它可以最先应用到加入Kernel的new  feature，用于查看热点函数，查看cashe miss的比率，从而帮助开发者来优化程序性能</li></ul></li></ul><p><img data-src="assets/wKiom1kb-QjiRnkfAAHriQsrHj8104.jpg-wh_651x-s_3593761084.jpg" alt="wKiom1kb-QjiRnkfAAHriQsrHj8104.jpg-wh_651x-s_3593761084"><br><img data-src="assets/wKiom1kb-Ybyz9HtAAF1dG7duYI681.jpg" alt="wKiom1kb-Ybyz9HtAAF1dG7duYI681"><br><img data-src="assets/wKiom1kb-Y-gzmWNAAFEu7oQvNY181.jpg" alt="wKiom1kb-Y-gzmWNAAFEu7oQvNY181"><br><img data-src="assets/wKiom1kb-aLjr5alAAE0WUog_as391.jpg" alt="wKiom1kb-aLjr5alAAE0WUog_as391"></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/index.html"/>
      <url>man/linux/%E5%AE%89%E5%85%A8%E7%AD%96%E7%95%A5/index.html</url>
      
        <content type="html"><![CDATA[<p>安全策略</p><ul><li>1.修改ssh登录端口号<ul><li>vim /etc/ssh/sshd_config</li><li>修改port为2222</li></ul></li><li>2.安装fail2ban，配置失败次数<ul><li>默认的 /etc/fail2ban/jail.conf文件不要动，需要配置了在新建一个jail.local文件，在其内编辑</li><li>在 /etc/fail2ban/ 文件夹内新建一个jail.local文件。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># jail.local 文件内容</span><br><span class="line">[DEFAULT]</span><br><span class="line">ignoreip &#x3D; 127.0.0.1&#x2F;8</span><br><span class="line">findtime  &#x3D; 60</span><br><span class="line"></span><br><span class="line">[sshd]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">port &#x3D; 2222</span><br><span class="line">banaction &#x3D; iptables-multiport</span><br><span class="line">maxretry &#x3D; 5</span><br><span class="line">bantime &#x3D; 1200</span><br><span class="line"></span><br><span class="line">[mysqld-auth]</span><br><span class="line">enabled &#x3D; true</span><br><span class="line">filter   &#x3D; mysqld-auth</span><br><span class="line">port     &#x3D; 3306</span><br><span class="line">logpath  &#x3D; &#x2F;var&#x2F;log&#x2F;mysqld.log</span><br><span class="line">maxretry &#x3D; 5</span><br><span class="line">bantime &#x3D; 1200</span><br></pre></td></tr></table></figure></li></ul></li><li>腾讯云没有阿里云安全，没有进行设置防火墙，直接把没用的端口暴露在外部。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/net/http/%E7%8A%B6%E6%80%81%E7%A0%81.html"/>
      <url>man/net/http/%E7%8A%B6%E6%80%81%E7%A0%81.html</url>
      
        <content type="html"><![CDATA[<ul><li>1xx    提示信息 －－－ 表示请求已被接收，需要继续处理<ul><li>100    Continue</li><li>101    Switching    Protocols</li><li>102    Porcessing</li></ul></li><li>2xx    成功 －－－ 表示请求已被成功接收，理解，接受<ul><li>200    OK        请求已成功</li><li>201    Created    请求已经被实现，而且有一个新的资源已经依据请求的需要而创建，且其URI已经随Location头信息返回。</li><li>202    Accepted    服务器已接受请求，但未处理</li><li>203    Non-Authoritative Information    服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。</li><li>204    No Content    服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。</li><li>205    Reset Content</li></ul></li><li>3xx    重定向       －－－ 要完成请求必须进一步处理<ul><li>300    Multiple Choices    被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。</li><li>301    Moved Permanently    被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个URI之一。</li><li>302     Found    请求的资源现在临时从不同的URI响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。</li><li>303     See Other    对应当前请求的响应可以在另一个URI上被找到，而且客户端应当采用GET的方式访问那个资源。</li><li>304     Not Modified    如果客户端发送了一个带条件的GET请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变</li><li>305     Use Proxy    被请求的资源必须通过指定的代理才能被访问</li></ul></li><li>4xx    客户端错 －－－ 请求有语法错误或请求无法实现<ul><li>400     Bad Request    由于包含语法错误，当前请求无法被服务器理解。</li><li>401    Unauthorized    当前请求需要用户验证。</li><li>402    Payment Required    该状态码是为了将来可能的需求而预留的。</li><li>403    Forbidden    服务器已经理解请求，但是拒绝执行它。</li><li>404    Not Found    请求失败，请求所希望得到的资源未被在服务器上发现。</li><li>405    Method Not Allowed    请求行中指定的请求方法不能被用于请求相应的资源。</li><li>429</li><li>499</li></ul></li><li>5xx    服务端错 －－－  服务器未能实现合法的请求<ul><li>500     Internal Server Error    服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。</li><li>501     Not Implemented    服务器不支持当前请求所需要的某个功能。</li><li>502     Bad Gateway    作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503    Service Unavailable    由于临时的服务器维护或者过载，服务器当前无法处理请求。</li><li>504     Gateway Timeout 作为网关或者代理工作的服务器尝试执行请求时，未能及时从上游服务器（URI标识出的服务器，例如HTTP、FTP、LDAP）或者辅助服务器（例如DNS）收到响应。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/excel%E6%93%8D%E4%BD%9C.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/excel%E6%93%8D%E4%BD%9C.html</url>
      
        <content type="html"><![CDATA[<h1 id="python对Excel的操作"><a href="#python对Excel的操作" class="headerlink" title="python对Excel的操作"></a>python对Excel的操作</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>日期：2018-10-26</li></ul><p>[TOC]</p><h3 id="一、XlsxWriter"><a href="#一、XlsxWriter" class="headerlink" title="一、XlsxWriter"></a>一、XlsxWriter</h3><ul><li>优点<ul><li>1.功能比较强<ul><li>相对而言，这是除Excel自身之外功能最强的工具了。比如我就用到了它提供的：字体设置、前景色背景色、border设置、视图缩放（zoom）、单元格合并、autofilter、freeze panes、公式、data validation、单元格注释、行高和列宽设置等等。最让我惊奇的是，用它生成的带有单元格注释的Excel文件，不论是Excel 2007还是Excel 2013都可正常打开（下面会提到，这个任务用Excel自身都无法完成）。</li></ul></li><li>2.支持大文件写入<ul><li>如果数据量非常大，可以启用constant memory模式，这是一种顺序写入模式，得到一行数据就立刻写入一行，而不会把所有的数据都保持在内存中。</li></ul></li></ul></li><li>缺点<ul><li>1.不支持读</li><li>2.不支持xls</li><li>3.不支持透视图<h3 id="二、xlrd-amp-xlwt"><a href="#二、xlrd-amp-xlwt" class="headerlink" title="二、xlrd&amp;xlwt"></a>二、xlrd&amp;xlwt</h3></li></ul></li><li>优点<ul><li>1.支持XLS格式</li><li>2.可读可写</li></ul></li><li>缺点<ul><li>1.对xlsx不支持</li><li>2.功能很弱<h3 id="三、OpenPyXL"><a href="#三、OpenPyXL" class="headerlink" title="三、OpenPyXL"></a>三、OpenPyXL</h3></li></ul></li><li>优点<ul><li>1.能读能写能修改</li><li>2.功能还算可以</li></ul></li><li>缺点<ul><li>1.不支持XLS</li><li>2.不支持读取公式<h3 id="四、Microsoft-Excel-API"><a href="#四、Microsoft-Excel-API" class="headerlink" title="四、Microsoft Excel API"></a>四、Microsoft Excel API</h3></li></ul></li><li>优点<ul><li>1.强大无极限</li><li>2.文档丰富</li><li>3.调试方便</li></ul></li><li>缺点<ul><li>1.致命的缺点：慢到死</li><li>2.平台限制。非windows不可用</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/format%E4%BD%BF%E7%94%A8.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/format%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2018-10-26 17:15:234</li></ul><h3 id="0x00、介绍"><a href="#0x00、介绍" class="headerlink" title="0x00、介绍"></a>0x00、介绍</h3><ul><li>format优点<ul><li>1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型</li><li>2.单个参数可以多次输出，参数顺序可以不相同</li><li>3.填充方式十分灵活，对齐方式十分强大</li><li>4.官方推荐用的方式，%方式将会在后面的版本被淘汰</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'hello &#123;0&#125;'</span>.format(<span class="string">'world'</span>)</span><br><span class="line"></span><br><span class="line">// hello world</span><br></pre></td></tr></table></figure><ul><li><p>format格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#format的格式</span></span><br><span class="line">replacement_field ::= <span class="string">"&#123;"</span> [field_name] [<span class="string">"!"</span> conversion] [<span class="string">":"</span> format_spec] <span class="string">"&#125;"</span></span><br><span class="line">field_name ::= arg_name (<span class="string">"."</span> attribute_name | <span class="string">"["</span> element_index <span class="string">"]"</span>)*</span><br><span class="line">arg_name ::= [identifier | integer]</span><br><span class="line">attribute_name ::= identifier</span><br><span class="line">element_index ::= integer | index_string</span><br><span class="line">index_string ::= &lt;any source character <span class="keyword">except</span> <span class="string">"]"</span>&gt; +</span><br><span class="line">conversion ::= <span class="string">"r"</span> | <span class="string">"s"</span> | <span class="string">"a"</span></span><br><span class="line">format_spec ::= &lt;described <span class="keyword">in</span> the next section&gt;</span><br></pre></td></tr></table></figure></li><li><p>format_spec 的格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">format_spec 　　::= 　　[[fill]align][sign][<span class="comment">#][0][width][,][.precision][type]</span></span><br><span class="line">fill 　　　　　::= 　　&lt;any character&gt;</span><br><span class="line">align 　　　　::= 　　<span class="string">"&lt;"</span> | <span class="string">"&gt;"</span> | <span class="string">"="</span> | <span class="string">"^"</span></span><br><span class="line">sign 　　　　 ::= 　　<span class="string">"+"</span> | <span class="string">"-"</span> | <span class="string">" "</span></span><br><span class="line">width 　　　　 ::= 　　 integer</span><br><span class="line">precision 　　　　::= 　　 integer</span><br><span class="line">type 　　　　::= 　　<span class="string">"b"</span> | <span class="string">"c"</span> | <span class="string">"d"</span> | <span class="string">"e"</span> | <span class="string">"E"</span> | <span class="string">"f"</span> | <span class="string">"F"</span> | <span class="string">"g"</span> | <span class="string">"G"</span> | <span class="string">"n"</span> | <span class="string">"o"</span> | <span class="string">"s"</span> | <span class="string">"x"</span> | <span class="string">"X"</span> | <span class="string">"%"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="0x01、应用"><a href="#0x01、应用" class="headerlink" title="0x01、应用"></a>0x01、应用</h3><h4 id="一、填充"><a href="#一、填充" class="headerlink" title="一、填充"></a>一、填充</h4><ul><li>1.通过位置来填充字符串</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">print(<span class="string">'hello &#123;0&#125; i am &#123;1&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))                  <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;&#125; i am &#123;&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))                <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;0&#125; i am &#123;1&#125; . my name is &#123;0&#125;'</span>.format(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>)) <span class="comment"># hello Kevin i am Tom . my name is Kevin</span></span><br></pre></td></tr></table></figure><ul><li>2.通过key来填充</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">print(<span class="string">'hello &#123;name1&#125; i am &#123;name2&#125;'</span>.format(name1=<span class="string">'Kevin'</span>,name2=<span class="string">'Tom'</span>) )    <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure><ul><li>3.通过下标填充</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">names=[<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>]</span><br><span class="line">print(<span class="string">'hello &#123;names[0]&#125; i am &#123;names[1]&#125;'</span>.format(names=names))                  <span class="comment"># hello Kevin i am Tom</span></span><br><span class="line">print(<span class="string">'hello &#123;0[0]&#125; i am &#123;0[1]&#125;'</span>.format(names))                                <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure><ul><li>4..通过字典的key    注意访问字典的key，不用引号的</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">names=&#123;<span class="string">'name'</span>:<span class="string">'Kevin'</span>,<span class="string">'name2'</span>:<span class="string">'Tom'</span>&#125;</span><br><span class="line">print(<span class="string">'hello &#123;names[name]&#125; i am &#123;names[name2]&#125;'</span>.format(names=names))    <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure><ul><li>5.通过对象的属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Names</span><span class="params">()</span>:</span></span><br><span class="line">    name1=<span class="string">'Kevin'</span></span><br><span class="line">    name2=<span class="string">'Tom'</span></span><br><span class="line">print(<span class="string">'hello &#123;names.name1&#125; i am &#123;names.name2&#125;'</span>.format(names=Names))                  <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure><ul><li>6.使用魔法参数</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">args=[<span class="string">'lu'</span>]</span><br><span class="line">kwargs = &#123;<span class="string">'name1'</span>: <span class="string">'Kevin'</span>, <span class="string">'name2'</span>: <span class="string">'Tom'</span>&#125;</span><br><span class="line">print(<span class="string">'hello &#123;name1&#125; &#123;&#125; i am &#123;name2&#125;'</span>.format(*args, **kwargs))  <span class="comment"># hello Kevin i am Tom</span></span><br></pre></td></tr></table></figure><h4 id="二、格式转换"><a href="#二、格式转换" class="headerlink" title="二、格式转换"></a>二、格式转换</h4><ul><li>b、d、o、x分别是二进制、十进制、八进制、十六进制。</li></ul><table><thead><tr><th>数字</th><th>格式</th><th>输出</th><th>描述</th></tr></thead><tbody><tr><td>3.1415926</td><td>{:.2f}</td><td>3.14</td><td>保留小数点后两位</td></tr><tr><td>3.1415926</td><td>{:+.2f}</td><td>3.14</td><td>带符号保留小数点后两位</td></tr><tr><td>-1</td><td>{:+.2f}</td><td>-1</td><td>带符号保留小数点后两位</td></tr><tr><td>2.71828</td><td>{:.0f}</td><td>3</td><td>不带小数</td></tr><tr><td>1000000</td><td>{:,}</td><td>1,000,000</td><td>以逗号分隔的数字格式</td></tr><tr><td>0.25</td><td>{:.2%}</td><td>25.00%</td><td>百分比格式</td></tr><tr><td>1000000000</td><td>{:.2e}</td><td>1.00E+09</td><td>指数记法</td></tr><tr><td>25</td><td>{0:b}</td><td>11001</td><td>转换成二进制</td></tr><tr><td>25</td><td>{0:d}</td><td>25</td><td>转换成十进制</td></tr><tr><td>25</td><td>{0:o}</td><td>31</td><td>转换成八进制</td></tr><tr><td>25</td><td>{0:x}</td><td>19</td><td>转换成十六进制</td></tr></tbody></table><h4 id="三、对齐与填充"><a href="#三、对齐与填充" class="headerlink" title="三、对齐与填充"></a>三、对齐与填充</h4><p>|数字|    格式|    输出|    描述|<br>|—|—|—|—|—|<br>|5    |{:0&gt;2}    |05    |数字补零 (填充左边, 宽度为2)|<br>|5    |{:x&lt;4}|5xxx|    数字补x (填充右边, 宽度为4)|<br>|10|{:x^4}|x10x|    数字补x (填充右边, 宽度为4)|<br>|13    |{:10}|13|    右对齐 (默认, 宽度为10)|<br>|13    |{:&lt;10}|13|    左对齐 (宽度为10)|<br>|13    |{:^10}|13|    中间对齐 (宽度为10)|</p><h4 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h4><ul><li><p>1.转义{和}符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">prin(<span class="string">'&#123;&#123; hello &#123;0&#125; &#125;&#125;'</span>.format(<span class="string">'Kevin'</span>))</span><br><span class="line"><span class="comment"># 跟%中%%转义%一样，formate中用两个大括号来转义</span></span><br></pre></td></tr></table></figure></li><li><p>2.format作为函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f = <span class="string">'hello &#123;0&#125; i am &#123;1&#125;'</span>.format</span><br><span class="line">print(f(<span class="string">'Kevin'</span>,<span class="string">'Tom'</span>))</span><br></pre></td></tr></table></figure></li><li><p>3.格式化datetime</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">now=datetime.now()</span><br><span class="line">print(<span class="string">'&#123;:%Y-%m-%d %X&#125;'</span>.format(now))</span><br></pre></td></tr></table></figure></li><li><p>4.{}内嵌{}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">'hello &#123;0:&gt;&#123;1&#125;&#125; '</span>.format(<span class="string">'Kevin'</span>,<span class="number">50</span>))</span><br></pre></td></tr></table></figure></li><li><p>5.叹号的用法</p><ul><li>！后面可以加s r a 分别对应str() repr() ascii()</li><li>作用是在填充前先用对应的函数来处理参数</li><li>差别就是repr带有引号，str()是面向用户的，目的是可读性，repr()是面向python解析器的，返回值表示在python内部的含义<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">"&#123;!s&#125;"</span>.format(<span class="string">'2'</span>))  <span class="comment"># 2</span></span><br><span class="line">print(<span class="string">"&#123;!r&#125;"</span>.format(<span class="string">'2'</span>))   <span class="comment"># '2'</span></span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/rust-python.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/rust-python.html</url>
      
        <content type="html"><![CDATA[<p>用rust来加速python的一些需要性能提升的地方。<br>可以使用rust中的cpython或者PyO3相关的库来实现，把rust相关代码编译成dylib动态库，然后改成.so类型的动态库，就可以在python内直接import进来来使用了。</p><ul><li><a href="https://github.com/rochacbruno/rust-python-example" target="_blank" rel="noopener">例子</a></li></ul><p>假如用cpython来实现</p><ul><li><p>运行如下命令创建一个lib库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cargo new req --lib</span><br></pre></td></tr></table></figure></li><li><p>Cargo.toml文件配置添加如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[lib]</span><br><span class="line">name &#x3D; &quot;req&quot;</span><br><span class="line">crate-type &#x3D; [&quot;cdylib&quot;]</span><br><span class="line"></span><br><span class="line">[dependencies]</span><br><span class="line"># hyper &#x3D; &quot;0.13&quot;</span><br><span class="line">tokio &#x3D; &#123; version &#x3D; &quot;0.2&quot;, features &#x3D; [&quot;full&quot;] &#125;</span><br><span class="line"># pretty_env_logger &#x3D; &quot;0.4&quot;</span><br><span class="line">reqwest &#x3D; &#123; version &#x3D; &quot;0.10&quot;,features&#x3D;[&quot;blocking&quot;,&quot;json&quot;] &#125;</span><br><span class="line">cpython &#x3D; &#123; version &#x3D; &quot;0.4&quot;,features &#x3D; [&quot;extension-module&quot;]&#125;</span><br><span class="line">http &#x3D; &#123; version &#x3D; &quot;0.2&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>lib.rs文件内容</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[macro_use]</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cpython;</span><br><span class="line"><span class="keyword">use</span> cpython::&#123;PyDict, PyObject, PyResult, Python, PyString, PyUnicode&#125;;</span><br><span class="line"><span class="keyword">use</span> http::Method;</span><br><span class="line"><span class="keyword">use</span> reqwest;</span><br><span class="line"><span class="keyword">use</span> reqwest::header::&#123;HeaderMap, HeaderName, HeaderValue&#125;;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line">py_module_initializer!(req, initreq, PyInit_req, |py, m| &#123;</span><br><span class="line">    m.add(py, <span class="string">"__doc__"</span>, <span class="string">"Module documentation string"</span>)?;</span><br><span class="line">    m.add(py, <span class="string">"run"</span>, py_fn!(py, run()))?;</span><br><span class="line">    m.add(</span><br><span class="line">        py,</span><br><span class="line">        <span class="string">"request"</span>,</span><br><span class="line">        py_fn!(</span><br><span class="line">            py,</span><br><span class="line">            request_py(method: &amp;[<span class="built_in">u8</span>], url: &amp;<span class="built_in">str</span>, timeout: <span class="built_in">u64</span>, headers: PyDict, proxy: &amp;<span class="built_in">str</span>)</span><br><span class="line">        ),</span><br><span class="line">    )?;</span><br><span class="line">    <span class="literal">Ok</span>(())</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(py: Python) -&gt; PyResult&lt;PyObject&gt; &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Rust says: Hello Python!"</span>);</span><br><span class="line">    <span class="literal">Ok</span>(py.<span class="literal">None</span>())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">request_py</span></span>(</span><br><span class="line">    py: Python,</span><br><span class="line">    method: &amp;[<span class="built_in">u8</span>],</span><br><span class="line">    url: &amp;<span class="built_in">str</span>,</span><br><span class="line">    timeout: <span class="built_in">u64</span>,</span><br><span class="line">    headers: PyDict,</span><br><span class="line">    p: &amp;<span class="built_in">str</span></span><br><span class="line">) -&gt; PyResult&lt;PyDict&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> uri = reqwest::Url::parse(url).unwrap();</span><br><span class="line">    <span class="keyword">let</span> ts = Duration::new(timeout, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> method = Method::from_bytes(method).unwrap();</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> headersMap = HeaderMap::new();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hs = headers.items(py);</span><br><span class="line">    <span class="keyword">for</span> h <span class="keyword">in</span> hs &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, h);</span><br><span class="line">        <span class="keyword">let</span> (k, v) = h;</span><br><span class="line">        <span class="keyword">let</span> k_ss: Python;</span><br><span class="line">        <span class="keyword">let</span> k_s = k.extract(k_ss);</span><br><span class="line">        <span class="keyword">let</span> kss = PyString::fromPyObject(k_ss);</span><br><span class="line">        headersMap.insert(</span><br><span class="line">            HeaderName::from_static(k_s),</span><br><span class="line">            HeaderValue::from_static((v.cast_into(PyString).to_string_lossy(py)),</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> proxy = reqwest::Proxy::all(p).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> gil = Python::acquire_gil();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> res = request(gil.python(), uri, method, headersMap, proxy, ts).unwrap();</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">request</span></span>(</span><br><span class="line">    py: Python,</span><br><span class="line">    url: reqwest::Url,</span><br><span class="line">    method: Method,</span><br><span class="line">    headers: HeaderMap,</span><br><span class="line">    proxy: reqwest::Proxy,</span><br><span class="line">    timeout: Duration,</span><br><span class="line">) -&gt; <span class="built_in">Result</span>&lt;PyDict, reqwest::Error&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> data = PyDict::new(py);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> client = reqwest::blocking::Client::builder()</span><br><span class="line">        .proxy(proxy)</span><br><span class="line">        .timeout(timeout)</span><br><span class="line">        .build()?;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Requests Headers &#123;:#?&#125;"</span>, headers);</span><br><span class="line">    <span class="keyword">let</span> res = client.request(method, url).headers(headers).send()?;</span><br><span class="line">    data.set_item(py, <span class="string">"status"</span>, res.status().to_string());</span><br><span class="line">    <span class="keyword">let</span> body = res.text()?;</span><br><span class="line">    data.set_item(py, <span class="string">"body"</span>, body);</span><br><span class="line">    <span class="literal">Ok</span>(data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后运行<br>cargo build –release</p></li><li><p>把target的debug文件夹内的libreq.dylib文件复制到python目录下，修改为req.so文件</p></li><li><p>然后在python直接import就可以使用了。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/index.html"/>
      <url>man/linux/%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>1.目录结构<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/</span><br><span class="line">|-bin -&gt; /usr/bin   【存放可执行文件】</span><br><span class="line">|-boot 【启动库】</span><br><span class="line">|-data</span><br><span class="line">|-dev</span><br><span class="line">|-etc  【配置】</span><br><span class="line">|-home 【普通用户家目录】</span><br><span class="line">|-lib -&gt; /usr/lib  【库文件】</span><br><span class="line">|-lib64</span><br><span class="line">|-lost+found</span><br><span class="line">|-media</span><br><span class="line">|-mnt</span><br><span class="line">|-opt</span><br><span class="line">|-proc</span><br><span class="line">|-root 【root家目录】</span><br><span class="line">|-run</span><br><span class="line">|-sbin 【超级管理员可执行文件】</span><br><span class="line">|-srv</span><br><span class="line">|-sys</span><br><span class="line">|-tmp 【临时目录】</span><br><span class="line">|-usr 【用户文件】</span><br><span class="line">|-var 【存放日志等】</span><br></pre></td></tr></table></figure></li></ul><ul><li>2./bin  /sbin  /usr/bin  /usr/sbin  /usr/local/bin  /usr/local/sbin的区别<ul><li>所有用户皆可用的系统程序放在/bin</li><li>超级用户才能使用的系统程序放在/sbin</li><li>所有用户都可用的应用程序放在/usr/bin</li><li>超级用户才能使用的应用程序放在/usr/sbin</li><li>所有用户都可用的与本地机器无关的程序存放在/usr/local/bin</li><li>超级用户才能使用的与本地机器无关的程序存放在/usr/local/sbin</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/sphinx%E4%BD%BF%E7%94%A8.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/sphinx%E4%BD%BF%E7%94%A8.html</url>
      
        <content type="html"><![CDATA[<h1 id="Sphinx使用"><a href="#Sphinx使用" class="headerlink" title="Sphinx使用"></a>Sphinx使用</h1><blockquote><h2 id="0x00、简介"><a href="#0x00、简介" class="headerlink" title="0x00、简介"></a>0x00、简介</h2></blockquote><ul><li>1.把rst文件转换为多种格式文档的工具.</li></ul><blockquote><h2 id="0x01、使用"><a href="#0x01、使用" class="headerlink" title="0x01、使用"></a>0x01、使用</h2></blockquote><h4 id="1-安装"><a href="#1-安装" class="headerlink" title="1.安装"></a>1.安装</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx</span><br></pre></td></tr></table></figure><h4 id="2-创建文档目录"><a href="#2-创建文档目录" class="headerlink" title="2.创建文档目录"></a>2.创建文档目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir docs</span><br></pre></td></tr></table></figure><h4 id="3-初始化文档目录"><a href="#3-初始化文档目录" class="headerlink" title="3.初始化文档目录"></a>3.初始化文档目录</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sphinx-quickstart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 按照提示进行初始化</span></span><br></pre></td></tr></table></figure><h4 id="4-生成文档"><a href="#4-生成文档" class="headerlink" title="4.生成文档"></a>4.生成文档</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd docs</span><br><span class="line">sphinx-apidoc -o . ..</span><br><span class="line">make html</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/%E6%9C%80%E5%B7%AE%E5%AE%9E%E8%B7%B5.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/%E6%9C%80%E5%B7%AE%E5%AE%9E%E8%B7%B5.html</url>
      
        <content type="html"><![CDATA[<p>最近在看一些陈年老系统，其中有一些不好的代码习惯遗留下来的坑；加上最近自己也写了一段烂代码导致服务器负载飙升，所以就趁此机会总结下我看到过/写过的自认为不好的Python代码习惯，时刻提醒自己远离这些“最差实践”，避免挖坑。</p><p>下面所举的例子中，有一部分会造成性能问题，有一部分会导致隐藏bug，或日后维护、重构困难，还有一部分纯粹是我认为不够pythonic。所以大家自行甄别，取精去糟吧。</p><p>函数默认参数使用可变对象<br>这个例子我想大家应该在各种技术文章中见过许多遍了，也足以证明这是一个大坑。</p><p>先看错误示范吧：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_mutable_default_param</span><span class="params">(idx=<span class="number">0</span>, ids=[])</span>:</span></span><br><span class="line">    ids.append(idx)</span><br><span class="line">    print(idx)</span><br><span class="line">    print(ids)</span><br><span class="line">use_mutable_default_param(idx=<span class="number">1</span>)</span><br><span class="line">use_mutable_default_param(idx=<span class="number">2</span>)</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span></span><br><span class="line">[<span class="number">1</span>]</span><br><span class="line"><span class="number">2</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>理解这其中的原因，最重要的是有两点：</p><p>函数本身也是一个对象，默认参数绑定于这个函数对象上</p><p>append这类方法会直接修改对象，所以下次调用此函数时，其绑定的默认参数已经不再是空list了</p><p>正确的做法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">donot_use_mutable_default_param</span><span class="params">(idx=<span class="number">0</span>, ids=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> ids <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        ids = []</span><br><span class="line">    ids.append(idx)</span><br><span class="line">    print(idx)</span><br><span class="line">    print(ids)</span><br></pre></td></tr></table></figure><p>try…except不具体指明异常类型<br>虽然在Python中使用try…except不会带来严重的性能问题，但是不加区分，直接捕获所有类型异常的做法，往往会掩盖掉其他的bug，造成难以追查的bug。<br>一般的，我觉得应该尽量少的使用try…except，这样可以在开发期尽早的发现问题。即使要使用try…except，也应该尽可能的指定出要捕获的具体异常，并在except语句中将异常信息记入log，或者处理完之后，再直接raise出来。</p><p>关于dict的冗余代码<br>我经常能够看到这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;&#125;</span><br><span class="line">datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> datas:</span><br><span class="line">    <span class="keyword">if</span> k <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">        d[k] = <span class="number">0</span></span><br><span class="line">    d[k] += <span class="number">1</span></span><br><span class="line">其实，完全可以使用collections.defaultdict这一数据结构更简单优雅的实现这样的功能：</span><br><span class="line"></span><br><span class="line">default_d = defaultdict(<span class="keyword">lambda</span>: <span class="number">0</span>)</span><br><span class="line">datas = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> datas:</span><br><span class="line">    default_d[k] += <span class="number">1</span></span><br></pre></td></tr></table></figure><p>同样的，这样的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d is a dict</span></span><br><span class="line"><span class="keyword">if</span> <span class="string">'list'</span> <span class="keyword">not</span> <span class="keyword">in</span> d:</span><br><span class="line">    d[<span class="string">'list'</span>] = []</span><br><span class="line">d[<span class="string">'list'</span>].append(x)</span><br></pre></td></tr></table></figure><p>完全可以用这样一行代码替代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d is a dict</span></span><br><span class="line">d.setdefault(<span class="string">'list'</span>, []).append(x)</span><br></pre></td></tr></table></figure><p>同样的，下面这两种写法一看就是带有浓浓的C味儿：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d is a dict</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> d:</span><br><span class="line">    v = d[k]</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line"><span class="comment"># l is a list</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> len(l):</span><br><span class="line">    v = l[i]</span><br><span class="line">    <span class="comment"># do something</span></span><br></pre></td></tr></table></figure><p>应该用更pythonic的写法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># d is a dict</span></span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> d.iteritems():</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># l is a list</span></span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(l):</span><br><span class="line">    <span class="comment"># do something</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>另外，enumerate其实还有个第二参数，表示序号从几开始。如果想要序号从1开始数起，可以使用enumerate(l, 1)。</p><p>使用flag变量而不使用for…else语句<br>同样，这样的代码也很常见：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">search_list = [<span class="string">'Jone'</span>, <span class="string">'Aric'</span>, <span class="string">'Luise'</span>, <span class="string">'Frank'</span>, <span class="string">'Wey'</span>]</span><br><span class="line">found = <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> search_list:</span><br><span class="line">    <span class="keyword">if</span> s.startswith(<span class="string">'C'</span>):</span><br><span class="line">        found = <span class="literal">True</span></span><br><span class="line">        <span class="comment"># do something when found</span></span><br><span class="line">        print(<span class="string">'Found'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> found:</span><br><span class="line">    <span class="comment"># do something when not found</span></span><br><span class="line">    print(<span class="string">'Not found'</span>)</span><br></pre></td></tr></table></figure><p>其实，用for…else更优雅：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">search_list = [<span class="string">'Jone'</span>, <span class="string">'Aric'</span>, <span class="string">'Luise'</span>, <span class="string">'Frank'</span>, <span class="string">'Wey'</span>]</span><br><span class="line"><span class="keyword">for</span> s <span class="keyword">in</span> search_list:</span><br><span class="line">    <span class="keyword">if</span> s.startswith(<span class="string">'C'</span>):</span><br><span class="line">        <span class="comment"># do something when found</span></span><br><span class="line">        print(<span class="string">'Found'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># do something when not found</span></span><br><span class="line">    print(<span class="string">'Not found'</span>)</span><br></pre></td></tr></table></figure><p>过度使用tuple unpacking<br>在Python中，允许对tuple类型进行unpack操作，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># human = ('James', 180, 32)</span></span><br><span class="line">name，height，age = human</span><br></pre></td></tr></table></figure><p>这个特性用起来很爽，比写name=human[0]之类的不知道高到哪里去了。所以，这一特性往往被滥用，一个human在程序的各处通过上面的方式unpack。</p><p>然而如果后来需要在human中插入一个表示性别的数据sex，那么对于所有的这种unpack都需要进行修改，即使在有些逻辑中并不会使用到性别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># human &#x3D; (&#39;James&#39;, 180, 32)</span><br><span class="line">name，height，age, _ &#x3D; human</span><br><span class="line"># or</span><br><span class="line"># name, height, age, sex &#x3D; human</span><br></pre></td></tr></table></figure><p>有如下几种方式解决这一问题：</p><p>老老实实写name=human[0]这种代码，在需要使用性别信息处加上sex=human[3]</p><p>使用dict来表示human</p><p>使用namedtuple</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># human = namedtuple('human', ['name', 'height', 'age', 'sex'])</span></span><br><span class="line">h = human(<span class="string">'James'</span>, <span class="number">180</span>, <span class="number">32</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># then you can use h.name, h.sex and so on everywhere.</span></span><br></pre></td></tr></table></figure><p>到处都是import *<br>import *是一种懒惰的行为，它不仅会污染当前的命名空间，并且还会使得pyflakes等代码检查工具失效。在后续查看代码或者debug的过程中，往往也很难从一堆import *中找到一个第三方函数的来源。<br>可以说这种习惯是百害而无一利的。</p><p>文件操作<br>文件操作不要使用裸奔的f = open(‘filename’)了，使用with open(‘filename’) as f来让context manager帮你处理异常情况下的关闭文件等乱七八糟的事情多好。</p><p>野蛮使用class.name判断类型<br>我曾经遇见过一个bug：为了实现某特定功能，我新写了一个class B(A)，在B中重写了A的若干函数。整个实现很简单，但是就是有一部分A的功能无法生效。最后追查到的原因，就是在一些逻辑代码中，硬性的判断了entity.<strong>class</strong>.<strong>name</strong> == ‘A’。</p><p>除非你就是想限定死继承层级中的当前类型（也就是，屏蔽未来可能会出现的子类），否则，不要使用<strong>class</strong>.<strong>name</strong>，而改用isinstance这个内建函数。毕竟，Python把这两个变量的名字都刻意带上那么多下划线，本来就是不太想让你用嘛。</p><p>循环内部有多层函数调用<br>循环内部有多层函数调用，有如下两方面的隐患：</p><p>Python没有inline函数，所以函数调用本来就会导致一定的开销，尤其是本身逻辑简单的时候，这个开销所占的比例就会挺可观的。</p><p>更严重的是，在之后维护这份代码时，会容易让人忽略掉函数是在循环中被调用的，所以容易在函数内部添加了一些开销较大却不必每次循环都调用的函数，比如time.localtime()。如果是直接一个平铺直叙的循环，我想大部分的程序员都应该知道把time.localtime()写到循环的外面，但是引入多层的函数调用之后，就不一定了哦。</p><p>所以我建议，在循环内部，如非特别复杂的逻辑，都应该直接写在循环里，不要进行函数调用。如果一定要包装一层函数调用，应该在函数的命名或注释中，提示后续的维护者，这个函数会在循环内部使用。</p><p>Python是一门非常容易入门的语言，严格的缩进要求和丰富的内置数据类型，使得大部分Python代码都能做到比较好的规范。但是，不严格要求自己，也很容易就写出犯二的代码。上面列出的只是很小的一部分，唯有多读、多写、多想，才能培养敏锐的代码嗅觉，第一时间发现坏味道啊。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mongodb/%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3.html"/>
      <url>man/storeage/mongodb/%E6%93%8D%E4%BD%9C%E6%96%87%E6%A1%A3.html</url>
      
        <content type="html"><![CDATA[<h1 id="mongodb操作文档"><a href="#mongodb操作文档" class="headerlink" title="mongodb操作文档"></a>mongodb操作文档</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-08-02 11:46:49</li></ul><p>[TOC]</p><ul><li>时间类型存储为字符串时，需要使用聚合查询，把原str类型转换为ISO时间类型<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.douban_subject.find(&#123;<span class="string">"create_time"</span>:&#123;<span class="string">"$gte"</span>: new ISODate(<span class="string">"2019-06-20T00:00:00Z"</span>),<span class="string">"$lte"</span>: new ISODate(<span class="string">"2019-06-21T00:00:00Z"</span>)&#125;&#125;);</span><br><span class="line"></span><br><span class="line">db.douban_subject.find(&#123;<span class="string">"create_time"</span>:&#123;<span class="string">"$gte"</span>: <span class="string">"2019-06-20"</span>,<span class="string">"$lte"</span>: <span class="string">"2019-06-21"</span>&#125;&#125;);</span><br></pre></td></tr></table></figure></li><li>help<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li>db.stats<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">db.stats();</span><br><span class="line">db.stats(<span class="number">1024</span>); <span class="comment">#Kb</span></span><br><span class="line">db.stats(<span class="number">1073741824</span>); <span class="comment"># Gb</span></span><br></pre></td></tr></table></figure></li><li>version<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.version();</span><br></pre></td></tr></table></figure></li><li>user<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#添加用户、设置密码、是否只读</span></span><br><span class="line">db.addUser(<span class="string">"userName"</span>, <span class="string">"pwd123"</span>, true);</span><br><span class="line"></span><br><span class="line"><span class="comment"># 授权</span></span><br><span class="line"> db.auth(<span class="string">"userName"</span>, <span class="string">"123123"</span>);</span><br><span class="line"><span class="comment"># 显示user</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="collection查询"><a href="#collection查询" class="headerlink" title="collection查询"></a>collection查询</h3><ul><li><p>1、查询所有记录</p><ul><li>db.userInfo.find();</li><li>相当于：select* from userInfo;</li><li>默认每页显示20条记录，当显示不下的情况下，可以用it迭代命令查询下一页数据。注意：键入it命令不能带“；”</li><li>但是你可以设置每页显示数据的大小，用DBQuery.shellBatchSize= 50;这样每页就显示50条记录了。</li></ul></li><li><p>2、查询去掉后的当前聚集集合中的某列的重复数据</p><ul><li>db.userInfo.distinct(“name”);</li><li>会过滤掉name中的相同数据</li><li>相当于：select distict name from userInfo;</li></ul></li><li><p>3、查询age = 22的记录</p><ul><li>db.userInfo.find({“age”: 22});</li><li>相当于： select * from userInfo where age = 22;</li></ul></li><li><p>4、查询age &gt; 22的记录</p><ul><li>db.userInfo.find({age: {$gt: 22}});</li><li>相当于：select * from userInfo where age &gt;22;</li></ul></li><li><p>5、查询age &lt; 22的记录<br>  *db.userInfo.find({age: {$lt: 22}});<br>  *相当于：select * from userInfo where age &lt;22;</p></li><li><p>6、查询age &gt;= 25的记录</p><ul><li>db.userInfo.find({age: {$gte: 25}});</li><li>相当于：select * from userInfo where age &gt;= 25;</li></ul></li><li><p>7、查询age &lt;= 25的记录</p><ul><li>db.userInfo.find({age: {$lte: 25}});</li></ul></li><li><p>8、查询age &gt;= 23 并且 age &lt;= 26</p><ul><li>db.userInfo.find({age: {$gte: 23, $lte: 26}});</li></ul></li><li><p>9、查询name中包含 mongo的数据</p><ul><li>db.userInfo.find({name: /mongo/});</li><li>//相当于%%</li><li>select * from userInfo where name like ‘%mongo%’;</li></ul></li><li><p>10、查询name中以mongo开头的</p><ul><li>db.userInfo.find({name: /^mongo/});</li><li>select * from userInfo where name like ‘mongo%’;</li></ul></li><li><p>11、查询指定列name、age数据</p><ul><li>db.userInfo.find({}, {name: 1, age: 1});</li><li>相当于：select name, age from userInfo;</li><li>当然name也可以用true或false,当用ture的情况下河name:1效果一样，如果用false就是排除name，显示name以外的列信息。</li></ul></li><li><p>12、查询指定列name、age数据, age &gt; 25</p><ul><li>db.userInfo.find({age: {$gt: 25}}, {name: 1, age: 1});</li><li>相当于：select name, age from userInfo where age &gt;25;</li></ul></li><li><p>13、按照年龄排序</p><ul><li>升序：db.userInfo.find().sort({age: 1});</li><li>降序：db.userInfo.find().sort({age: -1});</li></ul></li><li><p>14、查询name = zhangsan, age = 22的数据</p><ul><li>db.userInfo.find({name: ‘zhangsan’, age: 22});</li><li>相当于：select * from userInfo where name = ‘zhangsan’ and age = ‘22’;</li></ul></li><li><p>15、查询前5条数据</p><ul><li>db.userInfo.find().limit(5);</li><li>相当于：selecttop 5 * from userInfo;</li></ul></li><li><p>16、查询10条以后的数据</p><ul><li>db.userInfo.find().skip(10);</li><li>相当于：select * from userInfo where id not in (</li><li>selecttop 10 * from userInfo</li><li>);</li></ul></li><li><p>17、查询在5-10之间的数据</p><ul><li>db.userInfo.find().limit(10).skip(5);</li><li>可用于分页，limit是pageSize，skip是第几页*pageSize</li></ul></li><li><p>18、or与 查询</p><ul><li>db.userInfo.find({$or: [{age: 22}, {age: 25}]});</li><li>相当于：select * from userInfo where age = 22 or age = 25;</li></ul></li><li><p>19、查询第一条数据</p><ul><li>db.userInfo.findOne();</li><li>相当于：selecttop 1 * from userInfo;</li><li>db.userInfo.find().limit(1);</li></ul></li><li><p>20、查询某个结果集的记录条数</p><ul><li>db.userInfo.find({age: {$gte: 25}}).count();</li><li>相当于：select count(*) from userInfo where age &gt;= 20;</li></ul></li><li><p>21、按照某列进行排序</p><ul><li>db.userInfo.find({sex: {$exists: true}}).count();</li><li>相当于：select count(sex) from userInfo;</li></ul></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li><p>1、创建索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.userInfo.ensureIndex(&#123;name: <span class="number">1</span>&#125;);</span><br><span class="line">db.userInfo.ensureIndex(&#123;name: <span class="number">1</span>, ts: <span class="number">-1</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>2、查询当前聚集集合所有索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.userInfo.getIndexes();</span><br></pre></td></tr></table></figure></li><li><p>3、查看总索引记录大小</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.userInfo.totalIndexSize();</span><br></pre></td></tr></table></figure></li><li><p>4、读取当前集合的所有index信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.reIndex();</span><br></pre></td></tr></table></figure></li><li><p>5、删除指定索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.dropIndex(<span class="string">"name_1"</span>);</span><br></pre></td></tr></table></figure></li><li><p>6、删除所有索引索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.dropIndexes();</span><br></pre></td></tr></table></figure></li></ul><h3 id="修改、添加、删除集合数据"><a href="#修改、添加、删除集合数据" class="headerlink" title="修改、添加、删除集合数据"></a>修改、添加、删除集合数据</h3><ul><li><p>1、添加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.users.save(&#123;name: ‘zhangsan’, age: <span class="number">25</span>, sex: true&#125;);</span><br><span class="line">添加的数据的数据列，没有固定，根据添加的数据为准</span><br></pre></td></tr></table></figure></li><li><p>2、修改</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">db.users.update(&#123;age: <span class="number">25</span>&#125;, &#123;$set: &#123;name: <span class="string">'changeName'</span>&#125;&#125;, false, true);</span><br><span class="line">相当于：update users set name = ‘changeName’ where age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line">db.users.update(&#123;name: <span class="string">'Lisi'</span>&#125;, &#123;$inc: &#123;age: <span class="number">50</span>&#125;&#125;, false, true);</span><br><span class="line">相当于：update users set age = age + <span class="number">50</span> where name = ‘Lisi’;</span><br><span class="line"></span><br><span class="line">db.users.update(&#123;name: <span class="string">'Lisi'</span>&#125;, &#123;$inc: &#123;age: <span class="number">50</span>&#125;, $set: &#123;name: <span class="string">'hoho'</span>&#125;&#125;, false, true);</span><br><span class="line">相当于：update users set age = age + <span class="number">50</span>, name = ‘hoho’ where name = ‘Lisi’;</span><br></pre></td></tr></table></figure></li><li><p>3、删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.users.remove(&#123;age: <span class="number">132</span>&#125;);</span><br></pre></td></tr></table></figure></li><li><p>4、查询修改删除</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">db.users.findAndModify(&#123;</span><br><span class="line">    query: &#123;age: &#123;$gte: <span class="number">25</span>&#125;&#125;,</span><br><span class="line">    sort: &#123;age: <span class="number">-1</span>&#125;,</span><br><span class="line">    update: &#123;$set: &#123;name: <span class="string">'a2'</span>&#125;, $inc: &#123;age: <span class="number">2</span>&#125;&#125;,</span><br><span class="line">    remove: true</span><br><span class="line">&#125;);</span><br><span class="line">db.runCommand(&#123; findandmodify : <span class="string">"users"</span>,</span><br><span class="line">    query: &#123;age: &#123;$gte: <span class="number">25</span>&#125;&#125;,</span><br><span class="line">    sort: &#123;age: <span class="number">-1</span>&#125;,</span><br><span class="line">    update: &#123;$set: &#123;name: <span class="string">'a2'</span>&#125;, $inc: &#123;age: <span class="number">2</span>&#125;&#125;,</span><br><span class="line">    remove: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.html"/>
      <url>man/python/%E6%8A%80%E6%9C%AF%E7%82%B9/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>sys.argv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'参数个数为:'</span>, len(sys.argv), <span class="string">'个参数。'</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'参数列表:'</span>, str(sys.argv)</span><br></pre></td></tr></table></figure></li><li><p>getopt模块<br>getopt模块是专门处理命令行参数的模块，用于获取命令行选项和参数，也就是sys.argv。命令行选项使得程序的参数更加灵活。支持短选项模式（-）和长选项模式（–）。</p></li></ul><p>该模块提供了两个方法及一个异常处理来解析命令行参数。</p><ul><li>getopt.getopt(args, options[, long_options])<ul><li>args: 要解析的命令行参数列表。</li><li>options : 以字符串的格式定义，options 后的冒号 : 表示如果设置该选项，必须有附加的参数，否则就不附加参数。</li><li>long_options : 以列表的格式定义，long_options 后的等号 = 表示该选项必须有附加的参数，不带冒号表示该选项不附加参数。</li><li>该方法返回值由两个元素组成: 第一个是 (option, value) 元组的列表。 第二个是参数列表，包含那些没有 - 或 – 的参数。</li></ul></li></ul><ul><li>argparse</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/env/python python</span></span><br><span class="line"><span class="comment"># _*_ coding: utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create ArgumentParser() object</span></span><br><span class="line">parser = argparse.ArgumentParser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add argument</span></span><br><span class="line">parser.add_argument(<span class="string">'--train'</span>, required=<span class="literal">True</span>, help=<span class="string">'path to dataset'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--val'</span>, required=<span class="literal">True</span>, help=<span class="string">'path to dataset'</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--total'</span>, type=int, help=<span class="string">'number of dataset'</span>, default=<span class="number">100</span>)</span><br><span class="line">parser.add_argument(<span class="string">'--lr'</span>, type=float, default=<span class="number">0.01</span>, help=<span class="string">'learning rate'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print usage</span></span><br><span class="line">parser.print_help()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Parse argument</span></span><br><span class="line">args = parser.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Print args</span></span><br><span class="line"><span class="keyword">print</span> args</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> args.train</span><br><span class="line"><span class="keyword">print</span> type(args.train)</span><br><span class="line"><span class="keyword">print</span> args.val</span><br><span class="line"><span class="keyword">print</span> type(args.val)</span><br><span class="line"><span class="keyword">print</span> args.total</span><br><span class="line"><span class="keyword">print</span> type(args.total)</span><br><span class="line"><span class="keyword">print</span> args.lr</span><br><span class="line"><span class="keyword">print</span> type(args.lr)</span><br></pre></td></tr></table></figure><p>ArgumentParser类创建时的参数如下：</p><ul><li>prog - 程序的名字（默认：sys.argv[0]）</li><li>usage - 描述程序用法的字符串（默认：从解析器的参数生成）</li><li>description - 参数帮助信息之前的文本（默认：空）</li><li>epilog - 参数帮助信息之后的文本（默认：空）</li><li>parents - ArgumentParser 对象的一个列表，这些对象的参数应该包括进去</li><li>formatter_class - 定制化帮助信息的类</li><li>prefix_chars - 可选参数的前缀字符集（默认：‘-‘）</li><li>fromfile_prefix_chars - 额外的参数应该读取的文件的前缀字符集（默认：None）</li><li>argument_default - 参数的全局默认值（默认：None）</li><li>conflict_handler - 解决冲突的可选参数的策略（通常没有必要）</li><li>add_help - 给解析器添加-h/–help 选项（默认：True）</li></ul><p>add_argument函数的参数如下：</p><ul><li>name or flags - 选项字符串的名字或者列表，例如foo 或者-f, –foo。</li><li>action - 在命令行遇到该参数时采取的基本动作类型。</li><li>nargs - 应该读取的命令行参数数目。</li><li>const - 某些action和nargs选项要求的常数值。</li><li>default - 如果命令行中没有出现该参数时的默认值。</li><li>type - 命令行参数应该被转换成的类型。</li><li>choices - 参数可允许的值的一个容器。</li><li>required - 该命令行选项是否可以省略（只针对可选参数）。</li><li>help - 参数的简短描述。</li><li>metavar - 参数在帮助信息中的名字。</li><li>dest - 给parse_args()返回的对象要添加的属性名称。</li></ul><p>group功能</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/kudu/%E8%A1%8C%E4%B8%8E%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93.html"/>
      <url>man/storeage/kudu/%E8%A1%8C%E4%B8%8E%E5%88%97%E6%95%B0%E6%8D%AE%E5%BA%93.html</url>
      
        <content type="html"><![CDATA[<h1 id="行与列式数据库"><a href="#行与列式数据库" class="headerlink" title="行与列式数据库"></a>行与列式数据库</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2018-08-10 13:23:49</li></ul><p>[TOC]</p><blockquote><h2 id="0x00、简介"><a href="#0x00、简介" class="headerlink" title="0x00、简介"></a>0x00、简介</h2></blockquote><h4 id="1-行式数据库"><a href="#1-行式数据库" class="headerlink" title="1.行式数据库"></a>1.行式数据库</h4><ul><li>平常用的结构化关系型数据库，比如mysql、sqlserver等</li><li>一行为一条数据，进行记录存储</li><li>可以进行join查询，可以进行笛卡尔积运算</li></ul><h4 id="2-列式数据库"><a href="#2-列式数据库" class="headerlink" title="2.列式数据库"></a>2.列式数据库</h4><ul><li>列式数据库是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。</li><li>特点<ul><li>因为硬盘寻址时间相较于计算机上其他部件的运行速度来说不是一般的慢，所以常用相同工作负载下的硬盘访问性能来比较行数据库和列数据库。通常，顺序读取数据要比随机访问更快。而且，硬盘寻址时间的提升比起CPU速度的进步要慢得多 (参看 摩尔定律)，在使用硬盘作为存储媒介的系统上这种情况很可能还会持续一段时间。下面简单罗列了一些选择行数据库还是列数据库的权衡依据。当然，如果能够把数据全放在内存中，那么使用内存数据库性能会更好。<ul><li>1.在只需要根据某几列来聚合数据的时候按列的数据组织方式更有效。因为这样只需要读取一部分数据，要比读取全部数据更快。</li><li>2.当只需要修改某一列值的时候按列的数据组织方式更有效。因为可以直接找到某列数据并修改，而与行中的其他列无关。</li><li>3.当需要某行的多列数据的时候按行的数据组织方式更有效。当行中数据不是太多的情况下一次硬盘寻址就可以获得该行的所有数据。</li><li>4.在新增行数据的时候，如果各列都有值，那么按行的数据组织方式会更有效，因为只需要一次硬盘寻址就可以写入整行的全部数据。</li></ul></li></ul></li></ul><h4 id="3-应用"><a href="#3-应用" class="headerlink" title="3.应用"></a>3.应用</h4><ul><li>面向行的数据存储架构更适用于OLTP-频繁交互事务的场景。</li><li>面向列的数据存储架构更适用于OLAP-(如数据仓库)这样在海量数据（(可能达到 terabyte规模)）中进行有限复杂查询的场景。</li></ul><blockquote><h2 id="0x01、比较"><a href="#0x01、比较" class="headerlink" title="0x01、比较"></a>0x01、比较</h2></blockquote><p><img data-src="img/Yinxiang_2020050118:00:23.png" alt="Yinxiang_2020050118:00:23"><br><img data-src="img/Yinxiang_2020050118:00:23_6kg3hgid7.png" alt="Yinxiang_2020050118:00:23"></p><ul><li>底层存储实例<ul><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6186" alt="1e57e21ae055809aa9a55c8a7ad78ddf.jpeg"></li><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6187" alt="2bc661f551745f4525127a491b3d0f35.jpeg"></li><li><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p6188" alt="c9ffcb4fce02fac7511163425be27e38.jpeg"></li></ul></li><li>随机读与顺序读</li></ul><blockquote><h2 id="0x02、优缺点"><a href="#0x02、优缺点" class="headerlink" title="0x02、优缺点"></a>0x02、优缺点</h2></blockquote><h4 id="1-列数据库"><a href="#1-列数据库" class="headerlink" title="1.列数据库"></a>1.列数据库</h4><pre><code>- 优点：    * 极高的装载速度（最高可以等于所有硬盘IO 的总和，基本是极限了）    * 适合大量的数据而不是小数据    * 实时加载数据仅限于增加（删除和更新需要解压缩Block 然后计算然后重新压缩储存    * 高效的压缩率，不仅节省储存空间也节省计算内存和CPU。    * 非常适合做聚合操作。- 缺点：    * 不适合扫描小量数据    * 不适合随机的更新    * 批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。    * 不适合做含有删除和更新的实时操作</code></pre><h4 id="2-行数据库"><a href="#2-行数据库" class="headerlink" title="2.行数据库"></a>2.行数据库</h4><ul><li>优点<ul><li>适合频繁的增删改数据</li><li>小量数据的频繁维护和简单统计</li></ul></li><li>缺点<ul><li>不适合做统计类操作</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/php.html"/>
      <url>interview/%E5%BC%80%E5%8F%91%E8%AF%AD%E8%A8%80/php.html</url>
      
        <content type="html"><![CDATA[<ol><li>数组操作函数</li><li>字符串操作函数（数组和字符串的函数是最常问的，非常多，一定不要记混了）</li><li>指针和引用区别</li><li>堆和栈的区别</li><li>== ===区别</li><li>PHP的垃圾回收机制</li><li>zval结构</li><li>防sql注入</li><li>跨域问题</li><li>长链接和长轮询</li></ol><ul><li>1.php数组函数常见的那些?并说出使用方法 (array_merge、in_array的作用)<br>// 遍历数组<br>list();  //不是真正的函数，而是PHP的语言结构，用于给一组变量赋值，仅能用于索引数组<br>foreach();  //返回数组当前元素的键值对，并将指针移动到下一个元素位置<br>while(); //可配合list或each使用：while(list($key, $value) = each($arr)){each $key, $value; }<br>//数组内部指针控制<br>current();  //读取指针位置的内容<br>key();      //读取当前指针指向内容的索引值<br>next();     //将数组中的内部指针指向下一单元<br>prev();     //将数组内部指针倒回一位<br>end();      //将数组内部指针指向最后一个元素<br>reset();    //将目前指针指向第一个索引位置<br>//数组键值操作函数<br>array_values($arr);       //获得数组的值<br>array_keys($arr);         //获得数组的键名<br>array_flip($arr);         //数组中的值与键名互换（如果有重复前面的会被后面的覆盖）<br>array_search(‘PHP’,$arr); //检索给定的值，加true则是严格类型检查<br>array_reverse($arr);      //将数组中的元素翻转(前后顺序)<br>in_array(“apple”, $arr);  //在数组中检索apple<br>array_key_exists(“apple”, $arr); // 检索给定的键名是否存在数组中<br>array_count_values($arr);        // 统计数组中所有值出现的次数<br>array_unique($arr);              // 删除数组中重复的值<br>//数组回调函数<br>array_filter(); //使用回调函数过滤数组中的元素，如果回调返回true则当前的元素被包含到返回数组中<br>array_walk();   //回调函数处理数组，自定义函数要有两个参数，本函数第三个参数可以作为回调第三个参数返回<br>array_map();    //可以处理多个数组，每个数组的长度应该相同，传入数组的个数和回调函数参数个数应该一致<br>//数组的分段和填充<br>array_slice($arr, 0, 3);    //将数组中的一段取出，此函数忽略键名（数组的分段）<br>array_splice($arr, 0, 3，array(“black”,”maroon”));    //将数组中的一段取出，返回的序列从原数组中删除<br>array_chunk($arr, 3, TRUE);   //将一个数组分割成多个，TRUE为保留原数组的键名（分割多个数组）<br>//数组与栈，列队<br>array_push($arr, “apple”, “pear”);    //将一个或多个元素压入数组栈的末尾（入栈），返回入栈元素的个数<br>array_pop($arr);    // 将数组栈的最后一个元素弹出（出栈）<br>array_shift($arr);   //数组中第一个元素移出并返回（长度减1，其他元素向前移动一位，数字键名改为从零计数，文字键名不变）<br>array_unshift($arr,”a”,array(1,2));  //在数组的开头插入一个或多个元素<br>//数组的排序<br>sort($arr);      //由小到大，忽略键名<br>rsort($arr);     //由大到小，忽略键名<br>asort($arr);     //由小到大，保留键名<br>arsort($arr);    //由大到小，保留键名<br>ksort($arr);     //按照键名正序排序<br>krsort($arr);    //按照键名逆序排序<br>//数组的计算<br>array_sum($arr);   //对数组内部的所有元素做求和运算（数组元素的求和）<br>array_merge($arr1, $arr2); //合并两个或多个（相同字符串键名，后面覆盖前面，相同的数字键名，后面的附加到后面）<br>array_diff($arr1, $arr2);       //返回差集结果数组<br>array_diff_assoc($arr1, $arr2, $arr3);  //返回差集结果数组，键名也做比较<br>array_intersect($arr1, $arr2);  //返回交集结果数组<br>array_intersect_assoc($arr1, $arr2);   //返回交集结果数组，键名也做比较<br>//其他的数组函数<br>array_unique($arr);   //移除数组中重复的值，新的数组中会保留原始的键名<br>shuffle($arr);        // 将数组的顺序打乱</li><li>2.PHP中几个输出函数echo，print()，print_r()，sprintf()，var_dump()的区别<ul><li>echo：是语句不是函数，没有返回值，可输出多个变量值，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。</li><li>print：是语句不是函数，有返回值 1 ，只能输出一个变量，不需要圆括号。不能输出数组和对象，只能打印简单类型(如int,string)。</li><li>print_r：是函数，可以打印复合类型，例如：stirng、int、float、array、object等，输出array时会用结构表示，而且可以通过print_r($str,true)来使print_r不输出而返回print_r处理后的值</li><li>printf：是函数，有返回值，返回值是打印内容的长度，把文字格式化以后输出（参看C语言）</li><li>sprintf：是函数，跟printf相似，但不打印，而是返回格式化后的文字（该函数把格式化的字符串写写入一个变量中，而不是输出来），其    他的与printf一样。</li><li>var_dump()：函数，输出变量的内容、类型或字符串的内容、类型、长度。常用来调试。</li></ul></li><li>3.不用新变量直接交换现有两个变量的值<br>// 1<br>list($a, $b) = array($b, $a);<br>//2<br>$a = $a . $b;<br>$b = strlen( $b );<br>$b = substr( $a, 0, (strlen($a) – $b ) );<br>$a = substr( $a, strlen($b) );<br>//3<br>$a = $b.’,’.$a ;<br>$a = explode(‘,’, $a);<br>$b = $a[1];<br>$a = $a[0];<br>//这个是当两个数都是数字的时候:<br>$a = $a + $b;<br>$b = $a – $b;<br>$a = $a – $b;<br>//借助数组<br>$a = array($a,$b);<br>$b = $a[0];<br>$a = $a[1];</li><li>4.写个函数来解决多线程同时读写一个文件的问题。<br>&lt;?php<br>   $fp = fopen(“/tmp/lock.txt”,”w+”);<br>   if(flock($fp, LOCK_EX)){// 进行排它型锁定<pre><code>fwrite($fp,&quot;Write something here\n&quot;);flock($fp, LOCK_UN);// 释放锁定</code></pre>   }else{<pre><code>echo &quot;Couldn&apos;t lock the file !&quot;;</code></pre>   }<br>   fclose($fp);</li><li>5.禁掉cookie的session使用方案，设置session过期的方法，对应函数<ul><li>通过 url 传值，把session id附加到url上（缺点：整个站点中不能有纯静态页面，因为纯静态页面session id 将无法继续传到下一页面）</li><li>通过隐藏表单，把session id 放到表单的隐藏文本框中同表单一块提交过去（缺点：不适用<a>标签这种直接跳转的非表单的情况）</li><li>直接配置php.ini文件,将php.ini文件里的session.use_trans_sid= 0设为1,（好像在win上不支持）</li><li>用文件、数据库等形式保存Session ID，在跨页过程中手动调用<br>//第一种  setcookie() 直接用setcookie设置session id的生命周期。<br>$lifetime=60; //保存1分钟<br>session_start();<br>setcookie(session_name(), session_id(), time()+$lifetime, “/“);<br>//第二种  session_set_cookie_params()<br>$lifetime=60;//保存1分钟<br>session_set_cookie_params($lifetime);<br>session_start();<br>session_regenerate_id(true);<br>//其中session_regenerate_id();方法用于改变当前session_id的值，并保留session中数组的值。参数默认为 false,如果设置为true则改变session_id的值，并清空当前session数组。</li></ul></li><li>6.php获取文件内容的方法，对应的函数<ul><li>file_get_contents得到文件的内容（可以以get和post的方式获取），整个文件读入一个字符串中</li><li>用fopen打开url, 以get方式获取内容（借助fgets()函数）</li><li>用fsockopen函数打开url（可以以get和post的方式获取），以get方式获取完整的数据，包括header和body</li><li>使用curl库获取内容，使用curl库之前，需要查看php.ini，查看是否已经打开了curl扩展</li></ul></li><li>7.php魔术方法与魔术常量<ul><li>类方法：<ul><li>1、__construct();<ul><li>说明：具有构造函数的类会在每次创建新对象时先调用此方法，适合在使用对象之前做一些初始化工作。如果子类中定义了构造函数则不会隐式调用其父类的构造函数。要执行父类的构造函数，需要在子类的构造函数中调用 parent::__construct()。如果子类没有定义构造函数则会如同一个普通的类方法一样从父类继承。</li></ul></li><li>2、__destruct();<ul><li>说明：析构函数会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行。</li></ul></li></ul></li><li>方法重载：<ul><li>3、__call();<ul><li>说明：在对象中调用一个不可访问方法时，__call(); 方法会被调用。</li></ul></li><li>4、__callStatic();<ul><li>说明：用静态方式中调用一个不可访问方法时，__callStatic(); 方法会被调用。</li></ul></li></ul></li><li>属性重载：(只对类中私有受保护的成员属性有效)<ul><li>5、__get();<ul><li>说明：读取不可访问属性的值时，__get() 会被调用。</li></ul></li><li>6、__set();<ul><li>说明：在给不可访问属性赋值时，__set() 会被调用。</li></ul></li><li>7、__isset();<ul><li>说明：当对不可访问属性调用 isset() 或 empty() 时，__isset() 会被调用。</li></ul></li><li>8、__unset();<ul><li>说明：当对不可访问属性调用 unset() 时，__unset() 会被调用。</li></ul></li></ul></li><li>序列化相关：<ul><li>9、__sleep();<ul><li>说明：序列化时调用，serialize() 函数会检查类中是否存在该魔术方法。如果存在，该方法会先被调用，然后才执行序列化操作。</li></ul></li><li>10、__wakeup();<ul><li>说明：unserialize() 会检查是否存在一个 __wakeup() 方法。如果存在，则会先调用该方法，用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作</li></ul></li></ul></li><li>操作类和对象方法：<ul><li>11、__toString();<ul><li>说明：方法用于一个类被当成字符串时调用，例如把一个类当做字符串进行输出</li></ul></li><li>12、__invoke()；<ul><li>说明：当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。</li></ul></li><li>13、__set_state()；<ul><li>说明：当调用 var_export() 导出类时，此静态 方法会被调用。 本方法的唯一参数是一个数组</li></ul></li><li>14、__clone();<ul><li>说明：当复制完成时，如果定义了 __clone() 方法，则新创建的对象（复制生成的对象）中的 __clone() 方法会被调用，可用于修改属性的值。</li></ul></li><li>15、__autoload();<ul><li>说明：该方法可以自动实例化需要的类。当程序要用一个类但没有被实例化时，改方法在指定路径下查找和该类名称相同的文件。否则报错。</li></ul></li><li>16 __debugInfo();<ul><li>说明：php5.6增加的特性，var_dump()一个类时触发，返回一个包含对象属性的数组</li></ul></li></ul></li><li>常量：<ul><li><strong>LINK</strong>      //文件中的当前行号。</li><li><strong>FILE</strong>       //文件的完整路径和文件名。如果用在被包含文件中，则返回被包含的文件名。</li><li><strong>DIR</strong>       //文件所在的目录。如果用在被包括文件中，则返回被包括的文件所在的目录，它等价于 dirname(<strong>FILE</strong>)。</li><li><strong>FUNCTION</strong>       //函数名称。自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</li><li><strong>CLASS</strong>              //类的名称。自 PHP 5 起本常量返回该类被定义时的名字（区分大小写）。在 PHP 4 中该值总是小写字母的。</li><li><strong>METHOD</strong>         //类的方法名（PHP 5.0.0 新加）。返回该方法被定义时的名字（区分大小写）。</li><li><strong>NAMESPACE</strong>   //当前命名空间的名称（大小写敏感）。这个常量是在编译时定义的（PHP 5.3.0 新增)</li></ul></li></ul></li><li>8.PHP 如何获取客户端的IP地址<ul><li>用$_SERVER获取的IP地址有什么问题？</li><li>$_SERVER[‘REMOTE_ADDR’] ;   通过全局数组来获得</li><li>getenv(‘REMOTE_ADDR’) ; 通过环境变量来获得</li><li>当客户机使用代理的时候获取不到真实的IP地址</li></ul></li><li>9.写一个函数，可以遍历文件夹下的所有文件和文件夹。<br>function get_dir_info($path){<br> $handle = opendir($path);//打开目录返回句柄<br> while(($content = readdir($handle))!== false){<pre><code>$new_dir = $path . DIRECTORY_SEPARATOR . $content;if($content == &apos;..&apos; || $content == &apos;.&apos;){   continue;}if(is_dir($new_dir)){    echo “</code></pre>目录：”.$new_dir . ‘<br>‘;<pre><code>    get_dir_info($new_dir);}else{    echo &quot;文件：&quot;.$path.&apos;:&apos;.$content .&apos;&apos;;}</code></pre> }<br>}<br>get_dir_info($dir);</li><li>10.PHP缓存技术有哪些?<ul><li>全页面静态化缓存，也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程</li><li>页面部分缓存，将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示</li><li>数据缓存，通过一个id进行请求的数据,将数据缓存到一个php文件中,id和文件是对应的,下次通过这个id进行请求时 直接读php文件</li><li>查询缓存，和数据缓存差不多,根据查询语句进行缓存;</li><li>常用的缓存技术有：redis和memcache</li></ul></li><li>11.strlen()与mb_strlen的作用与区别<ul><li>在PHP中，strlen与mb_strlen是求字符串长度的函数</li><li>PHP内置的字符串长度函数strlen无法正确处理中文字符串，它得到的只是字符串所占的字节数。对于GB2312的中文编码，strlen得到的值是汉字个数的2倍，而对于UTF-8编码的中文，就是3倍（在 UTF-8编码下，一个汉字占3个字节）。</li><li>采用mb_strlen函数可以较好地解决这个问题。mb_strlen的用法和strlen类似，只不过它有第二个可选参数用于指定字符编码。例如得到UTF-8的字符串</li><li>str长度，可以用mbstrlen(str,’UTF-8’)。如果省略第二个参数，则会使用PHP的内部编码。内部编码可以通过 mb_internal_encoding()函数得到。</li><li>需要注意的是，mb_strlen并不是PHP核心函数，使用前需要确保在php.ini中加载了php_mbstring.dll，即保“extension=php_mbstring.dll”这一行存在并且没有被注释掉，否则会出现未定义函 数的问题。</li></ul></li><li>12.写一个函数，尽可能高效的从一个标准url中取出扩展名<br>$arr = parse_url(‘<a href="http://www.sina.com.cn/abc/de/fg.php?id=1&#39;" target="_blank" rel="noopener">http://www.sina.com.cn/abc/de/fg.php?id=1&#39;</a>);<br>result=pathinfo(arr[‘path’]);<br>var_dump($arr);<br>var_dump($result[‘extension’]);</li><li>13.php.ini 中safe mod关闭 影响哪些函数和参数，至少写6个？<br>move_uploaded_file()     exec()    system()   passthru()   popen()   fopen()  mkdir()    rmdir()  rename()                     unlink()  copy()      chgrp()    chown()   chmod()     touch()  symlink()    link()  parse_ini_file()<br>set_time_limit()  max_execution_time mail()</li><li>14.isset() 、empty()与is_null的区别<ul><li>当变量未定义时，is_null() 和“参数本身”是不允许作为参数判断的，会报Notice警告错误；</li><li>empty , isset首先都会检查变量是否存在，然后对变量值进行检测。而is_null 和 “参数本身”只是直接检查变量值，是否为null，因此如果变量未定义就会出现错误！</li><li>isset()：仅当null和未定义，返回false；</li><li>empty()：””、0、”0”、NULL、FALSE、array(),未定义，均返回true；</li><li>is_null()：仅判断是否为null，未定义报警告；</li><li>变量本身作为参数，与empty()一致，但接受未定义变量时，报警告；</li></ul></li><li>15.MVC是什么，有什么优缺点<ul><li>MVC的优点<ul><li>（1） 可以为一个模型在运行时同时建立和使用多个视图。变化-传播机制可以确保所有相关的视图及时得到模型数据变化，从而使所有关联的视图和控制器做到行为</li><li>（2） 视图与控制器的可接插性，允许更换视图和控制器对象，而且可以根据需求动态的打开或关闭、甚至在运行期间进行对象</li><li>（3） 模型的可移植性。因为模型是独立于视图的，所以可以把一个模型独立地移植到新的平台工作。需要做的只是在新平台上对视图和控制器进行新的</li><li>（4） 潜在的框架结构。可以基于此模型建立应用程序框架，不仅仅是用在设计界面的设计中。</li></ul></li><li>2、 MVC的不足之<ul><li>（1） 增加了系统结构和实现的复杂性。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行</li><li>（2） 视图与控制器间的过于紧密的连接。视图与控制器是相互分离，但确实联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用。</li><li>（3） 视图对模型数据的低效率访问。依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能。</li><li>（4） 目前，一般高级的界面工具或构造器不支持MVC模式。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。</li></ul></li></ul></li><li>16.session与cookie的联系和区别（运行机制），session共享问题解决方案<ul><li>区别与联系：<ul><li>使用session_start()调用session，服务器端在生成session文件的同时生成session ID哈希值和默认值为PHPSESSID的session name，并向客户端发送变量为PHPSESSID(session name)(默认)值为一个128位的哈希值。服务器端将通过该cookie与客户端进行交互，session变量的值经php内部系列化后保存在服务器 机器上的文本文件中，和客户端的变量名默认情况下为PHPSESSID的coolie进行对应交互，即服务器自动发送了http 头:header(‘Set-Cookie: session_name()=session_id(); path=/’);即setcookie(session_name(),session_id());当从该页跳转到的新页面并调用 session_start()后,PHP将检查与给定ID相关联的服务器端存贮的session数据，如果没找到则新建一个数据集。</li></ul></li><li>共享方案：<ul><li>使用数据库保存session， 使用数据库来保存session，就算服务器宕机了也没事，session照样在。<ul><li>问题：程序需要定制；每次请求都进行数据库读写开销不小，另外数据库是一个单点，可以做数据库的hash来解 决这个问题。</li></ul></li><li>使用 memcached来保存session， 这种方式跟数据库类似，内存存取性能比数据库好很多。<ul><li>问题：程序需要定制，增加 了工作量；存入memcached中的数据都需要序列化，效率较低，断电或者重启电脑容易丢失数据；</li></ul></li><li>通过加密的cookie，在A服务器上登录，在用户的浏览器上添加加密的cookie，当用户访问B服务器时，检查有无Session，如果没有，就检验 Cookie是否有效，Cookie有效的话就在B服务器上重建session。简单，高效， 服务器的压力减小了，因为session数据不存在服务器磁盘上。根本就不会出现session读取不到的问题。</li><li>问题：网络请求占用很多。每次请求时，客户端都要通过cookie发送session数据给服务器，session中数据不能太多，浏览器对cookie 的大</li><li>小存在限制。不适合高访问量的情况，因为高访问量的情况下。</li></ul></li></ul></li><li>17.PHP支持多继承吗？为什么？<ul><li>不支持。PHP类只能继承一个父类，并用关键字“extended”标识。</li></ul></li><li>18.include和require 分别返回什么错误级别<ul><li>include会系统警告并继续执行</li><li>require会发出系统警告但是会引致致命错误令脚本终止运行</li></ul></li><li>19.防sql注入方法<br>function post_check($post){<br>if(!get_magic_quotes_gpc()){//  判断magic_quotes_gpc是否为打开<pre><code>$post = addslashes($post);//  进行magic_quotes_gpc没有打开的情况对提交数据的过滤</code></pre>}<br>$post = str_replace(“<em>“,”\</em>“,  $post);// 把 ‘_’过滤掉<br>$post = str_replace(“%”,”%“,  $post);// 把 ‘%’过滤掉<br>$post = nl2br($post);//  回车转换<br>$post = htmlspecialchars($post);//  html标记转换<br>return $post;<br>}</li><li><ol start="20"><li>php连接mysql数据库的几种方式及区别<ul><li>mysql:面向过程</li><li>mysqli:面向对象</li><li>pdo:可移植性高</li></ul></li></ol></li></ul><ul><li>1.php数组函数常见的那些?并说出使用方法 (array_merge、in_array的作用)</li><li>2.PHP中几个输出函数echo，print()，print_r()，sprintf()，var_dump()的区别</li><li>3.不用新变量直接交换现有两个变量的值</li><li>4.写个函数来解决多线程同时读写一个文件的问题。</li><li>5.禁掉cookie的session使用方案，设置session过期的方法，对应函数</li><li>6.php获取文件内容的方法，对应的函数</li><li>7.php魔术方法与魔术常量</li><li>8.PHP 如何获取客户端的IP地址</li><li>9.写一个函数，可以遍历文件夹下的所有文件和文件夹。</li><li>10.PHP缓存技术有哪些?</li><li>11.strlen()与mb_strlen的作用与区别</li><li>12.写一个函数，尽可能高效的从一个标准url中取出扩展名</li><li>13.php.ini 中safe mod关闭 影响哪些函数和参数，至少写6个？</li><li>14.isset() 、empty()与is_null的区别</li><li>15.MVC是什么，有什么优缺点</li><li>16.session与cookie的联系和区别（运行机制），session共享问题解决方案</li><li>17.PHP支持多继承吗？为什么？</li><li>18.include和require 分别返回什么错误级别</li><li>19.防sql注入方法</li><li><ol start="20"><li>php连接mysql数据库的几种方式及区别</li></ol></li><li><ul><li>3.场景公司表和投资事件表同步轮次方法：如果投资事件的轮次大与公司轮次也修改公司轮次，否则不修改</li></ul></li><li><ul><li>4.数据版本化</li></ul></li><li><ul><li>5.php空对象在json_encode和json_decode之后会称为空数组</li></ul></li><li><ul><li>6.foreach循环不会修改数组的值，只有加&amp;符才会同步修改</li></ul></li><li><ul><li>7.cookie和session的区别，post和get区别</li></ul></li><li><ul><li>8.设置或生成cookie的方法有几种，cookie的参数有几个，分别是什么</li></ul></li><li><ul><li>9.Php里魔术方法有哪些，分别作用是什么</li></ul></li><li><ul><li>写一个函数把一个数组进行倒序排列</li></ul></li><li><ul><li>Php里的数组是如何实现的？</li></ul></li><li><ul><li>把一个二叉树按行输出</li></ul></li><li><ul><li>Php如何发送一个请求</li></ul></li><li><ul><li>Php如何发送头请求</li></ul></li><li><ul><li>如何修改或配置虚拟ip</li></ul></li><li><ul><li>请求返回的状态码代表什么意义？（301.302.401，501等）</li></ul></li><li><ul><li>如何防止攻击，例如用ajax提交如何保证其安全性</li></ul></li><li><ul><li>Linux下查看磁盘的命令</li></ul></li><li><ul><li>df -h</li></ul></li><li><ul><li>du -sh *</li></ul></li><li><ul><li>Php里的use是干什么的</li></ul></li><li><ul><li>Php写出一个单例模型</li></ul></li><li><ul><li>数据库优化，需要注意些什么</li></ul></li><li><ul><li>大流量网站优化</li></ul></li><li><ul><li>书写匹配url正则表达式</li></ul></li><li><ul><li>冒泡排序或二分查找</li></ul></li><li><ul><li>数据库存储引擎有哪些，各有什么特点</li></ul></li><li><ul><li>数据库三范式是什么，实际使用是什么场景</li></ul></li><li><ul><li>GD库是什么，可以做什么</li></ul></li><li><ul><li>时间函数获取，获得前一天的时间，获取两个时间差</li></ul></li><li><ul><li>php扩展使用过哪些？各有什么特点</li></ul></li><li><ul><li>大表如何拆分</li></ul></li><li><ul><li>如何预防sql注入、xss攻击</li></ul></li><li><ul><li>error_report()是做什么的</li></ul></li><li><ul><li>写一个求阶乘函数</li></ul></li><li><ul><li>在js中.和#的区别</li></ul></li><li><ul><li>html中position是做什么的</li></ul></li><li><ul><li>如何防止中文乱码</li></ul></li><li><ul><li>linux常用命令有哪些，都是做什么的</li></ul></li><li><ul><li>数据库缓存如何做，redis，memcache等</li></ul></li><li><ul><li>char和varchar有什么区别，用哪种字段查询效率更高，为什么</li></ul></li><li><ul><li>POP3、SMTP、HTTP、DNS、FTP都是什么</li></ul></li><li><ul><li>对于MVC的理解</li></ul></li><li><ul><li>print，echo，print_r有什么区别</li></ul></li><li><ul><li>如何学习积累知识的，未来几年的职业规划</li></ul></li><li><ul><li>用过的版本控制器有哪些，有哪些命令</li></ul></li><li><ul><li>封装，继承，多态是什么</li></ul></li><li><ul><li>静态方法是否可以继承</li></ul></li><li><ul><li>框架路由机制什么</li></ul></li><li><ul><li>进程状态</li></ul></li><li><ul><li>谈谈自己最有代表性的一个项目，遇到哪些问题，以及如何解决的</li></ul></li><li><ul><li>如何捕获异常</li></ul></li><li><ul><li>如何控制发布后代码错误不被抛出</li></ul></li><li><ul><li>生成环境和开发环境有什么不同</li></ul></li><li><ul><li>一个错误码不想被抛出，而是可以拦截并且做邮件或短信通知</li></ul></li><li><ul><li>如何获取3.1415926这个浮点型的前三位</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark.html"/>
      <url>interview/%E5%A4%A7%E6%95%B0%E6%8D%AE/spark.html</url>
      
        <content type="html"><![CDATA[<ul><li>Spark 算子有哪些，项目用到哪些算子<br>  *</li><li>Spark 广播变量<br>  *</li><li>Spark内存溢出<br>  *</li><li>Spark OOM问题解决办法<br>  *</li><li>Spark 任务执行速度倾斜问题解决方案<br>  *</li><li>Spark与Hadoop MapReduce的异同<ul><li>首先Spark是借鉴了mapreduce并在其基础上发展起来的，继承了其分布式计算的优点并改进了mapreduce明显的缺陷，但是二者也有不少的差异具体如下：<ul><li>1、spark把运算的中间数据存放在内存，迭代计算效率更高；mapreduce的中间结果需要落地，需要保存到磁盘，这样必然会有磁盘io操做，影响性能。</li><li>2、spark容错性高，它通过弹性分布式数据集RDD来实现高效容错，RDD是一组分布式的存储在节点内存中的只读性质的数据集，这些集合是弹性的，某一部分丢失或者出错，可以通过整个数据集的计算流程的血缘关系来实现重建；mapreduce的话容错可能只能重新计算了，成本较高。</li><li>3、spark更加通用，spark提供了transformation和action这两大类的多个功能api，另外还有流式处理sparkstreaming模块、图计算GraphX等等；mapreduce只提供了map和reduce两种操作，流计算以及其他模块的支持比较缺乏。</li><li>4、spark框架和生态更为复杂，首先有RDD、血缘lineage、执行时的有向无环图DAG、stage划分等等，</li><li>很多时候spark作业都需要根据不同业务场景的需要进行调优已达到性能要求；mapreduce框架及其生态相对较为简单，对性能的要求也相对较弱，但是运行较为稳定，适合长期后台运行。</li></ul></li><li>最后总结：<ul><li>spark生态更为丰富，功能更为强大、性能更佳，适用范围更广；mapreduce更简单、稳定性好、适合离线海量数据挖掘计算。</li></ul></li></ul></li><li>Spark streaming的数据来源<br>  *</li><li>Spark与hadoop的shuffle有何异同<br>  *</li><li>Spark RDD操作map与flatmap的区别<ul><li>map：对RDD每个元素转换，文件中的每一行数据返回一个数组对象</li><li>flatMap：对RDD每个元素转换，然后再扁平化将所有的对象合并为一个对象，文件中的所有行数据仅返回一个数组对象，会抛弃值为null的值</li></ul></li><li>Spark  RDD的理解<br>  *</li><li>Spark 有哪些算子<br>  *</li><li>Spark 的stage的理解<br>  *</li><li>Spark 宽依赖和窄依赖<br>  *</li><li>Sparkcore 的广播变量<br>  *</li><li>Spark 累加变量<br>  *</li><li>Spark 二次排序<br>  *</li><li>Spark reduceByKey和groupByKey区别<br>  *</li><li>为什么要进行序列化<ul><li>序列化可以减少数据的体积，减少存储空间，高效存储和传输数据，不好的是使用的时候要反序列化，非常消耗CPU</li></ul></li><li>介绍一下join操作优化经验？<ul><li>join其实常见的就分为两类： map-side join 和  reduce-side join。当大表和小表join时，用map-side join能显著提高效率。将多份数据进行关联是数据处理过程中非常普遍的用法，不过在分布式计算系统中，这个问题往往会变的非常麻烦，因为框架提供的 join 操作一般会将所有数据根据 key 发送到所有的 reduce 分区中去，也就是 shuffle 的过程。造成大量的网络以及磁盘IO消耗，运行效率极其低下，这个过程一般被称为 reduce-side-join。如果其中有张表较小的话，我们则可以自己实现在 map 端实现数据关联，跳过大量数据进行 shuffle 的过程，运行时间得到大量缩短，根据不同数据可能会有几倍到数十倍的性能提升。</li><li>备注：这个题目面试中非常非常大概率见到，务必搜索相关资料掌握，这里抛砖引玉。</li></ul></li><li>collect功能是什么，其底层是怎么实现的？<ul><li>driver通过collect把集群中各个节点的内容收集过来汇总成结果，collect返回结果是Array类型的，collect把各个节点上的数据抓过来，抓过来数据是Array型，collect对Array抓过来的结果进行合并，合并后Array中只有一个元素，是tuple类型（KV类型的）的。</li></ul></li><li>rdd有几种操作类型？<ul><li>1）transformation，rdd由一种转为另一种rdd</li><li>2）action，</li><li>3）cronroller，crontroller是控制算子,cache,persist，对性能和效率的有很好的支持</li></ul></li><li>RDD创建有哪几种方式？<ul><li>1).使用程序中的集合创建rdd</li><li>2).使用本地文件系统创建rdd</li><li>3).使用hdfs创建rdd，</li><li>4).基于数据库db创建rdd</li><li>5).基于Nosql创建rdd，如hbase</li><li>6).基于s3创建rdd，</li><li>7).基于数据流，如socket创建rdd</li></ul></li><li>RDD有哪些缺陷？<ul><li>1）不支持细粒度的写和更新操作（如网络爬虫），spark写数据是粗粒度的所谓粗粒度，就是批量写入数据，为了提高效率。但是读数据是细粒度的也就是说可以一条条的读</li><li>2）不支持增量迭代计算，Flink支持</li></ul></li><li>RDD的弹性表现在哪几点？<ul><li>1）自动的进行内存和磁盘的存储切换；</li><li>2）基于Lingage的高效容错；</li><li>3）task如果失败会自动进行特定次数的重试；</li><li>4）stage如果失败会自动进行特定次数的重试，而且只会计算失败的分片；</li><li>5）checkpoint和persist，数据计算之后持久化缓存</li><li>6）数据调度弹性，DAG TASK调度和资源无关</li><li>7）数据分片的高度弹性，a.分片很多碎片可以合并成大的，b.par</li></ul></li><li>对于Spark中的数据倾斜问题你有什么好的方案？<ul><li>1前提是定位数据倾斜，是OOM了，还是任务执行缓慢，看日志，看WebUI</li><li>2解决方法，有多个方面<ul><li>避免不必要的shuffle，如使用广播小表的方式，将reduce-side-join提升为map-side-join</li><li>分拆发生数据倾斜的记录，分成几个部分进行，然后合并join后的结果</li><li>改变并行度，可能并行度太少了，导致个别task数据压力大</li><li>两阶段聚合，先局部聚合，再全局聚合</li><li>自定义paritioner，分散key的分布，使其更加均匀</li><li>详细解决方案参考博文《Spark数据倾斜优化方法》</li></ul></li></ul></li><li>你所理解的Spark的shuffle过程？<ul><li>1）shuffle过程的划分</li><li>2）shuffle的中间结果如何存储</li><li>3）shuffle的数据如何拉取过来</li><li>可以参考这篇博文：<a href="http://www.cnblogs.com/jxhd1/p/6528540.html" target="_blank" rel="noopener">http://www.cnblogs.com/jxhd1/p/6528540.html</a></li></ul></li><li>spark的有几种部署模式，每种模式特点？<ul><li>1）本地模式Spark不一定非要跑在hadoop集群，可以在本地，起多个线程的方式来指定。将Spark应用以多线程的方式直接运行在本地，一般都是为了方便调试，本地模式分三类<ul><li>local：只启动一个executor</li><li>local[k]:启动k个executor</li><li>local启动跟cpu数目相同的 executor</li></ul></li><li>2)standalone模式<ul><li>分布式部署集群， 自带完整的服务，资源管理和任务监控是Spark自己监控，这个模式也是其他模式的基础，</li></ul></li><li>3)Spark on yarn模式<ul><li>分布式部署集群，资源和任务监控交给yarn管理，但是目前仅支持粗粒度资源分配方式，包含cluster和client运行模式，cluster适合生产，driver运行在集群子节点，具有容错功能，client适合调试，dirver运行在客户端</li></ul></li><li>4）Spark On Mesos模式。官方推荐这种模式（当然，原因之一是血缘关系）。正是由于Spark开发之初就考虑到支持Mesos，因此，目前而言，Spark运行在Mesos上会比运行在YARN上更加灵活，更加自然。用户可选择两种调度模式之一运行自己的应用程序：<ul><li>1)   粗粒度模式（Coarse-grained Mode）：每个应用程序的运行环境由一个Dirver和若干个Executor组成，其中，每个Executor占用若干资源，内部可运行多个Task（对应多少个“slot”）。应用程序的各个任务正式运行之前，需要将运行环境中的资源全部申请好，且运行过程中要一直占用这些资源，即使不用，最后程序运行结束后，回收这些资源。</li><li>2)   细粒度模式（Fine-grained Mode）：鉴于粗粒度模式会造成大量资源浪费，Spark On Mesos还提供了另外一种调度模式：细粒度模式，这种模式类似于现在的云计算，思想是按需分配。</li></ul></li></ul></li><li>Spark技术栈有哪些组件，每个组件都有什么功能，适合什么应用场景？<ul><li>可以画一个这样的技术栈图先，然后分别解释下每个组件的功能和场景</li><li>1）Spark core：是其它组件的基础，spark的内核，主要包含：有向循环图、RDD、Lingage、Cache、broadcast等，并封装了底层通讯框架，是Spark的基础。</li><li>2）SparkStreaming是一个对实时数据流进行高通量、容错处理的流式处理系统，可以对多种数据源（如Kdfka、Flume、Twitter、Zero和TCP 套接字）进行类似Map、Reduce和Join等复杂操作，将流式计算分解成一系列短小的批处理作业。</li><li>3）Spark sql：Shark是SparkSQL的前身，Spark SQL的一个重要特点是其能够统一处理关系表和RDD，使得开发人员可以轻松地使用SQL命令进行外部查询，同时进行更复杂的数据分析</li><li>4）BlinkDB ：是一个用于在海量数据上运行交互式 SQL 查询的大规模并行查询引擎，它允许用户通过权衡数据精度来提升查询响应时间，其数据的精度被控制在允许的误差范围内。</li><li>5）MLBase是Spark生态圈的一部分专注于机器学习，让机器学习的门槛更低，让一些可能并不了解机器学习的用户也能方便地使用MLbase。MLBase分为四部分：MLlib、MLI、ML Optimizer和MLRuntime。</li><li>6）GraphX是Spark中用于图和图并行计算</li></ul></li><li>Spark中Work的主要工作是什么？<ul><li>主要功能：管理当前节点内存，CPU的使用状况，接收master分配过来的资源指令，通过ExecutorRunner启动程序分配任务，worker就类似于包工头，管理分配新进程，做计算的服务，相当于process服务。</li><li>需要注意的是：1）worker会不会汇报当前信息给master，worker心跳给master主要只有workid，它不会发送资源信息以心跳的方式给mater，master分配的时候就知道work，只有出现故障的时候才会发送资源。</li><li>2）worker不会运行代码，具体运行的是Executor是可以运行具体appliaction写的业务逻辑代码，操作代码的节点，它不会运行程序的代码的。</li></ul></li><li>Spark为什么比mapreduce快？<ul><li>1）基于内存计算，减少低效的磁盘交互；</li><li>2）高效的调度算法，基于DAG；</li><li>3)容错机制Linage，精华部分就是DAG和Lingae</li></ul></li><li>简单说一下hadoop和spark的shuffle相同和差异？<ul><li>1）从 high-level 的角度来看，两者并没有大的差别。 都是将 mapper（Spark 里是 ShuffleMapTask）的输出进行 partition，不同的 partition 送到不同的 reducer（Spark 里 reducer 可能是下一个 stage 里的 ShuffleMapTask，也可能是 ResultTask）。Reducer 以内存作缓冲区，边 shuffle 边 aggregate 数据，等到数据 aggregate 好以后进行 reduce() （Spark 里可能是后续的一系列操作）。</li><li>2）从 low-level 的角度来看，两者差别不小。 Hadoop MapReduce 是 sort-based，进入 combine() 和 reduce() 的 records 必须先 sort。这样的好处在于 combine/reduce() 可以处理大规模的数据，因为其输入数据可以通过外排得到（mapper 对每段数据先做排序，reducer 的 shuffle 对排好序的每段数据做归并）。目前的 Spark 默认选择的是 hash-based，通常使用 HashMap 来对 shuffle 来的数据进行 aggregate，不会对数据进行提前排序。如果用户需要经过排序的数据，那么需要自己调用类似 sortByKey() 的操作；如果你是Spark 1.1的用户，可以将spark.shuffle.manager设置为sort，则会对数据进行排序。在Spark 1.2中，sort将作为默认的Shuffle实现。</li><li>3）从实现角度来看，两者也有不少差别。 Hadoop MapReduce 将处理流程划分出明显的几个阶段：map(), spill, merge, shuffle, sort, reduce() 等。每个阶段各司其职，可以按照过程式的编程思想来逐一实现每个阶段的功能。在 Spark 中，没有这样功能明确的阶段，只有不同的 stage 和一系列的 transformation()，所以 spill, merge, aggregate 等操作需要蕴含在 transformation() 中。</li><li>如果我们将 map 端划分数据、持久化数据的过程称为 shuffle write，而将 reducer 读入数据、aggregate 数据的过程称为 shuffle read。那么在 Spark 中，问题就变为怎么在 job 的逻辑或者物理执行图中加入 shuffle write 和 shuffle read 的处理逻辑？以及两个处理逻辑应该怎么高效实现？</li><li>Shuffle write由于不要求数据有序，shuffle write 的任务很简单：将数据 partition 好，并持久化。之所以要持久化，一方面是要减少内存存储空间压力，另一方面也是为了 fault-tolerance。</li></ul></li><li>Mapreduce和Spark的都是并行计算，那么他们有什么相同和区别<ul><li>两者都是用mr模型来进行并行计算:</li><li>1)hadoop的一个作业称为job，job里面分为map task和reduce task，每个task都是在自己的进程中运行的，当task结束时，进程也会结束。</li><li>2)spark用户提交的任务成为application，一个application对应一个sparkcontext，app中存在多个job，每触发一次action操作就会产生一个job。这些job可以并行或串行执行，每个job中有多个stage，stage是shuffle过程中DAGSchaduler通过RDD之间的依赖关系划分job而来的，每个stage里面有多个task，组成taskset有TaskSchaduler分发到各个executor中执行，executor的生命周期是和app一样的，即使没有job运行也是存在的，所以task可以快速启动读取内存进行计算。</li><li>3)hadoop的job只有map和reduce操作，表达能力比较欠缺而且在mr过程中会重复的读写hdfs，造成大量的io操作，多个job需要自己管理关系。spark的迭代计算都是在内存中进行的，API中提供了大量的RDD操作如join，groupby等，而且通过DAG图可以实现良好的容错。</li></ul></li><li>spark有哪些组件？<ul><li>1）master：管理集群和节点，不参与计算。</li><li>2）worker：计算节点，进程本身不参与计算，和master汇报。</li><li>3）Driver：运行程序的main方法，创建spark context对象。</li><li>4）spark context：控制整个application的生命周期，包括dagsheduler和task scheduler等组件。</li><li>5）client：用户提交程序的入口。</li></ul></li><li>spark工作机制？<ul><li>用户在client端提交作业后，会由Driver运行main方法并创建spark context上下文。</li><li>执行add算子，形成dag图输入dagscheduler，按照add之间的依赖关系划分stage输入task scheduler。 task scheduler会将stage划分为task set分发到各个节点的executor中执行。</li></ul></li><li>spark的优化怎么做？<ul><li>spark调优比较复杂，但是大体可以分为三个方面来进行，</li><li>1）平台层面的调优：防止不必要的jar包分发，提高数据的本地性，选择高效的存储格式如parquet，</li><li>2）应用程序层面的调优：过滤操作符的优化降低过多小任务，降低单条记录的资源开销，处理数据倾斜，复用RDD进行缓存，作业并行化执行等等，</li><li>3）JVM层面的调优：设置合适的资源量，设置合理的JVM，启用高效的序列化方法如kyro，增大off head内存等等</li></ul></li><li>简要描述Spark分布式集群搭建的步骤<ul><li>1）准备linux环境，设置集群搭建账号和用户组，设置ssh，关闭防火墙，关闭seLinux，配置host，hostname</li><li>2）配置jdk到环境变量</li><li>3）搭建hadoop集群，如果要做master ha，需要搭建zookeeper集群修改hdfs-site.xml,hadoop_env.sh,yarn-site.xml,slaves等配置文件</li><li>4）启动hadoop集群，启动前要格式化namenode</li><li>5）配置spark集群，修改spark-env.xml，slaves等配置文件，拷贝hadoop相关配置到spark conf目录下</li><li>6)启动spark集群。</li></ul></li><li>什么是RDD宽依赖和窄依赖？<ul><li>RDD和它依赖的parent RDD(s)的关系有两种不同的类型，即窄依赖（narrow dependency）和宽依赖（wide dependency）。</li><li>1）窄依赖指的是每一个parent RDD的Partition最多被子RDD的一个Partition使用</li><li>2）宽依赖指的是多个子RDD的Partition会依赖同一个parent RDD的Partition</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>理论</title>
      <link href="man/cs/%E7%90%86%E8%AE%BA.html"/>
      <url>man/cs/%E7%90%86%E8%AE%BA.html</url>
      
        <content type="html"><![CDATA[<ul><li>语言的基本类型<ul><li>字符串</li></ul></li><li>可能涉及到编码。编码是最基础的东西，只有规定好了类型，才能向上层发展。</li><li>那么编码有哪些类型。最早的是ASCII编码，稍后有中文UTF-8。编码规定字符所占字节，</li><li>那么显示技术又是如何把内容显示出来的呢。显示器有像素点，调光。</li><li>gRPC的关键字、属性有哪些？</li><li>RPC的应用场景有哪些？或者说什么场景适合RPC服务？<ul><li>内部服务调用</li><li>在客户端拥有一个存根能够像服务端一样的方法。</li></ul></li><li>使用 protocol buffers 来作为序列化和反序列化，以及接口定义语言 （IDL）</li><li>跨语言，跨平台，gRPC支持多种平台和多种语言，这应该是 gRPC 框架最大的优势</li><li>客户端充分利用高级流和链接功能，从而有助于节省宽带、降低TCP的连接次数、节省CPU的使用和电池寿命。</li><li>易于使用，安装编译环境和运行环境</li><li>基于 HTTP/2 ，提供双向传输和认证机制</li><li>RPC与HTTP接口有哪些不同？</li><li>HTTP2和HTTP有哪些不同，有哪些优势？</li><li>调用地图服务，批量查询公司地址，应该如何使用？</li><li>需要获取大量数据(30万)，而且在不同的表，且需要有更新机制。该如何处理？根据公司地址做热力地图，并提供相关公司信息。<ul><li>1.新建表存储。数据冗余了一份，且要定时更新，并且敏感数据部分不能够单独存储。这个不太可行。</li><li>2.接口直接读取。数据量大，慢慢取可以解决。但是更新机制没法去设计。</li><li>3.存量数据用excel一次性导出，另外可以单独查询接口来服务。</li><li>4.消息服务。需要有消息源，然后进行通知相关变更。消息源：监听数据表的变动，把消息推送出去。但是为了安全方面，需要实时同步一次。</li></ul></li><li>如何根据地理位置点和地理区域来判断是否在该区域内？<ul><li>1.地图提供的地址围栏服务。地址围栏算法。</li></ul></li><li>在group by查询重复数据时，获取最大那一条id<ul><li>1.select max(id) from table group by name;</li></ul></li><li>有变动的地方就有机遇。越是动荡，越是有大的机会。</li><li>有些时候规则限定了所能实现的能力。特别是在开发规则制定，语言设计等方面。该突破时或者调整时，就去调整。</li><li>python列表内的转换为数字?</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">numbers = [ int(x) <span class="keyword">for</span> x <span class="keyword">in</span> numbers ]</span><br><span class="line">numbers = list(map(int, numbers))</span><br><span class="line"><span class="keyword">for</span> i, v <span class="keyword">in</span> enumerate(numbers)</span><br><span class="line">    numbers[i] = int(v)</span><br></pre></td></tr></table></figure><ul><li><p>sql如何根据查询一个一对多的表，而且多的那个表只取最大的那一条？</p><ul><li>先把多条记录的表化作符合条件的单条记录表作为join的子查询表结构</li></ul></li><li><p>tensorflow是干什么的？有哪些特性？</p></li><li><p>如何根据端口号看下进程？并进行kill</p></li><li><p>python在赋值给self时，需要避免赋值给自身已有值。比如：_id</p></li><li><p>知识如何通过基因传递？</p></li><li><p>制作各种知识网络代替各个领域的专家</p></li><li><p>程序读懂文本？</p></li><li><p>以技术栈为模板，进行技术归类总结。</p></li><li><p>docker容器一直restarting是啥问题？怎么解决</p><ul><li>可能是强制删除了节点，在启动时已经不可以添加到集群了。需要进入到集群，进行集群操作</li></ul></li><li><p>python取小数位数</p><ul><li>rand(192.12, 2) 来处理</li></ul></li><li><p>删除表是需要设置每次删除的数据量；删除数据需要时间来处理，删除大表数据不能直接delete，需要进行limit处理。</p></li><li><p>limit的数据量看数据大小、索引数量、机器性能而定。差不多是10万/10s左右</p></li><li><p>删除事务失败是会进行回滚操作的，这里占用来缓存备份数据，用备份数据来回复数据。</p></li><li><p>恢复数据时，该表不能做任何操作，查询也不行。</p></li><li><p>curl参数熟悉</p></li><li><p>show engine innodb status;</p></li><li><p>kill掉mysql的thread_id</p></li><li><p>[bug、linux]linux命令终端显示-bash-4.2#解决方法</p><ul><li>该用户下没有相关的配置文件导致</li><li>解决办法：<ul><li>cp /etc/skel/.bashrc /root/</li><li>cp /etc/skel/.bash_profile /root/<br>智慧城市建设</li></ul></li></ul></li><li><p>1.城市大脑在数字化进程中越来越清晰。一个完整的智慧生物，除了大脑，还有反射弧。智能反射弧，在物联网、云计算、大数据的作用下，可以搭建的很好。反射弧越复杂，反应越快，表明智慧程度越高！</p></li><li><p>2.城市神经元网络（大社交网络）</p></li><li><p>3.智能反射弧包含很多安防云反射弧，金融云反射弧，交通云反射弧，能源云反射弧，教育云反射弧，医疗云反射弧、旅游云反射弧、零售云反射弧。</p></li><li><p>4.从设计上可以看出信息的触发、传播、决策、反馈、执行整个信息处理流程的完善程度！</p></li><li></li><li><p>2.所有的http库，实现的是网络通用协议，只有熟悉了网络协议，才能彻底明白所有的http库所包含的功能！so，接下来要熟悉http协议，从而彻底搞明白http库！</p></li><li><p>3.从以上也能明白，编程语言有基本的规则及规范；文件操作基本规则；。。。只有这些基本规则及功能掌握后，才能应对所有新出工具、思想应对自如！</p></li><li></li><li><p>1.计算机不能一下子识别一张图片，必须是一像素一像素的辨别？这个还需要好好的考察一下！</p></li><li><p>2.开拓性技术，摄像头识别个人（包括行为、人脸、身体体征，外表等）并进行追踪</p></li><li><p>3.不禁要辨别事物，还要能理解事物。欺骗是很难判断的，不知道是嬉闹还是真打架。</p></li><li><p>4.使计算机拥有好奇心、想象力。求知欲</p></li><li><p>5.把绘画融入计算机，使之拥有感性思考，理解艺术，拥有创造力！</p></li><li><p>6.可以进行自我认知、自我理解，运用已知的相关知识、记忆、逻辑推理来进行思维发散的思考。这其中还需要有思考的目的性，有了目的才能汇聚知识、理清知识间的逻辑，走通各种知识联通的道路，最后达到运用各种知识组合运用的创造！</p></li><li><p>7.短暂的灵感！这个需要存储记忆，在需要时拿出，同时，这也是发现真理规律的重要节点！</p></li><li><p>8.是否有必要创造出一个类人的智能？因为机器有其特有的属性和能力，是否有必要一定要模仿人类来创造智能？</p></li><li><p>9.利用生物学或化学并结合算法创造出一种永生的生物！</p></li><li><p>10.要聘用比自己聪明、比自己有能力的人！</p></li><li><p>11.人类大脑及其相关部件都是有大自然创造的，可以进行剖析，拆分出基础组件，重新组合来创造智能，或许是新的生命体！</p></li><li><p>调试bug，需要看错误日志、现象问题，进行层层排除，不断深究。</p></li><li><p>知识与数据的获取分析都需要有强有力的理论做指导。</p></li><li><p>1.我们的知识和搜索都是自然的一部分</p></li><li><p>2.我们正在用技术把生命的边缘扩张</p></li><li><p>3.即使我们所做的都是正确的，没有污染、没有大气变暖、没有超级病毒，可能也逃不过超级火山爆发或者小行星碰撞，只有努力成为可以不断移植星球繁衍的生物才能长存！</p></li><li><p>4.测试不仅是功能逻辑是否正确，还有效率问题！</p></li><li><p>1.坐在时间的列车，不能只看近处，会很累很迷茫，只有着眼未来，才能坚定清晰</p></li><li><p>2.技术的进步是一步一步来的，不能一口吃个胖子。还是要踏踏实实来完善自己！</p></li><li><p>1.系统磁盘分三层：逻辑层、虚拟层、物理层</p></li><li><p>2.磁盘在计算容量大小时需要考虑磁盘索引、磁盘分块等容量</p></li><li><p>1.工程内的配置文件json不是最好的。最好满足的特性：</p><ul><li>语法要简单，灵活</li><li>能够写注释，这点json简直可悲，不过可以考虑加预处理的过程</li><li>能够比较方便的覆盖参数值（方便书写或者debug），比如说在config文件中定义了 a=1<br>可以在运行的时候，通过类似 program -Da=2或者a=2 program的方式来覆盖参数值，而不需要跑去修改配置文件本身.这一点HOCON完爆其他的几种</li><li>能够重用配置片段，比较大一点的project中，经常有很多地方的配置需要保持一致，最好的办法就是引入变量和引用的概念</li><li>可以继承 。这是HOCON完爆其他语言的地方</li><li>另外HOCON可以包含文件，比如说你可以写一个基础的配置文件base.conf，然后再针对dev，staging和production分别做一份不同的文件，这样可以很轻松地做到在不同的环境下，用不同的配置而且没有重复的配置代码</li></ul></li><li><p>2.各种格式的配置文件的解析库。</p><ul><li>json文件解析库</li><li>ini文件解析库</li><li>yaml文件解析库</li></ul></li></ul><ul><li>软件设计是很多基本运算单位组成，把一些基本的运算单位集成到一起，不断聚合。</li><li>聚合是一门技术，单独运算单位也是一门技术。在需要快速掌握的世界里，都需要不断与已有的知识融合。</li><li>树形结构是多链表的另外一种表示。可以表示家族图谱，组织结构。凡事金字塔形式的都可以用树形表示。有层次性，一个节点只有一个父节点，如果有多个的话，就成为了图形结构了。</li><li>树的类型<ul><li>二叉树，平衡二叉树，完全二叉树，满二叉树</li><li>红黑树</li><li>哈夫曼树</li><li>B树，B+树</li></ul></li><li>树的计算</li><li>树的遍历</li><li>树形与图的不同。<ul><li>树有明显的层次性，网没有。</li><li>树里一个节点只有一个父节点，图里可以与多个其他节点相交。</li></ul></li><li>插件形比较好，易扩展</li><li>如何探究一项软件技术<ul><li>这是一篇方法论，来讨论如何进行一项技术研究活动或者是对一款软件进行整体的掌握。</li><li>首先，一项技术不会无缘无故的产生，一定有其背景或者动因，也就是要了解其历史。在整个历史背景下，可以更好的去思考实现。</li><li>然后需要进行数据</li><li>功能定位</li><li>常用法</li><li>依赖的技术</li><li>有什么创新</li><li>内部实现原理</li><li>生态环境</li><li>应用场景</li></ul></li><li>BI重点<ul><li>reporting:报告</li><li>visual：可视化</li><li>存储可以查找</li></ul></li><li>grafana果然是个好东西，有很多现成的配置图表可以用，很多的监控项。这个可以和数据可视化进行配置，把监控做的非常棒。这个需要研究下需要的数据格式是怎样的，以及如何设置可视化及响应的通知。</li><li>grafana对于每一个图表，都可以设置对应的监控报警。报警的方式可以有多种：发邮件、dingding、webhook等</li><li>textrank算法研究。这个在摘要自动提取里需要好好的研究一下。</li><li>Raft 或者 Paxos 这样的分布式一致性算法。</li><li>分布式存储的核心无非两点，一个是 Sharding 策略，一个是元信息存储，如何在 Sharding 的过程中保持业务的透明及一致性是一个拥有「弹性伸缩」能力的存储系统的关键。</li><li>MySQL 的静态路由中间件（如 Cobar）或者 Twemproxy 这样的 Redis 中间件，这些系统都很难无缝地进行 Scale</li><li>Sharding 的几种策略 在集群中的每一个物理节点都存储若干个 Sharding 单元，数据移动和均衡的单位都是 Sharding 单元。策略主要分两种，一种是 Range 另外一种是 Hash。针对不同类型的系统可以选择不同的策略，比如 HDFS 的Datanode 的数据分布就是一个很典型的</li><li>状态机:当我们说一致性的时候，实际就是在说要保证这个状态机的一致性。状态机会从log里面取出所有的命令，然后执行一遍，得到的结果就是我们对外提供的保证了一致性的数据</li><li>Log:保存了所有修改记录</li><li>一致性模块:一致性模块算法就是用来保证写入的log的命令的一致性，这也是raft算法核心内容</li><li>软件层次结构。分为控制层、业务层、数据层、工具集。其他的如：定时任务、命令终端等其他服务。</li><li>在复制项目时，尽可能的全部复制；否则就要慢慢来，一点一点的搬运，安装自己的需求，慢慢的来做处理。最忌讳的就是复制一点，自己改一点</li><li>在进行场景应用中，平常的web服务、文件上传、日记记录、消息传递、信息安全、session与cookie、网络协议、数据库设计与操作、中间件、定时任务、数据抓取、数据流与状态机、通用框架设计、表单校验</li><li>数据仓库粒度问题。多重粒度级别</li><li>主题、可重复使用</li><li>数据分区问题</li><li>nginx的配置需要以逗号结尾，一个指令一行为好。</li><li>go的路由配置必须以’/‘开始，否则会找不到</li><li>vue 生产模式下没有proxyTable,是用于开发模式下解决跨域问题的。</li><li>vue在多个客户端的情况下<ul><li>后端接口需要有一个统一的命名空间且不能与页面路由相冲突</li><li>在proxyTable内，域名后直接跟后端服务的端口号来做处理。</li></ul></li><li>nginx的debug功能，这个非常重要</li><li>让行为、流程、理论更加的透明！让一切都更加透明！</li><li>任何的请求其实都是针对端口号来说的，有些请求没有带端口其实是有默认的端口</li></ul><ul><li>[已解]刷数据有原则<ul><li>数据正确，格式兼容，内存够用，效率够高，易回滚，可断续，高容错</li></ul></li><li>[待解]整理hadoop、zookeeper、hbase、redis文档</li><li>[待解]mac如何添加快捷键？</li><li>[已解、sql]一个主表一对多关联一个从表，从表的一个字段需要concat处理？<ul><li>GROUP_CONCAT 有长度限制，默认是1024，可以使用SHOW VARIABLES LIKE “%group_concat_max_len%”查看</li><li>SET SESSION group_concat_max_len = 102400; 修改长度</li></ul></li><li>select i.id,i.cid, i.phase, i.finance_date, i.finance_amount, i.finance_amount_unit, group_concat(ip.entity_name) from investment as i left join investment_participant ip on ip.investment_id = i.id where i.status = 1 and i.cid=1123 group by i.id;</li><li>[总结]SQL 拼接多个字段的值&amp;一个字段多条记录的拼接？</li><li></li></ul><p>– 单列拼接，先查出一行，再加上逗号，接着拼接 查出的下一行<br>select group_concat(E.SUPPORT)<br>from ENGINES E<br>where E.XA IN(‘YES’,’NO’)<br>–结果如下：YES,YES,YES,YES,YES,YES,DEFAULT,YES</p><p>– 将查询的结果中的 “,” 号，替换成 “<strong>“ 号<br>select REPLACE(group_concat(E.SUPPORT),’,’,’</strong>‘)<br>from ENGINES E<br>where E.XA IN(‘YES’,’NO’)<br>–结果如下：YES<strong>YES</strong>YES<strong>YES</strong>YES<strong>YES</strong>DEFAULT**YES</p><p>– 将查询的结果中 重复 的记录 去掉，只剩一条记录，然后再拼接<br>select group_concat(DISTINCT(E.SUPPORT))<br>from ENGINES E<br>where E.XA IN(‘YES’,’NO’)<br>–结果如下：YES,DEFAULT</p><p>– 多列拼接，同一行的先拼接，再加上逗号，接着拼接下一行<br>select group_concat(E.ENGINE,E.SUPPORT)<br>from ENGINES E<br>where E.XA IN(‘YES’,’NO’)</p><h2 id="–结果如下：MRG-MYISAMYES-MyISAMYES-BLACKHOLEYES-CSVYES-MEMORYYES-ARCHIVEYES-InnoDBDEFAULT-PERFORMANCE-SCHEMAYES"><a href="#–结果如下：MRG-MYISAMYES-MyISAMYES-BLACKHOLEYES-CSVYES-MEMORYYES-ARCHIVEYES-InnoDBDEFAULT-PERFORMANCE-SCHEMAYES" class="headerlink" title="–结果如下：MRG_MYISAMYES,MyISAMYES,BLACKHOLEYES,CSVYES,MEMORYYES,ARCHIVEYES,InnoDBDEFAULT,PERFORMANCE_SCHEMAYES"></a>–结果如下：MRG_MYISAMYES,MyISAMYES,BLACKHOLEYES,CSVYES,MEMORYYES,ARCHIVEYES,InnoDBDEFAULT,PERFORMANCE_SCHEMAYES</h2><ul><li><p>[已解、python]python如何判断一个变量是数字或者是字符串</p><ul><li>用type方法</li><li>用isinstance</li><li>用字符串方法</li></ul></li><li><p>s为字符串<br>s.isalnum() 所有字符都是数字或者字母<br>s.isalpha() 所有字符都是字母<br>s.isdigit() 所有字符都是数字，不能够判断浮点数<br>s.islower() 所有字符都是小写<br>s.isupper() 所有字符都是大写<br>s.istitle() 所有单词都是首字母大写，像标题<br>s.isspace() 所有字符都是空白字符、\t、\n、\r</p></li><li><p>def _isnumber(cls,aString):</p><pre><code>try:    float(aString)    return Trueexcept:    return False</code></pre></li><li><p>[总结、sql]group_concat是干啥的？</p><ul><li>将多行的同一个字段链接为一个字段</li><li>也能同一个行多列拼接。先按照同一个行多列拼接，然后在按照多列拼接。</li><li>用法</li></ul></li><li><p>GROUP_CONCAT(DISTINCT expression</p><pre><code>ORDER BY expressionSEPARATOR sep);</code></pre></li><li><p>concat是干啥的？</p><ul><li>将同一行的不同字段链接为一个字段</li></ul></li><li><p>云计算其实是虚拟化加池化操作来实现对计算、网络和存储等资源的弹性管理，也就是IaaS服务。</p></li><li><p>然而仅仅有硬件资源的弹性管理还不够，还需要有软件资源的弹性管理，所以有了PaaS服务。</p></li><li><p>python的数据结构有哪些？</p><ul><li>字典、列表、元组、数字、字符串、布尔</li></ul></li><li><p>以上每种类型都有哪些特性？有哪些常用操作？</p></li><li><p>python的本质是什么？</p><ul><li>一切结对象</li></ul></li><li><p>python的灵活语法有哪些？</p></li><li><p>滴滴的城市星云图</p></li><li><p>use case</p></li><li><p>前端主动请求后端</p><ul><li>正常访问请求</li></ul></li><li><p>后端主动发送前端</p><ul><li>后端消息</li><li>不停查询服务器：秒杀、系统负载</li></ul></li><li><p>JSONP allows only GET</p></li><li><p>vue用proxyTable来做不同源规避</p></li><li><p>在语言的变量声明里，有些把类型放在变量名之前，叫表达式语法，如C语言家族；而有些放在变量名之后，叫变量声明语法，如go。这两者有什么不一样呢？</p><ul><li>在go的作者发帖说，由于C语言的类型声明在变量声明不复杂时，比较好，但是一旦复杂了就让人很难理解；而把类型放在后边，则都比较好表达理解。</li><li>还有者说是为了编译器利于编辑。语法上的歧义相对少，易于语法分析器的实现</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/net/%E8%B7%AF%E7%94%B1%E5%99%A8.html"/>
      <url>man/net/%E8%B7%AF%E7%94%B1%E5%99%A8.html</url>
      
        <content type="html"><![CDATA[<ul><li>路由器(Router，又称路径器)是一种计算机网络设备，它能将数据通过打包一个个网络传送至目的地(选择数据的传输路径)，这个过程称为路由。路由器就是连接两个以上各别网络的设备，路由工作在OSI模型的第三层——即网络层</li><li>路由器(Router)，是连接因特网中各局域网、广域网的设备，它会根据信道的情况自动选择和设定路由，以最佳路径，按前后顺序发送信号。</li><li>路由和交换机之间的主要区别就是交换机发生在OSI参考模型第二层(数据链路层)，而路由发生在第三层，即网络层。这一区别决定了路由和交换机在移动信息的过程中需使用不同的控制信息，所以两者实现各自功能的方式是不同的。</li><li>主要特点<ul><li>路由器具有判断网络地址和选择IP路径的功能</li><li>可用完全不同的数据分组和介质访问方法连接各种子网，路由器只接受源站或其他路由器的信息，属网络层的一种互联设备。它不关心各子网使用的硬件设备，但要求运行与网络层协议相一致的软件。</li></ul></li><li>路由器分本地路由器和远程路由器<ul><li>本地路由器是用来连接网络传输介质的，如光纤、同轴电缆、双绞线</li><li>远程路由器是用来连接远程传输介质，并要求相应的设备，如电话线要配调制解调器，无线要通过无线接收机、发射机。</li></ul></li><li>路由器通过路由决定数据的转发。转发策略称为路由选择(routing)</li><li>作用功能<ul><li>路由器有两大主要功能，即数据通道功能和控制功能。<ul><li>数据通道功能包括转发决定、背板转发以及输出链路调度等，一般由特定的硬件来完成;</li><li>控制功能一般用软件来实现，包括与相邻路由器之间的信息交换、系统配置、系统管理等。</li></ul></li><li>连通不同的网络。从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。从总体上说，在网络中添加路由器的整个安装过程要比即插即用的交换机复杂很多。</li><li>选择信息传送的线路。有的路由器仅支持单一协议，但大部分路由器可以支持多种协议的传输，即多协议路由器。由于每一种协议都有自己的规则，要在一个路由器中完成多种协议的算法，势必会降低路由器的性能。路由器的主要工作就是为经过路由器的每个数据帧寻找一条最佳传输路径，并将该数据有效地传送到目的站点。由此可见，选择最佳路径的策略即路由算法是路由器的关键所在。为了完成这项工作，在路由器中保存着各种传输路径的相关数据–路径表(Routing Table)，供路由选择时使用。路径表中保存着子网的标志信息、网上路由器的个数和下一个路由器的名字等内容。路径表可以是由系统管理员固定设置好的，也可以由系统动态修改，可以由路由器自动调整，也可以由主机控制。<ul><li>静态路由表：由系统管理员事先设置好固定的路径表称之为静态(static)路径表，一般是在系统安装时就根据网络的配置情况预先设定的，它不会随未来网络结构的改变而改变。</li><li>动态路由表：动态(Dynamic)路径表是路由器根据网络系统的运行情况而自动调整的路径表。路由器根据路由选择协议(Routing Protocol)提供的功能，自动学习和记忆网络运行情况，在需要时自动计算数据传输的最佳路径。</li></ul></li></ul></li><li>路由器级别<ul><li>使用级别<ul><li>接入路由器。接入路由器连接家庭或ISP内的小型企业客户。接入路由器已经开始不只是提供SLIP或PPP连接，还支持诸如PPTP和IPSec等虚拟私有网络协议。这些协议要能在每个端口上运行。诸如ADSL等技术将很快提高各家庭的可用带宽，这将进一步增加接入路由器的负担。由于这些趋势，接入路由器将来会支持许多异构和高速端口，并在各个端口能够运行多种协议，同时还要避开电话交换网。</li><li>企业级路由器。企业或校园级路由器连接许多终端系统，其主要目标是以尽量便宜的方法实现尽可能多的端点互连，并且进一步要求支持不同的服务质量。许多现有的企业网络都是由Hub或网桥连接起来的以太网段。尽管这些设备价格便宜、易于安装、无需配置，但是它们不支持服务等级。相反，有路由器参与的网络能够将机器分成多个碰撞域，并因此能够控制一个网络的大小。此外，路由器还支持一定的服务等级，至少允许分成多个优先级别。但是路由器的每端口造价要贵些，并且在能够使用之前要进行大量的配置工作。因此，企业路由器的成败就在于是否提供大量端口且每端口的造价很低，是否容易配置，是否支持QoS。另外还要求企业级路由器有效地支持广播和组播。企业网络还要处理历史遗留的各种LAN技术，支持多种协议，包括IP、IPX和Vine。它们还要支持防火墙、包过滤以及大量的管理和安全策略以及VLAN。</li><li>骨干级路由器。骨干级路由器实现企业级网络的互联。对它的要求是速度和可靠性，而代价则处于次要地位。硬件可靠性可以采用电话交换网中使用的技术，如热备份、双电源、双数据通路等来获得。这些技术对所有骨干路由器而言差不多是标准的。骨干IP路由器的主要性能瓶颈是在转发表中查找某个路由所耗的时间。当收到一个包时，输入端口在转发表中查找该包的目的地址以确定其目的端口，当包越短或者当包要发往许多目的端口时，势必增加路由查找的代价。因此，将一些常访问的目的端口放到缓存中能够提高路由查找的效率。不管是输入缓冲还是输出缓冲路由器，都存在路由查找的瓶颈问题。除了性能瓶颈问题，路由器的稳定性也是一个常被忽视的问题。</li><li>太比特路由器。在未来核心互联网使用的三种主要技术中，光纤和DWDM都已经是很成熟的并且是现成的。如果没有与现有的光纤技术和DWDM技术提供的原始带宽对应的路由器，新的网络基础设施将无法从根本上得到性能的改善，因此开发高性能的骨干交换/路由器(太比特路由器)已经成为一项迫切的要求。太比特路由器技术现在还主要处于开发实验阶段。</li><li>多WAN路由器。双WAN路由器具有物理上的2个WAN口作为外网接入，这样内网电脑就可以经过双WAN路由器的负载均衡功能同时使用2条外网接入线路，大幅提高了网络带宽。当前双WAN路由器主要有“带宽汇聚”和“一网双线”的应用优势，这是传统单WAN路由器做不到的。</li></ul></li><li>功能级别<ul><li>宽带路由器。<ul><li>宽带路由器是近几年来新兴的一种网络产品，它伴随着宽带的普及应运而生。宽带路由器在一个紧凑的箱子中集成了路由器、防火墙、带宽控制和管理等功能，具备快速转发能力，灵活的网络管理和丰富的网络状态等特点。多数宽带路由器针对中国宽带应用优化设计，可满足不同的网络流量环境，具备满足良好的电网适应性和网络兼容性。多数宽带路由器采用高度集成设计，集成10/100Mbps宽带以太网WAN接口、并内置多口10/100Mbps自适应交换机，方便多台机器连接内部网络与Internet，可以广泛应用于家庭、学校、办公室、网吧、小区接入、政府、企业等场合。</li></ul></li><li>模块化路由器<ul><li>模块化路由器主要是指该路由器的接口类型及部分扩展功能是可以根据用户的实际需求来配置的路由器，这些路由器在出厂时一般只提供最基本的路由功能，用户可以根据所要连接的网络类型来选择相应的模块，不同的模块可以提供不同的连接和管理功能。例如，绝大多数模块化路由器可以允许用户选择网络接口类型，有些模块化路由器可以提供VPN等功能模块，有些模块化路由器还提供防火墙的功能，等等。目前的多数路由器都是模块化路由器。</li></ul></li><li>非模块化路由器<ul><li>非模块化路由器都是低端路由器，平时家用的即为这类非模块化路由器。该类路由器主要用于连接家庭或ISP内的小型企业客户。它不仅提供SLIP或PPP连接，还支持诸如PPTP和IPSec等虚拟私有网络协议。这些协议要能在每个端口上运行。诸如ADSL等技术将很快提高各家庭的可用宽带，这将进一步增加接入路由器的负担。由于这些趋势，该类路由器将来会支持许多异构和高速端口，并在各个端口能够运行多种协议，同时还要避开电话交换网。</li></ul></li><li>虚拟路由器<ul><li>虚拟路由器以虚求实。最近，一些有关IP骨干网络设备的新技术突破，为将来因特网新服务的实现铺平了道路。虚拟路由器就是这样一种新技术，它使一些新型因特网服务成为可能。通过这些新型服务，用户将可以对网络的性能、因特网地址和路由以及网络安全等进行控制。以色列RND网络公司是一家提供从局域网到广域网解决方案的厂商，该公司最早提出了虚拟路</li></ul></li><li>核心路由器<ul><li>核心路由器又称“骨干路由器”，是位于网络中心的路由器。位于网络边缘的路由器叫接入路由器。核心路由器和边缘路由器是相对概念。它们都属于路由器，但是有不同的大小和容量。某一层的核心路由器是另一层的边缘路由器。</li></ul></li><li>无线路由器<ul><li>无线路由器就是带有无线覆盖功能的路由器，它主要应用于用户上网和无线覆盖。市场上流行的无线路由器一般都支持专线xdsl/cable，动态xdsl，pptp四种接入方式，它还具有其它一些网络管理的功能，如dhcp服务、nat防火墙、mac地址过滤等等功能。</li></ul></li><li>独臂路由器<ul><li>独臂路由器的概念是出现在三层交换机之前，网内各个VLAN之间的通信可以用ISL关联来实现，那样的话，路由器就成为一个“独臂路由器”，VLAN之间的数据传输要进入先路由器处理，然后输出，以使得网络中的大部分报文同一个VLAN内的报文将用不着通过路由器而直接在交换设备间进行高速传输。这种路由方式的不足之处在于它仍然是一种集中式的路由策略，因此在主干网上一般均设置有多个冗余“独臂”路由器，来分担数据处理任务，从而可以减少因路由器引起的瓶颈问题，还可以增加冗余链路，但如果网络中VLAN之间的数据传输量比较大，那么在路由器处将形成瓶颈。独臂路由器现在基本被第3层交换机取代。</li></ul></li><li>无线网络路由器<ul><li>无线网络路由器是一种用来连接有线和无线网络的通讯设备，它可以通过Wi-Fi技术收发无线信号来与个人数码助理和笔记本等设备通讯。无线网络路由器可以在不设电缆的情况下，方便地建立一个电脑网络。但是，一般在户外通过无线网络进行数据传输时，它的速度可能会受到天气的影响。其他的无线网络还包括了红外线、蓝牙及卫星微波等</li></ul></li><li>智能流控路由器<ul><li>智能流控路由器能够在自动地调整每个节点的带宽，这样每个节点的网速均能达到最快,不用限制每个节点的速度，这是其最大的特点。智能流控路由器经常用在电信的主干道上，如华为，思科。网吧,酒店等则常用网星路由器。</li></ul></li><li>动态限速路由器<ul><li>动态限速路由器是一种能实时地计算每位用户所需要的带宽，精确分析用户上网类型，并合理分配带宽，达到按需分配，合理利用，还具有优先通道的智能调配功能，这种功能主要应用于网吧、酒店、小区、学校等，网吧最常用的则是奥雷路由器。</li></ul></li><li>软路由器<ul><li>利用台式机或服务器配合软件形成路由解决方案，主要靠软件的设置，达成路由器的功能，常见的有小草软路由、海蜘蛛等。</li></ul></li></ul></li></ul></li><li>协议<ul><li>动态路由协议分为内部网关协议（IGP）和外部网关协议（EGP）。这里的自治域指一个具有统一管理机构、统一路由策略的网络。自治域内部采用的路由选择协议称为内部网关协议，常用的有RIP、OSPF；外部网关协议主要用于多个自治域之间的路由选择，常用的是BGP和BGP-4。</li><li>RIP路由协议<ul><li>RIP协议最初是为Xerox网络系统的Xerox parc通用协议而设计的，是Internet中常用的路由协议。RIP采用距离向量算法，即路由器根据距离选择路由，所以也称为距离向量协议。路由器收集所有可到达目的地的不同路径，并且保存有关到达每个目的地的最少站点数的路径信息，除到达目的地的最佳路径外，任何其它信息均予以丢弃。同时路由器也把所收集的路由信息用RIP协议通知相邻的其它路由器。这样，正确的路由信息逐渐扩散到了全网。</li><li>RIP使用非常广泛，它简单、可靠，便于配置。但是RIP只适用于小型的同构网络，因为它允许的最大站点数为15，任何超过15个站点的目的地均被标记为不可达。而且RIP每隔30s一次的路由信息广播也是造成网络的广播风暴的重要原因之一。</li></ul></li><li>OSPF路由协议<ul><li>0SPF是一种基于链路状态的路由协议，需要每个路由器向其同一管理域的所有其它路由器发送链路状态广播信息。在OSPF的链路状态广播中包括所有接口信息、所有的量度和其它一些变量。利用0SPF的路由器首先必须收集有关的链路状态信息，并根据一定的算法计算出到每个节点的最短路径。而基于距离向量的路由协议仅向其邻接路由器发送有关路由更新信息。</li><li>与RIP不同，OSPF将一个自治域再划分为区，相应地即有两种类型的路由选择方式：当源和目的地在同一区时，采用区内路由选择；当源和目的地在不同区时，则采用区间路由选择。这就大大减少了网络开销，并增加了网络的稳定性。当一个区内的路由器出了故障时并不影响自治域内其它区路由器的正常工作，这也给网络的管理、维护带来方便。</li></ul></li><li>BGP和BGP-4路由协议<ul><li>BGP是为TCP／IP互联网设计的外部网关协议，用于多个自治域之间。它既不是基于纯粹的链路状态算法，也不是基于纯粹的距离向量算法。它的主要功能是与其它自治域的BGP交换网络可达信息。各个自治域可以运行不同的内部网关协议。BGP更新信息包括网络号／自治域路径的成对信息。自治域路径包括到达某个特定网络须经过的自治域串，这些更新信息通过TCP传送出去，以保证传输的可靠性。</li></ul></li></ul></li><li>路由算法<ul><li>路由算法在路由协议中起着至关重要的作用，采用何种算法往往决定了最终的寻径结果，因此选择路由算法一定要仔细。通常需要综合考虑以下几个设计目标：<ul><li>（1）最优化：指路由算法选择最佳路径的能力。</li><li>（2）简洁性：算法设计简洁，利用最少的软件和开销，提供最有效的功能。</li><li>（3）坚固性：路由算法处于非正常或不可预料的环境时，如硬件故障、负载过高或操作失误时，都能正确运行。由于路由器分布在网络联接点上，所以在它们出故障时会产生严重后果。最好的路由器算法通常能经受时间的考验，并在各种网络环境下被证实是可靠的。</li><li>（4）快速收敛：收敛是在最佳路径的判断上所有路由器达到一致的过程。当某个网络事件引起路由可用或不可用时，路由器就发出更新信息。路由更新信息遍及整个网络，引发重新计算最佳路径，最终达到所有路由器一致公认的最佳路径。收敛慢的路由算法会造成路径循环或网络中断。</li><li>（5）灵活性：路由算法可以快速、准确地适应各种网络环境。例如，某个网段发生故障，路由算法要能很快发现故障，并为使用该网段的所有路由选择另一条最佳路径。</li></ul></li><li>路由算法按照种类可分为以下几种：静态和动态、单路和多路、平等和分级、源路由和透明路由、域内和域间、链路状态和距离向量。前面几种的特点与字面意思基本一致，下面着重介绍链路状态和距离向量算法。</li><li>链路状态算法（也称最短路径算法）发送路由信息到互联网上所有的结点，然而对于每个路由器，仅发送它的路由表中描述了其自身链路状态的那一部分。距离向量算法（也称为Bellman-Ford算法）则要求每个路由器发送其路由表全部或部分信息，但仅发送到邻近结点上。从本质上来说，链路状态算法将少量更新信息发送至网络各处，而距离向量算法发送大量更新信息至邻接路由器。</li><li>由于链路状态算法收敛更快，因此它在一定程度上比距离向量算法更不易产生路由循环。但另一方面，链路状态算法要求比距离向量算法有更强的CPU能力和更多的内存空间，因此链路状态算法将会在实现时显得更昂贵一些。除了这些区别，两种算法在大多数环境下都能很好地运行。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/basic.html"/>
      <url>man/storeage/mysql/basic.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>mysqldump出数据</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -hhost -uroot -ppassword --database db --tables table_name &gt; table_name.sql</span><br><span class="line">mysqldump -hhost -uroot -ppassword --all-databases &gt; table_name.sql</span><br></pre></td></tr></table></figure></li><li><p>导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -hhost -uroot -p basebase &lt; table.sql</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql</title>
      <link href="man/storeage/mysql/index.html"/>
      <url>man/storeage/mysql/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>1.<a href="mysql/basic.html">架构介绍</a></li><li>2.<a href="mysql/commands.html">常用命令</a></li><li>3.<a href="mysql/character.html">编码类型</a></li><li>4.<a href="mysql/column_type.html">字段类型</a></li><li>5.<a href="mysql/transaction.html">事务处理</a></li><li>6.<a href="mysql/indexed.html">索引介绍</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/sql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5.html"/>
      <url>man/storeage/mysql/sql%E5%B8%B8%E7%94%A8%E8%AF%AD%E5%8F%A5.html</url>
      
        <content type="html"><![CDATA[<h1 id="mysql常用语句"><a href="#mysql常用语句" class="headerlink" title="mysql常用语句"></a>mysql常用语句</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-10 18:20:48</li></ul><h2 id="0x00、常用语句"><a href="#0x00、常用语句" class="headerlink" title="0x00、常用语句"></a>0x00、常用语句</h2><ul><li>1.授权用户<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;GRANT ALL PRIVILEGES ON *.* TO &#39;zxc&#39;@&#39;%&#39; IDENTIFIED BY &#39;ydp#2015$Z!!!&#39; WITH GRANT OPTION;</span><br><span class="line">mysql&gt;FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure></li><li>2.远程连接<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;mysql -h127.0.0.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure></li><li>3.导出数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;mysqldump -h127.0.0.1 -P3306 -uroot -p sqsx &gt; sqsx.sql</span><br></pre></td></tr></table></figure></li><li>4.导入数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shell&gt;mysql -uroot -p sqsx &lt; sqsx.sql</span><br></pre></td></tr></table></figure></li><li>5.分析查询<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;explain select * from user;</span><br></pre></td></tr></table></figure></li><li>6.查询所有的进程<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show procelist;</span><br></pre></td></tr></table></figure></li><li>7.建数据库语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;create database dbname default character set utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li>8.创建数据表语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;create table dbname.tablename () engine&#x3D;Innodb charset&#x3D;utf8;</span><br></pre></td></tr></table></figure></li><li>9.删除数据库<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;drop database dbname;</span><br></pre></td></tr></table></figure></li><li>10.查看数据库状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;use dbname;</span><br><span class="line">mysql&gt;status;</span><br></pre></td></tr></table></figure></li><li>11.查看参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show variables like “%sql%”;</span><br></pre></td></tr></table></figure></li><li>12.查看事件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show events;</span><br></pre></td></tr></table></figure></li><li>13.查看触发器<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show triggers;</span><br></pre></td></tr></table></figure></li><li>14.查看所有参数<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show status;</span><br></pre></td></tr></table></figure></li><li>15.查看打开表<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show open tables;</span><br></pre></td></tr></table></figure></li><li>16.查看表状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show table status;</span><br></pre></td></tr></table></figure></li><li>17.查看主数据状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show master status;</span><br></pre></td></tr></table></figure></li><li>18.查看从数据库状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show slave status;</span><br></pre></td></tr></table></figure></li><li>19.查看函数状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show function status;</span><br></pre></td></tr></table></figure></li><li>20.查看插件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show plugins;</span><br></pre></td></tr></table></figure></li><li>21.查看某用户的授权<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show grants for username;</span><br></pre></td></tr></table></figure></li><li>22.查看错误<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show errors;</span><br></pre></td></tr></table></figure></li><li>23.查看创建表语句<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show create table tablename;</span><br></pre></td></tr></table></figure></li><li>24.查看表头<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show columns from tablename;</span><br></pre></td></tr></table></figure></li><li>25.查看存储引擎<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show engines;</span><br></pre></td></tr></table></figure></li><li>26.查看表状态<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show table status;</span><br></pre></td></tr></table></figure></li><li>27.修改root密码</li></ul><ul><li>字符串截取</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL 字符串截取函数：left(), right(), substring(), substring_index()。还有 mid(), substr()。其中，mid(), substr() 等价于 substring() 函数，substring() 的功能非常强大和灵活。</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html"/>
      <url>man/storeage/mysql/%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5.html</url>
      
        <content type="html"><![CDATA[<h1 id="mysql数据库主从同步"><a href="#mysql数据库主从同步" class="headerlink" title="mysql数据库主从同步"></a>mysql数据库主从同步</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2019-03-10 18:25:53</li></ul><h2 id="0x00、同步步骤"><a href="#0x00、同步步骤" class="headerlink" title="0x00、同步步骤"></a>0x00、同步步骤</h2><ul><li>1.主库和从库创建同步账户<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; grant replication slave, replication client on *.* to repl@<span class="string">'192.168.1.%'</span> identified by <span class="string">'123456'</span>;</span><br></pre></td></tr></table></figure></li><li>2.主库配置/etc/my.cnf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server-id=130<span class="comment">#保证唯一值</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">binlog-do-db=test2</span><br><span class="line">binlog-ignore-db=mysql</span><br><span class="line"><span class="built_in">log</span>-error=/var/lib/mysql/mysql.err</span><br></pre></td></tr></table></figure><ul><li><p>3.重启主库</p></li><li><p>4.查看主库状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show master status;</span><br><span class="line">+-------------------------+-----------------+--------------------+-------------------------+</span><br><span class="line">| File            | Position | Binlog_Do_DB | Binlog_Ignore_DB |</span><br><span class="line">+-------------------------+----------------+--------------------+--------------------------+</span><br><span class="line">| mysql-bin.000002 |      120 |   test2      |   mysql        |</span><br><span class="line">+-------------------------+----------------+---------------------+------------------------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br></pre></td></tr></table></figure></li><li><p>5.从库配置 /etc/my.cnf</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">server-id=131 <span class="comment">#保证唯一值</span></span><br><span class="line"><span class="built_in">log</span>-bin=mysql-bin</span><br><span class="line">binlog_format=mixed</span><br><span class="line">replicate-do-db=test2</span><br><span class="line">replicate-ignore-db=mysql</span><br><span class="line">relay_log=/var/lib/mysql/mysql-relay-bin</span><br><span class="line">log_slave_updates=1</span><br><span class="line">read_only=1</span><br></pre></td></tr></table></figure><ul><li>6.重启从库</li><li>7.指向主库操作<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; change master to master_host&#x3D;&#39;192.168.1.201&#39;,</span><br><span class="line">master_user&#x3D;&#39;repl&#39;,</span><br><span class="line">master_password&#x3D;&#39;123456&#39;,</span><br><span class="line">master_log_file&#x3D;&#39;mysql-bin.000002&#39;,</span><br><span class="line">master_log_pos&#x3D;120;</span><br></pre></td></tr></table></figure></li><li>8.开始同步</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;start slave;</span><br></pre></td></tr></table></figure><ul><li>9.查看状态<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt;show slave status;</span><br></pre></td></tr></table></figure></li><li>10.双向主从的话，把主库按照从库在配置一遍即可</li></ul><h2 id="0x01、备注"><a href="#0x01、备注" class="headerlink" title="0x01、备注"></a>0x01、备注</h2><ul><li>1.两个数据库版本尽量一致，如果不一致，高版本做从库，此时不可双向主从</li><li>2.主库和从库的数据库名必须相同；</li><li>3.主库和从库的复制可以精确到表，但是在需要更改主库或从库的数据结构时需要立刻重启slave；</li><li>4.不能在mysql配置文件里直接写入master的配置信息，需要用change master命令来完成；</li><li>5.指定replicate_do_db必须在my.ini里配置，不能用change master命令来完成；</li><li>6.如果不及时清理，日积月累二进制日志文件可能会把磁盘空间占满，可以在配置文件里加上expire_logs_days=7，只保留最近7天的日志，建议当slave不再使用时，通过reset slave来取消relaylog；</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html"/>
      <url>man/storeage/mysql/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.html</url>
      
        <content type="html"><![CDATA[<p>常见问题</p><ul><li><p>1.在delete语句后添加的condition不能用select子查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span>  zhihu_answer_entity <span class="keyword">where</span> <span class="keyword">id</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> <span class="keyword">id</span> <span class="keyword">from</span> zhihu_answer_entity <span class="keyword">where</span> post_id <span class="keyword">in</span> (</span><br><span class="line"><span class="keyword">select</span> post_id <span class="keyword">from</span> zhihu_answer_entity <span class="keyword">group</span> <span class="keyword">by</span> post_id <span class="keyword">having</span> <span class="keyword">count</span>(*) &gt; <span class="number">1</span></span><br><span class="line">) <span class="keyword">and</span> create_time &lt; <span class="string">'2019-11-10'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>会报如下错误</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">You can&#39;t specify target table &#39;zhihu_answer_entity&#39; for update in FROM clause</span><br></pre></td></tr></table></figure></li><li><p>2.mac下启动mysql</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mysql.server start</span><br><span class="line">mysql.server restart</span><br><span class="line">mysql.server stop</span><br></pre></td></tr></table></figure></li><li><p>子查询排序失效<br>问题描述：高版本的MySQL（5.6以上）在子查询中使用order by 语句后查询结果并不会显示排序后的结果。<br>以下是我使用的两个解决方法，供参考：</p></li></ul><p>1.当子查询的order by语句后面没有limit关键字时，数据库会自动优化，即忽略order by语句。因此只需要添加limit关键字即可。<br>2.在子查询中使用聚合函数。</p><ul><li><p>1.mysql的timestamp不支持直接写入时间戳的整型值，需要转换为时间格式，在写入。</p></li><li><p>28.truncate、delete与drop的区别</p><ul><li>相同点：<ul><li>1.truncate和不带where子句的delete、以及drop都会删除表内的数据。</li><li>2.drop、truncate都是DDL语句(数据定义语言),执行后会自动提交。</li></ul></li><li>不同点：<ul><li><ol><li>truncate 和 delete 只删除数据不删除表的结构(定义)；drop 语句将删除表的结构被依赖的约束(constrain)、触发器(trigger)、索引(index)；依赖于该表的存储过程/函数将保留,但是变为 invalid 状态。</li></ol></li><li><ol start="2"><li>delete 语句是数据库操作语言(dml)，这个操作会放到 rollback segement 中，事务提交之后才生效；如果有相应的 trigger，执行的时候将被触发。truncate、drop 是数据库定义语言(ddl)，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。</li></ol></li><li>3.delete 语句不影响表所占用的 extent，高水线(high watermark)保持原位置不动；drop 语句将表所占用的空间全部释放；truncate 语句缺省情况下见空间释放到 minextents个 extent，除非使用reuse storage；truncate 会将高水线复位(回到最开始)。</li><li>4.速度，一般来说: drop&gt; truncate &gt; delete</li><li>5.安全性：小心使用 drop 和 truncate，尤其没有备份的时候.否则哭都来不及；使用上,想删除部分数据行用 delete，注意带上where子句. 回滚段要足够大.想删除表,当然用 drop；想保留表而将所有数据删除，如果和事务无关，用truncate即可。如果和事务有关,或者想触发trigger,还是用delete；如果是整理表内部的碎片，可以用truncate跟上reuse stroage，再重新导入/插入数据。</li><li>6.delete是DML语句,不会自动提交。drop/truncate都是DDL语句,执行后会自动提交。</li><li>7.TRUNCATE   TABLE 在功能上与不带WHERE子句的DELETE语句相同：二者均删除表中的全部行。但   TRUNCATE   TABLE   比   DELETE   速度快，且使用的系统和事务日志资源少；DELETE语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE   TABLE   通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</li><li>8.TRUNCATE   TABLE   删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用DELETE。如果要删除表定义及其数据，请使用DROP   TABLE语句。</li><li>9.于由   FOREIGN   KEY   约束引用的表，不能使用   TRUNCATE   TABLE，而应使用不带   WHERE   子句的   DELETE   语句。由于   TRUNCATE   TABLE   不记录在日志中，所以它不能激活触发器。</li><li>10.TRUNCATE   TABLE   不能用于参与了索引视图的表</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE.html"/>
      <url>man/storeage/mysql/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="sql性能优化建议"><a href="#sql性能优化建议" class="headerlink" title="sql性能优化建议"></a>sql性能优化建议</h1><ul><li>作者：<a href="mailto:codehackfox@gmail.com">codehackfox@gmail.com</a></li><li>时间：2015-12-28 12:23:00</li></ul><h2 id="0x00、优化建议"><a href="#0x00、优化建议" class="headerlink" title="0x00、优化建议"></a>0x00、优化建议</h2><h4 id="0-方法"><a href="#0-方法" class="headerlink" title="0.方法"></a>0.方法</h4><ul><li>explain查询.</li></ul><h4 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1.索引优化"></a>1.索引优化</h4><ul><li>where条件字段上需要建立索引</li><li>Where条件上不要使用运算函数，以免索引失效</li><li>排序字段上需要建立索引</li><li>分组字段上需要建立索引</li><li>多表连接的字段上需要建立索引.这样可以极大的提高表连接的效率</li><li>根据需要建立多列联合索引.当单个列过滤之后还有很多数据，那么索引的效率将会比较低，即列的区分度较低，那么如果在多个列上建立索引，那么多个列的区分度就大多了，将会有显著的效率提高</li></ul><h4 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2.查询优化"></a>2.查询优化</h4><ul><li>当只要一行数据时使用limit 1；</li><li>避免select ；</li></ul><h4 id="3-存储优化"><a href="#3-存储优化" class="headerlink" title="3.存储优化"></a>3.存储优化</h4><ul><li>选择正确的存储引擎；</li><li>列类型尽量定义成数值类型，且长度尽可能短，如主键和外键，类型字段等等</li><li>垂直分割、水平分割</li></ul><h4 id="4-具体优化"><a href="#4-具体优化" class="headerlink" title="4.具体优化"></a>4.具体优化</h4><ul><li>把ip地址存成UNSIGNED INT</li><li>使用enum而不是varchar;</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/storeage/mysql/%E7%B4%A2%E5%BC%95.html"/>
      <url>man/storeage/mysql/%E7%B4%A2%E5%BC%95.html</url>
      
        <content type="html"><![CDATA[<h1 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h1><p>索引类型有主键索引<br>唯一索引<br>普通索引<br>联合索引</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index.html"/>
      <url>man/linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="Linux常用命令"><a href="#Linux常用命令" class="headerlink" title="Linux常用命令"></a>Linux常用命令</h1><h3 id="文件信息"><a href="#文件信息" class="headerlink" title="文件信息"></a>文件信息</h3><ul><li><p><strong><code>ls</code></strong> – 罗列目录内容</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [-ABCFGHLOPRSTUW@abcdefghiklmnopqrstuwx1%] [file ...]</span><br></pre></td></tr></table></figure><ul><li><code>-1</code> - 每行一个文件，只显示文件名</li><li><code>-a</code> - 显示所有的文件，包括隐藏文件</li><li><code>-A</code> - 罗列所有的文件，出来<code>.</code>和<code>..</code>这两个</li><li><code>-h</code> - When used with the -l option, use unit suffixes: Byte, Kilobyte, Megabyte, Gigabyte, Terabyte and Petabyte in order to reduce the number of digits to three or less using base 2 for sizes.</li><li><code>-l</code> - (The lowercase letter ``ell’’.)  List in long format.  (See below.)  A total sum for all the file sizes is output on a line before the long listing.</li><li><code>-S</code> - 按文件大小排序</li><li><code>-T</code> - 当有<code>-l</code>选项时，显示文件的全部时间，包括年月日、时分秒</li><li><code>-t</code> - Sort by time modified (most recently modified first) before sorting the operands by lexicographical order.</li><li><code>-u</code> - Use time of last access, instead of last modification of the file for sorting (-t) or long printing (-l).</li><li><code>-U</code> - Use time of file creation, instead of last modification for sorting (-t) or long output (-l).</li><li><code>-R</code> - Recursively list subdirectories encountered.</li><li><code>-m</code> - Stream output format; list files across the page, separated by commas.</li><li><code>-p</code>- Write a slash (‘/‘) after each filename if that file is a directory.</li></ul></li><li><p><strong><code>cd</code></strong> – 进入目录。终端内置命令。</p><ul><li><code>-</code> - 返回上次目录<ul><li><code>-2</code> - 返回倒数第二次所在目录</li><li><code>-3</code> - 返回倒数第三次所在目录</li></ul></li><li><code>..</code> - 返回上级目录</li></ul></li><li><p><strong><code>mv</code></strong> – 移动或重命名文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv [-f | -i | -n] [-v] <span class="built_in">source</span> target</span><br><span class="line">mv [-f | -i | -n] [-v] <span class="built_in">source</span> ... directory</span><br></pre></td></tr></table></figure><ul><li><code>-f</code> - 忽略提醒，不论是否已经存在，直接移动覆盖。并且会忽略掉之前的<code>-i</code>和<code>-n</code>选项。</li><li><code>-i</code> - 如果有文件存在，则提醒；否则直接移动。将覆盖以前的<code>-f</code>或<code>-n</code>选项</li><li><code>-n</code> - 如果目标目录文件已存在，则不覆盖。将覆盖以前的<code>-f</code>或<code>-i</code>选项</li><li><code>-v</code> - 显示文件移动详细信息。</li></ul></li><li><p><strong><code>cp</code></strong> - 复制文件</p></li><li><p><strong><code>rm</code></strong> - 删除文件或文件夹</p></li><li><p><strong><code>ln</code></strong> - 链接文件</p></li><li><p><strong><code>cat</code></strong> - 查看文件内容</p></li><li><p><strong><code>touch</code></strong> – 创建一个空文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch a.txt</span><br></pre></td></tr></table></figure></li><li><p><strong><code>mkdir</code></strong> #创建目录</p></li><li><p><strong><code>head</code></strong> 查看文件开头</p></li><li><p><strong><code>tail</code></strong> 查看文件结尾</p></li><li><p><strong><code>wc</code></strong> 统计</p></li><li><p><strong><code>tree</code></strong>  查看目录树</p></li><li><p><strong><code>more</code></strong></p></li><li><p><strong><code>less</code></strong></p></li><li><p><strong><code>open</code></strong> 打开文件或目录</p></li></ul><h3 id="权限"><a href="#权限" class="headerlink" title="权限"></a>权限</h3><ul><li><strong><code>chmod</code></strong> – 修改文件权限<ul><li><code>+</code> - 增加权限、<code>－</code> - 取消权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x a.txt <span class="comment"># 给a.txt增加执行的权限</span></span><br></pre></td></tr></table></figure></li><li>文件权限<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 a.txt <span class="comment"># 给a.txt 用户-用户组-其他给与读写可执行的权限</span></span><br></pre></td></tr></table></figure></li><li><code>-R</code> - 对目前目录下的所有档案与子目录进行相同的权限变更<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R 755 adir</span><br></pre></td></tr></table></figure></li><li><code>-f</code> - 若该文件权限无法被更改也不要显示错误讯息</li><li><code>-v</code> - 显示权限变更的详细资料</li></ul></li><li><strong><code>chown</code></strong> 修改文件所有者和组</li><li><strong><code>chgrp</code></strong></li><li><strong><code>useradd</code></strong></li><li><strong><code>groupadd</code></strong></li><li><strong><code>passwd</code></strong> 修改密码</li></ul><h3 id="用户"><a href="#用户" class="headerlink" title="用户"></a>用户</h3><ul><li><strong><code>whoami</code></strong></li><li><strong><code>who</code></strong></li><li><strong><code>w</code></strong></li><li><strong><code>last</code></strong> – 查看最后登录的用户。 indicate last logins of users and ttys<ul><li><code>-n</code> - Limits the report to n lines.</li><li><code>-h</code> - Host names may be names or internet numbers.</li><li><code>-t</code> - Specify the tty.  Tty names may be given fully or abbreviated, for example, <code>last -t 03&#39;&#39; is equivalent to</code>last -t tty03’’.</li></ul></li><li><strong><code>lastcomm</code></strong> – show last commands executed in reverse order</li><li><strong><code>history</code></strong></li><li><strong><code>ac</code></strong> – display connect-time accounting<ul><li><code>-d</code>  Display the connect times in 24 hour chunks.</li><li><code>-p</code>  Display individual user totals.</li></ul></li><li><strong><code>login</code></strong> – log into the computer</li></ul><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><ul><li><strong><code>cat /proc/cpuinfo</code></strong> – 查看cpu信息</li><li><strong><code>cat /etc/redhat-release</code></strong> – 查看版本</li><li><strong><code>cat /etc/sysconfig/keyboard</code></strong>    #查看磁盘布局</li><li><strong><code>uname</code></strong> – 查看系统名称<ul><li><code>-r</code></li><li><code>-a</code> - 详情信息</li></ul></li><li><strong><code>hostname</code></strong></li><li><strong><code>ps</code></strong></li><li><strong><code>top</code></strong></li><li><strong><code>htop</code></strong></li><li><strong><code>pstree</code></strong> 查看进程树</li><li><strong><code>shutdown</code></strong></li><li><strong><code>env</code></strong> – 系统环境变量信息.set environment and execute command, or print environment</li><li><strong><code>printenv</code></strong> – 同<code>env</code></li><li><strong><code>echo</code></strong> – 输出打印信息</li><li><strong><code>exit</code></strong> – 退出登录</li><li><strong><code>systemctl</code></strong> – Control the systemd system and service manager</li><li><strong><code>journalctl</code></strong></li><li><strong><code>loginctl</code></strong></li><li><strong><code>machinectl</code></strong></li><li><strong><code>wall</code></strong></li><li><strong><code>glob</code></strong></li></ul><h3 id="终端"><a href="#终端" class="headerlink" title="终端"></a>终端</h3><ul><li><strong><code>sh</code></strong> – POSIX-compliant command interpreter</li><li><strong><code>zsh</code></strong> –</li><li><strong><code>bash</code></strong> –</li><li><strong><code>dash</code></strong></li><li><strong><code>ksh</code></strong></li></ul><h3 id="磁盘操作"><a href="#磁盘操作" class="headerlink" title="磁盘操作"></a>磁盘操作</h3><ul><li><strong><code>df</code></strong> – ＃查看磁盘空间<ul><li><code>-h</code></li></ul></li><li><strong><code>fdisk</code></strong> – ＃查看挂在的分区<ul><li><code>-l</code></li></ul></li><li><strong><code>du</code></strong> -sh    ＃查看分区，查看文件大小</li><li><strong><code>mount</code></strong></li><li><strong><code>unmount</code></strong></li></ul><h3 id="工具查看"><a href="#工具查看" class="headerlink" title="工具查看"></a>工具查看</h3><ul><li><strong><code>cal</code></strong>    #查看日历</li><li><strong><code>date</code></strong>    ＃查看当前时间</li><li><strong><code>grep</code></strong></li><li><strong><code>stat</code></strong></li></ul><h3 id="安装软件"><a href="#安装软件" class="headerlink" title="安装软件"></a>安装软件</h3><ul><li><strong><code>rpm</code></strong><ul><li><code>-qa</code><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa|wc -l</span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>yum</code></strong><ul><li>list</li><li>update</li><li>install</li><li>search<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed|wc -l</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><strong><code>cat /etc/sysconfig/network</code></strong></li><li><strong><code>cat /etc/sysconfig-script/etho</code></strong></li><li><strong><code>cat /etc/resolv.conf</code></strong></li><li><strong><code>netstat</code></strong></li><li><strong><code>ifconfig</code></strong></li><li><strong><code>ping</code></strong></li><li><strong><code>telnet</code></strong></li><li><strong><code>ssh</code></strong><ul><li>ssh用key远程登陆：ssh   user@host即可登陆</li></ul></li></ul><h3 id="压缩与解压缩"><a href="#压缩与解压缩" class="headerlink" title="压缩与解压缩"></a>压缩与解压缩</h3><ul><li><strong><code>tar</code></strong> – archive and extract<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar [bundled-flags &lt;args&gt;] [&lt;file&gt; | &lt;pattern&gt; ...]</span><br><span class="line">tar &#123;-c&#125; [options] [files | directories]</span><br><span class="line">tar &#123;-r | -u&#125; -f archive-file [options] [files | directories]</span><br><span class="line">tar &#123;-t | -x&#125; [options] [patterns]</span><br></pre></td></tr></table></figure><ul><li><code>-c</code> - Create a new archive containing the specified items.  The long option form is –create.</li><li><code>-r</code> - Like -c, but new entries are appended to the archive.  Note that this only works on uncompressed archives stored in regular files.  The -f option is required.  The long option form is –append.</li><li><code>-t</code> - List archive contents to stdout.  The long option form is –list.</li><li><code>-u</code> - Like -r, but new entries are added only if they have a modification date newer than the corresponding entry in the archive.  Note that this only works on uncompressed archives stored in regular files.  The -f option is required.  The long form is –update.</li><li><code>-x</code> - Extract to disk from the archive.  If a file with the same name appears more than once in the archive, each copy will be extracted, with later copies overwriting (replacing) earlier copies.  The long option form is –extract.<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 示例</span></span><br><span class="line"><span class="comment"># Create an archive from files:</span></span><br><span class="line">tar cf target.tar file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a gzipped archive:</span></span><br><span class="line">tar czf target.tar.gz file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a gzipped archive from a directory using relative paths:</span></span><br><span class="line">tar czf target.tar.gz -C path/to/directory .</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract a (compressed) archive into the current directory:</span></span><br><span class="line">tar xf source.tar[.gz|.bz2|.xz]</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract an archive into a target directory:</span></span><br><span class="line">tar xf source.tar -C directory</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a compressed archive, using archive suffix to determine the compression program:</span></span><br><span class="line">tar caf target.tar.xz file1 file2 file3</span><br><span class="line"></span><br><span class="line"><span class="comment"># List the contents of a tar file:</span></span><br><span class="line">tar tvf source.tar</span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract files matching a pattern:</span></span><br><span class="line">tar xf source.tar --wildcards <span class="string">"*.html"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Extract a specific file without preserving the folder structure:</span></span><br><span class="line">tar xf source.tar source.tar/path/to/extract --strip-components=depth_to_strip</span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>zip</code></strong> –  package and compress (archive) files<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"> </span><br></pre></td></tr></table></figure></li><li><strong><code>unzip</code></strong></li></ul><h3 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h3><ul><li><strong><code>man</code></strong> 查看manual手册。<ul><li>format and display the on-line manual pages。The standard sections of the manual include:<ul><li>1 User Commands</li><li>2 System Calls</li><li>3 C Library Functions</li><li>4 Devices and Special Files</li><li>5 File Formats and Conventions</li><li>6 Games et. Al.</li><li>7 Miscellanea</li><li>8 System Administration tools and Deamons</li></ul></li><li>通过<code>man man</code>来查看其用法</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/linux/%E5%86%85%E5%AD%98oom%E5%A4%84%E7%90%86/index.html"/>
      <url>man/linux/%E5%86%85%E5%AD%98oom%E5%A4%84%E7%90%86/index.html</url>
      
        <content type="html"><![CDATA[<p>内存OOM处理</p><ul><li>Linux下有一种 OOM KILLER 的机制，它会在系统内存耗尽的情况下，启用自己算法有选择性的杀掉一些进程。</li><li>在Linux中当malloc返回的是非空时，并不代表有可以使用的内存空间。Linux系统允许程序申请比系统可用内存更多的内存空间，这个特性叫做 overcommit 特性，这样做可能是为了系统的优化，因为不是所有的程序申请了内存就会立刻使用，当真正的使用时，系统可能已经回收了一些内存。但是，当你使用时Linux系统没有内存可以使用时，OOM Killer就会出来让一些进程退出。</li><li>Linux下有3种Overcommit的策略（参考内核文档： Documentation/vm/overcommit-accounting ），可以在 /proc/sys/vm/overcommit_memory 配置（可以取0,1和2三个值，默认是0）。<ul><li>0： 启发式策略 ，比较严重的Overcommit将不能得逞，比如你突然申请了128TB的内存。而轻微的overcommit将被允许。另外，root能Overcommit的值比普通用户要稍微多。</li><li>1： 永远允许overcommit ，这种策略适合那些不能承受内存分配失败的应用，比如某些科学计算应用。</li><li>2： 永远禁止overcommit ，在这个情况下，系统所能分配的内存不会超过 swap+RAM*系数 （/proc/sys/vm/overcmmit_ratio，默认50%，你可以调整），如果这么多资源已经用光，那么后面任何尝试申请内存的行为都会返回错误，这通常意味着此时没法运行任何新程序。</li></ul></li><li>Linux系统的选择策略也一直在不断的演化。我们可以通过设置一些值来影响OOM killer做出决策。Linux下每个进程都有个OOM权重，在/proc/<pid>/oom_adj里面，取值是-17到+15，取值越高，越容易被干掉。<ul><li>最终OOM killer是通过 /proc/<pid>/oom_score 这个值来决定哪个进程被干掉的。这个值是系统综合进程的内存消耗量、CPU时间(utime + stime)、存活时间(uptime - start time)和oom_adj计算出的，消耗内存越多分越高，存活时间越长分越低。</li><li>总之，总的策略是：损失最少的工作，释放最大的内存同时不伤及无辜的用了很大内存的进程，并且杀掉的进程数尽量少。  另外，Linux在计算进程的内存消耗的时候，会将子进程所耗内存的一半同时算到父进程中。</li></ul></li><li>memblock机制<ul><li>memblock管理算法 将可用可分配的内存在 memblock.memory 进行管理起来，已分配的内存在 memblock.reserved 进行管理，只要内存块加入到 memblock.reserved 里面就表示该内存已经被申请占用了。所以有个关键点需要注意，内存申请的时候，仅是把被申请到的内存加入到 memblock.reserved 中，并不会在 memblock.memory 里面有相关的删除或改动的操作，这也就是为什么申请和释放的操作都集中在 memblock.reserved 的原因了。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>title</title>
      <link href="man/net/http/http%E5%8D%8F%E8%AE%AE.html"/>
      <url>man/net/http/http%E5%8D%8F%E8%AE%AE.html</url>
      
        <content type="html"><![CDATA[<h1 id="http协议"><a href="#http协议" class="headerlink" title="http协议"></a>http协议</h1><h2 id="1-get和post的区别"><a href="#1-get和post的区别" class="headerlink" title="1.get和post的区别"></a>1.get和post的区别</h2><p>GET    POST<br>数据都从url传输，以？为分隔符，参数以&amp;区分<br>数据是存放在httpbody里提交<br>提交数据有限制<br>提交数据无限制<br>通过Request.QueryString获取变量值<br>通过Request.Form来获取值<br>会有安全问题</p><h3 id="2-包含的各种操作"><a href="#2-包含的各种操作" class="headerlink" title="2.包含的各种操作"></a>2.包含的各种操作</h3><p>GET    POST    PUT    DELETE    HEAD    TRACE    OPTIONS</p><h3 id="3-Response"><a href="#3-Response" class="headerlink" title="3.Response"></a>3.Response</h3><pre><code>第一行：状态行        有HTTP协议版本号，状态码，状态消息三部分组成            HTTP1.1定义了5类状态码，有三位数字组成，第一个数字定义了相应级别</code></pre><h3 id="4http请求流程"><a href="#4http请求流程" class="headerlink" title="4http请求流程"></a>4http请求流程</h3><ul><li>1 ) 、地址解析，</li><li>如用客户端浏览器请求这个页面：<a href="http://localhost.com:8080/index.htm" target="_blank" rel="noopener">http://localhost.com:8080/index.htm</a></li><li>从中分解出协议名、主机名、端口、对象路径等部分，对于我们的这个地址，解析得到的结果如下：</li><li>协议名：http</li><li>主机名：localhost.com</li><li>端口：8080</li><li>对象路径：/index.htm</li><li>在这一步，需要域名系统DNS解析域名localhost.com,得主机的IP地址。</li><li>2）、封装HTTP请求数据包</li><li>把以上部分结合本机自己的信息，封装成一个HTTP请求数据包</li><li>3）封装成TCP包，建立TCP连接（TCP的三次握手）</li><li>在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。这里是8080端口</li><li>4）客户机发送请求命令</li><li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可内容。</li><li>5）服务器响应</li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li><li>实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据</li><li>6）服务器关闭TCP连接<pre><code>一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码</code></pre>Connection:keep-alive      TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。</li></ul><h3 id="5-HTTP协议栈中各层数据流"><a href="#5-HTTP协议栈中各层数据流" class="headerlink" title="5.HTTP协议栈中各层数据流"></a>5.HTTP协议栈中各层数据流</h3><h3 id="6-服务器解析流程"><a href="#6-服务器解析流程" class="headerlink" title="6.服务器解析流程"></a>6.服务器解析流程</h3><h3 id="7-https实现原理"><a href="#7-https实现原理" class="headerlink" title="7.https实现原理"></a>7.https实现原理</h3><ul><li>1.在http下加入SSL层</li><li>2.加密分为对称加密，和非对称加密</li><li>3.过程<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1）SSL客户端通过TCP和服务器建立连接之后（443端口），并且在一般的tcp连接协商（握手）过程中请求证书。即客户端发出一个消息给服务器，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个数据包，这里面确定了这次通信所需要的算法，然后服务器向客户端返回证书。（证书里面包含了服务器信息：域名。申请证书的公司，公共秘钥）。</span><br><span class="line">2）Client在收到服务器返回的证书后，判断签发这个证书的公共签发机构，并使用这个机构的公共秘钥确认签名是否有效，客户端还会确保证书中列出的域名就是它正在连接的域名。</span><br><span class="line">3）如果确认证书有效，那么生成对称秘钥并使用服务器的公共秘钥进行加密。然后发送给服务器，服务器使用它的私钥对它进行解密，这样两台计算机可以开始进行对称加密进行通信。</span><br></pre></td></tr></table></figure><h3 id="8-请求"><a href="#8-请求" class="headerlink" title="8.请求"></a>8.请求</h3></li><li>1.一个请求包含请求行、请求头、请求体</li><li>2.请求行<ul><li>请求方法    URI    协议／版本</li></ul></li><li>3.请求头<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 5.1; rv:10.0.2) Gecko/20100101 Firefox/10.0.2</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-cn,zh;q=0.5</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Connection: keep-alive</span><br><span class="line">Referer: http://localhost/</span><br><span class="line">Content-Length：25</span><br><span class="line">Content-Type：application/x-www-form-urlencoded</span><br></pre></td></tr></table></figure></li></ul><h3 id="9-响应"><a href="#9-响应" class="headerlink" title="9.响应"></a>9.响应</h3><ul><li>1.一个相应包含状态行、消息报头、相应正文</li><li>2.状态行<ul><li>协议／版本    状态码    状态描述</li></ul></li><li>3.相应头<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Date: Sun, 17 Mar 2013 08:12:54 GMT</span><br><span class="line">Server: Apache/2.2.8 (Win32) PHP/5.2.5</span><br><span class="line">X-Powered-By: PHP/5.2.5</span><br><span class="line">Set-Cookie: PHPSESSID=c0huq7pdkmm5gg6osoe3mgjmm3; path=/</span><br><span class="line">Expires: Thu, 19 Nov 1981 08:52:00 GMT</span><br><span class="line">Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Content-Length: 4393</span><br><span class="line">Keep-Alive: timeout=5, max=100 Connection:</span><br><span class="line">Keep-Alive Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure></li></ul><p>http1与http2的异同点</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>hbase简介</title>
      <link href="man/storeage/hbase/hbase%E7%AE%80%E4%BB%8B/index.html"/>
      <url>man/storeage/hbase/hbase%E7%AE%80%E4%BB%8B/index.html</url>
      
        <content type="html"><![CDATA[<center>分布式列存储数据库</center><a id="more"></a><p>[TOC]</p><h2 id="一、架构"><a href="#一、架构" class="headerlink" title="一、架构"></a>一、架构</h2><h3 id="1-1-概览"><a href="#1-1-概览" class="headerlink" title="1.1 概览"></a>1.1 概览</h3><img data-src="assets/61026AE8-683D-4D8B-B758-093DDD72A929.png" alt="61026AE8-683D-4D8B-B758-093DDD72A929" style="zoom:150%;" /><ul><li><p>1、HBase架构中有若干个从节点HRegionServer，负责维护主节点HMaster分配给它的HRegion，响应客户端Client的I/O请求，向HDFS文件系统中读写数据，切分在运行过程中变得过大的HRegion。并发性能与HRegionServer的个数有关。</p></li><li><p>2、一个HRegionServer中有若干个HRegion，若干连续的行构成一个HRegion，当一个HRegion所有的storefile的大小超过阈值后，这个HRegion会分割为两个，并由HMaster分配到相应的HRegionServer服务器，实现负载均衡，所以一张完整的表可能被保存在多个HRegionServer上，HRegion是HBase中分布式存储和负载均衡的最小单元，但并不是存储的最小单元。</p></li><li><p>3、HBase中的每张表都通过RowKey按照一定的范围被分割成多个HRegion，默认一个HRegion超过256M就要被分割成两个，这个过程由HRegionServer管理，而HRegion的分配由HMaster管理。 一个HRegion中有若干个Store，每个Store是一个列族，Store分两种，新插入的数据在内存数据MemStore中，满了之后写到磁盘StoreFile中，数据以HFile的格式保存在hdfs的DataNode中，StoreFile中有Hfile的元数据，方便索引。客户端在检索数据时，先在MemStore找，找不到再找StoreFile。不断的写StoreFile生成HFile会产生很多小文件不利于性能，所以会合并小StoreFile形成更大的，过大的话再切分。</p></li><li><p>4、HLog是一种预写日志WAL log，即Write ahead log，对hbase操作之前会将指令先写入HLog，如MemStore中的数据还没写入StoreFile时停电了，就可以进行数据恢复。每个HRegionServer只有一个HLog，缺点是如果一台HRegionServer下线，为了恢复其上的HRegion，需要将HLog进行拆分，然后分发到其它HRegionServer上进行恢复。</p></li><li><p>5、HMaster管理用户的增删改查操作，管理HRegionServer的负载均衡，调整Region分布，在HRegionServer停机后，负责失效HRegionServer上的HRegion迁移。由于master只维护表和HRegion的元数据，而不参与表数据I/O的过程，HMaster下线仅导致所有元数据的修改被冻结(无法创建删除表，无法修改表的schema，无法进行HRegion的负载均衡，无法处理HRegion上下线，无法进行HRegion的合并，唯一例外的是HRegion的 split可以正常进行，因为只有HRegionServer参与)，表的数据读写还可以正常进行。因此HMaster下线短时间内对整个HBase集群没有影响。从上线过程可以看到，HMaster保存的 信息全是可以冗余信息(都可以从系统其它地方收集到或者计算出来)，因此，一般HBase集群中总是有一个HMaster在提供服务，还有一个以上的”HMaster”在等待时机抢占它的位置(StandBy状态)。</p></li><li><p>6、客户端client包含有各种接口，client维护着一些cache来加快对HBase的访问，比如HRegion的位置信息。读写操作时，客户端直接与HRegionServer通信，建表等管理操作则请求ZooKeeper与HMaster通信。</p></li><li><p>7、ZooKeeper是分布式应用程序协调服务，保存了表元数据寻址地址（-ROOT-表的地址）、HMaster和HRegionServer的状态信息。它的作用是保证集群中只有一个HMaster，实时监控HRegionServer的状态并通知给HMaster。</p></li></ul><h3 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h3><ul><li><strong>面向列：</strong> Hbase是面向列的存储和权限控制，并支持独立索引。列式存储，其数据在表中是按照某列存储的，这样在查询时只需要少数几个字段，可以大大减少读取的数据量。</li><li><strong>多版本：</strong> Hbase每一个列会存储多个Version。</li><li><strong>稀疏性：</strong> 为空的列不占用存储空间，表可以设计的非常稀疏。</li><li><strong>可扩展性：</strong> 因为底层依赖的是HDFS，HDFS本身就可以进行扩展。</li><li><strong>高可靠性：</strong> WAL机制保证了数据写入时不会因为集群异常而导致写入数据丢失，Replication机制保证了在集群出现严重的问题时，数据不会发生丢失或损坏。而且Hbase底层使用HDFS，HDFS本身就会进行备份。</li><li><strong>高性能：</strong> 底层的LSM数据结构和RowKey有序排列等架构上的独特设计，使得Hbase具有非常高的写入性能。region切分主键索引和缓存机制使得Hbase在海量数据下具备一定的随机读取性能，该性能针对RowKey的查询能达到毫秒级别。</li><li><strong>HBase依赖于Zookeeper：</strong> Hbase是依赖于Zookeeper的，HBase中有内置的Zookeeper，但一般我们会用其他的 Zookeeper 集群来监管 HMaster 和HRegionServer，Zookeeper 通过选举，保证任何时候，集群中只有一个活跃的 HMaster 。</li></ul><h2 id="二、表设计"><a href="#二、表设计" class="headerlink" title="二、表设计"></a>二、表设计</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><ul><li>Table(表)<ul><li>Hbase组织数据存储到表内。</li><li>大。一个表可以有上亿行，上百万列</li><li>面向列。面向列(族)的存储和权限控制，列(族)独立检索。</li><li>稀疏。对于为空(null)的列，并不占用存储空间，因此，表可以设计的非常稀疏。</li></ul></li><li>Row(行)<ul><li>数据按行存储，并有一个<code>RowKey</code>来标识。</li><li><code>RowKey</code>可以是任意内容(最大长度是 64KB，实际应用中长度一般为 10-100bytes)，保存为字节数组。</li><li>存储时，数据按照Row key的字典序(byte order)排序存储。</li><li>每条数据按照<code>RowKey</code>切割到不同的HRegion里。</li></ul></li><li>ColumnFamily(列族)<ul><li>数据被按照<code>列族</code>的方式来组织</li><li>列族是表的chema的一部分(而列不是)，必须在使用表之前定义。列名都以列族作为前缀。例如courses:history，courses:math都属于courses 这个列族。</li><li>hbase表中的每个列，都归属与某个列族。</li><li>访问控制、磁盘和内存的使用统计都是在列族层面进行的。实际应用中，列族上的控制权限能帮助我们管理不同类型的应用：我们允许一些应用可以添加新的基本数据、一些应用可以读取基本数据并创建继承的列族、一些应用则只允许浏览数据（甚至可能因为隐私的原因不能浏览所有数据）。</li></ul></li><li>ColumnQualifier(列)<ul><li>一个<code>列</code>相当于一个字段。</li><li>一个<code>列族</code>内，可以有多个<code>列</code>。</li></ul></li><li>Timestamp(时间戳)<ul><li>每个cell里的数据，都有一个毫秒级时间戳对应，作为版本控制。</li><li>每个 cell中，不同版本的数据按照时间倒序排序，即最新的数据排在最前面。</li><li>时间戳也可以由客户显式赋值。如果应用程序要避免数据版本冲突，就必须自己生成具有唯一性的时间戳。</li><li>增删改，就是在数据上添加时间戳来标识。</li><li>为了避免数据存在过多版本造成的的管理 (包括存贮和索引)负担，hbase提供了两种数据版本回收方式。一是保存数据的最后n个版本，二是保存最近一段时间内的版本（比如最近七天）。用户可以针对每个列族进行设置。</li></ul></li><li>Cell(单元)<ul><li>存储数据地方。</li><li>由{RowKey， ColumnFamily,  ColumnQualifier， version} 唯一确定的单元</li></ul></li></ul><p>总体上，RowKey的设计是最重要的。那么在设计时，注意一下几点：</p><ul><li><strong>唯一原则</strong>。必须在设计上保证其唯一性，rowkey是按照字典顺序排序存储的，因此，设计rowkey的时候，要充分利用这个排序的特点，将经常读取的数据存储到一块，将最近可能会被访问的数据放到一块。</li><li><strong>散列原则</strong>。如果rowkey按照时间戳的方式递增，不要将时间放在二进制码的前面，建议将rowkey的高位作为散列字段，由程序随机生成，低位放时间字段，这样将提高数据均衡分布在每个RegionServer，以实现负载均衡的几率。如果没有散列字段，首字段直接是时间信息，所有的数据都会集中在一个RegionServer上，这样在数据检索的时候负载会集中在个别的RegionServer上，造成热点问题，会降低查询效率。</li><li><strong>长度原则</strong>。rowkey是一个二进制码流，可以是任意字符串，最大长度 64kb ，实际应用中一般为10-100bytes，以 byte[] 形式保存，一般设计成定长。建议越短越好，不要超过16个字节，原因如下：<ul><li>数据的持久化文件HFile中是按照KeyValue存储的，如果rowkey过长，比如超过100字节，1000w行数据，光rowkey就要占用100*1000w=10亿个字节，将近1G数据，这样会极大影响HFile的存储效率；</li><li>MemStore将缓存部分数据到内存，如果rowkey字段过长，内存的有效利用率就会降低，系统不能缓存更多的数据，这样会降低检索效率。</li><li>目前操作系统都是64位系统，内存8字节对齐，控制在16个字节，8字节的整数倍利用了操作系统的最佳特性。</li></ul></li></ul><h3 id="2-2-存储示意"><a href="#2-2-存储示意" class="headerlink" title="2.2 存储示意"></a>2.2 存储示意</h3><h4 id="2-2-1-逻辑存储"><a href="#2-2-1-逻辑存储" class="headerlink" title="2.2.1 逻辑存储"></a>2.2.1 逻辑存储</h4><p><img data-src="assets/image-20200721124222590.png" alt="image-20200721124222590"></p><img data-src="assets/image-20200721124248667.png" alt="image-20200721124248667" style="zoom:67%;" /><h4 id="2-2-2-物理存储"><a href="#2-2-2-物理存储" class="headerlink" title="2.2.2 物理存储"></a>2.2.2 物理存储</h4><ul><li>1.Table中的所有行都按照row key的字典序排列。Table 在行的方向上分割为多个Hregion。</li></ul><p><img data-src="assets/20120905125622_717.png" alt="20120905125622_717"></p><ul><li>2.region按大小分割的，每个表一开始只有一个region，随着数据不断插入表，region不断增大，当增大到一个阀值的时候，Hregion就会等分会两个新的Hregion。当table中的行不断增多，就会有越来越多的Hregion。</li></ul><p><img data-src="assets/20120905125622_287.png" alt="20120905125622_287"></p><ul><li><p>3.HRegion是Hbase中分布式存储和负载均衡的最小单元。最小单元就表示不同的Hregion可以分布在不同的HRegion server上。但一个Hregion是不会拆分到多个server上的。</p><p><img data-src="assets/20120905125622_387.png" alt="20120905125622_387"></p></li><li><p>4.HRegion虽然是分布式存储的最小单元，但并不是存储的最小单元。</p><ul><li><p>事实上，HRegion由一个或者多个Store组成，每个store保存一个columns family。每个Strore又由一个memStore和0至多个StoreFile组成。如图：StoreFile以HFile格式保存在HDFS上。</p><p><img data-src="assets/20120905125622_637.png" alt="20120905125622_637"></p></li></ul></li></ul><ul><li><p>5.HFile的格式</p><img data-src="assets/20120905125622_812-5313359.png" alt="20120905125622_812" style="zoom:150%;" /><ul><li>HFile分为六个部分：<ul><li>Data Block 段–保存表中的数据，这部分可以被压缩</li><li>Meta Block 段 (可选的)–保存用户自定义的kv对，可以被压缩。</li><li>File Info 段–Hfile的元信息，不被压缩，用户也可以在这一部分添加自己的元信息。</li><li>Data Block Index 段–Data Block的索引。每条索引的key是被索引的block的第一条记录的key。</li><li>Meta Block Index段 (可选的)–Meta Block的索引。</li><li>Trailer– 这一段是定长的。保存了每一段的偏移量，读取一个HFile时，会首先读取Trailer，Trailer保存了每个段的起始位置(段的Magic Number用来做安全check)，然后，DataBlock Index会被读取到内存中，这样，当检索某个key时，不需要扫描整个HFile，而只需从内存中找到key所在的block，通过一次磁盘io将整个 block读取到内存中，再找到需要的key。DataBlock Index采用LRU机制淘汰。</li><li>HFile的Data Block，Meta Block通常采用压缩方式存储，压缩之后可以大大减少网络IO和磁盘IO，随之而来的开销当然是需要花费cpu进行压缩和解压缩。目标Hfile的压缩支持两种方式：Gzip，Lzo。</li></ul></li><li>HLog(WAL log)<ul><li>WAL 意为Write ahead log(<a href="http://en.wikipedia.org/wiki/Write-ahead_logging)，类似mysql中的binlog,用来" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/Write-ahead_logging)，类似mysql中的binlog,用来</a> 做灾难恢复只用，Hlog记录数据的所有变更,一旦数据修改，就可以从log中进行恢复。</li><li>每 个Region Server维护一个Hlog,而不是每个Region一个。这样不同region(来自不同table)的日志会混在一起，这样做的目的是不断追加单个 文件相对于同时写多个文件而言，可以减少磁盘寻址次数，因此可以提高对table的写性能。带来的麻烦是，如果一台region server下线，为了恢复其上的region，需要将region server上的log进行拆分，然后分发到其它region server上进行恢复。</li><li>HLog 文件就是一个普通的Hadoop Sequence File，Sequence File 的Key是HLogKey对象，HLogKey中记录了写入数据的归属信息，除了table和region名字外，同时还包括 sequence number和timestamp，timestamp是”写入时间”，sequence number的起始值为0，或者是最近一次存入文件系统中sequence number。HLog Sequece File的Value是HBase的KeyValue对象，即对应HFile中的KeyValue，可参见上文描述。</li></ul></li></ul></li></ul><h2 id="三、常用命令操作"><a href="#三、常用命令操作" class="headerlink" title="三、常用命令操作"></a>三、常用命令操作</h2><h3 id="3-1-版本操作"><a href="#3-1-版本操作" class="headerlink" title="3.1 版本操作"></a>3.1 版本操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询状态</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> status</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询版本</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> version</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询用户</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> whoami</span></span><br></pre></td></tr></table></figure><h3 id="3-2表结构操作"><a href="#3-2表结构操作" class="headerlink" title="3.2表结构操作"></a>3.2表结构操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> create <span class="string">'t1'</span>, <span class="string">'cf1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> create <span class="string">'t1'</span>, &#123;NAME =&gt; <span class="string">'cf1'</span>&#125;, &#123;NAME =&gt; <span class="string">'cf2'</span>&#125;, &#123;NAME =&gt; <span class="string">'f3'</span>&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> create <span class="string">'t1'</span>, &#123;NAME =&gt; <span class="string">'f1'</span>, VERSIONS =&gt; 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有的表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> list</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> list <span class="string">'abc.*'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看结构</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> describe <span class="string">'t1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">disable</span>表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> <span class="built_in">disable</span> <span class="string">'t1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> disable_all <span class="string">'t.*'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断是否<span class="built_in">disable</span>了</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> is_disabled <span class="string">'t1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">enable</span> 已经<span class="built_in">disable</span>的表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> <span class="built_in">enable</span> <span class="string">'t1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> enable_all <span class="string">'t.*'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> drop <span class="string">'t1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> drop_all <span class="string">'t.*'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 判断表是否存在</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> exists <span class="string">'t1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改数据保存版本数量</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> alter <span class="string">'t1'</span>, NAME =&gt; <span class="string">'cf1'</span>, VERSIONS =&gt; 5</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除某列族</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> alter <span class="string">'t1'</span>, <span class="string">'delete'</span> =&gt; <span class="string">'cf1'</span></span></span><br></pre></td></tr></table></figure><h3 id="3-3-数据操作"><a href="#3-3-数据操作" class="headerlink" title="3.3 数据操作"></a>3.3 数据操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 写入数据。往t1表内写入一个以r1为rowkey,列内c1对应的value，时间戳是t1</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> put <span class="string">'t1'</span>, <span class="string">'r1'</span>, <span class="string">'c1'</span>, <span class="string">'value'</span>, ts1</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> t1.put <span class="string">'r1'</span>, <span class="string">'c1'</span>, <span class="string">'value'</span>, ts1</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取某行或某个cell或某版本</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;TIMERANGE =&gt; [ts1, ts2]&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;COLUMN =&gt; <span class="string">'c1'</span>&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;COLUMN =&gt; [<span class="string">'c1'</span>, <span class="string">'c2'</span>, <span class="string">'c3'</span>]&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;COLUMN =&gt; <span class="string">'c1'</span>, TIMESTAMP =&gt; ts1&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;COLUMN =&gt; <span class="string">'c1'</span>, TIMERANGE =&gt; [ts1, ts2], VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;COLUMN =&gt; <span class="string">'c1'</span>, TIMESTAMP =&gt; ts1, VERSIONS =&gt; 4&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, &#123;FILTER =&gt; <span class="string">"ValueFilter(=, 'binary:abc')"</span>&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, <span class="string">'c1'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, <span class="string">'c1'</span>, <span class="string">'c2'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> get <span class="string">'t1'</span>, <span class="string">'r1'</span>, [<span class="string">'c1'</span>, <span class="string">'c2'</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 扫描</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> scan <span class="string">'t1'</span>, &#123;COLUMNS =&gt; [<span class="string">'c1'</span>, <span class="string">'c2'</span>], LIMIT =&gt; 10, STARTROW =&gt; <span class="string">'xyz'</span>&#125;</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> scan <span class="string">'t1'</span>, &#123;COLUMNS =&gt; <span class="string">'c1'</span>, TIMERANGE =&gt; [1303668804, 1303668904]&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除某个cell数据，必须精确到</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> delete <span class="string">'t1'</span>, <span class="string">'r1'</span>, <span class="string">'c1'</span>, ts1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除正行数据</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> deleteall <span class="string">'t1'</span>, <span class="string">'r1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 禁用、删除并新建表</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> truncate <span class="string">'t1'</span></span></span><br></pre></td></tr></table></figure><h3 id="3-4-权限"><a href="#3-4-权限" class="headerlink" title="3.4 权限"></a>3.4 权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对某用户授权。READ(‘R’), WRITE(‘W’), EXEC(‘X’), CREATE(‘C’), ADMIN(‘A’)</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> grant <span class="string">'person1'</span>, <span class="string">'RWXCA'</span></span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> grant <span class="string">'person2'</span>, <span class="string">'RW'</span>, <span class="string">'t1'</span>, <span class="string">'f1'</span>, <span class="string">'col1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 取消授权</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> revoke <span class="string">'bobsmith'</span>, <span class="string">'t1'</span>, <span class="string">'f1'</span>, <span class="string">'col1'</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询权限</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> user_ermission</span></span><br><span class="line"><span class="meta">hbase&gt;</span><span class="bash"> user_permission <span class="string">'table1'</span></span></span><br></pre></td></tr></table></figure><h2 id="四、Python操作"><a href="#四、Python操作" class="headerlink" title="四、Python操作"></a>四、Python操作</h2><p>使用<code>happybase</code>库来操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> happybase</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接</span></span><br><span class="line">connection = happybase.Connection(<span class="string">'hostname'</span>)</span><br><span class="line"><span class="comment"># 打印所有表</span></span><br><span class="line">print(connection.tables())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立连接池</span></span><br><span class="line">pool = happybase.ConnectionPool(size=<span class="number">3</span>, host=<span class="string">'...'</span>, table_prefix=<span class="string">'myproject'</span>)</span><br><span class="line"><span class="keyword">with</span> pool.connection() <span class="keyword">as</span> connection:</span><br><span class="line">    print(connection.tables())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建表</span></span><br><span class="line">connection.create_table(</span><br><span class="line">    <span class="string">'mytable'</span>,</span><br><span class="line">    &#123;<span class="string">'cf1'</span>: dict(max_versions=<span class="number">10</span>),</span><br><span class="line">     <span class="string">'cf2'</span>: dict(max_versions=<span class="number">1</span>, block_cache_enabled=<span class="literal">False</span>),</span><br><span class="line">     <span class="string">'cf3'</span>: dict(),  <span class="comment"># use defaults</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 连接表</span></span><br><span class="line">table = connection.table(<span class="string">'table-name'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 写入数据</span></span><br><span class="line">table.put(<span class="string">b'row-key'</span>, &#123;<span class="string">b'family:qual1'</span>: <span class="string">b'value1'</span>,<span class="string">b'family:qual2'</span>: <span class="string">b'value2'</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">#########################  查询   ##############################</span></span><br><span class="line"><span class="comment"># 查询某行</span></span><br><span class="line">row = table.row(<span class="string">b'row-key'</span>)</span><br><span class="line"><span class="comment"># 打印该行某列数据</span></span><br><span class="line">print(row[<span class="string">b'family:qual1'</span>])  <span class="comment"># prints 'value1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某行的某列</span></span><br><span class="line">row = table.row(<span class="string">b'row-key'</span>, columns=[<span class="string">b'cf1'</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某个版本数据</span></span><br><span class="line">row = table.row(<span class="string">b'row-key'</span>, timestamp=<span class="number">123456789</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带时间戳查询</span></span><br><span class="line">row = table.row(<span class="string">b'row-key'</span>, columns=[<span class="string">b'cf1:col1'</span>], include_timestamp=<span class="literal">True</span>)</span><br><span class="line">value, timestamp = row[<span class="string">b'cf1:col1'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历某个rowkey区间</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.rows([<span class="string">b'row-key-1'</span>, <span class="string">b'row-key-2'</span>]):</span><br><span class="line">    print(key, data)  <span class="comment"># prints row key and data for each row</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询某个cell的某个版本</span></span><br><span class="line">values = table.cells(<span class="string">b'row-key'</span>, <span class="string">b'cf1:col1'</span>, versions=<span class="number">2</span>)</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> values:</span><br><span class="line">    print(<span class="string">"Cell data: &#123;&#125;"</span>.format(value))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 带时间戳的查询某个cell的某个版本</span></span><br><span class="line">cells = table.cells(<span class="string">b'row-key'</span>, <span class="string">b'cf1:col1'</span>, versions=<span class="number">3</span>, include_timestamp=<span class="literal">True</span>)</span><br><span class="line"><span class="keyword">for</span> value, timestamp <span class="keyword">in</span> cells:</span><br><span class="line">    print(<span class="string">"Cell data at &#123;&#125;: &#123;&#125;"</span>.format(timestamp, value))</span><br><span class="line"></span><br><span class="line"><span class="comment">########################   扫描   ###################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全表扫描</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.scan():</span><br><span class="line">    print(key, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从某行开始扫描</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.scan(row_start=<span class="string">b'aaa'</span>):</span><br><span class="line">    print(key, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描到某行结束</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.scan(row_stop=<span class="string">b'xyz'</span>):</span><br><span class="line">    print(key, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描区间</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.scan(row_start=<span class="string">b'aaa'</span>, row_stop=<span class="string">b'xyz'</span>):</span><br><span class="line">    print(key, data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 扫描行前缀</span></span><br><span class="line"><span class="keyword">for</span> key, data <span class="keyword">in</span> table.scan(row_prefix=<span class="string">b'row'</span>):</span><br><span class="line">    print(key, data)  <span class="comment"># prints 'value1' and 'value2'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#########################  删除  ############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除某条数据</span></span><br><span class="line">table.delete(<span class="string">b'row-key'</span>)</span><br><span class="line"><span class="comment"># 删除某行的某写列</span></span><br><span class="line">table.delete(<span class="string">b'row-key'</span>, columns=[<span class="string">b'cf1:col1'</span>, <span class="string">b'cf1:col2'</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">########################## 批量  #############################</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量操作</span></span><br><span class="line"><span class="keyword">with</span> table.batch() <span class="keyword">as</span> b:</span><br><span class="line">    b.put(<span class="string">b'row-key-1'</span>, &#123;<span class="string">b'cf:col1'</span>: <span class="string">b'value1'</span>, <span class="string">b'cf:col2'</span>: <span class="string">b'value2'</span>&#125;)</span><br><span class="line">    b.put(<span class="string">b'row-key-2'</span>, &#123;<span class="string">b'cf:col2'</span>: <span class="string">b'value2'</span>, <span class="string">b'cf:col3'</span>: <span class="string">b'value3'</span>&#125;)</span><br><span class="line">    b.put(<span class="string">b'row-key-3'</span>, &#123;<span class="string">b'cf:col3'</span>: <span class="string">b'value3'</span>, <span class="string">b'cf:col4'</span>: <span class="string">b'value4'</span>&#125;)</span><br><span class="line">    b.delete(<span class="string">b'row-key-4'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量事务</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">with</span> table.batch(transaction=<span class="literal">True</span>) <span class="keyword">as</span> b:</span><br><span class="line">        b.put(<span class="string">b'row-key-1'</span>, &#123;<span class="string">b'cf:col1'</span>: <span class="string">b'value1'</span>, <span class="string">b'cf:col2'</span>: <span class="string">b'value2'</span>&#125;)</span><br><span class="line">        b.put(<span class="string">b'row-key-2'</span>, &#123;<span class="string">b'cf:col2'</span>: <span class="string">b'value2'</span>, <span class="string">b'cf:col3'</span>: <span class="string">b'value3'</span>&#125;)</span><br><span class="line">        b.put(<span class="string">b'row-key-3'</span>, &#123;<span class="string">b'cf:col3'</span>: <span class="string">b'value3'</span>, <span class="string">b'cf:col4'</span>: <span class="string">b'value4'</span>&#125;)</span><br><span class="line">        b.delete(<span class="string">b'row-key-4'</span>)</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">"Something went wrong!"</span>)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 批次操作</span></span><br><span class="line"><span class="keyword">with</span> table.batch(batch_size=<span class="number">1000</span>) <span class="keyword">as</span> b:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1200</span>):</span><br><span class="line">        b.put(<span class="string">b'row-%04d'</span> % i, &#123;</span><br><span class="line">            <span class="string">b'cf1:col1'</span>: <span class="string">b'v1'</span>,</span><br><span class="line">            <span class="string">b'cf1:col2'</span>: <span class="string">b'v2'</span>,</span><br><span class="line">        &#125;)</span><br></pre></td></tr></table></figure><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><ul><li><a href="https://hbase.apache.org/apache_hbase_reference_guide.pdf" target="_blank" rel="noopener">官方文档</a></li><li><a href="https://happybase.readthedocs.io/en/latest/" target="_blank" rel="noopener">happybase文档</a></li><li><a href="https://learnhbase.net/2013/03/02/hbase-shell-commands/" target="_blank" rel="noopener">终端命令总结</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>架构概览</title>
      <link href="architecture/outline.html"/>
      <url>architecture/outline.html</url>
      
        <content type="html"><![CDATA[<p>架构已重构开始，学习以重构开始，编程就是在重构中不停的实践成长。</p><p>架构涉及到前段、后端、服务器、分布式、数据库等各个方面，当然也要考虑现有的业务场景和资源。最好的架构就是在满足当下的需求时还能很好很快的我实现。</p><p>架构设计技术线路图<br>基础：git、自动发布、单元测试、数据表结构<br>开发：数据表结构、nginx配置、后端web、前端、爬虫<br>中级：设计模式、分布式基础、高并发<br>高级：高可用、高并发、分布式底层、大数据</p><p>重构代码<br>一、单个函数内的逻辑进行优化。</p><ul><li>参数接口设置</li><li>过多的if else判断进行剪枝处理</li><li>过长的代码需要封装和拆分</li><li>重复代码进行子方法或者拆分处理<br>二、多函数归类、封装、复用</li></ul><p>三、多个类封装</p><p>四、以来多个项目优化</p><p>函数重构<br>1.函数的参数</p><ul><li>必需传入的不能设置默认参数，让逻辑自动判断错误；不是必传入的，则设置默认值</li></ul><p>在不停的重构中，形成一定的规范，在后续开发中，直接用规范来开发，便于项目的优质</p><p>以测试驱动编程，那么就要代码结构便于测试，逻辑需要拆分合理。对于web后端来说，需要把</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>架构</title>
      <link href="architecture/index.html"/>
      <url>architecture/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h1><ul><li><a href="distribution/raft.html">raft</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>raft协议</title>
      <link href="architecture/distribution/raft.html"/>
      <url>architecture/distribution/raft.html</url>
      
        <content type="html"><![CDATA[<p>Raft协议</p><ul><li>每个副本都会处于三种状态之一：Leader、Follower、Candidate。<ul><li>Leader：所有请求的处理者，Leader副本接受client的更新请求，本地处理后再同步至多个其他副本；</li><li>Follower：请求的被动更新者，从Leader接受更新请求，然后写入本地日志文件</li><li>Candidate：如果Follower副本在一段时间内没有收到Leader副本的心跳，则判断Leader可能已经故障，此时启动选主过程，此时副本会变成Candidate状态，直到选主结束。</li></ul></li><li>时间被分为很多连续的随机长度的term，term有唯一的id。每个term一开始就进行选主<ul><li><ol><li>Follower将自己维护的current_term_id加1。</li></ol></li><li><ol start="2"><li>然后将自己的状态转成Candidate</li></ol></li><li><ol start="3"><li>发送RequestVoteRPC消息(带上current_term_id) 给 其它所有server</li></ol></li></ul></li><li>投票策略：<ul><li>每个节点只会给每个term投一票，具体的是否同意和后续的Safety有关。</li><li>当投票被瓜分后，所有的candidate同时超时，然后有可能进入新一轮的票数被瓜分，为了避免这个问题，Raft采用一种很简单的方法：每个Candidate的election timeout从150ms-300ms之间随机取，那么第一个超时的Candidate就可以发起新一轮的leader election，带着最大的term_id给其它所有server发送RequestVoteRPC消息，从而自己成为leader，然后给他们发送心跳消息以告诉他们自己是主。</li></ul></li><li>Log Replication</li><li>Log Compaction<ul><li>在实际的系统中，不能让日志无限增长，否则系统重启时需要花很长的时间进行回放，从而影响availability。Raft采用对整个系统进行snapshot来处理，snapshot之前的日志都可以丢弃。Snapshot技术在Chubby和ZooKeeper系统中都有采用。</li><li>Raft使用的方案是：每个副本独立的对自己的系统状态进行Snapshot，并且只能对已经提交的日志记录（已经应用到状态机）进行snapshot。</li><li>Snapshot中包含以下内容：<ul><li>日志元数据，最后一条commited log entry的 (log index, last_included_term)。这两个值在Snapshot之后的第一条log entry的AppendEntriesRPC的consistency check的时候会被用上，之前讲过。一旦这个server做完了snapshot，就可以把这条记录的最后一条log index及其之前的所有的log entry都删掉。</li><li>系统状态机：存储系统当前状态（这是怎么生成的呢？）</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="architecture/distribution/index.html"/>
      <url>architecture/distribution/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分布式系统概念与设计(原书第5版)</title>
      <link href="books/distribution-system-5th/index.html"/>
      <url>books/distribution-system-5th/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-分布式系统的特征"><a href="#第1章-分布式系统的特征" class="headerlink" title="第1章 分布式系统的特征"></a>第1章 分布式系统的特征</h1><p>分布式系统是其组件分布在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统。</p><ul><li>组件的并发性、缺乏全局时钟、组件故障的独立性</li></ul><p>资源共享是构造分布式系统的主要动机。资源可以被服务器管理，由客户访问，或者它们被封装成对象，由其他客户对象访问。</p><p>构造分布式系统的挑战是处理其组件的异构性、开放性（允许增加或替换组件）、安全性、可伸缩性（用户的负载或数量增加时能正常运行的能力）、故障处理、组件的并发性、透明性和提供服务质量的问题。</p><h2 id="1-1简介"><a href="#1-1简介" class="headerlink" title="1.1简介"></a>1.1简介</h2><p>我们把分布式系统定义成一个其硬件或软件组件分布在连网的计算机上，组件之间通过传递消息进行通信和动作协调的系统。这个简单的定义覆盖了所有可有效部署连网计算机的系统.</p><p>显著特征:</p><ul><li>并发</li><li>缺乏全局时钟。在程序需要协作时，它们通过交换消息来协调它们的动作。密切的协作通常取决于对程序动作发生的时间的共识。</li><li>故障独立性。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>正则基础</title>
      <link href="man/re/base.html"/>
      <url>man/re/base.html</url>
      
        <content type="html"><![CDATA[<p>目前正则表达式引擎主要有两种：NFA 和 DFA，当然还有一个POXI NFA，但是用的不多。</p><p>NFA 是指 Nondeterministic Finite Automaton，非确定有限状态自动机。</p><p>问题：</p><ul><li>那么正则和状态机有什么关系？</li><li>什么是状态机、状态机的用处？</li><li>什么是有限状态机，确定和不确定又是什么？</li><li>状态机和集合的关系如何，对应着什么数学模型？</li><li>如何用状态机原理实现一个正则引擎？</li></ul><p>有穷自动机（Finite Automate）是用来模拟实物系统的数学模型，它包括如下五个部分：</p><ul><li>有穷状态集States</li><li>输入字符集Input symbols</li><li>转移函数Transitions</li><li>起始状态Start state</li><li>接受状态Accepting state(s)(终止状态)</li></ul><p>有穷自动机，按照转移函数的不同，又可分为</p><ul><li>确定型有穷自动机（Determinism Finite Automate, DFA）</li><li>非确定型有穷自动机（Non-determinism Finite Automate, NFA）。非确定有穷自动机容许转移函数不确定，换句话说，对任意状态，输入任意一个字符，可以转移到0个，1个或者多个状态。</li></ul><p>自动机理论</p><p>有限状态机（Automation）</p><p>动作类型：</p><ul><li>进入动作（entry action）：在进入状态时进行</li><li>退出动作（exit action）：在退出状态时进行</li><li>输入动作：依赖于当前状态和输入条件进行</li><li>转移动作：在进行特定转移时进行</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>每天5分钟玩转kubernetes</title>
      <link href="books/every-day-five-minutes-k8s/index.html"/>
      <url>books/every-day-five-minutes-k8s/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="第1章-先把Kubernetes跑起来"><a href="#第1章-先把Kubernetes跑起来" class="headerlink" title="第1章　先把Kubernetes跑起来"></a>第1章　先把Kubernetes跑起来</h1><p>对于Kubernetes这项平台级技术，覆盖的技术范围非常广，包括计算、网络、存储、高可用、监控、日志管理等多个方面</p><p>Kubernetes是Google Omega的开源版本。</p><p>讨论Kubernetes重要的概念和架构，学习Kubernetes如何编排容器，包括优化资源利用、高可用、滚动更新、网络插件、服务发现、监控、数据管理、日志管理等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 启动</span></span><br><span class="line">minikube start</span><br><span class="line"><span class="comment"># 获取节点</span></span><br><span class="line">kubectl get nodes</span><br><span class="line"><span class="comment"># 查看集群信息</span></span><br><span class="line">kubectl cluster-info</span><br><span class="line">kubectl cluster-info dump</span><br><span class="line"><span class="comment"># 启动一个应用</span></span><br><span class="line">kubectl run &lt;app-name&gt; --image=&lt;image-url&gt; --port=8080</span><br></pre></td></tr></table></figure><p>Pod是容器的集合，通常会将紧密相关的一组容器放到一个Pod中，同一个Pod中的所有容器共享IP地址和Port空间，也就是说它们在一个network namespace中。<br>Pod是Kubernetes调度的最小单位，同一Pod中的容器始终被一起调度。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有的pods</span></span><br><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure><h3 id="1-4-访问应用"><a href="#1-4-访问应用" class="headerlink" title="1.4　访问应用"></a>1.4　访问应用</h3><p>默认情况下，所有Pod只能在集群内部访问。为了能够从外部访问应用，我们需要将容器的8080端口映射到节点的端口。端口号是随机分配的</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployments/&lt;app-name&gt; --<span class="built_in">type</span>=<span class="string">"NodePort"</span> --port=8080</span><br><span class="line"><span class="comment"># 可以查看应用被映射到节点的哪个端口</span></span><br><span class="line">kubectl get services</span><br></pre></td></tr></table></figure><h3 id="1-5-Scale应用"><a href="#1-5-Scale应用" class="headerlink" title="1.5 Scale应用"></a>1.5 Scale应用</h3><p>默认情况下应用只会运行一个副本，可以通过kubectl get deployments查看副本数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure><ul><li><p>执行如下命令将副本数增加到3个</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/&lt;app-name&gt; --replicas=3</span><br></pre></td></tr></table></figure></li><li><p>要scale down也很方便，执行下列命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl scale deployments/&lt;app-name&gt; --replicas=2</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-6-滚动更新"><a href="#1-6-滚动更新" class="headerlink" title="1.6　滚动更新"></a>1.6　滚动更新</h3><ul><li><p>当前应用使用的image版本为v1，执行如下命令将其升级到v2</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">set</span> image deployments/&lt;app-name&gt; &lt;app-name&gt;=&lt;new-image-url&gt;</span><br></pre></td></tr></table></figure></li><li><p>如果要回退到v1版本也很容易，执行kubectl rollout undo命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl rollout undo deployments/&lt;app-name&gt;</span><br></pre></td></tr></table></figure></li></ul><h1 id="第2章-重要概念"><a href="#第2章-重要概念" class="headerlink" title="第2章　重要概念"></a>第2章　重要概念</h1><p>1．Cluster</p><ul><li>Cluster是计算、存储和网络资源的集合，Kubernetes利用这些资源运行各种基于容器的应用。</li></ul><p>2．Master</p><ul><li>Master是Cluster的大脑，它的主要职责是调度，即决定将应用放在哪里运行。Master运行Linux操作系统，可以是物理机或者虚拟机。为了实现高可用，可以运行多个Master。</li></ul><p>3．Node</p><ul><li>Node的职责是运行容器应用。Node由Master管理，Node负责监控并汇报容器的状态，同时根据Master的要求管理容器的生命周期。Node运行在Linux操作系统上，可以是物理机或者是虚拟机。</li></ul><p>4．Pod</p><ul><li>Pod是Kubernetes的最小工作单元。每个Pod包含一个或多个容器。Pod中的容器会作为一个整体被Master调度到一个Node上运行。</li><li>Kubernetes引入Pod主要基于下面两个目的：<ul><li>（1）可管理性。有些容器天生就是需要紧密联系，一起工作。Pod提供了比容器更高层次的抽象，将它们封装到一个部署单元中。Kubernetes以Pod为最小单位进行调度、扩展、共享资源、管理生命周期。</li><li>（2）通信和资源共享。Pod中的所有容器使用同一个网络namespace，即相同的IP地址和Port空间。它们可以直接用localhost通信。同样的，这些容器可以共享存储，当Kubernetes挂载volume到Pod，本质上是将volume挂载到Pod中的每一个容器。</li></ul></li><li>Pods有两种使用方式：<ul><li>（1）运行单一容器。</li><li>（2）运行多个容器。这些容器联系必须非常紧密，而且需要直接共享资源。</li></ul></li></ul><p>5．Controller</p><ul><li>Kubernetes通常不会直接创建Pod，而是通过Controller来管理Pod的。</li><li>Controller中定义了Pod的部署特性，比如有几个副本、在什么样的Node上运行等。为了满足不同的业务场景，Kubernetes提供了多种Controller，包括Deployment、ReplicaSet、DaemonSet、StatefuleSet、Job等，我们逐一讨论。<ul><li>（1）Deployment是最常用的Controller，Deployment可以管理Pod的多个副本，并确保Pod按照期望的状态运行。</li><li>（2）ReplicaSet实现了Pod的多副本管理。使用Deployment时会自动创建ReplicaSet，也就是说Deployment是通过ReplicaSet来管理Pod的多个副本的，我们通常不需要直接使用ReplicaSet。</li><li>（3）DaemonSet用于每个Node最多只运行一个Pod副本的场景。正如其名称所揭示的，DaemonSet通常用于运行daemon。</li><li>（4）StatefuleSet能够保证Pod的每个副本在整个生命周期中名称是不变的，而其他Controller不提供这个功能。当某个Pod发生故障需要删除并重新启动时，Pod的名称会发生变化，同时StatefuleSet会保证副本按照固定的顺序启动、更新或者删除。</li><li>（5）Job用于运行结束就删除的应用，而其他Controller中的Pod通常是长期持续运行。</li></ul></li></ul><p>6．Service</p><ul><li>Deployment可以部署多个副本，每个Pod都有自己的IP，外界如何访问这些副本呢？通过Pod的IP吗？要知道Pod很可能会被频繁地销毁和重启，它们的IP会发生变化，用IP来访问不太现实。</li><li>Kubernetes Service定义了外界访问一组特定Pod的方式。Service有自己的IP和端口，Service为Pod提供了负载均衡。</li><li>Kubernetes运行容器（Pod）与访问容器（Pod）这两项任务分别由Controller和Service执行。</li></ul><p>7．Namespace</p><ul><li>Namespace可以将一个物理的Cluster逻辑上划分成多个虚拟Cluster，每个Cluster就是一个Namespace。不同Namespace里的资源是完全隔离的。<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get namespace</span><br></pre></td></tr></table></figure></li><li>kubernetes默认有3个命名空间<ul><li>default：创建资源时如果不指定，将被放到这个Namespace中。</li><li>kube-system：Kubernetes自己创建的系统资源将放到这个Namespace中。</li></ul></li></ul><h1 id="第3章-部署Kubernetes-Cluster"><a href="#第3章-部署Kubernetes-Cluster" class="headerlink" title="第3章　部署Kubernetes Cluster"></a>第3章　部署Kubernetes Cluster</h1><p>kubelet运行在Cluster所有节点上，负责启动Pod和容器。kubeadm用于初始化Cluster。kubectl是Kubernetes命令行工具。通过kubectl可以部署和管理应用，查看各种资源，创建、删除和更新各种组件。</p><h3 id="3-3-1-初始化Master"><a href="#3-3-1-初始化Master" class="headerlink" title="3.3.1　初始化Master"></a>3.3.1　初始化Master</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm --apiserver-advertise-address 192.168.56.105 --pod-network-cidr=10.244.0.0/16</span><br></pre></td></tr></table></figure><ul><li>–apiserver-advertise-address指明用Master的哪个interface与Cluster的其他节点通信。如果Master有多个interface，建议明确指定，如果不指定，kubeadm会自动选择有默认网关的interface。</li><li>–pod-network-cidr指定Pod网络的范围。Kubernetes支持多种网络方案，而且不同网络方案对–pod-network-cidr有自己的要求，这里设置为10.244.0.0/16是因为我们将使用flannel网络方案，必须设置成这个CIDR。在后面的实践中我们会切换到其他网络方案，比如Canal。</li></ul><h3 id="3-3-2-配置kubectl"><a href="#3-3-2-配置kubectl" class="headerlink" title="3.3.2　配置kubectl"></a>3.3.2　配置kubectl</h3><h3 id="3-3-3-安装Pod网络"><a href="#3-3-3-安装Pod网络" class="headerlink" title="3.3.3　安装Pod网络"></a>3.3.3　安装Pod网络</h3><h3 id="3-3-4-添加k8s-node1和k8s-node2"><a href="#3-3-4-添加k8s-node1和k8s-node2" class="headerlink" title="3.3.4　添加k8s-node1和k8s-node2"></a>3.3.4　添加k8s-node1和k8s-node2</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join --token  &lt;token&gt; &lt;ip&gt;:&lt;port&gt;</span><br></pre></td></tr></table></figure><h1 id="第4章-Kubernetes架构"><a href="#第4章-Kubernetes架构" class="headerlink" title="第4章　Kubernetes架构"></a>第4章　Kubernetes架构</h1><p>Kubernetes Cluster由Master和Node组成，节点上运行着若干Kubernetes服务。</p><h2 id="4-1-Master节点"><a href="#4-1-Master节点" class="headerlink" title="4.1　Master节点"></a>4.1　Master节点</h2><p>Master是Kubernetes Cluster的大脑，运行着的Daemon服务包括kube-apiserver、kube-scheduler、kube-controller-manager、etcd和Pod网络（例如flannel）</p><p>1．API Server（kube-apiserver）</p><ul><li>API Server提供HTTP/HTTPS RESTful API，即Kubernetes API。</li><li>API Server是KubernetesCluster的前端接口，各种客户端工具（CLI或UI）以及Kubernetes其他组件可以通过它管理Cluster的各种资源。</li></ul><p>2．Scheduler（kube-scheduler）</p><ul><li>Scheduler负责决定将Pod放在哪个Node上运行。</li><li>Scheduler在调度时会充分考虑Cluster的拓扑结构，当前各个节点的负载，以及应用对高可用、性能、数据亲和性的需求。</li></ul><p>3．Controller Manager（kube-controller-manager）</p><ul><li>Controller Manager负责管理Cluster各种资源，保证资源处于预期的状态</li><li>ControllerManager由多种controller组成，包括replication controller、endpoints controller、namespace controller、serviceaccounts controller等。</li></ul><p>4．etcd</p><ul><li>etcd负责保存Kubernetes Cluster的配置信息和各种资源的状态信息。</li><li>当数据发生变化时，etcd会快速地通知Kubernetes相关组件。</li></ul><p>5．Pod网络</p><ul><li>Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案。</li></ul><h2 id="4-2-Node节点"><a href="#4-2-Node节点" class="headerlink" title="4.2　Node节点"></a>4.2　Node节点</h2><p>Node是Pod运行的地方，Kubernetes支持Docker、rkt等容器Runtime。<br>Node上运行的Kubernetes组件有kubelet、kube-proxy和Pod网络（例如flannel）</p><p>1．kubelet</p><ul><li>kubelet是Node的agent，当Scheduler确定在某个Node上运行Pod后，会将Pod的具体配置信息（image、volume等）发送给该节点的kubelet，kubelet根据这些信息创建和运行容器，并向Master报告运行状态。</li></ul><p>2．kube-proxy</p><ul><li>service在逻辑上代表了后端的多个Pod，外界通过service访问Pod。</li><li>每个Node都会运行kube-proxy服务，它负责将访问service的TCP/UPD数据流转发到后端的容器。如果有多个副本，kube-proxy会实现负载均衡。</li></ul><p>3．Pod网络</p><ul><li>Pod要能够相互通信，Kubernetes Cluster必须部署Pod网络，flannel是其中一个可选方案。</li></ul><h1 id="第5章-运行应用"><a href="#第5章-运行应用" class="headerlink" title="第5章　运行应用"></a>第5章　运行应用</h1><h2 id="5-1-Deployment"><a href="#5-1-Deployment" class="headerlink" title="5.1　Deployment"></a>5.1　Deployment</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 部署一个nginx deployment</span></span><br><span class="line">kubectl run nginx-deployment --image=1.7.9 --replicas=2</span><br><span class="line"><span class="comment"># 查看deployment 状态</span></span><br><span class="line">kubectl get deployment nginx-deployment</span><br><span class="line"><span class="comment"># 查看详细信息</span></span><br><span class="line">kubectl describe deployment nginx-deployment</span><br><span class="line"><span class="comment"># 查看每个副本情况</span></span><br><span class="line">kubectl describe replicaset nginx-deployment-12360345</span><br><span class="line"><span class="comment"># 查看pod详情</span></span><br><span class="line">kubectl describe pod &lt;pod-name&gt;</span><br></pre></td></tr></table></figure><h3 id="5-1-2-命令vs配置文件"><a href="#5-1-2-命令vs配置文件" class="headerlink" title="5.1.2　命令vs配置文件"></a>5.1.2　命令vs配置文件</h3><p>通过配置文件和kubectl apply创建</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply<span class="_">-f</span> nginx.yml</span><br></pre></td></tr></table></figure><h3 id="5-1-3-Deployment配置文件简介"><a href="#5-1-3-Deployment配置文件简介" class="headerlink" title="5.1.3　Deployment配置文件简介"></a>5.1.3　Deployment配置文件简介</h3><p>①apiVersion是当前配置格式的版本。<br>②kind是要创建的资源类型，这里是Deployment。<br>③metadata是该资源的元数据，name是必需的元数据项。<br>④spec部分是该Deployment的规格说明。<br>⑤replicas指明副本数量，默认为1。<br>⑥template定义Pod的模板，这是配置文件的重要部分。<br>⑦metadata定义Pod的元数据，至少要定义一个label。label的key和value可以任意指定。<br>⑧spec描述Pod的规格，此部分定义Pod中每一个容器的属性，name和image是必需的。</p><h3 id="5-1-4-伸缩"><a href="#5-1-4-伸缩" class="headerlink" title="5.1.4　伸缩"></a>5.1.4　伸缩</h3><h3 id="5-1-5-Failover"><a href="#5-1-5-Failover" class="headerlink" title="5.1.5　Failover"></a>5.1.5　Failover</h3><h3 id="5-1-6-用label控制Pod的位置"><a href="#5-1-6-用label控制Pod的位置" class="headerlink" title="5.1.6　用label控制Pod的位置"></a>5.1.6　用label控制Pod的位置</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看节点label</span></span><br><span class="line">kubectl get node --show-labels</span><br></pre></td></tr></table></figure><h2 id="5-2-DaemonSet"><a href="#5-2-DaemonSet" class="headerlink" title="5.2　DaemonSet"></a>5.2　DaemonSet</h2><p>Deployment部署的副本Pod会分布在各个Node上，每个Node都可能运行好几个副本。DaemonSet的不同之处在于：每个Node上最多只能运行一个副本。<br>DaemonSet的典型应用场景有：</p><ul><li>（1）在集群的每个节点上运行存储Daemon，比如glusterd或ceph。</li><li>（2）在每个节点上运行日志收集Daemon，比如flunentd或logstash。</li><li>（3）在每个节点上运行监控Daemon，比如Prometheus Node Exporter或collectd。</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get daemon-set --namespace=kube-system</span><br></pre></td></tr></table></figure><h2 id="5-3-Job"><a href="#5-3-Job" class="headerlink" title="5.3　Job"></a>5.3　Job</h2><p>容器按照持续运行的时间可分为两类：服务类容器和工作类容器。</p><ul><li>服务类容器通常持续提供服务，需要一直运行，比如HTTP Server、Daemon等。</li><li>工作类容器则是一次性任务，比如批处理程序，完成后容器就退出。<br>Kubernetes的Deployment、ReplicaSet和DaemonSet都用于管理服务类容器；对于工作类容器，我们使用Job。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>《深入分布式缓存:从原理到实践》读书笔记</title>
      <link href="books/deep-analysis-distributed-cache/index.html"/>
      <url>books/deep-analysis-distributed-cache/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-缓存为王"><a href="#第1章-缓存为王" class="headerlink" title="第1章 缓存为王"></a>第1章 缓存为王</h2><h3 id="1-1-什么是缓存？"><a href="#1-1-什么是缓存？" class="headerlink" title="1.1 什么是缓存？"></a>1.1 什么是缓存？</h3><p>我们平时在编程的时候，接触到的都是虚拟地址而不是真实的物理地址，这是虚拟内存的主要功能之一。假如请求一个页的地址，需要将页的虚拟地址转化为页的物理地址。页表（pagetable）和内存管理单元（MMU）就负责将页的虚拟地址映射到物理地址。页表负责记录哪些是物理页，哪些是虚拟页，以及这些页的页表条目（PTE）。而MMU是一个物理硬件，MMU负责进行虚拟地址到物理地址的翻译，翻译过程中需要从页表获取页的PTE, MMU也会使用翻译后备缓存器（TLB）的缓存页号。可见，在操作系统层面都有缓存。</p><ul><li>根据在软件系统中所处位置的不同，缓存大体可以分为三类：<ul><li>客户端缓存；</li><li>服务端缓存；</li><li>网络中的缓存。</li></ul></li><li>根据规模和部署方式缓存也可以分为：<ul><li>单体缓存；</li><li>缓存集群；</li><li>分布式缓存。</li></ul></li></ul><h3 id="1-2-为什么使用缓存？"><a href="#1-2-为什么使用缓存？" class="headerlink" title="1.2 为什么使用缓存？"></a>1.2 为什么使用缓存？</h3><blockquote><p> 关于系统的性能</p></blockquote><ul><li>系统性能的指标一般包括响应时间、延迟时间、吞吐量，并发用户数和资源利用率等几个方面。<ul><li>响应时间是指系统对用户请求做出响应的时间</li><li>吞吐量是指系统在单位时间内处理请求的数量。</li><li>并发用户数是指系统可以同时承载的正常使用系统功能的用户数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。而资源利用率反映的是在一段时间内资源平均被占用的情况。</li></ul></li></ul><p>从浏览器到网络，再到应用服务器，甚至到数据库，通过在各个层面应用缓存技术，整个系统的性能将大幅提高</p><p>使用缓存技术，可以降低系统的响应时间，减少网络传输时间和应用延迟时间，进而提高了系统的吞吐量，增加了系统的并发用户数。</p><h3 id="1-3-从网站的架构发展看缓存"><a href="#1-3-从网站的架构发展看缓存" class="headerlink" title="1.3 从网站的架构发展看缓存"></a>1.3 从网站的架构发展看缓存</h3><p><img data-src="assets/web-architecture.png" alt="架构图"></p><h3 id="1-4-客户端缓存"><a href="#1-4-客户端缓存" class="headerlink" title="1.4 客户端缓存"></a>1.4 客户端缓存</h3><h4 id="1-4-1-页面缓存"><a href="#1-4-1-页面缓存" class="headerlink" title="1.4.1 页面缓存"></a>1.4.1 页面缓存</h4><p>页面缓存有两层含义：一个是页面自身对某些元素或全部元素进行缓存；另一层意思是服务端将静态页面或动态页面的元素进行缓存，然后给客户端使用。</p><p>HTML5中使用本地缓存的方法也很简单，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem()</span><br><span class="line">localStorage.getItem()</span><br></pre></td></tr></table></figure><p>HTML5提供的离线应用缓存机制，使得网页应用可以离线使用，这种机制在浏览器上支持度非常广，可以放心地使用该特性来加速页面的访问。开启离线缓存的步骤如下：</p><ul><li>1）准备用于描述页面需要缓存的资源列表清单文件（manifest text/cache-manifest）。</li><li>2）在需要离线使用的页面中添加manifest属性，指定缓存清单文件的路径。</li></ul><h4 id="1-4-2-浏览器缓存"><a href="#1-4-2-浏览器缓存" class="headerlink" title="1.4.2 浏览器缓存"></a>1.4.2 浏览器缓存</h4><p>浏览器缓存是根据一套与服务器约定的规则进行工作的，工作规则很简单：检查以确保副本是最新的，通常只要一次会话。</p><p>HTTP1.0提供了一些很基本的缓存特性。服务器侧设置Expires的HTTP头来告诉客户端在重新请求文件之前缓存多久是安全的，可以通过if-modified-since的条件请求来使用缓存。其中，发送的时间是文件最初被下载的时间，而不是即将过期的时间，如果文件没有改变，服务器可以用304-Not Modified来应答。客户端收到304代码，就可以使用缓存的文件版本了。</p><p>HTTP 1.1有了较大的增强，缓存系统被形式化了，引入了实体标签e-tag。e-tag是文件或对象的唯一标识，这意味着可以请求一个资源，以及提供所持有的文件，然后询问服务器这个文件是否有变化。如果某一个文件的e-tag是有效的，那么服务器会生成304-Not Modified应答，并提供正确文件的e-tag，否则，发送200-OK应答</p><p>Last-Modified/ETag与Cache-Control/Expires的作用是不一样的，如果检测到本地的缓存还在有效的时间范围内，浏览器则直接使用本地缓存，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（e-tag）了。</p><p>Cache-Control与Expires的功能一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间，当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用服务端的返回码304，从而减少响应开销。</p><h4 id="1-4-3-APP上的缓存"><a href="#1-4-3-APP上的缓存" class="headerlink" title="1.4.3 APP上的缓存"></a>1.4.3 APP上的缓存</h4><p>APP可以将内容缓存在内存、文件或本地数据库（例如SQLite）中，但基于内存的缓存要谨慎使用。</p><h3 id="1-5-网络中的缓存"><a href="#1-5-网络中的缓存" class="headerlink" title="1.5 网络中的缓存"></a>1.5 网络中的缓存</h3><p>网络中的缓存位于客户端和服务端之间，代理或响应客户端的网络请求，从而对重复的请求返回缓存中的数据资源。同时，接受服务端的请求，更新缓存中的内容。</p><h4 id="1-5-1-Web代理缓存"><a href="#1-5-1-Web代理缓存" class="headerlink" title="1.5.1 Web代理缓存"></a>1.5.1 Web代理缓存</h4><p>Web代理几乎是伴随着互联网诞生的，常用的Web代理分为正向代理、反向代理和透明代理。Web代理缓存是将Web代理作为缓存的一种技术。</p><p>反向代理与正向代理相反，对于客户端而言代理服务器就像是源服务器，并且客户端不需要进行设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处转发请求，并将从源服务器获得的内容返回给客户端。</p><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，由代理服务器改变客户端请求的报文字段，并会传送真实的IP地址。<br>加密的透明代理属于匿名代理，不用设置就可以使用代理了。透明代理的例子就是时下很多公司使用的行为管理软件。</p><p>对于Web代理缓存而言，较流行的是Squid，它支持建立复杂的缓存层级结构，拥有详细的日志、高性能缓存以及用户认证支持</p><h4 id="1-5-2-边缘缓存"><a href="#1-5-2-边缘缓存" class="headerlink" title="1.5.2 边缘缓存"></a>1.5.2 边缘缓存</h4><p>如果这些反向代理服务器能够做到和用户来自同一个网络，那么用户访问反向代理服务器，就会得到很高质量的响应速度，所以可以将这样的反向代理缓存称为边缘缓存。</p><p>边缘缓存在网络上位于靠近用户的一侧，可以处理来自不同用户的请求，主要用于向用户提供静态的内容，以减少应用服务器的介入</p><p>边缘缓存中典型的商业化服务就是CDN了</p><p>CDN边缘节点的缓存策略因服务商不同而有所变化，但一般都会遵循HTTP标准协议，通过HTTP响应头中的Cache-control: max-age的字段来设置CDN边缘节点的数据缓存时间</p><p>一般地，CDN边缘节点对开发者来说是透明的，开发者可以通过CDN服务商提供的“刷新缓存”接口来清理位于CDN边缘节点上的缓存数据</p><h3 id="1-6-服务端缓存"><a href="#1-6-服务端缓存" class="headerlink" title="1.6 服务端缓存"></a>1.6 服务端缓存</h3><h4 id="1-6-1-数据库缓存"><a href="#1-6-1-数据库缓存" class="headerlink" title="1.6.1 数据库缓存"></a>1.6.1 数据库缓存</h4><p>数据库缓存是一类特殊的缓存，是数据库自身的缓存机制。</p><p>大多数数据库不需要配置就可以快速运行，但并没有为特定的需求进行优化。在数据库调优的时候，缓存优化是一项很重要的工作。</p><blockquote><ol><li>MySQL的查询缓存</li></ol></blockquote><p>Query cache作用于整个MySQL实例，主要用于缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。</p><ul><li>Query Cache的使用需要多个参数配合，其中最为关键的是query_cache_size和query_cache_type，前者设置用于缓存ResultSet的内存大小，后者设置在何种场景下使用Query Cache。这可以通过计算Query Cache的命中率来进行调整。query_cache_type可以设置为0（OFF）,1（ON）或者2（DEMAND），分别表示完全不使用Query Cache，除显式要求不使用Query Cache之外的所有select都使用Query Cache，以及只有显式要求才使用Query Cache。</li></ul><blockquote><p>2．检验Query Cache的合理性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query_cache%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><p>通过调节以下几个参数可以知道query_cache_size设置得是否合理：</p><ul><li>Qcache inserts</li><li>Qcache hits<ul><li>如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；</li></ul></li><li>Qcache lowmem prunes<ul><li>如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况</li></ul></li><li>Qcache free blocks<ul><li>Qcache_free_blocks值非常大，则表明缓存区中的碎片很多，可能需要寻找合适的机会进行整理。</li></ul></li></ul><p>其中Qcache_hits表示多少次命中，通过这个参数我们可以查看到Query Cache的基本效果；而Qcache_inserts表示多少次未命中然后插入。通过“Qcache_hits”和“Qcache_inserts”两个参数可以算出Query Cache的命中率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query Cache 命中率&#x3D;Qcache_hits&#x2F;(Qcache_hits + Qcache_inserts)</span><br></pre></td></tr></table></figure><p>Qcache_lowmem_prunes表示多少条Query因为内存不足而被清除出Query Cache。通过Qcache_lowmem_prunes和Qcache_free_memory相互结合，能够更清楚地了解到系统中Query Cache的内存大小是否真的足够，是否频繁的出现因为内存不足而有Query被换出的情况。</p><blockquote><ol start="3"><li>InnoDB的缓存性能</li></ol></blockquote><p>当使用InnoDB存储引擎的时候，innodb_buffer_pool_size参数可能是影响性能的最为关键的一个参数了，用来设置用于缓存InnoDB索引及数据块的内存区域大小，更像是Oracle数据库的db_cache_size</p><p>可以通过<code>(Innodb_buffer_pool_read_requests - Innodb_buffer_pool_reads) /Innodb_buffer_pool_read_requests*100%</code>计算缓存命中率，并根据命中率来调整<code>innodb_buffer_pool_size</code>参数大小进行优化</p><p>table_cache是一个非常重要的MySQL性能参数，主要用于设置table高速缓存的数量。由于每个客户端连接都会至少访问一个表，因此该参数与max_connections有关。</p><p>在执行缓存操作之前，table_cache参数用于限制缓存表的最大数目：如果当前已经缓存的表未达到table_cache数目，则会将新表添加进来；若已经达到此值，MySQL将根据缓存表的最后查询时间、查询率等规则释放之前的缓存。</p><h4 id="1-6-2-平台级缓存"><a href="#1-6-2-平台级缓存" class="headerlink" title="1.6.2 平台级缓存"></a>1.6.2 平台级缓存</h4><p>平台级缓存在这里指的是用来写带有缓存特性的应用框架，或者可用于缓存功能的专用库（如PHP中的Smarty模板库）。</p><p>在Java语言中，缓存框架更多，例如Ehcache, Cacheonix, Voldemort, JBoss Cache,OSCache等等。</p><h4 id="1-6-3-应用级缓存"><a href="#1-6-3-应用级缓存" class="headerlink" title="1.6.3 应用级缓存"></a>1.6.3 应用级缓存</h4><p>应用级缓存，需要开发者通过代码来实现缓存机制。这里是NoSQL的胜场，不论是Redis还是MongoDB，以及Memcached都可以作为应用级缓存的重要技术。一种典型的方式是每分钟或一段时间后统一生成某类页面存储在缓存中，或者可以在热数据变化时更新缓存。</p><blockquote><p>1．面向Redis的缓存应用</p></blockquote><p>Redis集群采用无中心节点方式实现，无需proxy代理，客户端直接与Redis集群的每个节点连接，根据同样的哈希算法计算出key对应的slot，然后直接在slot对应的Redis上执行命令。在Redis看来，响应时间是最苛刻的条件，增加一层带来的开销是不能接受的。因此，Redis实现了客户端对节点的直接访问，为了去中心化，节点之间通过Gossip协议交换相互的状态，以及探测新加入的节点信息</p><p>所有的Redis节点通过PING-PONG机制彼此互联，内部使用二进制协议优化传输速度和带宽。节点故障是通过集群中超过半数的节点检测失效时才会生效。</p><blockquote><p>2．多级缓存实例</p></blockquote><p>多级缓存示例<br><img data-src="assets/mulit_level_cache.png" alt="多级缓存"></p><blockquote><p>3．缓存算法</p></blockquote><p>在实现缓存应用的时候，需要了解缓存技术中的几个术语。</p><ul><li>缓存命中：当客户发起一个请求时，系统接收到这个请求，如果该请求的数据是在缓存中，这一数据就会被使用，这一行为叫作缓存命中。</li><li>没有命中：cache miss是没有命中。如果缓存中还有存储空间，那么没有命中的对象会被存储到缓存中来。</li><li>存储成本：当没有缓存命中时，系统会从数据库或其他数据源取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。</li><li>缓存失效：当存储在缓存中的数据需要更新时，就意味着缓存中的这一数据失效了。❑ 替代策略：当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中去除一条旧数据，然后加入一条新数据，而到底应该去除哪些数据，就是由替代策略决定的。</li></ul><p>替代策略的具体实现就是缓存算法，这里简要介绍一下主流的缓存算法：</p><ul><li>（1）Least-Recently-Used（LRU）<ul><li>替换掉最近被请求最少的对象，这种传统策略在实际中应用最广。</li><li>在CPU缓存淘汰和虚拟内存系统中效果很好。然而在直接应用与代理缓存中效果欠佳，因为Web访问的时间局部性常常变化很大。</li><li>浏览器就一般使用了LRU作为缓存算法。新的对象会被放在缓存的顶部，</li></ul></li><li>（2）Least-Frequently-Used（LFU）<ul><li>替换掉访问次数最少的缓存，这一策略意图是保留最常用的、最流行的对象，替换掉很少使用的那些数据。</li></ul></li><li>（3）Least Recently Used 2（LRU2）<ul><li>LRU的变种，把被两次访问过的对象放入缓存池，当缓存池满了之后，会把有两次最少使用的缓存对象去除。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。</li></ul></li><li>（4）Two Queues（2Q）<ul><li>Two Queues是LRU的另一个变种，把被访问的数据放到LRU的缓存中，如果这个对象再一次被访问，就把他转移到第二个、更大的LRU缓存，使用了多级缓存的方式。去除缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把LRU换成LRU2，就比增加缓存的容量更好。</li></ul></li><li>（5）SIZE<ul><li>替换占用空间最大的对象，这一策略通过淘汰一个大对象而不是多个小对象来提高命中率。不过，可能有些进入缓存的小对象永远不会再被访问。SIZE策略没有提供淘汰这类对象的机制，也会导致“缓存污染”。</li></ul></li><li>（6）LRU-Threshold<ul><li>不缓存超过某一size的对象，其他与LRU相同。</li></ul></li><li>（7）Log(Size)+LRU<ul><li>替换size最大的对象，当size相同时，按LRU进行替换。</li></ul></li><li>（8）Hyper-G<ul><li>LFU的改进版，同时考虑上次访问时间和对象size。</li></ul></li><li>（9）Pitkow/Recker<ul><li>替换最近最少使用的对象，除非所有对象都是今天访问过的。如果是这样，则替换掉最大的对象。这一策略试图符合每日访问Web网页的特定模式。这一策略也被建议在每天结束时运行，以释放被“旧的”、最近最少使用的对象占用的空间。</li></ul></li><li>（10）Lowest-Latency-First<ul><li>替换下载时间最少的文档。显然它的目标是最小化平均延迟。</li></ul></li><li>（11）Hybrid Hybrid<ul><li>有一个目标是减少平均延迟。对缓存中的每个文档都会计算一个保留效用，保留效用最低的对象会被替换掉</li></ul></li><li>（12）Lowest Relative Value（LRV）<ul><li>LRV也是基于计算缓存中文档的保留效用，然后替换保留效用最低的文档。</li></ul></li><li>（13）Adaptive Replacement Cache（ARC）<ul><li>ARC介于LRU和LFU之间，为了提高效果，由2个LRU组成，第一个包含的条目是最近只被使用过一次的，而第二个LRU包含的是最近被使用过两次的条目，因此，得到了新的对象和常用的对象。ARC能够自我调节，并且是低负载的。</li></ul></li><li>（14）Most Recently Used（MRU）<ul><li>MRU与LRU是相对，移除最近最多被使用的对象。当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这时会考虑MRU，在数据库内存缓存中比较常见。</li></ul></li><li>（15）First in First out（FIFO）<ul><li>FIFO通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。</li></ul></li><li>（16）Random Cache<ul><li>随机缓存就是随意的替换缓存数据，比FIFO机制好，在某些情况下，甚至比LRU好，但是通常LRU都会比随机缓存更好些。</li></ul></li></ul><blockquote><p>4．使用公有云的缓存服务</p></blockquote><p>基于Redis的云存储服务</p><ul><li>动态扩容</li><li>数据多备</li><li>自动容灾</li><li>成本较低</li></ul><h2 id="第2章-分布式系统理论"><a href="#第2章-分布式系统理论" class="headerlink" title="第2章 分布式系统理论"></a>第2章 分布式系统理论</h2><p>分布式理论体系宏大精深，先从分布式系统理论，比如Paxos、分布式系统设计策略、心跳检测、分布式系统设计实践、全局ID生成几个方面讲。</p><h3 id="2-1-分布式系统概论"><a href="#2-1-分布式系统概论" class="headerlink" title="2.1 分布式系统概论"></a>2.1 分布式系统概论</h3><p>深入地讨论了以下几个方面：</p><ul><li>分布式程序设计语言：基本结构。</li><li>理论基础：全局状态和事件排序；逻辑时钟和物理时钟。</li><li>分布式操作系统：互斥和选举；死锁的检测和解决方法；自稳定；任务调度和负载平衡。</li><li>分布式通信：一对一通信；组（collective）通信。</li><li>可靠性：一致性；错误恢复；可靠通信。</li><li>分布式数据管理：复制数据的一致性；分布式并发控制。</li><li>应用：分布式操作系统；分布式文件系统；分布式数据库系统；分布式共享存储器；异型处理。</li></ul><p>综上所述，分布式系统是一个内涵极度丰富的领域，单就应用层次而言就涉及分布式缓存、分布式存储、分布式文件系统、分布式锁、分布式事务、分布式调度任务、分布式调度计算、分布式消息、分布式采集等等，</p><h3 id="2-2-分布式系统概念"><a href="#2-2-分布式系统概念" class="headerlink" title="2.2 分布式系统概念"></a>2.2 分布式系统概念</h3><h4 id="2-2-1-进程与线程"><a href="#2-2-1-进程与线程" class="headerlink" title="2.2.1 进程与线程"></a>2.2.1 进程与线程</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><h4 id="2-2-2-并发"><a href="#2-2-2-并发" class="headerlink" title="2.2.2 并发"></a>2.2.2 并发</h4><p>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其他线程处于挂起状态。这种方式我们称之为并发（Concurrent）。</p><p>应用层的并发：定义为单位时间内对于共享资源的访问。</p><h4 id="2-2-3-锁"><a href="#2-2-3-锁" class="headerlink" title="2.2.3 锁"></a>2.2.3 锁</h4><p>锁（lock）作为用于保护临界区（critical section）的一种机制，被广泛应用在多线程程序中</p><p>减少或规避锁争用的几种策略：</p><ul><li>分拆锁；</li><li>分离锁；</li><li>避免共享变量缓存；</li><li>使用并发容器如Amino；</li><li>使用Immutable数据和ThreadLocal中的数据</li></ul><h4 id="2-2-4-并行"><a href="#2-2-4-并行" class="headerlink" title="2.2.4 并行"></a>2.2.4 并行</h4><p>当系统有一个以上的CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p><p>并发与并行的区别</p><ul><li>并行是指两个或者多个事件在同一时刻发生；</li><li>并发是指两个或多个事件在同一时间间隔内发生。</li></ul><h4 id="2-2-5-集群"><a href="#2-2-5-集群" class="headerlink" title="2.2.5 集群"></a>2.2.5 集群</h4><p>集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。</p><p>分布式系统可以表达为很多机器组成的集群，靠彼此之间的网络通信，担当的角色可能不同，共同完成同一件事情的系统</p><p>可以划分为以下几种类型：</p><ul><li>节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器。</li><li>网络：系统的数据传输通道，用来彼此通信。通信是具有方向性的。</li><li>存储：系统中持久化数据的数据库或者文件存储。</li></ul><p>根据典型的集群体系结构，集群中涉及的关键技术可以归属于四个层次：</p><ul><li>网络层：网络互联结构、通信协议、信号技术等。</li><li>节点机及操作系统层高性能客户机、分层或基于微内核的操作系统等。</li><li>集群系统管理层：资源管理、资源调度、负载平衡、并行IPO、安全等。</li><li>应用层：并行程序开发环境、串行应用、并行应用等</li></ul><h4 id="2-2-6-状态特性"><a href="#2-2-6-状态特性" class="headerlink" title="2.2.6 状态特性"></a>2.2.6 状态特性</h4><p>分布式环境中的任何节点（Node）也是无状态的。无状态是指不保存存储状态，则可以随意重启和替代，便于做扩展。</p><h4 id="2-2-7-系统重发与幂等性"><a href="#2-2-7-系统重发与幂等性" class="headerlink" title="2.2.7 系统重发与幂等性"></a>2.2.7 系统重发与幂等性</h4><p>系统重发示例<br><img data-src="assets/net-service-retry.jpeg" alt="系统重发"></p><p>所谓幂等性就是调用1次和调用N次要返回一样的结果。<br>比如一次转账动作，A账户转账1000到B账户，由于网络调用超时，客户端client基于上述保障成功率的原因发起了retry，那么最终应该转账1000还是2000呢，客户的意愿是1000。只需要在设计上加上调用订单号就可以规避这个问题，多次重发，调用的订单号一样，则在服务提供方内部只做一次真实转账动作就行了。</p><h4 id="2-2-8-硬件异常"><a href="#2-2-8-硬件异常" class="headerlink" title="2.2.8 硬件异常"></a>2.2.8 硬件异常</h4><blockquote><p>1．服务器宕机</p></blockquote><p>引发服务器宕机的原因可能是服务器停电、内存错误等等故障，换言之，服务器故障是大概率事件。</p><p>在分布式环境下，采用低廉的PC Server代替高大上的服务器已是常态。我们把宕机时不能提供服务的节点，称为不可用。</p><p>服务器宕机时，节点将丢失所有内部信息，因此设计时需要考虑存储系统的持久化，在重启系统后，可以进行相关存储内容的恢复</p><blockquote><p>2．网络异常</p></blockquote><p>网络异常的原因可能是消息丢失、网络包数据错误。</p><p>设计容错系统的一个方案是，任何消息只有收到对方回复才可以认为发送成功。</p><blockquote><p>3．磁盘故障</p></blockquote><p>在分布式环境中，需要把数据存储在多台服务器，一旦一台出现故障，也能从其他服务器恢复。</p><blockquote><p>4．机房级异常</p></blockquote><p>对容灾而言也有同城灾备和异地机房的做法。当发生机房级异常比如光纤出了问题，异地机房可以继续提供服务</p><h3 id="2-3-分布式系统理论"><a href="#2-3-分布式系统理论" class="headerlink" title="2.3 分布式系统理论"></a>2.3 分布式系统理论</h3><p>CAP理论提出了一致性、可用性、分区容忍性的取舍问题；<br>Paxos、Raft、2PC、3PC分别给出了一致性的解决方案；<br>Lease机制主要针对网络拥塞或瞬断的情况下，出现双主情况的解法；<br>Quorum NWR和MVCC主要解决分布式存储领域的一致性问题；<br>Gossip是一种去中心化、容错而又最终一致性的算法</p><h4 id="2-3-1-CAP理论"><a href="#2-3-1-CAP理论" class="headerlink" title="2.3.1 CAP理论"></a>2.3.1 CAP理论</h4><p>分布式系统的CAP理论：首先将分布式系统中的三个特性进行如下归纳：</p><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否有同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在一定时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><blockquote><p>（1）CA without P</p></blockquote><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。</p><p>CA的系统更多的是允许分区后各子系统依然保持CA。</p><p>典型放弃分区容忍性的例子有关系型数据库、LDAP等。</p><blockquote><p>（2）CP without A</p></blockquote><p>如果不要求A（可用性），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的</p><blockquote><p>（3）AP wihtout C</p></blockquote><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性</p><p>现在众多的NoSQL都属于此类</p><h4 id="2-3-3-Paxos"><a href="#2-3-3-Paxos" class="headerlink" title="2.3.3 Paxos"></a>2.3.3 Paxos</h4><blockquote><ol><li>Paxos是什么</li></ol></blockquote><p>一言以蔽之，Paxos协议是一个解决分布式系统中，多个节点之间就某个值（提案）达成一致（决议）的通信协议。它能够处理在少数节点离线的情况下，剩余的多数节点仍然能够达成一致。</p><blockquote><ol start="2"><li>Paxos协议简介</li></ol></blockquote><p>Paxos协议是一个两阶段协议，分为Prepare阶段和Accept阶段</p><p>Proposer是提议提案的服务器，而Acceptor是批准提案的服务器。二者在物理上可以是同一台机器。</p><ul><li>Prepare阶段（1）Prepare阶段1:Proposer发送Prepare</li></ul><h4 id="2-3-4-2PC"><a href="#2-3-4-2PC" class="headerlink" title="2.3.4 2PC"></a>2.3.4 2PC</h4><p>在事务处理、关系型数据库及计算机网络中，2阶段提交协议（2PC）是一种典型的原子提交协议（atomic commitment protocol）。它是一种由协调器来处理分布式原子参与者是提交或者回滚事务的分布式算法。</p><p>该协议包括2个阶段：</p><ul><li>（1）提交请求阶段或者叫投票阶段该阶段的任务是确定相关参与者对于事务处理是否准备就绪，YES代表可以commit, NO则反之。</li><li>（2）提交阶段基于投票结果，由协调器决定提交事务抑或是退出事务处理；各事务参与者遵循指示，对本地事务资源做需要的动作。</li></ul><h4 id="2-3-5-3PC"><a href="#2-3-5-3PC" class="headerlink" title="2.3.5 3PC"></a>2.3.5 3PC</h4><p>第一阶段，投票，事务协调器询问参与者是否能提交（canCommit），都得到肯定回答后，继续第二阶段。<br>第二阶段是预提交，都确认预提交成功后，进行第三阶段。<br>第三阶段就是真实的提交，成功则完成事务；失败则继续重试</p><h4 id="2-3-6-Raft"><a href="#2-3-6-Raft" class="headerlink" title="2.3.6 Raft"></a>2.3.6 Raft</h4><p>在Raft中，任何时候一个服务器可以扮演下面角色之一：</p><ul><li>领导者：处理所有客户端交互、日志复制等动作，一般一次只有一个领导者。</li><li>选民：类似选民，完全被动的角色，这样的服务器等待被通知投票。</li><li>候选人：候选人就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者。</li></ul><h4 id="2-3-7-Lease机制"><a href="#2-3-7-Lease机制" class="headerlink" title="2.3.7 Lease机制"></a>2.3.7 Lease机制</h4><p>Lease英文含义是“租期”、“承诺”</p><h4 id="2-3-8-解决“脑裂”问题"><a href="#2-3-8-解决“脑裂”问题" class="headerlink" title="2.3.8 解决“脑裂”问题"></a>2.3.8 解决“脑裂”问题</h4><p>主备是实现高可用的有效方式，但存在一个脑裂问题。脑裂（split-brain），指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源，结果会导致系统混乱，数据损坏</p><p>有一种做法称为设置仲裁机制，例如设置第三方检测服务器（Monitor），当Slave确定准备接管Master时，让Monitor也ping一下Master，如果没有通讯，则判断其“死亡”；同时Master在对外提供服务时，每隔一段时间比如10s由Master服务器ping Slave服务器和Monitor，如果均出现异常，则暂定业务操作，重试。重试多次之后则退出程序执行或者执行服务器重启操作。</p><h4 id="2-3-9-Quorum-NWR"><a href="#2-3-9-Quorum-NWR" class="headerlink" title="2.3.9 Quorum NWR"></a>2.3.9 Quorum NWR</h4><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。在Amazon的Dynamo云存储系统中，就应用NWR来控制一致性</p><ul><li>N：同一份数据的拷贝份数；</li><li>W：是更新一个数据对象的时候需要确保成功更新的份数；</li><li>R：读取一个数据需要读取的拷贝的份数。</li></ul><h4 id="2-3-10-MVCC"><a href="#2-3-10-MVCC" class="headerlink" title="2.3.10 MVCC"></a>2.3.10 MVCC</h4><p>MVCC，全称Multiversion concurrency control，翻译为基于多版本并发控制。人们一般把基于锁（比如行级锁）的并发控制机制称成为悲观机制，而把MVCC机制称为乐观机制.</p><p>由于MVCC是一种宽松的设计，读写相互不阻塞，可以获得较好的并发性能。</p><h4 id="2-3-11-Gossip"><a href="#2-3-11-Gossip" class="headerlink" title="2.3.11 Gossip"></a>2.3.11 Gossip</h4><p>Gossip就是一种去中心化思路的分布式协议，解决状态在集群中的传播和状态一致性的保证两个问题</p><p>Gossip的核心是在去中心化结构下，通过信息的部分传递，达到全集群的状态信息传播，传播的时间收敛在O(Log(N))以内，其中N是节点的数量。同时基于Gossip协议，可以构建出状态一致的各种解决方案。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h4 id="A-后续阅读"><a href="#A-后续阅读" class="headerlink" title="A.后续阅读"></a>A.后续阅读</h4><ul><li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念与设计(原书第5版).pdf</a></li><li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li><li><a href="https://kdocs.cn/l/sVgDvD5mY" target="_blank" rel="noopener">从PAXOS到ZOOKEEPER分布式一致性原理与实践.pdf</a></li></ul>]]></content>
      
    </entry>
    
    
  
</search>
