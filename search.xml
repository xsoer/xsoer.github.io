<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>friends</title>
    <url>/friends/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>工具集合</title>
    <url>/tools/index.html</url>
    <content><![CDATA[<h2 id="一、插件"><a href="#一、插件" class="headerlink" title="一、插件"></a>一、插件</h2><ul>
<li>github<ul>
<li>sourcegraph</li>
<li>octotree</li>
</ul>
</li>
<li>剪切网页<ul>
<li>evernote</li>
</ul>
</li>
<li>调试接口<ul>
<li>JSONview</li>
</ul>
</li>
<li>词典<ul>
<li>沙拉查词</li>
</ul>
</li>
<li>广告<ul>
<li>广告终结者</li>
</ul>
</li>
<li>产品原型<ul>
<li>axure</li>
</ul>
</li>
<li>多tab管理<ul>
<li>Toby</li>
</ul>
</li>
</ul>
<h2 id="二、工具网站"><a href="#二、工具网站" class="headerlink" title="二、工具网站"></a>二、工具网站</h2><ul>
<li>json格式化<ul>
<li><a href="https://json.cn" target="_blank" rel="noopener">https://json.cn</a></li>
<li><a href="http://json.parser.online.fr" target="_blank" rel="noopener">http://json.parser.online.fr</a></li>
</ul>
</li>
<li>随机密码生成<ul>
<li><a href="https://www.sexauth.com/" target="_blank" rel="noopener">https://www.sexauth.com/</a></li>
<li><a href="https://suijimimashengcheng.51240.com/" target="_blank" rel="noopener">https://suijimimashengcheng.51240.com/</a></li>
<li><a href="https://www.dashlane.com/zh/features/password-generator" target="_blank" rel="noopener">https://www.dashlane.com/zh/features/password-generator</a></li>
</ul>
</li>
<li>正则表达式<ul>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></li>
<li><a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">http://wangwl.net/static/projects/visualRegex</a></li>
</ul>
</li>
<li>问题讨论<ul>
<li><a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li>
<li><a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></li>
</ul>
</li>
</ul>
<h2 id="三、前沿科技网站"><a href="#三、前沿科技网站" class="headerlink" title="三、前沿科技网站"></a>三、前沿科技网站</h2><ul>
<li>论文<ul>
<li><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></li>
<li><a href="https://www.nature.com/" target="_blank" rel="noopener">https://www.nature.com/</a></li>
</ul>
</li>
</ul>
<h3 id="四、github系列"><a href="#四、github系列" class="headerlink" title="四、github系列"></a>四、github系列</h3><ul>
<li><p>awesome系列</p>
<ul>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">https://github.com/sindresorhus/awesome</a></li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">https://github.com/linyiqun/DataMiningAlgorithm</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>图书</title>
    <url>/books/index.html</url>
    <content><![CDATA[<h2 id="github图书链接"><a href="#github图书链接" class="headerlink" title="github图书链接"></a>github图书链接</h2><ul>
<li><a href="https://github.com/royeo/free-programming-books.pdf" target="_blank" rel="noopener">https://github.com/royeo/free-programming-books.pdf</a></li>
<li><a href="https://github.com/threerocks/studyFiles" target="_blank" rel="noopener">https://github.com/threerocks/studyFiles</a></li>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></li>
<li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="noopener">https://github.com/it-ebooks/it-ebooks-archive</a></li>
<li><a href="https://github.com/shivam-jha/DockerBooks" target="_blank" rel="noopener">https://github.com/shivam-jha/DockerBooks</a></li>
<li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md</a></li>
<li><a href="https://github.com/zhiwoeryi/eBook-3" target="_blank" rel="noopener">https://github.com/zhiwoeryi/eBook-3</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>面试</title>
    <url>/interview/index.html</url>
    <content><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><a href="cs/index.html">计算机基础</a></h2><ul>
<li><a href="cs/basic.html">基础</a></li>
<li><a href="cs/os.html">操作系统</a></li>
</ul>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="backend/index.md">后端</a></h2><ul>
<li><a href="backend/python.html">python</a></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a href="storage/index.html">数据库</a></h2><ul>
<li><a href="storage/basic.html">基础</a></li>
<li><a href="storage/mysql.html">mysql</a></li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a><a href="frontend/index.md">前端</a></h2><ul>
<li><a href="frontend/basic.html">大前端</a></li>
<li><a href="frontend/js.html">js</a></li>
<li><a href="frontend/vue.html">vue</a></li>
<li><a href="frontend/css.html">css</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a href="net/index.html">网络</a></h2><ul>
<li><a href="net/basic.html">基础</a></li>
<li><a href="net/http.html">http</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><ul>
<li><a href="basic.html">基础</a></li>
<li><a href="sort.html">排序算法</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>手册</title>
    <url>/man/index.html</url>
    <content><![CDATA[<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li><a href="linux/commands.html">常用命令</a></li>
<li><a href="linux/crontab.html">定时任务</a></li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li><a href="docker/commands.html">常用命令</a></li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li><a href="mysql/commands.html">常用命令</a></li>
</ul>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul>
<li><a href="vim/commands.html">常用命令</a></li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="git/commands.html">常用命令</a></li>
</ul>
<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><ul>
<li><a href="django/model.html">django ORM常用操作</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/django/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/docker/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/linux/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/mysql/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/git/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/vim/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/man/git/commands.html</url>
    <content><![CDATA[<ul>
<li><strong><code>git init</code></strong>                                #git 初始化仓库</li>
<li><strong><code>git clone remote_url</code></strong>                    #git 克隆远程库</li>
<li><strong><code>git add .</code></strong>                               #git  添加所有文件</li>
<li><strong><code>git commit -m &quot;批注&quot;</code></strong>                     #git 提交</li>
<li><strong><code>git push &lt;remoteName&gt; &lt;localName&gt;</code></strong>       #git推送至远程</li>
<li><strong><code>git remote add origin &lt;server&gt;</code></strong>          #远程没有创建仓库，将本地推送到远程仓库</li>
<li><strong><code>git checkout -b branch_name</code></strong>             #创建分支，并切换到分支</li>
<li><strong><code>git checkout master</code></strong>                     #切换到主分支</li>
<li><strong><code>git branch -d &lt;branch_name&gt;</code></strong>             #删除分支</li>
<li><strong><code>git pull &lt;remoteName&gt; &lt;localName&gt;</code></strong>        #将本地仓库更新至最新</li>
<li><strong><code>git merge branch_name</code></strong>                    #将其他分支合并到本地主分支</li>
<li><strong><code>git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</code></strong> #比对分支</li>
<li><strong><code>git tag &lt;tag_name&gt;</code></strong>                      #创建标签</li>
<li><strong><code>git show</code></strong></li>
<li><strong><code>git status</code></strong>                              #查看当前状态</li>
<li><strong><code>git fetch</code></strong>                               #合并</li>
<li><strong><code>git config --list</code></strong>                       #查看配置信息</li>
<li><strong><code>git rm &lt;file_name&gt;</code></strong>                      #删除文件</li>
<li><strong><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code></strong>            #重命名文件</li>
<li><strong><code>git log</code></strong>                                 #查看日志</li>
<li><strong><code>git rebase HEAD &lt;file_name&gt;</code></strong>             #重置</li>
<li><strong><code>git remote -v</code></strong>                           #查看远程仓库</li>
<li><strong><code>git remote rm &lt;file_name&gt;</code></strong>               #删除远程仓库</li>
<li><strong><code>git branch</code></strong>                              #查看本地分支</li>
<li><strong><code>git branch -r</code></strong>                           #查看远程分支</li>
<li><strong><code>git branch &lt;branch_name&gt;</code></strong>                #创建本地分支</li>
<li><strong><code>git config --global user.name NEWNAME</code></strong>   #修改用户名</li>
<li><strong><code>git config --global user.email NEWEMAIL</code></strong> #修改用户邮箱</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/man/docker/commands.html</url>
    <content><![CDATA[<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ul>
<li><p>Management Commands:</p>
<ul>
<li><strong><code>config</code></strong>      Manage Docker configs</li>
<li><strong><code>container</code></strong>   Manage containers</li>
<li><strong><code>image</code></strong>       Manage images</li>
<li><strong><code>network</code></strong>     Manage networks</li>
<li><strong><code>node</code></strong>        Manage Swarm nodes</li>
<li><strong><code>plugin</code></strong>      Manage plugins</li>
<li><strong><code>secret</code></strong>      Manage Docker secrets</li>
<li><strong><code>service</code></strong>     Manage services</li>
<li><strong><code>stack</code></strong>       Manage Docker stacks</li>
<li><strong><code>swarm</code></strong>       Manage Swarm</li>
<li><strong><code>system</code></strong>      Manage Docker</li>
<li><strong><code>volume</code></strong>      Manage volumes<br>
</li>
</ul>
</li>
<li><p>Commands:</p>
<ul>
<li><strong><code>attach</code></strong>      Attach local standard input, output, and error streams to a running container</li>
<li><strong><code>build</code></strong>       Build an image from a Dockerfile</li>
<li><strong><code>commit</code></strong>      Create a new image from a container’s changes</li>
<li><strong><code>cp</code></strong>          Copy files/folders between a container and the local filesystem</li>
<li><strong><code>create</code></strong>      Create a new container</li>
<li><strong><code>diff</code></strong>        Inspect changes to files or directories on a container’s filesystem</li>
<li><strong><code>events</code></strong>      Get real time events from the server</li>
<li><strong><code>exec</code></strong>        Run a command in a running container</li>
<li><strong><code>export</code></strong>      Export a container’s filesystem as a tar archive</li>
<li><strong><code>history</code></strong>     Show the history of an image</li>
<li><strong><code>images</code></strong>      List images</li>
<li><strong><code>import</code></strong>      Import the contents from a tarball to create a filesystem image</li>
<li><strong><code>info</code></strong>        Display system-wide information</li>
<li><strong><code>inspect</code></strong>     Return low-level information on Docker objects</li>
<li><strong><code>kill</code></strong>        Kill one or more running containers</li>
<li><strong><code>load</code></strong>        Load an image from a tar archive or STDIN</li>
<li><strong><code>login</code></strong>       Log in to a Docker registry</li>
<li><strong><code>logout</code></strong>      Log out from a Docker registry</li>
<li><strong><code>logs</code></strong>        Fetch the logs of a container</li>
<li><strong><code>pause</code></strong>       Pause all processes within one or more containers</li>
<li><strong><code>port</code></strong>        List port mappings or a specific mapping for the container</li>
<li><strong><code>ps</code></strong>          List containers</li>
<li><strong><code>pull</code></strong>        Pull an image or a repository from a registry</li>
<li><strong><code>push</code></strong>        Push an image or a repository to a registry</li>
<li><strong><code>rename</code></strong>      Rename a container</li>
<li><strong><code>restart</code></strong>     Restart one or more containers</li>
<li><strong><code>rm</code></strong>          Remove one or more containers</li>
<li><strong><code>rmi</code></strong>         Remove one or more images</li>
<li><strong><code>run</code></strong>         Run a command in a new container</li>
<li><strong><code>save</code></strong>        Save one or more images to a tar archive (streamed to STDOUT by default)</li>
<li><strong><code>search</code></strong>      Search the Docker Hub for images</li>
<li><strong><code>start</code></strong>       Start one or more stopped containers</li>
<li><strong><code>stats</code></strong>       Display a live stream of container(s) resource usage statistics</li>
<li><strong><code>stop</code></strong>        Stop one or more running containers</li>
<li><strong><code>tag</code></strong>         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</li>
<li><strong><code>top</code></strong>         Display the running processes of a container</li>
<li><strong><code>unpause</code></strong>     Unpause all processes within one or more containers</li>
<li><strong><code>update</code></strong>      Update configuration of one or more containers</li>
<li><strong><code>version</code></strong>     Show the Docker version information</li>
<li><strong><code>wait</code></strong>        Block until one or more containers stop, then print their exit codes</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><strong><code>docker images</code></strong>       // 查看存在多少镜像</li>
<li><strong><code>docker ps</code></strong>           // 查看镜像运行情况</li>
<li><strong><code>docker run -t -i</code></strong>    // 运行镜像。并进行交互模式。</li>
<li><strong><code>docker stop</code></strong>         // 停止运行镜像，后边跟镜像ID或name</li>
<li><strong><code>docker search</code></strong>       // 搜索镜像仓库</li>
<li><strong><code>docker pull</code></strong>         // 拉取镜像</li>
<li><strong><code>docker inspect</code></strong>      // 查看镜像的json文件，即全部详细信息</li>
<li><strong><code>docker port</code></strong>         // 查看docker与宿主机的端口映射关系</li>
<li><strong><code>docker commit</code></strong>       // 用来生成新的版本</li>
<li><strong><code>docker build</code></strong>        // 用docker file来创建镜像</li>
<li><strong><code>docker tag</code></strong>          // 设置镜像标签</li>
</ul>
<br>

<ul>
<li>容器生命周期管理<ul>
<li><strong><code>create</code></strong></li>
<li><strong><code>run</code></strong></li>
<li><strong><code>start/stop/restart</code></strong></li>
<li><strong><code>pause/unpause</code></strong></li>
<li><strong><code>exec</code></strong></li>
<li><strong><code>rm</code></strong></li>
<li><strong><code>kill</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li><p>容器操作</p>
<ul>
<li><strong><code>ps</code></strong></li>
<li><strong><code>inspect</code></strong></li>
<li><strong><code>top</code></strong></li>
<li><strong><code>attach</code></strong></li>
<li><strong><code>events</code></strong></li>
<li><strong><code>logs</code></strong></li>
<li><strong><code>wait</code></strong></li>
<li><strong><code>export</code></strong></li>
<li><strong><code>port</code></strong></li>
</ul>
</li>
<li><p>容器rootfs命令</p>
<ul>
<li><strong><code>commit</code></strong></li>
<li><strong><code>cp</code></strong></li>
<li><strong><code>diff</code></strong></li>
</ul>
</li>
<li><p>镜像仓库</p>
<ul>
<li><strong><code>login</code></strong></li>
<li><strong><code>pull</code></strong></li>
<li><strong><code>push</code></strong></li>
<li><strong><code>search</code></strong></li>
</ul>
</li>
<li><p>本地镜像管理</p>
<ul>
<li><strong><code>images</code></strong></li>
<li><strong><code>rmi</code></strong></li>
<li><strong><code>tag</code></strong></li>
<li><strong><code>build</code></strong></li>
<li><strong><code>history</code></strong></li>
<li><strong><code>save</code></strong></li>
<li><strong><code>import</code></strong></li>
</ul>
</li>
<li><p>信息</p>
<ul>
<li><strong><code>info</code></strong></li>
<li><strong><code>version</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li>查看容器重启次数<ul>
<li>docker inspect -f “ .RestartCount “ container_id</li>
</ul>
</li>
<li>查看容器最后一次的启动时间<ul>
<li>docker inspect -f “ .State.StartedAt ” container_id</li>
</ul>
</li>
<li>commit一个镜像<ul>
<li>docker run –name=”python_env_l” -it image_name /bin/bash</li>
<li>docker commit -m=”msg” -a=”user_name” 4631e1627784 image_name:2.1</li>
<li>docker tag  image_name:2.1 image_name:latest</li>
<li>docker push image_name</li>
</ul>
</li>
<li>Docker构建镜像<ul>
<li>docker build -t imageName .</li>
</ul>
</li>
<li>打标签<ul>
<li>Docker tag image user/newName:tag</li>
</ul>
</li>
<li>批量删除无用镜像<ul>
<li>docker image rm <code>docker images|grep none|awk {&#39;print $3&#39;}</code></li>
</ul>
</li>
<li>批量删除无用容器<ul>
<li>sudo docker rm <code>sudo docker ps -a |grep Exited| awk {&#39;print $1&#39;}</code></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/django/model.html</url>
    <content><![CDATA[<p>django model operate</p>
]]></content>
  </entry>
  <entry>
    <title>linux终端命令</title>
    <url>/man/linux/commands.html</url>
    <content><![CDATA[<ul>
<li>autojump</li>
<li><ul>
<li>自动跳转文件夹，不用cd</li>
</ul>
</li>
<li>tree</li>
<li><ul>
<li>以树状图列出当前目录结构</li>
</ul>
</li>
<li>you-get</li>
<li><ul>
<li>视频下载</li>
</ul>
</li>
<li>tldr</li>
<li><ul>
<li>命令示例文档</li>
</ul>
</li>
<li>htop</li>
<li><ul>
<li>更强大的top</li>
</ul>
</li>
<li>git</li>
<li><ul>
<li>版本控制工具</li>
</ul>
</li>
<li>vim</li>
<li><ul>
<li>编辑器</li>
</ul>
</li>
<li>tmux</li>
<li><ul>
<li>终端复用神器</li>
</ul>
</li>
<li>thefuck<ul>
<li>命令出错自动完善</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>VIM使用文档总结</title>
    <url>/man/vim/commands.html</url>
    <content><![CDATA[<ul>
<li><p>向下添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+f</span><br></pre></td></tr></table></figure>
</li>
<li><p>向上翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+b</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>
<ul>
<li><p>下一个词</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure>
</li>
<li><p>行尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个字符行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^</span><br></pre></td></tr></table></figure>
</li>
<li><p>行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gg</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">G</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+h</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+m</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+l</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>crontab表示法</title>
    <url>/man/linux/crontab.html</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>crontab是linux上的定时任务工具，用来做定时管理服务。其常用的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l <span class="comment"># 罗列出当前用户的所有定时任务列表</span></span><br><span class="line">crontab -e <span class="comment"># 编辑定时任务</span></span><br><span class="line">crontab -r <span class="comment"># 删除定时任务</span></span><br></pre></td></tr></table></figure>

<p>当然，最重要的还是如何使用cron来表示什么时候什么频次来执行任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*  *  * *  *   <span class="built_in">command</span></span><br><span class="line">分 时 日 月 周   命令</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>如上表示，有5个位置符来表示，后边跟需要执行的命令。</p>
<ul>
<li>第一列：分(0-59)</li>
<li>第二列：时(0-23)</li>
<li>第三列：日(1-31)</li>
<li>第四列：月(1-12)</li>
<li>第五列：周(0-6,0为星期天)</li>
</ul>
<p>除了以上的表示方法，还可以结合一些特殊的符号来表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* ：   表示任何时刻</span><br><span class="line">, ：   表示在这几个选项内</span><br><span class="line">－ ：  表示一个范围，如第二列里： 3-5，就表示3到5点</span><br><span class="line">/n ：  表示每个n的单位执行一次，如第二列里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.</span><br></pre></td></tr></table></figure>

<h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * *                           每分钟执行一次</span><br><span class="line">0 */1 * * *                         每分钟执行一次</span><br><span class="line">43 21 * * *                         21:43 执行</span><br><span class="line">15 05 * * *                         05:15 执行</span><br><span class="line">0 17 * * *                          17:00 执行</span><br><span class="line">0 17 * * 1                          每周一的 17:00 执行</span><br><span class="line">0,10 17 * * 0,2,3                   每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="line">0-10 17 1 * *                       毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="line">0 0 1,15 * 1                        毎月1日和 15日和 一日的 0:00 执行</span><br><span class="line">42 4 1 * *                          毎月1日的 4:42分 执行</span><br><span class="line">0 21 * * 1-6                        周一到周六 21:00 执行</span><br><span class="line">0,10,20,30,40,50 * * * *            每隔10分 执行</span><br><span class="line">*/10 * * * *                        每隔10分 执行</span><br><span class="line">* 1 * * *                           从1:0到1:59 每隔1分钟 执行</span><br><span class="line">0 1 * * *                           1:00 执行</span><br><span class="line">0 * * * *                           毎时0分 每隔1小时 执行</span><br><span class="line">2 8-20/3 * * *                      8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="line">30 5 1,15 * *                       1日 和 15日的 5:30 执行</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>mysql常用语句</title>
    <url>/man/mysql/commands.html</url>
    <content><![CDATA[<ul>
<li><p>1.授权用户</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO <span class="string">'zxc'</span>@<span class="string">'%'</span> IDENTIFIED BY <span class="string">'ydp#2015$Z!!!'</span> WITH GRANT OPTION;</span><br><span class="line">mysql&gt; FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.远程连接</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -h127.0.0.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.导出数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysqldump -h127.0.0.1 -P3306 -uroot -p sqsx &gt; sqsx.sql</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>
<ul>
<li><p>4.导入数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">shell&gt; mysql -uroot -p sqsx &lt; sqsx.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.分析查询</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; explain select * from user;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.查询所有的进程</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show procelist;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.建数据库语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create database dbname default character <span class="built_in">set</span> utf8 collate utf8_general_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.创建数据表语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table dbname.tablename () engine=Innodb charset=utf8;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.删除数据库</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; drop database dbname;</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.查看数据库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; use dbname;</span><br><span class="line">mysql&gt; status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>11.查看参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show variables like “%sql%”;</span><br></pre></td></tr></table></figure>
</li>
<li><p>12.查看事件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show events;</span><br></pre></td></tr></table></figure>
</li>
<li><p>13.查看触发器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show triggers;</span><br></pre></td></tr></table></figure>
</li>
<li><p>14.查看所有参数</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>15.查看打开表</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show open tables;</span><br></pre></td></tr></table></figure>
</li>
<li><p>16.查看表状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show table status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>17.查看主数据状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show master status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>18.查看从数据库状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show slave status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>19.查看函数状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show <span class="keyword">function</span> status;</span><br></pre></td></tr></table></figure>
</li>
<li><p>20.查看插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show plugins;</span><br></pre></td></tr></table></figure>
</li>
<li><p>21.查看某用户的授权</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show grants <span class="keyword">for</span> username;</span><br></pre></td></tr></table></figure>
</li>
<li><p>22.查看错误</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show errors;</span><br></pre></td></tr></table></figure>
</li>
<li><p>23.查看创建表语句</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show create table tablename;</span><br></pre></td></tr></table></figure>
</li>
<li><p>24.查看表头</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show columns from tablename;</span><br></pre></td></tr></table></figure>
</li>
<li><p>25.查看存储引擎</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show engines;</span><br></pre></td></tr></table></figure>
</li>
<li><p>26.查看表状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql&gt; show table status;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/algorithms/basic.html</url>
    <content><![CDATA[<ul>
<li>第一：复杂度估算和排序算法（上）<ul>
<li>1) 时间复杂度和空间复杂度</li>
<li>2）认识对数器</li>
<li>3）冒泡排序</li>
<li>4）选择排序</li>
<li>5）插入排序</li>
<li>6）如何分析递归过程的时间复杂度</li>
<li>7）归并排序</li>
<li>8）小和问题</li>
</ul>
</li>
<li>第二：复杂度估算和排序算法（下）<ul>
<li>1）荷兰国旗问题</li>
<li>2）随机快速排序</li>
<li>3）堆结构与堆排序</li>
<li>4）认识排序算法的稳定性</li>
<li>5）认识比较器</li>
<li>6）桶排序</li>
<li>7）计数排序</li>
<li>8）基数排序</li>
<li>9）数组排序后的最大差值问题</li>
<li>10）排序算法在工程中的应用</li>
</ul>
</li>
<li>第三：章栈、队列、链表、数组和矩阵结构<br>  1）栈结构<br>  2）队列结构<br>  3）链表结构<br>  4）数组结构<br>  5）矩阵结构<br>  6）二分搜索的扩展</li>
<li>第四：二叉树结构<ul>
<li>1）二叉树结构</li>
<li>2）二叉树的递归与非递归遍历</li>
<li>3）打印二叉树</li>
<li>4）判断搜索二叉树</li>
<li>5）判断完全二叉树</li>
<li>6）判断平衡二叉树</li>
<li>7）折纸问题</li>
<li>8）二叉树节点的前驱节点与后继节点</li>
<li>9）二叉树的序列化和反序列化</li>
</ul>
</li>
<li>第五：和哈希函数有关的三个结构与并查集<br>  1）哈希函数与哈希表<br>  2）布隆过滤器详解<br>  3）一致性哈希结构<br>  4）并查集结构与应用（岛问题）</li>
<li>第六：章图算法<br>  1）图结构的表示方法<br>  2）图的深度优先遍历与宽度优先遍历<br>  3）拓扑排序问题<br>  4）最小生成树问题<br>  5）单源最短路径问题</li>
<li>第七：前缀树、堆结构和贪心算法<br>  1）前缀树<br>  2）堆结构的扩展与应用<br>  3）介绍贪心算法及其相关题目<br>  4）在面试中如何快速的尝试出贪心策略</li>
<li>第八：暴力递归到动态规划<br>  1）递归<br>  2）动态规划<br>  3）如何把暴力递归套路的变成动态规划<br>算法高级：<br>第一：KMP算法和Manacher算法<br>  1）KMP算法及其扩展面试题目<br>  2）Manacher算法及其扩展面试题目<br>第二：窗口内最大值的更新结构和单调栈结构<br>  1）窗口内最大值的更新结构<br>  2）单调栈结构<br>第三：Morris遍历和sortedMap<br>  1）二叉树的Morris遍历<br>  2）跳表结构<br>  3）AVL树和红黑树结构<br>【今日头条、拼多多题目】<br>分类算法的理解<ul>
<li>决策树的原理</li>
<li>支持向量机</li>
<li>逻辑斯蒂回归<br>聚类算法的理解</li>
<li>均值聚类，可选的参数，如果确定聚类个数</li>
<li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li>
<li>xgboost</li>
<li>gbdt<br>【面试题目】</li>
<li><ol>
<li>二叉树前序递归遍历算法（手写代码）</li>
</ol>
</li>
<li><ol start="2">
<li>二叉树的前中后遍历</li>
</ol>
</li>
<li><ol start="3">
<li>二叉树的文件存储，也就是序列化。</li>
</ol>
</li>
<li><ol start="4">
<li>二叉树遍历，描述下层序遍历。</li>
</ol>
</li>
<li><ol start="5">
<li>二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。</li>
</ol>
</li>
<li><ol start="6">
<li>二维数组，每行递增，每列递增，实现查找。</li>
</ol>
</li>
<li><ol start="7">
<li>二维数组，每行递增，每列递增，求第k大的数。</li>
</ol>
</li>
<li><ol start="8">
<li>什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。</li>
</ol>
</li>
<li><ol start="9">
<li>介绍二叉树前序遍历非递归遍历算法（手写代码）</li>
</ol>
</li>
<li><ol start="10">
<li>介绍大顶堆和小顶堆</li>
</ol>
</li>
<li><ol start="11">
<li>从一组数中找出和为sum的三个数（leetcode）</li>
</ol>
</li>
<li><ol start="12">
<li>冒泡排序(手写代码)</li>
</ol>
</li>
<li><ol start="13">
<li>写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）</li>
</ol>
</li>
<li><ol start="14">
<li>写一个二叉树的非递归的后续遍历</li>
</ol>
</li>
<li><ol start="15">
<li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)</li>
</ol>
</li>
<li><ol start="16">
<li>写个动态规划，最长公共子序列</li>
</ol>
</li>
<li><ol start="17">
<li>判断一个字符串是否为另外一个字符串旋转之后的字符串</li>
</ol>
</li>
<li><ol start="18">
<li>前k大的数</li>
</ol>
</li>
<li><ol start="19">
<li>单链表的翻转</li>
</ol>
</li>
<li><ol start="20">
<li>去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。</li>
</ol>
</li>
<li><ol start="21">
<li>去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’。（Code）</li>
</ol>
</li>
<li><ol start="22">
<li>合法括号匹配</li>
</ol>
</li>
<li><ol start="23">
<li>在一个字符串中，找出最长的无重复字符的字串</li>
</ol>
</li>
<li><ol start="24">
<li>在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）</li>
</ol>
</li>
<li><ol start="25">
<li>堆排序(手写代码)</li>
</ol>
</li>
<li><ol start="26">
<li>堆是怎么调整的。</li>
</ol>
</li>
<li><ol start="27">
<li>复杂链表的复制<br>【大数据题目】</li>
</ol>
</li>
<li><ol>
<li>100亿数字，怎么统计前100大的？</li>
</ol>
</li>
<li><ol start="2">
<li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li>
</ol>
</li>
<li><ol start="3">
<li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li>
</ol>
</li>
<li><ol start="4">
<li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li>
</ol>
</li>
<li><ol start="5">
<li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li>
</ol>
</li>
<li><ol start="6">
<li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li>
</ol>
</li>
<li><ol start="7">
<li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li>
</ol>
</li>
<li><ol start="8">
<li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li>
</ol>
</li>
<li><ol start="9">
<li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li>
</ol>
</li>
<li><ol start="10">
<li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li>
</ol>
</li>
<li><ol start="11">
<li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li>
</ol>
</li>
<li><ol start="12">
<li>海量数据的topk问题。</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ol start="2">
<li>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</li>
</ol>
<ul>
<li><ol start="3">
<li>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</li>
</ol>
</li>
<li><ol start="4">
<li>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</li>
</ol>
</li>
<li><ol start="5">
<li>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</li>
</ol>
</li>
<li><ol start="6">
<li>二分查找（一般会深入，如寻找数组总和为K的两个数字）</li>
</ol>
</li>
<li><ol start="7">
<li>两个栈实现队列。</li>
</ol>
</li>
<li><ol start="8">
<li>图（深度广度优先遍历、单源最短路径、最小生成树）</li>
</ol>
</li>
<li><ol start="9">
<li>动态规划问题。</li>
</ol>
</li>
<li><ol start="10">
<li>深入</li>
</ol>
</li>
<li><ol start="11">
<li>红黑树性质</li>
</ol>
</li>
<li><ol start="12">
<li>分治法和动态规划的区别</li>
</ol>
</li>
<li><ol start="13">
<li>计算时间复杂度</li>
</ol>
</li>
<li><ol start="14">
<li>二叉树和哈希表查找的时间复杂度</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>常用的数据结构有哪些？</p>
<ul>
<li>Arrays</li>
<li>Binary Trees</li>
<li>Graphs</li>
<li>Linked Lists</li>
<li>Matrixes</li>
<li>Stacks</li>
<li>Queues</li>
<li>Heaps</li>
<li>Hash Tables</li>
</ul>
</li>
<li><p>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。<br>&lt;？php<br>function fuhuan($allnum, $ti){<br>   $arr = array();<br>   for($i = 0; $i &lt; $allnum; $i++){</p>
<pre><code>$arr[$i] = $i;</code></pre><p>   }</p>
<p>   $nums = 1;<br>   while(count($arr) &gt; 1){</p>
<pre><code> foreach ($arr as $key =&gt; $value) {
     if($nums == $ti){
         unset($arr[$key]);
         $nums = 1;
     }else{
         $nums++;
     }
}</code></pre><p>   }<br>   $new_arr = array_values($arr);<br>   var_dump($new_arr[0] + 1);<br>}<br>fuhuan(10,10);</p>
</li>
</ul>
<ul>
<li>常用的数据结构有哪些？</li>
<li>Graph Data Structure Interview Questions<ul>
<li>Breadth First Search</li>
<li>Depth First Search</li>
<li>A* Search</li>
<li>Dijkstra Algorithm</li>
<li>Comparing BFS, DFS, A* and Dijkstra</li>
</ul>
</li>
<li>Linked List Interview Questions (coming soon)<ul>
<li>Inserting and Removing nodes</li>
<li>Comparing Strings</li>
<li>Reversing a List</li>
<li>Selecting a Random Node</li>
</ul>
</li>
<li>Dynamic Programming Interview Questions (coming soon)<ul>
<li>Fibonacci Number Sequence</li>
<li>Longest Common Subsequence</li>
</ul>
</li>
<li>Sorting an Searching Interview Questions (coming soon)<ul>
<li>Binary Search</li>
<li>Bubble Sort</li>
<li>Insertion Sort</li>
<li>Merge Sort</li>
<li>Heap Sort</li>
<li>Quick Sort</li>
<li>Interpolation</li>
<li>Tree/Binary Search Tree</li>
<li>Minimum Depth</li>
<li>Maximum Path Sum</li>
</ul>
</li>
<li>Number Theory Interview Questions (coming soon)<ul>
<li>Euclid’s GCD Algorithm</li>
<li>Extending Euclid’s GCD Algorithm</li>
<li>Diophantine Equation</li>
<li>Chinese Remainder Theorem</li>
<li>Modular Inverse</li>
<li>Semi-Perfect Numbers</li>
</ul>
</li>
<li>String Interview Questions (coming soon)<ul>
<li>Reversing a String</li>
<li>Checking if String contains only digits</li>
<li>Finding Duplicate Characters in a String</li>
<li>How to Convert a String to Integer</li>
<li>Removing Duplicate Characters in a String</li>
<li>Finding the Maximum Occuring Character in a String</li>
<li>Find the First Non-Repeating Character in a String</li>
<li>Checking if Two Strings are Anagrams of Each Other</li>
<li>Counting the Number of Words in a String</li>
</ul>
</li>
<li>Array Interview Questions (coming soon)<ul>
<li>Finding the Missing Number from Array</li>
<li>Finding Duplicate Integers in an Array</li>
<li>Finding the Largest and Smallest Number in Unsorted Array</li>
<li>Removing Duplicates from an Array</li>
<li>Reversing an Array</li>
<li>Finding the k-th Smallest Integer in an Unsorted Array</li>
<li>Finding Common Elements Between Multiple Arrays</li>
</ul>
</li>
</ul>
<ul>
<li>基本数据结构<ul>
<li>数组</li>
<li>链表</li>
<li>树<ul>
<li>红黑树</li>
<li>二叉树</li>
</ul>
</li>
<li>图<ul>
<li>无环图</li>
<li>有环图</li>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
<li>Hash</li>
<li>跳跃表</li>
</ul>
</li>
</ul>
<ul>
<li>排序算法<ul>
<li>冒泡排序</li>
<li>归并排序(MERGE SORT)</li>
<li>快速排序(QUICK SORT)</li>
<li>堆积排序(HEAP SORT)</li>
</ul>
</li>
</ul>
<ul>
<li>查找算法<ul>
<li>二分查找</li>
</ul>
</li>
</ul>
<ul>
<li>分布式<ul>
<li>Raft 或者 Paxos 这样的分布式一致性算法</li>
</ul>
</li>
</ul>
<ul>
<li>文本相关<ul>
<li>textrank。自动提取文本摘要</li>
</ul>
</li>
</ul>
<ul>
<li>加密安全算法<ul>
<li>sha256</li>
<li>md5</li>
<li>RSA非对称加密算法</li>
<li>哈希安全算法(Secure Hash Algorithm)</li>
<li>整数质因子分解算法(Integer factorization)</li>
<li>Diffie-Hellman密钥交换算法<ul>
<li>一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。</li>
</ul>
</li>
<li>RSA<ul>
<li>公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>链接分析算法(Link Analysis)</p>
</li>
<li><p>比例微积分算法(Proportional Integral Derivative Algorithm)</p>
</li>
<li><p>数据压缩算法</p>
</li>
<li><p>随机数生成算法</p>
</li>
<li><p>推荐算法</p>
</li>
<li><p>决策树算法</p>
</li>
<li><p>人工智能算法</p>
<ul>
<li>C4.5算法。<ul>
<li>C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42395865" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42395865</a></li>
</ul>
</li>
<li>CART算法。<ul>
<li>CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42558235" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42558235</a></li>
</ul>
</li>
<li>KNN(K最近邻)算法。<ul>
<li>给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42613011" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42613011</a></li>
</ul>
</li>
<li>Naive Bayes(朴素贝叶斯)算法。<ul>
<li>朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。</a></li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42680161" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42680161</a></li>
</ul>
</li>
<li>SVM(支持向量机)算法。<ul>
<li>支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42780439" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42780439</a></li>
</ul>
</li>
<li>EM(期望最大化)算法。<ul>
<li>期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42921789" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42921789</a></li>
</ul>
</li>
<li>Apriori算法。<ul>
<li>Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43059211" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43059211</a></li>
</ul>
</li>
<li>FP-Tree(频繁模式树)算法。<ul>
<li>这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43234309" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43234309</a></li>
</ul>
</li>
<li>PageRank(网页重要性/排名)算法。<ul>
<li>PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link Span攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li>
</ul>
</li>
<li>HITS算法。<ul>
<li>HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li>
</ul>
</li>
<li>K-Means(K均值)算法。<ul>
<li>K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43373159" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43373159</a></li>
</ul>
</li>
<li>BIRCH算法。<ul>
<li>BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43532111" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43532111</a></li>
</ul>
</li>
<li>AdaBoost算法。<ul>
<li>AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43635115" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43635115</a></li>
</ul>
</li>
<li>GSP算法。<ul>
<li>GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43699083" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43699083</a></li>
</ul>
</li>
<li>PreFixSpan算法。<ul>
<li>PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43766253" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43766253</a></li>
</ul>
</li>
<li>CBA(基于关联规则分类)算法。<ul>
<li>CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43818787" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43818787</a></li>
</ul>
</li>
<li>RoughSets(粗糙集)算法。<ul>
<li>粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43876001" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43876001</a></li>
</ul>
</li>
<li>gSpan算法。<ul>
<li>gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/4392427" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/4392427</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>其他算法<ul>
<li>傅立叶变换<ul>
<li>实现时间域函数与频率域函数之间的相互转化</li>
</ul>
</li>
<li>快速傅立叶变换</li>
<li>代克思托演算法 (Dijkstra’s algorithm)<ul>
<li>解决最短路径问题</li>
</ul>
</li>
<li>A* 搜索算法<ul>
<li>图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。</li>
</ul>
</li>
<li>集束搜索（又名定向搜索，Beam Search）<ul>
<li>最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。</li>
</ul>
</li>
<li>分支界定算法（Branch and Bound）<ul>
<li>在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。</li>
</ul>
</li>
<li>Buchberger算法<ul>
<li>一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化</li>
</ul>
</li>
<li>离散微分算法（Discrete differentiation）</li>
<li>动态规划算法（Dynamic Programming）<ul>
<li>展示互相覆盖的子问题和最优子架构算法</li>
</ul>
</li>
<li>欧几里得算法（Euclidean algorithm）<ul>
<li>计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。</li>
</ul>
</li>
<li>期望-最大算法（Expectation-maximization algorithm，又名EM-Training）<ul>
<li>在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。</li>
</ul>
</li>
<li>梯度下降（Gradient descent）<ul>
<li>一种数学上的最优化算法。</li>
</ul>
</li>
<li>Karatsuba乘法<ul>
<li>需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。</li>
</ul>
</li>
<li>LLL算法（Lenstra-Lenstra-Lovasz  lattice reduction）<ul>
<li>以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。</li>
</ul>
</li>
<li>最大流量算法（Maximum flow）<ul>
<li>该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。</li>
</ul>
</li>
<li>牛顿法（Newton’s method）<ul>
<li>求非线性方程（组）零点的一种重要的迭代法。</li>
</ul>
</li>
<li>Q-learning学习算法<ul>
<li>这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。</li>
</ul>
</li>
<li>两次筛法（Quadratic Sieve）<ul>
<li>现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。</li>
</ul>
</li>
<li>RANSAC<ul>
<li>是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。</li>
</ul>
</li>
<li>Schönhage-Strassen算法<ul>
<li>在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。</li>
</ul>
</li>
<li>单纯型算法（Simplex Algorithm）<ul>
<li>在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。</li>
</ul>
</li>
<li>奇异值分解（Singular value decomposition，简称SVD）<ul>
<li>在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。</li>
</ul>
</li>
<li>求解线性方程组（Solving a system of linear equations）<ul>
<li>线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</li>
</ul>
</li>
<li>Strukturtensor算法<ul>
<li>应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。</li>
</ul>
</li>
<li>合并查找算法（Union-find）<ul>
<li>给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：<ul>
<li>查找：判断某特定元素属于哪个组。</li>
<li>合并：联合或合并两个组为一个组。</li>
</ul>
</li>
</ul>
</li>
<li>维特比算法（Viterbi algorithm）<ul>
<li>寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/storage/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>http面试题</title>
    <url>/interview/net/http.html</url>
    <content><![CDATA[<h3 id="HTTP-Keep-Alive的作用及应用场景"><a href="#HTTP-Keep-Alive的作用及应用场景" class="headerlink" title="HTTP Keep-Alive的作用及应用场景"></a>HTTP Keep-Alive的作用及应用场景</h3><ul>
<li>作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。</li>
<li>缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。</li>
<li>解决：Keep-Alive: timeout=5, max=100。timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</li>
</ul>
<h3 id="表单中-get与post提交方法的区别"><a href="#表单中-get与post提交方法的区别" class="headerlink" title="表单中 get与post提交方法的区别?"></a>表单中 get与post提交方法的区别?</h3><ul>
<li>get是发送请求HTTP协议通过url参数传递进行接收；数据量小；不太安全</li>
<li>post是实体数据,可以通过表单提交大量信息；数据量大；安全</li>
</ul>
<h3 id="下列HTTP状态码出现的可能原因-如何处理"><a href="#下列HTTP状态码出现的可能原因-如何处理" class="headerlink" title="下列HTTP状态码出现的可能原因, 如何处理"></a>下列HTTP状态码出现的可能原因, 如何处理</h3><ul>
<li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li>
<li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li>
<li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/net/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/cs/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/frontend/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>js面试题</title>
    <url>/interview/frontend/js.html</url>
    <content><![CDATA[<ul>
<li>基本数据类型？<ul>
<li>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li>
</ul>
</li>
<li>介绍js有哪些内置对象？<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
</li>
<li>null，undefined 的区别？<ul>
<li>null         表示一个对象是“没有值”的值，也就是值为“空”；</li>
<li>undefined     表示一个变量声明了没有初始化(赋值)；</li>
<li>undefined不是一个有效的JSON，而null是；</li>
<li>undefined的类型(typeof)是undefined；</li>
<li>null的类型(typeof)是object；</li>
<li>Javascript将未赋值的变量默认值设为undefined；</li>
<li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</li>
<li>注意：<ul>
<li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li>
<li>null == undefined // true</li>
<li>null === undefined // false</li>
</ul>
</li>
</ul>
</li>
<li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>//使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：<br>let obj = {};<br>let arr = [];<br>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>//从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br>let obj = {};<br>let arr = [];<br>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]<br>//而 [] === false 是返回 false 的。</li>
<li></li>
</ul>
<ul>
<li><h4 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h4><ul>
<li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
<li>两种类型的区别是：存储位置不同；<ul>
<li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h4><ul>
<li>parseFloat(‘12.3b’);</li>
<li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li>
<li>如何验证非空</li>
</ul>
</li>
<li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li>
<li><h4 id="异步与同步请求如何实现？"><a href="#异步与同步请求如何实现？" class="headerlink" title="异步与同步请求如何实现？"></a>异步与同步请求如何实现？</h4></li>
<li><h4 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h4><ul>
<li>window对象是指浏览器打开的窗口。</li>
<li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</li>
</ul>
</li>
<li><h4 id="cookie-和session-的区别？"><a href="#cookie-和session-的区别？" class="headerlink" title="cookie 和session 的区别？"></a>cookie 和session 的区别？</h4><ul>
<li>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li>
<li>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>5.所以个人建议：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li>
</ul>
</li>
<li><h4 id="cookie、sessionStorage、localStorage区别？"><a href="#cookie、sessionStorage、localStorage区别？" class="headerlink" title="cookie、sessionStorage、localStorage区别？"></a>cookie、sessionStorage、localStorage区别？</h4><ul>
<li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li>
<li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li>
<li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
<li>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
<li><h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</li>
<li>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性。</li>
</ul>
</li>
<li><h4 id="如何判断在数组中是否存在"><a href="#如何判断在数组中是否存在" class="headerlink" title="如何判断在数组中是否存在"></a>如何判断在数组中是否存在</h4>indexOf</li>
<li><h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><ul>
<li>使用instanceof</li>
</ul>
</li>
<li><h4 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h4></li>
<li><h4 id="数组转字符串-join-；字符串转数组-split-‘’"><a href="#数组转字符串-join-；字符串转数组-split-‘’" class="headerlink" title="数组转字符串(join)；字符串转数组(split(‘’))"></a>数组转字符串(join)；字符串转数组(split(‘’))</h4></li>
<li><h4 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h4>*(1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>*（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>*（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>*（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>*（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>*（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>*（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br>*（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<ul>
<li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</li>
</ul>
</li>
<li><h4 id="jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4></li>
<li><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
</li>
<li><h4 id="axios有哪些方法、参数？"><a href="#axios有哪些方法、参数？" class="headerlink" title="axios有哪些方法、参数？"></a>axios有哪些方法、参数？</h4></li>
<li><h4 id="ajax请求头部携带cookie"><a href="#ajax请求头部携带cookie" class="headerlink" title="ajax请求头部携带cookie"></a>ajax请求头部携带cookie</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true;//让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ul>
<li><h4 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h4></li>
<li><h4 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h4><ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</li>
</ul>
</li>
<li><h4 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h4><ul>
<li>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</li>
</ul>
</li>
<li><h4 id="组件的生命周期有哪些？"><a href="#组件的生命周期有哪些？" class="headerlink" title="组件的生命周期有哪些？"></a>组件的生命周期有哪些？</h4><ul>
<li>组件的声明周期有三种阶段，一种是初始化阶段（Mounting），一种是更新阶段（Updating）最后一种是析构阶段（Unmounting）。而这两个阶段的声明周期函数都是相似且有一一对应的关系的</li>
</ul>
</li>
<li><h4 id="什么时候使用-Class-Component-而非-Functional-Component"><a href="#什么时候使用-Class-Component-而非-Functional-Component" class="headerlink" title="什么时候使用 Class Component 而非 Functional Component?"></a>什么时候使用 Class Component 而非 Functional Component?</h4><ul>
<li>如果你的组件有state或者使用了生命周期函数，那么请使用Class component。 否则，使用Functional component。</li>
</ul>
</li>
<li>什么是keys 而且为什么他们很重要<ul>
<li>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li>
</ul>
</li>
</ul>
<ul>
<li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul>
<li>1）创建新节点<ul>
<li>createDocumentFragment() //创建一个DOM</li>
<li>createElement() //创建一个具体的</li>
<li>createTextNode() //创建一个文本节点</li>
</ul>
</li>
<li>2）添加、移除、替换、插入<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //并没有insertAfter()</li>
</ul>
</li>
<li>3）查找<ul>
<li>getElementsByTagName() //通过标签名</li>
<li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById() //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/interview/frontend/vue.html</url>
    <content><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul>
<li><p>####1.请谈谈Vue中的MVVM模式</p>
<ul>
<li>MVVM全称是Model-View-ViewModel</li>
<li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</li>
<li>DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li>
</ul>
</li>
<li><p>####2.v-show和v-if指令的共同点和不同点?</p>
<ul>
<li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li>
<li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li>
</ul>
</li>
<li><p>####3.如何让CSS只在当前组件中起作用?</p>
<ul>
<li>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></li>
</ul>
</li>
<li><p>####4.Vue中引入组件的步骤?</p>
<ul>
<li>1.采用ES6的import … from …语法或CommonJS的require()方法引入组件</li>
<li>2.对组件进行注册,代码如下</li>
<li>3.使用组件<my-component></my-component><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="组件间如何传递值或调用"><a href="#组件间如何传递值或调用" class="headerlink" title="组件间如何传递值或调用"></a>组件间如何传递值或调用</h4></li>
<li><p>####5.在Vue中使用插件的步骤</p>
<ul>
<li>采用ES6的import … from …语法或CommonJS的require()方法引入插件</li>
<li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li>
</ul>
</li>
<li><p>####6.请列举出3个Vue中常用的生命周期钩子函数?</p>
<ul>
<li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li>
<li>mounted:  el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li>
<li>activated: keep-alive组件激活时调用</li>
</ul>
</li>
<li><p>####7.请简述下Vuex的原理和使用方法</p>
<ul>
<li><p>数据单向流动</p>
</li>
<li><p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</p>
</li>
<li><p>Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</p>
</li>
<li><p>上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p>
<ul>
<li>state中保存着共有数据</li>
<li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li>
<li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>css面试题</title>
    <url>/interview/frontend/css.html</url>
    <content><![CDATA[<ul>
<li><p>display:none和visibility:hidden的区别？</p>
<ul>
<li>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>
<li>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>
</ul>
</li>
<li><p>CSS中link 和@import的区别是？</p>
<ul>
<li>(1) link属于HTML标签，而@import是CSS提供</li>
<li>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li>
<li>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
<li>(4) link方式的样式的权重 高于@import的权重.</li>
</ul>
</li>
<li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
<ul>
<li>选择符<ul>
<li>1.id选择器（ # myid）</li>
<li>2.类选择器（.myclassname）</li>
<li>3.标签选择器（div, h1, p）</li>
<li>4.相邻选择器（h1 + p）</li>
<li>5.子选择器（ul &gt; li）</li>
<li>6.后代选择器（li a）</li>
<li>7.通配符选择器（ * ）</li>
<li>8.属性选择器（a[rel = “external”]）</li>
<li>9.伪类选择器（a: hover, li:nth-child）</li>
</ul>
</li>
<li>优先级原则<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;</li>
</ul>
</li>
<li>优先级为:<ul>
<li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li>
<li>!important &gt; id &gt; class &gt; tag</li>
<li>important 比 内联优先级高</li>
</ul>
</li>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height</li>
</ul>
</li>
<li><p>display有哪些值？说明他们的作用。</p>
<ul>
<li>block     块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li>
<li>none     缺省值。象行内元素类型一样显示。</li>
<li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li>
<li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li>
<li>list-item     象块类型元素一样显示，并添加样式列表标记。</li>
<li>table     此元素会作为块级表格来显示。</li>
<li>inherit     规定应该从父元素继承 display 属性的值。</li>
</ul>
</li>
<li><p>position属性：指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型</p>
<ul>
<li>默认值：static</li>
<li>可选择值：relative、absolute、fixed、static、sticky、inherit</li>
<li>static:默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>
<li>relative:生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li>
<li>fiexd:生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
<li>absoluate:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
<li>sticky:粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li>
<li>inherit:规定应该从父元素继承 position 属性的值。</li>
</ul>
</li>
<li><p>display属性：规定元素应该生成的框的类型</p>
<ul>
<li>none:此元素不会被显示</li>
<li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li>
<li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li>
<li>inline-block:行内块元素。（CSS2.1 新增的值）</li>
<li>list-item: 此元素会作为列表显示。</li>
<li>run-in: 此元素会根据上下文作为块级元素或内联元素显示。</li>
<li>compact:CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li>
<li>marker:CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li>
<li>table: 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</table></li>
<li>inline-table: 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</table></li>
<li>table-row-group: 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</tbody></li>
<li>table-header-group: 此元素会作为一个或多个行的分组来显示（类似 <thead>）。</thead></li>
<li>table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</tfoot></li>
<li>table-row: 此元素会作为一个表格行显示（类似 <tr>）。</tr></li>
<li>table-column-group: 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</colgroup></li>
<li>table-column: 此元素会作为一个单元格列显示（类似 <col>）</li>
<li>table-cell: 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）</th></td></li>
<li>table-caption: 此元素会作为一个表格标题显示（类似 <caption>）</caption></li>
<li>inherit:规定应该从父元素继承 display 属性的值。</li>
<li>flex:用flex布局</li>
</ul>
</li>
<li><p>盒模型</p>
<ul>
<li>总共有四层，从外到内是：margin、border、padding、content</li>
<li>一个盒子中主要的属性就5个：width、height、padding、border、margin。<ul>
<li>width和height：内容的宽度、高度（不是盒子的宽度、高度）。</li>
<li>padding：内边距。</li>
<li>border：边框。</li>
<li>margin：外边距。<br>如果设置background-color，那么border以内的所有都会有背景色。<br>如果想让盒子保持大小不变，那么就要保证border以内的，也就是padding+content的width和height保持不变。</li>
</ul>
</li>
</ul>
</li>
<li><p>像素</p>
<ul>
<li>基准像素</li>
</ul>
</li>
<li><p>行内元素与块元素</p>
<ul>
<li>块元素</li>
<li>行内元素</li>
</ul>
</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul>
<li>display:flex</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机基础面试</title>
    <url>/interview/cs/basic.html</url>
    <content><![CDATA[<h3 id="1-对于软件运行机制的理解。"><a href="#1-对于软件运行机制的理解。" class="headerlink" title="1.对于软件运行机制的理解。"></a>1.对于软件运行机制的理解。</h3><ul>
<li>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</li>
<li>具体的工作流程是<ul>
<li>1.在控制器指挥下，从存储器上取出指令；</li>
<li>2.分析指令，得到计算命令和待操作的数；</li>
<li>3.从存储器上取出待计算的数放入运算器；</li>
<li>4.运算器计算结果；</li>
<li>5.输出到存储器或输出设备。</li>
</ul>
</li>
</ul>
<h3 id="2-对于好的代码架构的理解？或者好的代码结构是怎样的？"><a href="#2-对于好的代码架构的理解？或者好的代码结构是怎样的？" class="headerlink" title="2.对于好的代码架构的理解？或者好的代码结构是怎样的？"></a>2.对于好的代码架构的理解？或者好的代码结构是怎样的？</h3><ul>
<li>高内聚、低耦合</li>
<li>易扩展，维护方便</li>
<li>避免过度设计</li>
<li>可读性高，结构清晰</li>
<li>代码风格统一</li>
<li>低复杂性，简练</li>
</ul>
<h3 id="3-对于编码规范的理解，有哪些好的编程规范"><a href="#3-对于编码规范的理解，有哪些好的编程规范" class="headerlink" title="3.对于编码规范的理解，有哪些好的编程规范"></a>3.对于编码规范的理解，有哪些好的编程规范</h3><ul>
<li>变量命名规范</li>
<li>代码缩进规范</li>
<li>大小写规范</li>
<li>注释规范</li>
<li>可读性强</li>
</ul>
<h3 id="4-编程安全应该注意哪些问题"><a href="#4-编程安全应该注意哪些问题" class="headerlink" title="4.编程安全应该注意哪些问题"></a>4.编程安全应该注意哪些问题</h3><ul>
<li>表单数据验证</li>
<li>防范SQL语句注入攻击</li>
<li>程序资源的释放。例如内存泄漏、数据库连接、文件句柄等资源</li>
<li>线程安全性</li>
<li>数据类型校验</li>
</ul>
<h3 id="5-如何提升开发效率？提升开发效率的方法有哪些？"><a href="#5-如何提升开发效率？提升开发效率的方法有哪些？" class="headerlink" title="5.如何提升开发效率？提升开发效率的方法有哪些？"></a>5.如何提升开发效率？提升开发效率的方法有哪些？</h3><ul>
<li>大显示器</li>
<li>机械键盘</li>
<li>编辑器快捷键</li>
<li>快速文档查询能力</li>
<li>需求的准确理解，防止可能的返工</li>
</ul>
<h3 id="6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"><a href="#6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？" class="headerlink" title="6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"></a>6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</h3><ul>
<li>保证开发结果与需求相符</li>
<li>保证代码的正确性、可靠性</li>
<li>新的功能是否影响旧有的功能</li>
</ul>
<h3 id="7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"><a href="#7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？" class="headerlink" title="7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"></a>7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</h3><h3 id="对于软件运行机制的理解。"><a href="#对于软件运行机制的理解。" class="headerlink" title="对于软件运行机制的理解。"></a>对于软件运行机制的理解。</h3><ul>
<li><p>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</p>
</li>
<li><p>具体的工作流程是</p>
<ul>
<li>1在控制器指挥下，从存储器上取出指令；</li>
<li>2分析指令，得到计算命令和待操作的数；</li>
<li>3从存储器上取出待计算的数放入运算器；</li>
<li>4运算器计算结果；</li>
<li>5输出到存储器或输出设备。</li>
</ul>
</li>
<li><p>因此存储器是关键。存储器分为：寄存器（CPU内部，用于存放待操作数和结果）；高速缓存（通常在CPU内部，用做数据缓冲区）；内存；外存。</p>
</li>
<li><p>接下来是具体的命令执行，这需要预先定义好CPU能执行的命令，即CPU的指令集，用来计算和控制计算机系统的一套指令的集合，典型的有Intel X86指令集和ARM指令集。具体的指令以二进制码表示，包含一个或多个字节，也包含指令码（具体命令）和操作数（要操作的数或地址）。在具体的执行中，把宏观层次的命令转换为满足指令集要求的二进制代码，然后才能在计算机上运行；参见CPU的具体组成成分运算器 ALU和寄存器和控制器的工作流程。</p>
</li>
<li><p>最后程序的执行就是在以上基础进行的，一开始使用机器语言的时候，具体的命令形式是1001010101010011 00011110这样的。这个虽然足够底层能够直接与计算机进行交互，但不是一般人能够搞得定的，于是就有更高层次的抽象，汇编语言，变成add 0 1这种相对来说比较友好的语言；接着就是高级语言了，更加抽象，但接近我们一般人的思维习惯，如d = a*b+c;当然，这是前人的工作成果，他们把很多的细节封装起来，我们这些后人之间调用就行，不用管其具体的转换即具体的编译，不然一句程序有可能转换为多句指令，而且其执行的次序和次数之类的细节，各种内存地址和数据的调用足够使人发疯。</p>
</li>
<li><p>对于设计模式的理解，为什么要有设计模式，用过什么设计模式，每个的应用场景是怎样的？</p>
<ul>
<li>设计模式主要分三个类型:创建型、结构型和行为型。<br>创建型：<br>一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 ；<br>应用场景：一个无状态的类使用单例模式节省内存资源。<br>二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br>应用场景：一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。<br>三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。     应用场景：由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义 一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。<br>四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br>应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。<br>五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br>应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限</li>
</ul>
</li>
</ul>
<p>行为型：<br>    六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br>  应用场景：迭代。<br>    七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br>应用场景： 某个实例的变化将影响其他多个对象。<br>    八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。<br>应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类<br>     九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。<br>应用场景：将命令者与执行者完全解耦。<br>    十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br>应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。<br>    十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。       应用场景：<br>   十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系<br>    十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。<br>    十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。<br>    十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>    十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p>结构型：<br>    十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。<br>    十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。<br>    十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问<br>    二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。<br>    二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。<br>    二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br>    二十三、Flyweight，享元模式</p>
]]></content>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/interview/frontend/basic.html</url>
    <content><![CDATA[<h2 id="0x00、HTML"><a href="#0x00、HTML" class="headerlink" title="0x00、HTML"></a>0x00、HTML</h2><h2 id="0x01、CSS"><a href="#0x01、CSS" class="headerlink" title="0x01、CSS"></a>0x01、CSS</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><ul>
<li>display:none和visibility:hidden有什么区别</li>
<li>html引入样式的方式有几种</li>
<li>什么是盒模型</li>
<li>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</li>
<li>CSS什么是伪类，伪类有那些，有什么作用？</li>
<li>flex布局是什么，都有哪些语法，相比grid布局有什么不同？</li>
<li>css如何动态计算高度或宽度？</li>
</ul>
<h4 id="2-sass"><a href="#2-sass" class="headerlink" title="2.sass"></a>2.sass</h4><ul>
<li>什么是SASS？</li>
<li>sass的优缺点</li>
<li>SASS中的嵌套规则是什么？</li>
<li>有哪些运算符，都有什么作用？</li>
<li>如何在SASS中引用父选择器？</li>
</ul>
<h2 id="0x02、JS"><a href="#0x02、JS" class="headerlink" title="0x02、JS"></a>0x02、JS</h2><h4 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h4><ul>
<li>介绍js有哪些内置对象？</li>
<li>null，undefined 的区别？</li>
<li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</li>
<li>如何将字符串转化为数字，例如’12.3b’</li>
<li>字符串转化为数组，数组转化为字符串</li>
<li>如何判断一个对象中是否存在某个属性。</li>
<li>空数据组的boolean值</li>
<li>字符串替换值用什么方法？全部替换如何做？</li>
<li>什么是原型链</li>
</ul>
<h4 id="2-es6"><a href="#2-es6" class="headerlink" title="2.es6"></a>2.es6</h4><ul>
<li>新增了什么语法</li>
</ul>
<h4 id="3-typescript"><a href="#3-typescript" class="headerlink" title="3.typescript"></a>3.typescript</h4><ul>
<li>您对Typescript中的类有什么了解？列出类的一些功能。</li>
<li>如何从TypeScript中的子类调用基类构造函数？</li>
<li>内部模块和外部模块有什么区别？</li>
<li>请解释Typescript中的装饰器？</li>
<li>TypeScript类中属性/方法的默认可见性是什么？</li>
<li>如何在TypeScript中检查null和undefined？</li>
<li>readonly 和 const 有什么区别？</li>
</ul>
<h2 id="0x03、Vue"><a href="#0x03、Vue" class="headerlink" title="0x03、Vue"></a>0x03、Vue</h2><h2 id="0x04、React"><a href="#0x04、React" class="headerlink" title="0x04、React"></a>0x04、React</h2><ul>
<li>React 中 refs 的作用是什么？</li>
<li>createElement 与 cloneElement 的区别是什么？</li>
<li>组件的生命周期有哪些，生命周期的函数有哪些？</li>
<li>什么情况下组件会被更新</li>
<li>指令有哪些</li>
<li>子父组件如何通信</li>
</ul>
<h2 id="0x05、综合"><a href="#0x05、综合" class="headerlink" title="0x05、综合"></a>0x05、综合</h2><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h4><ul>
<li>前端性能优化有哪些？</li>
<li>cookie和session</li>
<li>本地存储类型及限制</li>
<li>webpack打包如何优化</li>
</ul>
<h4 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h4><ul>
<li>网络请求流程</li>
</ul>
<h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h4><ul>
<li>数据提交</li>
<li>跨域问题如何解决</li>
</ul>
<h4 id="4-业务场景"><a href="#4-业务场景" class="headerlink" title="4.业务场景"></a>4.业务场景</h4><ul>
<li>单点登录实现</li>
</ul>
<h4 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h4><ul>
<li>判断是否是数字、正数</li>
<li>替换变量</li>
</ul>
<h2 id="0x06、小程序"><a href="#0x06、小程序" class="headerlink" title="0x06、小程序"></a>0x06、小程序</h2><h4 id="1-uniapp"><a href="#1-uniapp" class="headerlink" title="1.uniapp"></a>1.uniapp</h4><h4 id="2-Taro"><a href="#2-Taro" class="headerlink" title="2.Taro"></a>2.Taro</h4><ul>
<li>为什么要用这个</li>
<li>坑在哪里</li>
<li>设计稿尺寸问题</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络基础面试题</title>
    <url>/interview/net/basic.html</url>
    <content><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul>
<li><ol>
<li>TCP报头格式</li>
</ol>
</li>
<li><ol start="2">
<li>UDP报头格式</li>
</ol>
</li>
<li><ol start="3">
<li>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</li>
</ol>
</li>
<li><ol start="4">
<li>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</li>
</ol>
</li>
<li><ol start="5">
<li>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</li>
</ol>
</li>
<li><ol start="6">
<li>OSI协议、TCP/IP协议以及每层对应的协议。</li>
</ol>
</li>
<li><ol start="7">
<li>SESSION机制、cookie机制</li>
</ol>
</li>
<li><ol start="8">
<li>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</li>
</ol>
</li>
<li><ol start="9">
<li>打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</li>
</ol>
</li>
<li><ol start="10">
<li>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</li>
</ol>
</li>
<li><ol start="11">
<li>IP地址子网划分</li>
</ol>
</li>
<li><ol start="12">
<li>POST和GET区别</li>
</ol>
</li>
<li><ol start="13">
<li>DNS解析过程</li>
</ol>
</li>
</ul>
<h2 id="深入部分"><a href="#深入部分" class="headerlink" title="深入部分"></a>深入部分</h2><ul>
<li><ol start="14">
<li>TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）</li>
</ol>
</li>
<li><ol start="15">
<li>地址解析协议ARP</li>
</ol>
</li>
<li><ol start="16">
<li>交换机和路由器的区别</li>
</ol>
</li>
</ul>
<h3 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h3><h3 id="端口个数为什么是65535个？"><a href="#端口个数为什么是65535个？" class="headerlink" title="端口个数为什么是65535个？"></a>端口个数为什么是65535个？</h3><ul>
<li>在TCP、UDP协议的开头，会分别有16位来存储源端口号和目标端口号，所以端口个数是2^16-1=65535个。</li>
<li>端口被设计出来主要是为了给协议栈和应用对应：<ul>
<li>协议栈用端口号将数据分配给不同的应用层程序</li>
<li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li>
</ul>
</li>
</ul>
<h3 id="端口状态有哪些"><a href="#端口状态有哪些" class="headerlink" title="端口状态有哪些"></a>端口状态有哪些</h3><ul>
<li>1、LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。</li>
<li>2、ESTABLISHED状态。ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li>
<li>3、CLOSE_WAIT。对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li>
<li>4、TIME_WAIT<ul>
<li>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</li>
<li>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li>
</ul>
</li>
<li>5、SYN_SENT状态<ul>
<li>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</li>
</ul>
</li>
</ul>
<h3 id="http的s加密是在哪一层，如何处理的。"><a href="#http的s加密是在哪一层，如何处理的。" class="headerlink" title="http的s加密是在哪一层，如何处理的。"></a>http的s加密是在哪一层，如何处理的。</h3><ul>
<li>s指的是SSL或TLS加密。因为http是明文传输，为了数据安全，在应用层与传输层中间添加一个加密层来加密数据的传输。</li>
<li>这个加密用了对称加密和非对称加密的结合。</li>
</ul>
<h3 id="什么是socket，为什么要有socket。"><a href="#什么是socket，为什么要有socket。" class="headerlink" title="什么是socket，为什么要有socket。"></a>什么是socket，为什么要有socket。</h3><ul>
<li>socket是传输层协议的分装，让应用层更方便的进行网络编程。</li>
</ul>
<h3 id="urlencode和urldecode何时使用，有什么作用？"><a href="#urlencode和urldecode何时使用，有什么作用？" class="headerlink" title="urlencode和urldecode何时使用，有什么作用？"></a>urlencode和urldecode何时使用，有什么作用？</h3><ul>
<li>url中合法的字符有两大类<ul>
<li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li>
<li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（），圆括号（()`）</li>
</ul>
</li>
<li>用来传输中文编码，转换成统一安全字符格式。</li>
</ul>
<h3 id="python中如何使用urlencode和urldecode。"><a href="#python中如何使用urlencode和urldecode。" class="headerlink" title="python中如何使用urlencode和urldecode。"></a>python中如何使用urlencode和urldecode。</h3><ul>
<li>urllib.parse.quote(str,  safe=’/‘)<ul>
<li>http%3A//<a href="http://www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li>
</ul>
</li>
<li>urllib.parse.quote(str,  safe=’/:?=’)<ul>
<li><a href="http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li>
</ul>
</li>
<li>如上，默认会处理一些非中文字符串情况，所以可以对中文进行单独转义既可</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据库基础面试题</title>
    <url>/interview/storage/basic.html</url>
    <content><![CDATA[<h3 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h3><ul>
<li>唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</li>
<li>为什么要用 B+tree 作为 MySql 索引的数据结构</li>
<li>聚集索引与非聚集索引的区别</li>
<li>DDL、DML、DCL 分别指什么</li>
<li>explain 命令</li>
<li>数据库的几大范式</li>
<li>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</li>
<li>什么是自适应哈希索引（AHI）</li>
<li>limit 20000 加载很慢怎么解决</li>
<li>常见的几种分布式 ID 的设计方案<br>基础部分<ul>
<li><ol>
<li>事务四大特性（ACID）</li>
</ol>
</li>
<li><ol start="2">
<li>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别</li>
</ol>
</li>
<li><ol start="3">
<li>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</li>
</ol>
</li>
<li><ol start="4">
<li>数据库的优化（从sql语句优化和索引两个部分回答）</li>
</ol>
</li>
<li><ol start="5">
<li>索引有B+索引和hash索引，各自的区别</li>
</ol>
</li>
<li><ol start="6">
<li>B+索引数据结构，和B树的区别</li>
</ol>
</li>
<li><ol start="7">
<li>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</li>
</ol>
</li>
<li><ol start="8">
<li>聚集索引和非聚集索引区别。</li>
</ol>
</li>
<li><ol start="9">
<li>有哪些锁（乐观锁悲观锁），select时怎么加排它锁</li>
</ol>
</li>
<li><ol start="10">
<li>关系型数据库和非关系型数据库区别</li>
</ol>
</li>
<li><ol start="11">
<li>了解nosql</li>
</ol>
</li>
<li><ol start="12">
<li>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</li>
</ol>
</li>
<li><ol start="13">
<li>数据库的主从复制</li>
</ol>
</li>
<li><ol start="14">
<li>使用explain优化sql和索引</li>
</ol>
</li>
<li><ol start="15">
<li>long_query怎么解决</li>
</ol>
</li>
<li><ol start="16">
<li>内连接、外连接、交叉连接、笛卡儿积等<br>深入</li>
</ol>
</li>
<li><ol>
<li>MVCC机制</li>
</ol>
</li>
<li><ol start="2">
<li>根据具体场景，说明版本控制机制</li>
</ol>
</li>
<li><ol start="3">
<li>死锁怎么解决</li>
</ol>
</li>
<li><ol start="4">
<li>varchar和char的使用场景。</li>
</ol>
</li>
<li><ol start="5">
<li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><ul>
<li>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li>
</ul>
<h3 id="优化MYSQL数据库的方法"><a href="#优化MYSQL数据库的方法" class="headerlink" title="优化MYSQL数据库的方法?"></a>优化MYSQL数据库的方法?</h3><ul>
<li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM</li>
<li>使用连接（JOIN）来代替子查询</li>
<li>使用联合(UNION)来代替手动创建的临时表</li>
<li>建立索引</li>
</ul>
<p>varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</p>
<h3 id="优化数据库的方法。说说-SQL-优化之道"><a href="#优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="优化数据库的方法。说说 SQL 优化之道"></a>优化数据库的方法。说说 SQL 优化之道</h3><ul>
<li>主机性能</li>
<li>内存使用性能</li>
<li>网络传输性能</li>
<li>SQL语句执行性能</li>
</ul>
<h3 id="ACID规则"><a href="#ACID规则" class="headerlink" title="ACID规则"></a>ACID规则</h3><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<ul>
<li>1、A (Atomicity) 原子性<ul>
<li>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li>
<li>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li>
</ul>
</li>
<li>2、C (Consistency) 一致性<ul>
<li>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li>
</ul>
</li>
<li>3、I (Isolation) 独立性<ul>
<li>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</li>
<li>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li>
</ul>
</li>
<li>4、D (Durability) 持久性<ul>
<li>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql面试题</title>
    <url>/interview/storage/mysql.html</url>
    <content><![CDATA[<h3 id="Mysql存储引擎有哪些？有什么区别？"><a href="#Mysql存储引擎有哪些？有什么区别？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？"></a>Mysql存储引擎有哪些？有什么区别？</h3><ul>
<li>innodb、myisam</li>
<li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li>
<li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li>
</ul>
<h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><ul>
<li>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。</li>
<li>char 固定长度，所以在处理速度上要比</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/backend/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python面试题</title>
    <url>/interview/backend/python.html</url>
    <content><![CDATA[<ul>
<li><p>装饰器的写法，并打印出方法名</p>
</li>
<li><p>定义一个字典，如果有动态的数据是不能够定义的，比如list. Tuple、字符串、数字是可以的</p>
</li>
<li><p>b树，b+树</p>
</li>
<li><p>深浅拷贝</p>
</li>
<li><p>redis数据类型，缓存失效方案</p>
</li>
<li><p>mysql存储引擎，索引方案</p>
</li>
<li><p>有序list合并成一个</p>
</li>
<li><p>协程</p>
</li>
<li><p>grpc</p>
</li>
<li><p><a href="https://github.com/leeguandong/Interview-code-practice-python" target="_blank" rel="noopener">https://github.com/leeguandong/Interview-code-practice-python</a></p>
</li>
<li><p><a href="https://github.com/princewen/leetcode_python" target="_blank" rel="noopener">https://github.com/princewen/leetcode_python</a></p>
</li>
<li><p><a href="http://bookshadow.com/leetcode/" target="_blank" rel="noopener">http://bookshadow.com/leetcode/</a></p>
</li>
<li><p>子类初始化父类</p>
<ul>
<li>子类必须显示的调用父类的构造方法赖初始化父类才行。</li>
</ul>
</li>
<li><p>python性能分析</p>
<ul>
<li>python -m cProfile -o profile.out main.py</li>
<li>brew install graphviz</li>
<li>pip install gprof2dot</li>
<li>gprof2dot -f pstats profile.out | dot -Tpng -o profile.png<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Stats对象</span></span><br><span class="line">p = pstats.Stats(<span class="string">"profile/profile.out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></span><br><span class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></span><br><span class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></span><br><span class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"sum_num"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></span><br><span class="line">p.print_callees(<span class="string">"topic"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>语言特性<br>1.谈谈对 Python 和其他语言的区别<br>2.简述解释型和编译型编程语言<br>3.Python 的解释器种类以及相关特点？<br>4.说说你知道的Python3 和 Python2 之间的区别？<br>5.Python3 和 Python2 中 int 和 long 区别？<br>6.xrange 和 range 的区别？<br>编码规范<br>7.什么是 PEP8?<br>8.了解 Python 之禅么？<br>9.了解 dosctring 么？<br>10.了解类型注解么？<br>11.例举你知道 Python 对象的命名规范，例如方法或者类等<br>12.Python 中的注释有几种？<br>13.如何优雅的给一个函数加注释？<br>14.如何给变量加注释？<br>15.Python 代码缩进中是否支持 Tab 键和空格混用。<br>16.是否可以在一句 import 中导入多个库?<br>17.在给 Py 文件命名的时候需要注意什么?<br>18.例举几个规范 Python 代码风格的工具<br>数据类型<br>字符串<br>19.列举 Python 中的基本数据类型？<br>20.如何区别可变数据类型和不可变数据类型<br>21.将”hello world”转换为首字母大写”Hello World”<br>22.如何检测字符串中只含有数字?<br>23.将字符串”ilovechina”进行反转<br>24.Python 中的字符串格式化方式你知道哪些？<br>25.有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。<br>26.获取字符串”123456“最后的两个字符。<br>27.一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？<br>28.s=”info:xiaoZhang 33 shandong”,用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]<br>27.怎样将字符串转换为小写？<br>28.单引号、双引号、三引号的区别？<br>29.a = “你好     中国  “,去除多余空格只留一个空格。<br>列表<br>30.已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。<br>31.如何实现 “1,2,3” 变成 [“1”,”2”,”3”]<br>32.给定两个 list，A 和 B，找出相同元素和不同元素<br>33.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]<br>34.合并列表[1,5,7,9]和[2,2,6,8]<br>35.如何打乱一个列表的元素？<br>字典<br>36.字典操作中 del 和 pop 有什么区别<br>37.按照字典的内的年龄排序<br>d1 = [<br>    {‘name’:’alice’, ‘age’:38},<br>    {‘name’:’bob’, ‘age’:18},<br>    {‘name’:’Carl’, ‘age’:28},<br>]<br>38.请合并下面两个字典 a = {“A”:1,”B”:2},b = {“C”:3,”D”:4}<br>39.如何使用生成式的方式生成一个字典，写一段功能代码。<br>40.如何把元组(“a”,”b”)和元组(1,2)，变为字典{“a”:1,”b”:2}<br>综合<br>41.Python 常用的数据结构的类型及其特性？<br>A：{1:0,2:0,3:0}<br>B：{“a”:0, “b”:0, “c”:0}<br>C: {(1,2):0, (2,3):0}<br>D: {[1,2]:0, [2,3]:0}<br>42.如何将元组(“A”,”B”)和元组(1,2),合并成字典{“A”:1,”B”:2}<br>43.Python 里面如何实现 tuple 和 list 的转换？<br>44.我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？<br>45.请将[i for i in range(3)]改成生成器<br>46.a=”hello”和 b=”你好”编码成 bytes 类型<br>47.下面的代码输出结果是什么？<br>a = (1,2,3,[4,5,6,7],8)<br>a[2] = 2<br>48.下面的代码输出的结果是什么?<br>a = (1,2,3,[4,5,6,7],8)<br>a[5] = 2<br>操作类题目<br>49.Python 交换两个变量的值<br>50.在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的左右<br>51.json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？<br>52.json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？<br>53.有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。<br>54.如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。<br>55.写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。<br>56.下面代码会存在什么问题，如何改进？<br>def strappend(num):<br>    str=’first’<br>    for i in range(num):<br>        str+=str(i)<br>    return str<br>57.一行代码输出 1-100 之间的所有偶数。<br>58.with 语句的作用，写一段代码？<br>59.python 字典和 json 字符串相互转化方法<br>60.请写一个 Python 逻辑，计算一个文件中的大写字母数量<br>高级特效<br>70.函数装饰器有什么作用？请列举说明？<br>71.Python 垃圾回收机制？<br>72.魔法函数 <strong>call</strong>怎么使用?<br>73.如何判断一个对象是函数还是方法？<br>74.@classmethod 和@staticmethod 用法和区别<br>75.Python 中的接口如何实现？<br>76.Python 中的反射了解么?<br>77.metaclass 作用？以及应用场景？<br>78.hasattr() getattr() setattr()的用法<br>79.请列举你知道的 Python 的魔法方法及用途。<br>80.如何知道一个 Python 对象的类型？<br>81.Python 的传参是传值还是传址？</p>
<p>82.Python 中的元类(metaclass)使用举例 什么是元类(meta_class)?<br>元类就是用来创建类的“东西”</p>
<p>83.简述 any()和 all()方法<br>84.filter 方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>85.什么是猴子补丁？<br>86.在 Python 中是如何管理内存的？<br>87.当退出 Python 时是否释放所有内存分配？<br>正则表达式<br>88.使用正则表达式匹配出<html><h1><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h1></html>中的地址<br>a=”张明 98 分”，用 re.sub，将 98 替换为 100<br>89.正则表达式匹配中(.<em>)和(.</em>?)匹配区别？<br>90.写一段匹配邮箱的正则表达式<br>其他内容<br>91.解释一下 python 中 pass 语句的作用？<br>92.简述你对 input()函数的理解<br>93.python 中的 is 和==<br>94.Python 中的作用域<br>95.三元运算写法和应用场景？<br>96.了解 enumerate 么？<br>97.列举 5 个 Python 中的标准模块<br>98.如何在函数中设置一个全局变量<br>99.pathlib 的用法举例<br>100.Python 中的异常处理，写一个简单的应用场景<br>101.Python 中递归的最大次数，那如何突破呢？<br>102.什么是面向对象的 mro<br>103.isinstance 作用以及应用场景？<br>104.什么是断言？应用场景？</p>
<p>105.lambda 表达式格式以及应用场景？<br>函数使用:</p>
<ol>
<li>代码块重复，这时候必须考虑到函数，降低程序的冗余度</li>
<li>代码块复杂，这时候必须考虑到函数，降低程序的复杂度<br>Python有两种函数,一种是def定义，一种是lambda函数()<br>当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数这个概念</li>
</ol>
<p>106.新式类和旧式类的区别<br>107.dir()是干什么用的？<br>108.一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。<br>109.列举 5 个 Python 中的异常类型以及其含义<br>110.copy 和 deepcopy 的区别是什么？<br>111.代码中经常遇到的*args, **kwargs 含义及用法。<br>112.Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?<br>113.w、a+、wb 文件写入模式的区别<br>114.举例 sort 和 sorted 的区别<br>115.什么是负索引？<br>116.pprint 模块是干什么的？<br>117.解释一下 Python 中的赋值运算符<br>118.解释一下 Python 中的逻辑运算符<br>119.讲讲 Python 中的位运算符<br>120.在 Python 中如何使用多进制数字？<br>121.怎样声明多个变量并赋值？<br>算法和数据结构<br>122.已知：<br>AList = [1,2,3]<br>BSet = {1,2,3}<br>(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？<br>(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？<br>123.用 Python 实现一个二分查找的函数</p>
<p>124.python 单例模式的实现方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- encoding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法1--------------------------'</span></span><br><span class="line"><span class="comment">#方法1,实现__new__方法</span></span><br><span class="line"><span class="comment">#并在将一个类的实例绑定到类变量_instance上,</span></span><br><span class="line"><span class="comment">#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回</span></span><br><span class="line"><span class="comment">#如果cls._instance不为None,直接返回cls._instance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass()</span><br><span class="line">two = MyClass()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#one和two完全相同,可以用id(), ==, is检测</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法2--------------------------'</span></span><br><span class="line"><span class="comment">#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)</span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),</span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可</span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="comment">#可参看:http://code.activestate.com/recipes/66531/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass2()</span><br><span class="line">two = MyClass2()</span><br><span class="line"></span><br><span class="line"><span class="comment">#one和two是两个不同的对象,id, ==, is对比结果可看出</span></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#28873680</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#28873712</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="comment">#但是one和two具有相同的（同一个__dict__属性）,见:</span></span><br><span class="line"><span class="keyword">print</span> id(one.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"><span class="keyword">print</span> id(two.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法3--------------------------'</span></span><br><span class="line"><span class="comment">#方法3:本质上是方法1的升级（或者说高级）版</span></span><br><span class="line"><span class="comment">#使用__metaclass__（元类）的高级python用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dict)</span>:</span></span><br><span class="line">        super(Singleton2, cls).__init__(name, bases, dict)</span><br><span class="line">        cls._instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = super(Singleton2, cls).__call__(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass3</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton2</span><br><span class="line"></span><br><span class="line">one = MyClass3()</span><br><span class="line">two = MyClass3()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法4--------------------------'</span></span><br><span class="line"><span class="comment">#方法4:也是方法1的升级（高级）版本,</span></span><br><span class="line"><span class="comment">#使用装饰器(decorator),</span></span><br><span class="line"><span class="comment">#这是一种更pythonic,更elegant的方法,</span></span><br><span class="line"><span class="comment">#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass4</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">one = MyClass4()</span><br><span class="line">two = MyClass4()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line">one.x = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> one.x</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">print</span> two.x</span><br><span class="line"><span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<p>125.使用 Python 实现一个斐波那契数列<br>126.找出列表中的重复数字<br>127.找出列表中的单个数字<br>128.写一个冒泡排序<br>129.写一个快速排序<br>130.写一个拓扑排序<br>131.python 实现一个二进制计算<br>132.有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。<br>133.单链表反转<br>134.交叉链表求交点<br>135.用队列实现栈<br>136.找出数据流的中位数<br>137.二叉搜索树中第 K 小的元素<br>爬虫相关<br>138.在 requests 模块中，requests.content 和 requests.text 什么区别<br>139.简要写一下 lxml 模块的使用方法框架<br>140.说一说 scrapy 的工作流程<br>141.scrapy 的去重原理<br>142.scrapy 中间件有几种类，你用过哪些中间件<br>143.你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？<br>144.为什么会用到代理？<br>145.代理失效了怎么处理？<br>146.列出你知道 header 的内容以及信息<br>147.说一说打开浏览器访问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 获取到结果，整个流程。<br>148.爬取速度过快出现了验证码怎么处理<br>149.scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？<br>150.分布式爬虫主要解决什么问题<br>151.写爬虫是用多进程好？还是多线程好？为什么？<br>152.解析网页的解析器使用最多的是哪几个<br>153.需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？<br>154.验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）<br>155.使用最多的数据库（mysql，mongodb，redis 等），对他的理解？<br>网络编程<br>156.TCP 和 UDP 的区别？<br>157.简要介绍三次握手和四次挥手<br>158.什么是粘包？socket 中造成粘包的原因是什么？哪些情况会发生粘包现象？<br>并发<br>159.举例说明 conccurent.future 的中线程池的用法<br>160.说一说多线程，多进程和协程的区别。</p>
<p>161.简述 GIL.什么是GIL?<br>每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.<br>那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行,<br>多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.<br>从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能</p>
<p>162.进程之间如何通信<br>163.IO 多路复用的作用？<br>164.select、poll、epoll 模型的区别？<br>165.什么是并发和并行？<br>167.解释什么是异步非阻塞？<br>168.threading.local 的作用？<br>Git 面试题<br>169.说说你知道的 git 命令<br>170.git 如何查看某次提交修改的内容x</p>
<p>180.说说你对zen of python的理解，你有什么办法看到它?<br>Python之禅,Python秉承一种独特的简洁和可读行高的语法，以及高度一致的编程模式，符合“大脑思维习惯”，使Python易于学习、理解和记忆。Python同时采用了一条极简主义的设计理念，了解完整的Python哲学理念，可以在任何一个Python交互解释器中键入import this命令，这是Python隐藏的一个彩蛋:描绘了一系列Python设计原则。如今已是Python社区内流行的行话”EIBTI”，明了胜于晦涩这条规则的简称. 在Python的思维方式中，明了胜于晦涩，简洁胜于复杂</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>181.说说你对pythonic的看法，尝试解决下面的小问题<br>简洁，明了，严谨，灵活</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换两个变量值</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="comment">#去掉list中的重复元素</span></span><br><span class="line">old_list = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">new_list = list(set(old_list))</span><br><span class="line"><span class="comment">#翻转一个字符串</span></span><br><span class="line">s = <span class="string">'abcde'</span></span><br><span class="line">ss = s[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#用两个元素之间有对应关系的list构造一个dict</span></span><br><span class="line">names = [<span class="string">'jianpx'</span>, <span class="string">'yue'</span>]</span><br><span class="line">ages = [<span class="number">23</span>, <span class="number">40</span>]</span><br><span class="line">m = dict(zip(names,ages))</span><br><span class="line"><span class="comment">#将数量较多的字符串相连，如何效率较高，为什么</span></span><br><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line">result = <span class="string">''</span>.join(fruits)</span><br></pre></td></tr></table></figure>

<p>182.你调试python代码的方法有哪些?<br>具体IDE都有调试，比如:IDLE, Eclipse+Pydev都可以设置断点调试。<br>pdb模块也可以做调试。<br>还有PyChecker和Pylint<br>PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告<br>Pylint   是另外一个工具可以进行coding standard检查。</p>
<p>Q: When will the else part of try-except-else be executed?<br>Q: What are metaclasses in Python?<br>Q: What is monkey patching? How to use in Python? Example?<br>Q: What are the tools that help to find bugs or perform static analysis? What static code analyzers do you know/used?<br>Q: Whenever Python exits, why isn’t all the memory de-allocated?<br>Q: Explain how can you access a module written in Python from C? Vise versa?<br>Q: What do these mean to you: @classmethod, @staticmethod, @property?<br>Q: Is Python a functional language?<br>Q: What is the attribute <strong>slots</strong>?<br>Q: Is it possible to use the construction True = False?<br>Q: How to create a class without the class statement?<br>Q: Give an example of filter and reduce over an iterable object<br>Q: Is it possible to have a producer thread reading from the network and a consumer thread writing to a file, really work in parallel? What about GIL?<br>Q: How do you create a dictionary which can preserve the order of pairs?<br>Q: What does the PYTHONOPTIMIZE flag do?<br>Q: What are descriptors? Code example?<br>Q: What is MRO in Python? How does it work?<br>Q: Mention what is the difference between Django, Pyramid, and Flask?<br>Q: Specify the requirements for code written in a functional style.<br>Q: Identify the pitfalls/limitations in the function code.<br>Q: How to package code in Python?<br>Q:What is wheels and eggs? What is the difference?<br>Q: How to package binary dependencies in Python?<br>Q: How can I reload a previously imported <code>module</code> module? (we assume that the module is a file with module.py)<br>Q: What advantages do NumPy arrays offer over (nested) Python lists?<br>Q: What is the process of compilation and linking in python?<br>Q: What id() function in Python is for?<br>Q: Is Python call-by-value or call-by-reference?<br>Q: Explain how you reverse a generator?<br>Q: Let A and B be objects of class Foo. What methods and in what order are called when “print (A + B)” is executed?<br>Q: Place the following functions below in order of their efficiency. How would you test your answer?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = sorted(lIn)</span><br><span class="line">    l2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> lIn <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> lIn]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;(<span class="number">0.5</span>*<span class="number">0.5</span>)]</span><br></pre></td></tr></table></figure>

<p>Q: Write a one-liner that will count the number of capital letters in a file. Your code should work even if the file is too big to fit in memory.<br>Q: Output? Why? Is this inheritance?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">type (C ())</span><br><span class="line">type (C)</span><br><span class="line">Q: What<span class="string">'s the output we get from running the following?</span></span><br><span class="line"><span class="string">big_num_1   = 1000</span></span><br><span class="line"><span class="string">big_num_2   = 1000</span></span><br><span class="line"><span class="string">small_num_1 = 1</span></span><br><span class="line"><span class="string">small_num_2 = 1</span></span><br><span class="line"><span class="string">big_num_1 is big_num_2</span></span><br><span class="line"><span class="string">small_num_1 is small_num_2</span></span><br><span class="line"><span class="string">Q: How is this possible?</span></span><br><span class="line"><span class="string">_MangledGlobal__mangled = 23</span></span><br><span class="line"><span class="string">class MangledGlobal:</span></span><br><span class="line"><span class="string">     def test(self):</span></span><br><span class="line"><span class="string">         return __mangled</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MangledGlobal().test()</span></span><br><span class="line"><span class="string">23</span></span><br></pre></td></tr></table></figure>

<p>1.Python这么好，说说它的特性吧<br>关键特性<br>Python是一种解释型语言，这意味着，与C，C++不同，Python不需要在运行之前进行编译。它是边运行边解释的。<br>Python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x=1 ，然后x=”abc”是没有错误。<br>Python非常适合面向对象编程，因为它允许定义类以及组合和继承。Python没有访问修饰符。<br>在Python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。<br>Python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，Python允许包含基于C的扩展，所以瓶颈可以被优化掉。</p>
<p>2.单引号、双引号和三引号之间的区别<br>关于怎么快速学python，可以加下小编的python学习群:611+530+101，不管你是小白还是大牛，小编我都欢迎，不定期分享干货<br>每天晚上20:00都会开直播给大家分享python学习知识和路线方法，群里会不定期更新最新的教程和学习方法，大家都是学习python的，或是转行，或是大学生，还有工作中想提升自己能力的，如果你是正在学习python的小伙伴可以加入学习。最后祝所有程序员都能够走上人生巅峰，让代码将梦想照进现实<br>单引号和双引号主要是用来表示字符串<br>比如:<br>单引号:’python’<br>双引号:”python”<br>区别:<br>若你的字符串里面本身包含单引号,必须用双引号包裹。<br>比如:”can’t find the log “<br>三引号<br>三单引号:’’’python ‘’’,也可以表示字符串一般用来输入多行文本,或者用于大段的注释。<br>三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档。</p>
<p>3.Python里面如何拷贝一个对象？<br>标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象.<br>使用deepcopy方法,对象中的属性也被复制</p>
<p>4.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<p>5.什么是lambda函数？它的好处是什么?<br>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br>lambda函数：首要用途是指点短小的回调函数。<br>lambda [arguments]:expression</p>
<blockquote>
<blockquote>
<blockquote>
<p>a=lambdax,y:x+y<br>a(3,11)<br>好处：<br>lambda能和def做同样种类的工作，特别是对于那些逻辑简单的函数，直接用lambda会更简洁，而且省去取函数名的麻烦。</p>
</blockquote>
</blockquote>
</blockquote>
<p>6.字符串格式化: %和 .format的区别是什么？<br>字符串的format函数非常灵活，很强大,可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如:填充、对齐、精度等)。</p>
<p>7.Python是如何进行内存管理的？<br>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放<br>内存池（memory pool）的概念：<br>当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>内存池的实现方式有很多，性能和适用范围也不一样。<br>python中的内存管理机制——Pymalloc：<br>python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。 关于释放内存方面，当一个对象的引用计数变为0时，python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作。</p>
<p>8.如何用Python来进行查询和替换一个文本字符串？<br>可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0])<br>replacement是被替换成的文本<br>string是需要被替换的文本<br>count是一个可选参数，指最大被替换的数量</p>
<p>9.Python里面search()和match()的区别？<br>match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配, 也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none 。</p>
<p>10.线程如何在Python中实现<br>Python有一个多线程包threading，可以使用多线程来加快你的代码。但是Python有一个叫做Global Interpreter Lock（GIL）的构造。GIL确保只有一个’线程’可以在任何时候执行。<br>线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在使得Python中的多线程无法真正的利用多核的优势来提高性能。<br>对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速！但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。</p>
<p>11.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<p>12.数据仓库是什么？<br>数据仓库是一个面向主题的、集成的、稳定的、反映历史变化的、随着时间的流逝发生变化的数据集合。它主要支持管理人员的决策分析。<br>数据仓库收集了企业相关内部和外部各个业务系统数据源、归档文件等一系列历史数据，最后转化成企业需要的战略决策信息。<br>特点：<br> 面向主题 ：根据业务的不同而进行的内容划分；<br> 集成特性 ：因为不同的业务源数据具有不同的数据特点，当业务源数据进入到数据仓库时，需要采用统一的编码格式进行数据加载，从而保证数据仓库中数据的唯一性；<br> 非易失性 ：数据仓库通过保存数据不同历史的各种状态，并不对数据进行任何更新操作。<br> 历史特性 ：数据保留时间戳字段，记录每个数据在不同时间内的各种状态。</p>
<p>1、一行代码实现1–100之和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum(range(<span class="number">0</span>,<span class="number">101</span>)</span><br></pre></td></tr></table></figure>

<p>2.如何在一个函数内部修改全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">fn()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>3.字典如何删除键和合并两个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span></span><br><span class="line">update</span><br></pre></td></tr></table></figure>

<p>4.python实现列表去重的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">list(set(a))</span><br></pre></td></tr></table></figure>

<p>5.fun(<em>args,*</em>kwargs)中的<em>args,*</em>kwargs什么意思？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.python2和python3的range（100）的区别<br>python2返回列表，python3返回迭代器，节约内存</p>
<p>7.一句话解释什么样的语言能够用装饰器?<br>函数可以作为参数传递的语言，可以使用装饰器</p>
<p>8.python内建数据类型有哪些<br>整型–int<br>布尔型–bool<br>字符串–str<br>列表–list<br>元组–tuple<br>字典–dict</p>
<p>9.简述面向对象中<strong>new</strong>和<strong>init</strong>区别<br><strong>init</strong>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数<br>1、<strong>new</strong>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别<br>2、<strong>new</strong>必须要有返回值，返回实例化出来的实例，这点在自己实现<strong>new</strong>时要特别注意，可以return父类（通过super(当前类名, cls)）<strong>new</strong>出来的实例，或者直接是object的<strong>new</strong>出来的实例<br>3、<strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值<br>4、如果<strong>new</strong>创建的是当前类的实例，会自动调用<strong>init</strong>函数，通过return语句里面调用的<strong>new</strong>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<strong>init</strong>函数，也不会调用其他类的<strong>init</strong>函数。</p>
<p>10.简述with方法打开处理文件帮我我们做了什么？<br>自带上下文管理器</p>
<p>11.列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a**<span class="number">2</span></span><br><span class="line">res = map(fn, a)</span><br><span class="line">res = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>12.python中生成随机整数、随机小数、0–1之间小数方法<br>随机整数：random.randint(a,b),生成区间内的整数<br>随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数<br>0-1随机小数：random.random(),括号中不传参</p>
<p>13.避免转义给字符串加哪个字母表示原始字符串？<br>r,表示需要原始字符串，不转义特殊字符</p>
<p>14.<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'&lt;div class="nam"&gt;中国&lt;/div&gt;'</span></span><br><span class="line">res = re.findall(<span class="string">r'&lt;div class=".*"0&gt;(.*?)&lt;/div&gt;'</span>, str)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<p>15.python中断言方法举例<br>assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错</p>
<p>16.列出python中可变数据类型和不可变数据类型，并简述原理<br>不可变数据类型：数值型、字符串型string和元组tuple<br>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p>
<p>可变数据类型：列表list和字典dict；<br>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p>
<p>17.字典根据键从小到大排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted(a.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>], reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>18.正则re.complie作用<br>re.compile是将正则表达式编译成一个对象，加快速度，并重复使用</p>
<p>19.a=（1，）b=(1)，c=(“1”) 分别是什么类型的数据？<br>tuple,int,str</p>
<p>20.两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">a + b</span><br><span class="line"></span><br><span class="line">a.sort()</span><br></pre></td></tr></table></figure>

<p>21.正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？<br>（.<em>）是贪婪匹配，会把满足正则的尽可能多的往后匹配<br>（.</em>?）是非贪婪匹配，会把满足正则的尽可能少匹配</p>
<p>22.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.array(a).flatten().tolist()</span><br></pre></td></tr></table></figure>

<p>23.提高python运行效率的方法<br>1、使用生成器，因为可以节约大量内存<br>2、循环代码优化，避免过多重复代码的执行<br>3、核心模块用Cython  PyPy等，提高效率<br>4、多进程、多线程、协程<br>5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
<p>24.写一个单列模式<br>因为创建对象时<strong>new</strong>方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _instance:</span><br><span class="line">            cls._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<p>25.保留两位小数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">123.23423</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>26.分别从前端、后端、数据库阐述web项目的性能优化<br>前端优化：<br>1、减少http请求、例如制作精灵图<br>2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差</p>
<p>后端优化：<br>1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。<br>2、异步方式，如果有耗时操作，可以采用异步，比如celery<br>3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况</p>
<p>数据库优化：<br>1、如有条件，数据可以存放于redis，读取速度快<br>2、建立索引、外键等</p>
<p>27.列出常见MYSQL数据存储引擎<br>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。<br>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。<br>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<p>29.简述多线程、多进程<br>进程：<br>1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立<br>2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制</p>
<p>线程：<br>1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源<br>2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃<br>应用：<br>IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间<br>CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势</p>
<p>30.IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常<br>IOError：输入输出异常<br>AttributeError：试图访问一个对象没有的属性<br>ImportError：无法引入模块或包，基本是路径问题<br>IndentationError：语法错误，代码没有正确的对齐<br>IndexError：下标索引超出序列边界<br>KeyError:试图访问你字典里不存在的键<br>SyntaxError:Python代码逻辑语法出错，不能执行<br>NameError:使用一个还未赋予对象的变量</p>
<p>31.python中copy和deepcopy区别<br>1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同<br>2、复制的值是可变对象（列表和字典）<br>浅拷贝copy有两种情况：<br>第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。<br>第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。<br>深拷贝deepcopy：完全复制独立，包括内层列表和字典</p>
<p>32.请将[i for i in range(3)]改成生成器<br>生成器是特殊的迭代器，<br>1、列表表达式的[]改为（）即可变成生成器<br>2、函数在返回值得时候出现yield就变成生成器，而不是函数了；<br>中括号换成小括号即可，有没有惊呆了</p>
<p>33.int(“1.4”),int(1.4)输出结果？<br>int(“1.4”)报错，int(1.4)输出1</p>
<p>34.列举3条以上PEP8编码规范<br>1、顶级定义之间空两行，比如函数或者类定义。<br>2、方法定义、类定义与第一个方法之间，都应该空一行<br>3、三引号进行注释<br>4、使用Pycharm、Eclipse一般使用4个空格来缩进代码</p>
<p>35.简述乐观锁和悲观锁<br>悲观锁, 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
<p>36.Linux命令重定向 &gt; 和 &gt;&gt;<br>Linux 允许将命令执行结果 重定向到一个 文件<br>将本应显示在终端上的内容 输出／追加 到指定文件中</p>
<blockquote>
<p>表示输出，会覆盖文件原有的内容</p>
<blockquote>
<p>表示追加，会将内容追加到已有文件的末尾</p>
</blockquote>
</blockquote>
<p>37.python传参数是传值还是传址？<br>Python中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。</p>
<p>38.求两个列表的交集、差集、并集</p>
<p>39.python正则中search和match</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/interview/cs/os.html</url>
    <content><![CDATA[<h3 id="core文件是什么，有什么用？"><a href="#core文件是什么，有什么用？" class="headerlink" title="core文件是什么，有什么用？"></a>core文件是什么，有什么用？</h3><ul>
<li>core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</li>
</ul>
<h3 id="什么是core-dump"><a href="#什么是core-dump" class="headerlink" title="什么是core dump"></a>什么是core dump</h3><ul>
<li>Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容出来生成的，它可以做为调试程序的参考.</li>
<li>core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。</li>
<li>如何使用core文件<ul>
<li>gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 哪个函数中.</li>
</ul>
</li>
</ul>
<h3 id="为什么没有core文件生成呢"><a href="#为什么没有core文件生成呢" class="headerlink" title="为什么没有core文件生成呢?"></a>为什么没有core文件生成呢?</h3><ul>
<li>core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.</li>
<li>ulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号</li>
</ul>
<h3 id="不用core文件，程序出了问题产生信号是否知道？"><a href="#不用core文件，程序出了问题产生信号是否知道？" class="headerlink" title="不用core文件，程序出了问题产生信号是否知道？"></a>不用core文件，程序出了问题产生信号是否知道？</h3><ul>
<li>内核向进程发信号嘛。</li>
</ul>
<h3 id="共享内存除了文件映射还有什么方式？二者有什么区别"><a href="#共享内存除了文件映射还有什么方式？二者有什么区别" class="headerlink" title="共享内存除了文件映射还有什么方式？二者有什么区别"></a>共享内存除了文件映射还有什么方式？二者有什么区别</h3><ul>
<li>共享内存对象映射。</li>
<li>区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</li>
</ul>
<h3 id="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"><a href="#请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc" class="headerlink" title="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"></a>请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc</h3><ul>
<li>top：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</li>
<li>ps：查看进程</li>
<li>mv：移动或者更改文件</li>
<li>find：在子目录中搜索匹配的文件</li>
<li>df：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。</li>
<li>cat：把一个或多个文件内容显示到标准输出</li>
<li>chmod：改变文件属性</li>
<li>chgrp：改变用户分组</li>
<li>grep：在文件内进行搜索</li>
<li>wc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</li>
</ul>
<h3 id="Linux文件属性有哪些？（共十位）"><a href="#Linux文件属性有哪些？（共十位）" class="headerlink" title="Linux文件属性有哪些？（共十位）"></a>Linux文件属性有哪些？（共十位）</h3><ul>
<li>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</li>
<li>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录 （directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</li>
<li>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</li>
<li>一个文件aaa具有完全空的权限- — — —。<ul>
<li>chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</li>
<li>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</li>
<li>chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</li>
</ul>
</li>
<li>如果aaa具有满权限- rwx rwx rwx。<ul>
<li>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</li>
</ul>
</li>
<li>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<ul>
<li>chmod u=rwx，go=rx aaa</li>
</ul>
</li>
</ul>
<h3 id="linux查询命令"><a href="#linux查询命令" class="headerlink" title="linux查询命令"></a>linux查询命令</h3><ul>
<li>find / -name “文件名”    在目录结构中搜索文件，并执行指定的操作。</li>
<li>grep</li>
<li>local 文件名  —他是 ‘find -name’ 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</li>
<li>whereis —是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li>
<li>which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li>
</ul>
<h3 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h3><ul>
<li>select<ul>
<li>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</li>
<li>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</li>
<li>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</li>
</ul>
</li>
<li>poll<ul>
<li>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</li>
<li>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
<li>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</li>
</ul>
</li>
<li>epoll<ul>
<li>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</li>
<li>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</li>
<li>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术这样  彻底省掉了 这些文件描述符在系统调用时复制的开销。</li>
<li>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callbac的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li>
</ul>
</li>
</ul>
<h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h3><ul>
<li><ol>
<li>内存的页面置换算法</li>
</ol>
</li>
<li><ol start="2">
<li>进程调度算法</li>
</ol>
</li>
<li><ol start="3">
<li>进程间通信方式</li>
</ol>
</li>
<li><ol start="4">
<li>进程和线程定义，区别和联系</li>
</ol>
</li>
<li><ol start="5">
<li>进程之间的通信</li>
</ol>
</li>
<li><ol start="6">
<li>父子进程、孤儿进程</li>
</ol>
</li>
<li><ol start="7">
<li>fork进程时的操作，</li>
</ol>
</li>
<li><ol start="11">
<li>硬链接和软连接区别</li>
</ol>
</li>
<li><ol start="12">
<li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li>
</ol>
</li>
<li><ol start="13">
<li>linux用过的命令</li>
</ol>
</li>
<li><ol start="14">
<li>系统管理命令（如查看内存使用、网络情况）</li>
</ol>
</li>
<li><ol start="15">
<li>管道的使用 |</li>
</ol>
</li>
<li><ol start="16">
<li>grep的使用，一定要掌握，每次都会问在文件中查找</li>
</ol>
</li>
<li><ol start="17">
<li>shell脚本</li>
</ol>
</li>
<li><ol start="19">
<li>awk使用</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/algorithms/sort.html</url>
    <content><![CDATA[<p>本文是常见的排序算法的一个简单总结，也是算法导论第三版的一些摘要记录，以作备忘和查询。</p>
<h2 id="0X00、简介"><a href="#0X00、简介" class="headerlink" title="0X00、简介"></a>0X00、简介</h2><ul>
<li><p>1.排序的定义：</p>
<ul>
<li>输入：n个数的一个序列&lt;a1,a2,…,an&gt;</li>
<li>输出：序列的一个排列&lt;a1’,a2’,…,an’&gt;,满足a1’&lt;=a2’&lt;=…&lt;=an’</li>
</ul>
</li>
<li><p>2.排序算法复杂度概览</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(logn)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody></table>
<ul>
<li><p>3.术语解释</p>
<ul>
<li>稳定性：如果a=b，且a在b前面，排序后a仍然在b前面，则说算法是稳定的；否则就是不稳定的。</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度：一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul>
</li>
<li><p>4.关于时间复杂度的排序:</p>
<ul>
<li>(O(n^2))排序:各类简单排序：直接插入、直接选择和冒泡排序；</li>
<li>(O(nlog2n))排序:快速排序、堆排序和归并排序；</li>
<li>O(n1+§))排序，§是介于0和1之间的常数:希尔排序</li>
<li>(O(n))排序:基数排序、桶、箱排序。</li>
</ul>
</li>
<li><p>5.关于稳定性的排序：</p>
<ul>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li>
</ul>
</li>
</ul>
<h2 id="0X01、冒泡排序"><a href="#0X01、冒泡排序" class="headerlink" title="0X01、冒泡排序"></a>0X01、冒泡排序</h2><p>冒泡排序是一种流行但是低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>3.针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>4.重复步骤1~3，直到排序完成。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">1  for i = 1 to A.length - 1</span><br><span class="line">2    for j = A.length downto i+1</span><br><span class="line">3       if A[j] &lt; A[j-1]</span><br><span class="line">4           exchange A[j] with A[j-1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(n^2)</li>
<li>平均情况：T(n) = O(n^2)</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="3-代码实现如下"><a href="#3-代码实现如下" class="headerlink" title="3.代码实现如下"></a>3.代码实现如下</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, cnt<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>] , a[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#for i in range(cnt-2):</span></span><br><span class="line">    <span class="comment">#    for j in range(cnt-1, i, -1):</span></span><br><span class="line">    <span class="comment">#        if a[j] &lt; a[j-1]:</span></span><br><span class="line">    <span class="comment">#            a[j], a[j-1] = a[j-1], a[j]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bubble_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X02、插入排序"><a href="#0X02、插入排序" class="headerlink" title="0X02、插入排序"></a>0X02、插入排序</h2><p>插入排序(Insertion-Sort)是一种简单有效的排序方法。整体思想就是把后边一个待排的元素和前边已经排序好的元素做比较，如果比这元素大，就把前边的元素依次后移，直到找到一个比待排元素小的值，在其后边插入既可。然后在排序下一个待排元素。</p>
<h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.从第一个元素开始，该元素可以认为已经被排序；</li>
<li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>4.将新元素插入到该位置后；</li>
<li>5.重复步骤2~5。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">1  for j = 2 to A.length:</span><br><span class="line">2    key = A[j]</span><br><span class="line">3    i = j - 1</span><br><span class="line">4    while i &gt; 0 and A[i] &gt; key:</span><br><span class="line">5        A[i+1] = A[i]</span><br><span class="line">6        i = i - 1</span><br><span class="line">7    A[i+1] = key</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度：<ul>
<li>最佳情况：T(n) = O(n)。</li>
<li>最坏情况：T(n) = O(n^2)。</li>
<li>平均情况：T(n) = O(n^2)。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(1)。因为其要占用一个存储空间来放置key。</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt - <span class="number">1</span>):</span><br><span class="line">        value = a[i+<span class="number">1</span>]</span><br><span class="line">        pre_index = i</span><br><span class="line">        <span class="keyword">while</span> (pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; a[pre_index]):</span><br><span class="line">            a[pre_index + <span class="number">1</span>] = a[pre_index]</span><br><span class="line">            pre_index -= <span class="number">1</span></span><br><span class="line">        a[pre_index+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    insert_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X03、选择排序"><a href="#0X03、选择排序" class="headerlink" title="0X03、选择排序"></a>0X03、选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1.算法分析"></a>1.算法分析</h4><ul>
<li>1.初始状态：无序区为R[1..n]，有序区为空；</li>
<li>2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>3.n-1趟结束，数组有序化了。</li>
</ul>
<h4 id="2-算法复杂度-1"><a href="#2-算法复杂度-1" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cnt)[i:]:</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; a[minIndex]:</span><br><span class="line">                a[minIndex], a[j] = a[j], a[minIndex]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    selection_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X04、希尔排序"><a href="#0X04、希尔排序" class="headerlink" title="0X04、希尔排序"></a>0X04、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="2-算法复杂度-2"><a href="#2-算法复杂度-2" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog2n)　</li>
</ul>
<h4 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    算法思路：</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)，最好：O(n)，最坏：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    gap = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, cnt, <span class="number">1</span>):</span><br><span class="line">            tmp = a[i]</span><br><span class="line">            pre_index = i - gap</span><br><span class="line">            <span class="keyword">while</span> pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> a[pre_index] &gt; tmp:</span><br><span class="line">                a[pre_index+gap] = a[pre_index]</span><br><span class="line">                pre_index -= gap</span><br><span class="line">            a[pre_index+gap] = tmp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    shell_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X05、归并排序"><a href="#0X05、归并排序" class="headerlink" title="0X05、归并排序"></a>0X05、归并排序</h2><p>归并排序是分治思想的一种实现。这里分治模式的每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li>
<li>解决这些子问题，递归的求解各个子问题。然而，若小问题的规模足够小，则直接求解。</li>
<li>合并这些子问题的解成原问题的解。<br>这便是分治模式的思想。把大问题拆分成几个规模较小的子问题，把子问题在拆分成几个在小的问题，直至可以直接求解。然后把所有子问题的解合并就是原问题的解。</li>
</ul>
<h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>归并排序完全是分治思想的实现。</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>分解。分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li>
<li>解决。使用归并排序递归地排序两个子序列。</li>
<li>合并。合并两个已排序的子序列以产生已排序的答案。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MERGE(A,p,q,r)</span><br><span class="line">1  n1 = p - q + 1</span><br><span class="line">2  n2 = r - q</span><br><span class="line">3  let L[1..n1+1] and R[1..n2+1] to be new arrays</span><br><span class="line">4  for i = 1 to n1</span><br><span class="line">5    L[i] = A[p+i-1]</span><br><span class="line">6  for j = 1 to n2</span><br><span class="line">7    R[j] = A[q+j]</span><br><span class="line">8  L[n1+1] = ∞</span><br><span class="line">9  R[n2+1] = ∞</span><br><span class="line">10 i = 1</span><br><span class="line">11 j = 1</span><br><span class="line">12 for k = p to r</span><br><span class="line">13   if L[i] &lt;= R[j]</span><br><span class="line">14      A[k] = L[i]</span><br><span class="line">15      i = i+1</span><br><span class="line">16   else</span><br><span class="line">17      A[k] = R[j]</span><br><span class="line">18      j = j+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2     q = (p+r)/2</span><br><span class="line">3     MERGE-SORT(A,p,q)</span><br><span class="line">4     MERGE-SORT(A,q+1,r)</span><br><span class="line">5     MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-算法复杂度-3"><a href="#2-算法复杂度-3" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    mid = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(a[:mid]), merge_sort(a[mid:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left: list, right: list)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X06、快速排序"><a href="#0X06、快速排序" class="headerlink" title="0X06、快速排序"></a>0X06、快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="1-算法思路-2"><a href="#1-算法思路-2" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2    q = PARTITION(A,p,r)</span><br><span class="line">3    QUICKSORT(A,p,q-1)</span><br><span class="line">4    QUICKSORT(A,q+1,r)</span><br><span class="line"></span><br><span class="line">PARTITION(A,p,r)</span><br><span class="line">1  x = A[r]</span><br><span class="line">2  i = p-1</span><br><span class="line">3  for j = p to r-1</span><br><span class="line">4    if A[j] &lt;= x</span><br><span class="line">5        i = i+1</span><br><span class="line">6        exchange A[i] with A[j]</span><br><span class="line">7  exchange A[i+1] with A[r]</span><br><span class="line">8  return i+1</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度-4"><a href="#2-算法复杂度-4" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)　</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= array[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i+<span class="number">1</span>], array[r] = array[r], array[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[len(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    quick_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X07、计数排序"><a href="#0X07、计数排序" class="headerlink" title="0X07、计数排序"></a>0X07、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="1-算法思路-3"><a href="#1-算法思路-3" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h4 id="2-算法复杂度-5"><a href="#2-算法复杂度-5" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</p>
<h4 id="3-算法实现-5"><a href="#3-算法实现-5" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    leng = len(array)</span><br><span class="line">    c = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, leng):</span><br><span class="line">        c[array[i]] = c[array[i]]+<span class="number">1</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>]+c[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(leng<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res[c[array[i]]<span class="number">-1</span>] = array[i]</span><br><span class="line">        c[array[i]] = c[array[i]]<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(count_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X08、基数排序"><a href="#0X08、基数排序" class="headerlink" title="0X08、基数排序"></a>0X08、基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h4 id="1-算法思路-4"><a href="#1-算法思路-4" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ul>
<h4 id="2-算法复杂度-6"><a href="#2-算法复杂度-6" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)<br>基数排序有两种方法：<br>MSD 从高位开始进行排序 LSD 从低位开始进行排序<br>基数排序 vs 计数排序 vs 桶排序<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h4 id="3-算法实现-6"><a href="#3-算法实现-6" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j//(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    radix_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X09、桶排序"><a href="#0X09、桶排序" class="headerlink" title="0X09、桶排序"></a>0X09、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h4 id="1-算法思路-5"><a href="#1-算法思路-5" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li>
</ul>
<h4 id="2-算法复杂度-7"><a href="#2-算法复杂度-7" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)　</p>
<h4 id="3-算法实现-7"><a href="#3-算法实现-7" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(lista)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        h.append(node(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lista)):</span><br><span class="line">        tmp = node(lista[i])</span><br><span class="line">        map = lista[i]//<span class="number">10</span></span><br><span class="line">        p = h[map]</span><br><span class="line">        <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">            h[map].next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span>(p.next != <span class="literal">None</span> <span class="keyword">and</span> p.next.key &lt;= tmp.key):</span><br><span class="line">                p = p.next</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        q = h[i].next</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">None</span>):</span><br><span class="line">            lista[k] = q.key</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bucket_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X10、堆排序"><a href="#0X10、堆排序" class="headerlink" title="0X10、堆排序"></a>0X10、堆排序</h2><p>堆排序(heap-sort),和归并排序一样，不同于插入排序的是，堆排序的时间复杂度是O(nlogn)。与插入排序相同，不同于堆排序的是，堆排序具有空间原址性：任何时候都需要常数个额外的元素空间来存储临时数据。<br>其思想便是引用一种成为堆的数据结构。常见的有大根堆（最大堆）和小根堆（最小堆）。在排序中一般使用大根堆，小根堆通常构建优先队列。</p>
<ul>
<li>大根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&gt;=A[i]</li>
</ul>
</li>
<li>小根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&lt;=A[i]</li>
</ul>
</li>
</ul>
<h4 id="1-算法思路-6"><a href="#1-算法思路-6" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>伪代码描述<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用于维护最大根堆的性质</span><br><span class="line"># 对于树高为h的大根堆，其时间复杂度为O(h)</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">1  l = LEFT(i)</span><br><span class="line">2  r = RIGHT(i)</span><br><span class="line">3  if l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">4    largest = l</span><br><span class="line">5  else larget = r</span><br><span class="line">6  if r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">7    largest = r</span><br><span class="line">8  if largest != i</span><br><span class="line">9    exchange A[i] with A[largest]</span><br><span class="line">10   MAX-HEAPIFY(A,largest)</span><br><span class="line"></span><br><span class="line"># 建堆</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">1  A.heap-size = A.length</span><br><span class="line">2  for i = ⌊A.length/2⌋ downto 1</span><br><span class="line">3    MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">HEAP-SORT(A)</span><br><span class="line">1  BUILD-MAX-HEAP(A)</span><br><span class="line">2  for i = A.length downto 2</span><br><span class="line">3    exchange A[1] with A[i]</span><br><span class="line">4    MAX-HEAPIFY(A, 1)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-算法复杂度-8"><a href="#2-算法复杂度-8" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-8"><a href="#3-算法实现-8" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_param</span><span class="params">(L, i, j)</span>:</span></span><br><span class="line">    L[i], L[j] = L[j], L[i]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    temp = L[start]</span><br><span class="line"></span><br><span class="line">    i = start</span><br><span class="line">    j = <span class="number">2</span> * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end) <span class="keyword">and</span> (L[j] &lt; L[j + <span class="number">1</span>]):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt; L[j]:</span><br><span class="line">            L[i] = L[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    L[i] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    L_length = len(L) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    first_sort_count = L_length // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first_sort_count):</span><br><span class="line">        heap_adjust(L, first_sort_count - i, L_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L_length - <span class="number">1</span>):</span><br><span class="line">        L = swap_param(L, <span class="number">1</span>, L_length - i)</span><br><span class="line">        heap_adjust(L, <span class="number">1</span>, L_length - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    L = deque(a)</span><br><span class="line">    L.appendleft(<span class="number">0</span>)</span><br><span class="line">    print(heap_sort(L))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
</search>
