<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    
    <entry>
      <title>关于</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>算法</title>
      <link href="/algorithms/index.html"/>
      <url>/algorithms/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><ul><li><a href="basic.html">基础</a></li><li><a href="sort.html">排序算法</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>读书笔记</title>
      <link href="/books/index.html"/>
      <url>/books/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><ul><li><a href="deep-analysis-distributed-cache.html">深入分布式缓存:从原理到实践</a></li></ul><h2 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h2><ul><li><a href="gopl.html">go语言程序设计</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="/interview/index.html"/>
      <url>/interview/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><a href="cs/index.html">计算机基础</a></h2><ul><li><a href="cs/basic.html">基础</a></li><li><a href="cs/os.html">操作系统</a></li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="backend/index.md">后端</a></h2><ul><li><a href="backend/python.html">python</a></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a href="storage/index.html">数据库</a></h2><ul><li><a href="storage/basic.html">基础</a></li><li><a href="storage/mysql.html">mysql</a></li></ul><h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a><a href="frontend/index.md">前端</a></h2><ul><li><a href="frontend/basic.html">大前端</a></li><li><a href="frontend/js.html">js</a></li><li><a href="frontend/vue.html">vue</a></li><li><a href="frontend/css.html">css</a></li></ul><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a href="net/index.html">网络</a></h2><ul><li><a href="net/basic.html">基础</a></li><li><a href="net/http.html">http</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>手册</title>
      <link href="/man/index.html"/>
      <url>/man/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul><li><a href="python/basic.html">基础</a></li><li><a href="python/os.html">操作系统</a></li><li><a href="python/thread.html">线程与进程</a></li><li><a href="python/net.html">网络</a></li><li><a href="python/class.html">面向对象</a></li><li><a href="python/async.html">异步</a></li><li><a href="python/lib.html">库</a></li><li><a href="python/lib-collection.html">库-集合</a></li><li><a href="python/lib-dbutils.html">库-DBUtils</a></li><li><a href="python/lib-nameko.html">库-nameko</a></li><li><a href="python/lib-pymysql.html">库-pymysql</a></li><li><a href="python/lib-redis.html">库-redis</a></li><li><a href="python/lib-sqlalchemy.html">库-sqlalchemy</a></li></ul><h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><ul><li><a href="rust/basic.html">基础</a></li></ul><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul><li><a href="linux/commands.html">常用命令</a></li><li><a href="linux/crontab.html">定时任务</a></li></ul><h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul><li><a href="docker/commands.html">常用命令</a></li></ul><h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul><li>1.<a href="mysql/basic.html">架构介绍</a></li><li>2.<a href="mysql/commands.html">常用命令</a></li><li>3.<a href="mysql/character.html">编码类型</a></li><li>4.<a href="mysql/column_type.html">字段类型</a></li><li>5.<a href="mysql/transaction.html">事务处理</a></li><li>6.<a href="mysql/indexed.html">索引介绍</a></li></ul><h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul><li><a href="vim/commands.html">常用命令</a></li></ul><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul><li><a href="git/commands.html">常用命令</a></li></ul><h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><ul><li><a href="django/model.html">django ORM常用操作</a></li></ul><h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul><li><a href="chip/basic.md">芯片</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>工具集合</title>
      <link href="/tools/index.html"/>
      <url>/tools/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、插件"><a href="#一、插件" class="headerlink" title="一、插件"></a>一、插件</h2><ul><li>github<ul><li>sourcegraph</li><li>octotree</li></ul></li><li>剪切网页<ul><li>evernote</li></ul></li><li>调试接口<ul><li>JSONview</li></ul></li><li>词典<ul><li>沙拉查词</li></ul></li><li>广告<ul><li>广告终结者</li></ul></li><li>产品原型<ul><li>axure</li></ul></li><li>多tab管理<ul><li>Toby</li></ul></li></ul><h2 id="二、工具网站"><a href="#二、工具网站" class="headerlink" title="二、工具网站"></a>二、工具网站</h2><ul><li>json格式化<ul><li><a href="https://json.cn" target="_blank" rel="noopener">https://json.cn</a></li><li><a href="http://json.parser.online.fr" target="_blank" rel="noopener">http://json.parser.online.fr</a></li></ul></li><li>随机密码生成<ul><li><a href="https://www.sexauth.com/" target="_blank" rel="noopener">https://www.sexauth.com/</a></li><li><a href="https://suijimimashengcheng.51240.com/" target="_blank" rel="noopener">https://suijimimashengcheng.51240.com/</a></li><li><a href="https://www.dashlane.com/zh/features/password-generator" target="_blank" rel="noopener">https://www.dashlane.com/zh/features/password-generator</a></li></ul></li><li>正则表达式<ul><li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></li><li><a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">http://wangwl.net/static/projects/visualRegex</a></li></ul></li><li>问题讨论<ul><li><a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li><li><a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a></li></ul></li><li>文章<ul><li><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></li></ul></li></ul><h2 id="三、前沿科技网站"><a href="#三、前沿科技网站" class="headerlink" title="三、前沿科技网站"></a>三、前沿科技网站</h2><ul><li>论文<ul><li><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></li><li><a href="https://www.nature.com/" target="_blank" rel="noopener">https://www.nature.com/</a></li><li><a href="https://paperswelove.org/" target="_blank" rel="noopener">https://paperswelove.org/</a></li></ul></li></ul><h3 id="四、github系列"><a href="#四、github系列" class="headerlink" title="四、github系列"></a>四、github系列</h3><ul><li><p>awesome系列</p><ul><li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">https://github.com/sindresorhus/awesome</a></li></ul></li><li><p>算法</p><ul><li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">https://github.com/linyiqun/DataMiningAlgorithm</a></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/backend/index.html"/>
      <url>/interview/backend/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/cs/index.html"/>
      <url>/interview/cs/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/frontend/index.html"/>
      <url>/interview/frontend/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/net/index.html"/>
      <url>/interview/net/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/interview/storage/index.html"/>
      <url>/interview/storage/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/django/index.html"/>
      <url>/man/django/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/docker/index.html"/>
      <url>/man/docker/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/git/index.html"/>
      <url>/man/git/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/linux/index.html"/>
      <url>/man/linux/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/vim/index.html"/>
      <url>/man/vim/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/algorithms/sort.html"/>
      <url>/algorithms/sort.html</url>
      
        <content type="html"><![CDATA[<p>本文是常见的排序算法的一个简单总结，也是算法导论第三版的一些摘要记录，以作备忘和查询。</p><h2 id="0X00、简介"><a href="#0X00、简介" class="headerlink" title="0X00、简介"></a>0X00、简介</h2><ul><li><p>1.排序的定义：</p><ul><li>输入：n个数的一个序列&lt;a1,a2,…,an&gt;</li><li>输出：序列的一个排列&lt;a1’,a2’,…,an’&gt;,满足a1’&lt;=a2’&lt;=…&lt;=an’</li></ul></li><li><p>2.排序算法复杂度概览</p></li></ul><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最好情况</th><th>最坏情况</th><th>空间复杂度</th><th>排序方式</th><th>稳定性</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>稳定</td></tr><tr><td>选择排序</td><td>O(n^2)</td><td>O(n^2)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>插入排序</td><td>O(n^2)</td><td>O(n)</td><td>O(n^2)</td><td>O(1)</td><td>In-Place</td><td>稳定</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O(nlog2n)</td><td>O(nlog2n)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n)</td><td>Out-place</td><td>稳定</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(n^2)</td><td>O(logn)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O(1)</td><td>In-Place</td><td>不稳定</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>O(k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>桶排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n^2)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr><tr><td>基数排序</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n * k)</td><td>O(n+k)</td><td>Out-place</td><td>稳定</td></tr></tbody></table><ul><li><p>3.术语解释</p><ul><li>稳定性：如果a=b，且a在b前面，排序后a仍然在b前面，则说算法是稳定的；否则就是不稳定的。</li><li>内排序：所有排序操作都在内存中完成；</li><li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li><li>时间复杂度：一个算法执行所耗费的时间。</li><li>空间复杂度：运行完一个程序所需内存的大小。</li></ul></li><li><p>4.关于时间复杂度的排序:</p><ul><li>(O(n^2))排序:各类简单排序：直接插入、直接选择和冒泡排序；</li><li>(O(nlog2n))排序:快速排序、堆排序和归并排序；</li><li>O(n1+§))排序，§是介于0和1之间的常数:希尔排序</li><li>(O(n))排序:基数排序、桶、箱排序。</li></ul></li><li><p>5.关于稳定性的排序：</p><ul><li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li><li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li></ul></li></ul><h2 id="0X01、冒泡排序"><a href="#0X01、冒泡排序" class="headerlink" title="0X01、冒泡排序"></a>0X01、冒泡排序</h2><p>冒泡排序是一种流行但是低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p><h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h4><ul><li><p>语言描述</p><ul><li>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li>3.针对所有的元素重复以上的步骤，除了最后一个；</li><li>4.重复步骤1~3，直到排序完成。</li></ul></li><li><p>伪代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">1  for i = 1 to A.length - 1</span><br><span class="line">2    for j = A.length downto i+1</span><br><span class="line">3       if A[j] &lt; A[j-1]</span><br><span class="line">4           exchange A[j] with A[j-1]</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(n^2)</li><li>平均情况：T(n) = O(n^2)</li></ul></li><li>空间复杂度：O(1)</li></ul><h4 id="3-代码实现如下"><a href="#3-代码实现如下" class="headerlink" title="3.代码实现如下"></a>3.代码实现如下</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, cnt<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>] , a[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#for i in range(cnt-2):</span></span><br><span class="line">    <span class="comment">#    for j in range(cnt-1, i, -1):</span></span><br><span class="line">    <span class="comment">#        if a[j] &lt; a[j-1]:</span></span><br><span class="line">    <span class="comment">#            a[j], a[j-1] = a[j-1], a[j]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bubble_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X02、插入排序"><a href="#0X02、插入排序" class="headerlink" title="0X02、插入排序"></a>0X02、插入排序</h2><p>插入排序(Insertion-Sort)是一种简单有效的排序方法。整体思想就是把后边一个待排的元素和前边已经排序好的元素做比较，如果比这元素大，就把前边的元素依次后移，直到找到一个比待排元素小的值，在其后边插入既可。然后在排序下一个待排元素。</p><h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li><p>语言描述</p><ul><li>1.从第一个元素开始，该元素可以认为已经被排序；</li><li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>4.将新元素插入到该位置后；</li><li>5.重复步骤2~5。</li></ul></li><li><p>伪代码描述</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">1  for j = 2 to A.length:</span><br><span class="line">2    key = A[j]</span><br><span class="line">3    i = j - 1</span><br><span class="line">4    while i &gt; 0 and A[i] &gt; key:</span><br><span class="line">5        A[i+1] = A[i]</span><br><span class="line">6        i = i - 1</span><br><span class="line">7    A[i+1] = key</span><br></pre></td></tr></table></figure><h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度：<ul><li>最佳情况：T(n) = O(n)。</li><li>最坏情况：T(n) = O(n^2)。</li><li>平均情况：T(n) = O(n^2)。</li></ul></li><li>空间复杂度：<ul><li>O(1)。因为其要占用一个存储空间来放置key。</li></ul></li></ul><h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt - <span class="number">1</span>):</span><br><span class="line">        value = a[i+<span class="number">1</span>]</span><br><span class="line">        pre_index = i</span><br><span class="line">        <span class="keyword">while</span> (pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; a[pre_index]):</span><br><span class="line">            a[pre_index + <span class="number">1</span>] = a[pre_index]</span><br><span class="line">            pre_index -= <span class="number">1</span></span><br><span class="line">        a[pre_index+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    insert_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X03、选择排序"><a href="#0X03、选择排序" class="headerlink" title="0X03、选择排序"></a>0X03、选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1.算法分析"></a>1.算法分析</h4><ul><li>1.初始状态：无序区为R[1..n]，有序区为空；</li><li>2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li><li>3.n-1趟结束，数组有序化了。</li></ul><h4 id="2-算法复杂度-1"><a href="#2-算法复杂度-1" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>最佳情况：T(n) = O(n2)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(n2)</li></ul><h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cnt)[i:]:</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; a[minIndex]:</span><br><span class="line">                a[minIndex], a[j] = a[j], a[minIndex]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    selection_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X04、希尔排序"><a href="#0X04、希尔排序" class="headerlink" title="0X04、希尔排序"></a>0X04、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p><h4 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li><li>按增量序列个数k，对序列进行k 趟排序；</li><li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="2-算法复杂度-2"><a href="#2-算法复杂度-2" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>最佳情况：T(n) = O(nlog2 n)</li><li>最坏情况：T(n) = O(nlog2 n)</li><li>平均情况：T(n) =O(nlog2n)　</li></ul><h4 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    算法思路：</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)，最好：O(n)，最坏：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    gap = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, cnt, <span class="number">1</span>):</span><br><span class="line">            tmp = a[i]</span><br><span class="line">            pre_index = i - gap</span><br><span class="line">            <span class="keyword">while</span> pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> a[pre_index] &gt; tmp:</span><br><span class="line">                a[pre_index+gap] = a[pre_index]</span><br><span class="line">                pre_index -= gap</span><br><span class="line">            a[pre_index+gap] = tmp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    shell_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X05、归并排序"><a href="#0X05、归并排序" class="headerlink" title="0X05、归并排序"></a>0X05、归并排序</h2><p>归并排序是分治思想的一种实现。这里分治模式的每层递归时都有三个步骤：</p><ul><li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li><li>解决这些子问题，递归的求解各个子问题。然而，若小问题的规模足够小，则直接求解。</li><li>合并这些子问题的解成原问题的解。<br>这便是分治模式的思想。把大问题拆分成几个规模较小的子问题，把子问题在拆分成几个在小的问题，直至可以直接求解。然后把所有子问题的解合并就是原问题的解。</li></ul><h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>归并排序完全是分治思想的实现。</p><ul><li><p>语言描述</p><ul><li>分解。分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li><li>解决。使用归并排序递归地排序两个子序列。</li><li>合并。合并两个已排序的子序列以产生已排序的答案。</li></ul></li><li><p>伪代码描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">MERGE(A,p,q,r)</span><br><span class="line">1  n1 = p - q + 1</span><br><span class="line">2  n2 = r - q</span><br><span class="line">3  let L[1..n1+1] and R[1..n2+1] to be new arrays</span><br><span class="line">4  for i = 1 to n1</span><br><span class="line">5    L[i] = A[p+i-1]</span><br><span class="line">6  for j = 1 to n2</span><br><span class="line">7    R[j] = A[q+j]</span><br><span class="line">8  L[n1+1] = ∞</span><br><span class="line">9  R[n2+1] = ∞</span><br><span class="line">10 i = 1</span><br><span class="line">11 j = 1</span><br><span class="line">12 for k = p to r</span><br><span class="line">13   if L[i] &lt;= R[j]</span><br><span class="line">14      A[k] = L[i]</span><br><span class="line">15      i = i+1</span><br><span class="line">16   else</span><br><span class="line">17      A[k] = R[j]</span><br><span class="line">18      j = j+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2     q = (p+r)/2</span><br><span class="line">3     MERGE-SORT(A,p,q)</span><br><span class="line">4     MERGE-SORT(A,q+1,r)</span><br><span class="line">5     MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-算法复杂度-3"><a href="#2-算法复杂度-3" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(n)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    mid = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(a[:mid]), merge_sort(a[mid:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left: list, right: list)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure><h2 id="0X06、快速排序"><a href="#0X06、快速排序" class="headerlink" title="0X06、快速排序"></a>0X06、快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p><h4 id="1-算法思路-2"><a href="#1-算法思路-2" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ul><li><p>语言描述</p><ul><li>从数列中挑出一个元素，称为 “基准”（pivot）</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li></ul></li><li><p>伪代码描述</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2    q = PARTITION(A,p,r)</span><br><span class="line">3    QUICKSORT(A,p,q-1)</span><br><span class="line">4    QUICKSORT(A,q+1,r)</span><br><span class="line"></span><br><span class="line">PARTITION(A,p,r)</span><br><span class="line">1  x = A[r]</span><br><span class="line">2  i = p-1</span><br><span class="line">3  for j = p to r-1</span><br><span class="line">4    if A[j] &lt;= x</span><br><span class="line">5        i = i+1</span><br><span class="line">6        exchange A[i] with A[j]</span><br><span class="line">7  exchange A[i+1] with A[r]</span><br><span class="line">8  return i+1</span><br></pre></td></tr></table></figure><h4 id="2-算法复杂度-4"><a href="#2-算法复杂度-4" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(n2)</li><li>平均情况：T(n) = O(nlogn)　</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= array[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i+<span class="number">1</span>], array[r] = array[r], array[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[len(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    quick_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X07、计数排序"><a href="#0X07、计数排序" class="headerlink" title="0X07、计数排序"></a>0X07、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p><h4 id="1-算法思路-3"><a href="#1-算法思路-3" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li></ul><h4 id="2-算法复杂度-5"><a href="#2-算法复杂度-5" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</p><h4 id="3-算法实现-5"><a href="#3-算法实现-5" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    leng = len(array)</span><br><span class="line">    c = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, leng):</span><br><span class="line">        c[array[i]] = c[array[i]]+<span class="number">1</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>]+c[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(leng<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res[c[array[i]]<span class="number">-1</span>] = array[i]</span><br><span class="line">        c[array[i]] = c[array[i]]<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(count_sort(a))</span><br></pre></td></tr></table></figure><h2 id="0X08、基数排序"><a href="#0X08、基数排序" class="headerlink" title="0X08、基数排序"></a>0X08、基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="1-算法思路-4"><a href="#1-算法思路-4" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>取得数组中的最大数，并取得位数；</li><li>arr为原始数组，从最低位开始取每个位组成radix数组；</li><li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li></ul><h4 id="2-算法复杂度-6"><a href="#2-算法复杂度-6" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)<br>基数排序有两种方法：<br>MSD 从高位开始进行排序 LSD 从低位开始进行排序<br>基数排序 vs 计数排序 vs 桶排序<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶</li><li>计数排序：每个桶只存储单一键值</li><li>桶排序：每个桶存储一定范围的数值</li></ul><h4 id="3-算法实现-6"><a href="#3-算法实现-6" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j//(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    radix_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X09、桶排序"><a href="#0X09、桶排序" class="headerlink" title="0X09、桶排序"></a>0X09、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p><h4 id="1-算法思路-5"><a href="#1-算法思路-5" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li><li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li><li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li></ul><h4 id="2-算法复杂度-7"><a href="#2-算法复杂度-7" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)　</p><h4 id="3-算法实现-7"><a href="#3-算法实现-7" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(lista)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        h.append(node(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lista)):</span><br><span class="line">        tmp = node(lista[i])</span><br><span class="line">        map = lista[i]//<span class="number">10</span></span><br><span class="line">        p = h[map]</span><br><span class="line">        <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">            h[map].next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span>(p.next != <span class="literal">None</span> <span class="keyword">and</span> p.next.key &lt;= tmp.key):</span><br><span class="line">                p = p.next</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        q = h[i].next</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">None</span>):</span><br><span class="line">            lista[k] = q.key</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bucket_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure><h2 id="0X10、堆排序"><a href="#0X10、堆排序" class="headerlink" title="0X10、堆排序"></a>0X10、堆排序</h2><p>堆排序(heap-sort),和归并排序一样，不同于插入排序的是，堆排序的时间复杂度是O(nlogn)。与插入排序相同，不同于堆排序的是，堆排序具有空间原址性：任何时候都需要常数个额外的元素空间来存储临时数据。<br>其思想便是引用一种成为堆的数据结构。常见的有大根堆（最大堆）和小根堆（最小堆）。在排序中一般使用大根堆，小根堆通常构建优先队列。</p><ul><li>大根堆：<ul><li>除了根以外的所有节点i都满足：A[PARENT(i)]&gt;=A[i]</li></ul></li><li>小根堆：<ul><li>除了根以外的所有节点i都满足：A[PARENT(i)]&lt;=A[i]</li></ul></li></ul><h4 id="1-算法思路-6"><a href="#1-算法思路-6" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul><li>伪代码描述<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 用于维护最大根堆的性质</span><br><span class="line"># 对于树高为h的大根堆，其时间复杂度为O(h)</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">1  l = LEFT(i)</span><br><span class="line">2  r = RIGHT(i)</span><br><span class="line">3  if l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">4    largest = l</span><br><span class="line">5  else larget = r</span><br><span class="line">6  if r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">7    largest = r</span><br><span class="line">8  if largest != i</span><br><span class="line">9    exchange A[i] with A[largest]</span><br><span class="line">10   MAX-HEAPIFY(A,largest)</span><br><span class="line"></span><br><span class="line"># 建堆</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">1  A.heap-size = A.length</span><br><span class="line">2  for i = ⌊A.length/2⌋ downto 1</span><br><span class="line">3    MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">HEAP-SORT(A)</span><br><span class="line">1  BUILD-MAX-HEAP(A)</span><br><span class="line">2  for i = A.length downto 2</span><br><span class="line">3    exchange A[1] with A[i]</span><br><span class="line">4    MAX-HEAPIFY(A, 1)</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-算法复杂度-8"><a href="#2-算法复杂度-8" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul><li>时间复杂度<ul><li>最佳情况：T(n) = O(nlogn)</li><li>最差情况：T(n) = O(nlogn)</li><li>平均情况：T(n) = O(nlogn)</li></ul></li><li>空间复杂度<ul><li>O(1)</li></ul></li></ul><h4 id="3-算法实现-8"><a href="#3-算法实现-8" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_param</span><span class="params">(L, i, j)</span>:</span></span><br><span class="line">    L[i], L[j] = L[j], L[i]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    temp = L[start]</span><br><span class="line"></span><br><span class="line">    i = start</span><br><span class="line">    j = <span class="number">2</span> * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end) <span class="keyword">and</span> (L[j] &lt; L[j + <span class="number">1</span>]):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt; L[j]:</span><br><span class="line">            L[i] = L[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    L[i] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    L_length = len(L) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    first_sort_count = L_length // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first_sort_count):</span><br><span class="line">        heap_adjust(L, first_sort_count - i, L_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L_length - <span class="number">1</span>):</span><br><span class="line">        L = swap_param(L, <span class="number">1</span>, L_length - i)</span><br><span class="line">        heap_adjust(L, <span class="number">1</span>, L_length - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    L = deque(a)</span><br><span class="line">    L.appendleft(<span class="number">0</span>)</span><br><span class="line">    print(heap_sort(L))</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>css面试题</title>
      <link href="/interview/frontend/css.html"/>
      <url>/interview/frontend/css.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>display:none和visibility:hidden的区别？</p><ul><li>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li><li>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li></ul></li><li><p>CSS中link 和@import的区别是？</p><ul><li>(1) link属于HTML标签，而@import是CSS提供</li><li>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li><li>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li><li>(4) link方式的样式的权重 高于@import的权重.</li></ul></li><li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p><ul><li>选择符<ul><li>1.id选择器（ # myid）</li><li>2.类选择器（.myclassname）</li><li>3.标签选择器（div, h1, p）</li><li>4.相邻选择器（h1 + p）</li><li>5.子选择器（ul &gt; li）</li><li>6.后代选择器（li a）</li><li>7.通配符选择器（ * ）</li><li>8.属性选择器（a[rel = “external”]）</li><li>9.伪类选择器（a: hover, li:nth-child）</li></ul></li><li>优先级原则<ul><li>优先级就近原则，同权重情况下样式定义最近者为准;</li><li>载入样式以最后载入的定位为准;</li></ul></li><li>优先级为:<ul><li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li><li>!important &gt; id &gt; class &gt; tag</li><li>important 比 内联优先级高</li></ul></li><li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li><li>不可继承的样式：border padding margin width height</li></ul></li><li><p>display有哪些值？说明他们的作用。</p><ul><li>block     块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li><li>none     缺省值。象行内元素类型一样显示。</li><li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li><li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li><li>list-item     象块类型元素一样显示，并添加样式列表标记。</li><li>table     此元素会作为块级表格来显示。</li><li>inherit     规定应该从父元素继承 display 属性的值。</li></ul></li><li><p>position属性：指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型</p><ul><li>默认值：static</li><li>可选择值：relative、absolute、fixed、static、sticky、inherit</li><li>static:默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li><li>relative:生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li><li>fiexd:生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>absoluate:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li><li>sticky:粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li><li>inherit:规定应该从父元素继承 position 属性的值。</li></ul></li><li><p>display属性：规定元素应该生成的框的类型</p><ul><li>none:此元素不会被显示</li><li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li><li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li><li>inline-block:行内块元素。（CSS2.1 新增的值）</li><li>list-item: 此元素会作为列表显示。</li><li>run-in: 此元素会根据上下文作为块级元素或内联元素显示。</li><li>compact:CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>marker:CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li><li>table: 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</table></li><li>inline-table: 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</table></li><li>table-row-group: 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</tbody></li><li>table-header-group: 此元素会作为一个或多个行的分组来显示（类似 <thead>）。</thead></li><li>table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</tfoot></li><li>table-row: 此元素会作为一个表格行显示（类似 <tr>）。</tr></li><li>table-column-group: 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</colgroup></li><li>table-column: 此元素会作为一个单元格列显示（类似 <col>）</li><li>table-cell: 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）</th></td></li><li>table-caption: 此元素会作为一个表格标题显示（类似 <caption>）</caption></li><li>inherit:规定应该从父元素继承 display 属性的值。</li><li>flex:用flex布局</li></ul></li><li><p>盒模型</p><ul><li>总共有四层，从外到内是：margin、border、padding、content</li><li>一个盒子中主要的属性就5个：width、height、padding、border、margin。<ul><li>width和height：内容的宽度、高度（不是盒子的宽度、高度）。</li><li>padding：内边距。</li><li>border：边框。</li><li>margin：外边距。<br>如果设置background-color，那么border以内的所有都会有背景色。<br>如果想让盒子保持大小不变，那么就要保证border以内的，也就是padding+content的width和height保持不变。</li></ul></li></ul></li><li><p>像素</p><ul><li>基准像素</li></ul></li><li><p>行内元素与块元素</p><ul><li>块元素</li><li>行内元素</li></ul></li></ul><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul><li>display:flex</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题</title>
      <link href="/interview/frontend/basic.html"/>
      <url>/interview/frontend/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、HTML"><a href="#0x00、HTML" class="headerlink" title="0x00、HTML"></a>0x00、HTML</h2><h2 id="0x01、CSS"><a href="#0x01、CSS" class="headerlink" title="0x01、CSS"></a>0x01、CSS</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>display:none和visibility:hidden有什么区别</li><li>html引入样式的方式有几种</li><li>什么是盒模型</li><li>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</li><li>CSS什么是伪类，伪类有那些，有什么作用？</li><li>flex布局是什么，都有哪些语法，相比grid布局有什么不同？</li><li>css如何动态计算高度或宽度？</li></ul><h4 id="2-sass"><a href="#2-sass" class="headerlink" title="2.sass"></a>2.sass</h4><ul><li>什么是SASS？</li><li>sass的优缺点</li><li>SASS中的嵌套规则是什么？</li><li>有哪些运算符，都有什么作用？</li><li>如何在SASS中引用父选择器？</li></ul><h2 id="0x02、JS"><a href="#0x02、JS" class="headerlink" title="0x02、JS"></a>0x02、JS</h2><h4 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h4><ul><li>介绍js有哪些内置对象？</li><li>null，undefined 的区别？</li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</li><li>如何将字符串转化为数字，例如’12.3b’</li><li>字符串转化为数组，数组转化为字符串</li><li>如何判断一个对象中是否存在某个属性。</li><li>空数据组的boolean值</li><li>字符串替换值用什么方法？全部替换如何做？</li><li>什么是原型链</li></ul><h4 id="2-es6"><a href="#2-es6" class="headerlink" title="2.es6"></a>2.es6</h4><ul><li>新增了什么语法</li></ul><h4 id="3-typescript"><a href="#3-typescript" class="headerlink" title="3.typescript"></a>3.typescript</h4><ul><li>您对Typescript中的类有什么了解？列出类的一些功能。</li><li>如何从TypeScript中的子类调用基类构造函数？</li><li>内部模块和外部模块有什么区别？</li><li>请解释Typescript中的装饰器？</li><li>TypeScript类中属性/方法的默认可见性是什么？</li><li>如何在TypeScript中检查null和undefined？</li><li>readonly 和 const 有什么区别？</li></ul><h2 id="0x03、Vue"><a href="#0x03、Vue" class="headerlink" title="0x03、Vue"></a>0x03、Vue</h2><h2 id="0x04、React"><a href="#0x04、React" class="headerlink" title="0x04、React"></a>0x04、React</h2><ul><li>React 中 refs 的作用是什么？</li><li>createElement 与 cloneElement 的区别是什么？</li><li>组件的生命周期有哪些，生命周期的函数有哪些？</li><li>什么情况下组件会被更新</li><li>指令有哪些</li><li>子父组件如何通信</li></ul><h2 id="0x05、综合"><a href="#0x05、综合" class="headerlink" title="0x05、综合"></a>0x05、综合</h2><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h4><ul><li>前端性能优化有哪些？</li><li>cookie和session</li><li>本地存储类型及限制</li><li>webpack打包如何优化</li></ul><h4 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h4><ul><li>网络请求流程</li></ul><h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h4><ul><li>数据提交</li><li>跨域问题如何解决</li></ul><h4 id="4-业务场景"><a href="#4-业务场景" class="headerlink" title="4.业务场景"></a>4.业务场景</h4><ul><li>单点登录实现</li></ul><h4 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h4><ul><li>判断是否是数字、正数</li><li>替换变量</li></ul><h2 id="0x06、小程序"><a href="#0x06、小程序" class="headerlink" title="0x06、小程序"></a>0x06、小程序</h2><h4 id="1-uniapp"><a href="#1-uniapp" class="headerlink" title="1.uniapp"></a>1.uniapp</h4><h4 id="2-Taro"><a href="#2-Taro" class="headerlink" title="2.Taro"></a>2.Taro</h4><ul><li>为什么要用这个</li><li>坑在哪里</li><li>设计稿尺寸问题</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>vue面试题</title>
      <link href="/interview/frontend/vue.html"/>
      <url>/interview/frontend/vue.html</url>
      
        <content type="html"><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul><li><p>####1.请谈谈Vue中的MVVM模式</p><ul><li>MVVM全称是Model-View-ViewModel</li><li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</li><li>DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li></ul></li><li><p>####2.v-show和v-if指令的共同点和不同点?</p><ul><li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li><li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li></ul></li><li><p>####3.如何让CSS只在当前组件中起作用?</p><ul><li>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></li></ul></li><li><p>####4.Vue中引入组件的步骤?</p><ul><li>1.采用ES6的import … from …语法或CommonJS的require()方法引入组件</li><li>2.对组件进行注册,代码如下</li><li>3.使用组件<my-component></my-component><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li><li><h4 id="组件间如何传递值或调用"><a href="#组件间如何传递值或调用" class="headerlink" title="组件间如何传递值或调用"></a>组件间如何传递值或调用</h4></li><li><p>####5.在Vue中使用插件的步骤</p><ul><li>采用ES6的import … from …语法或CommonJS的require()方法引入插件</li><li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li></ul></li><li><p>####6.请列举出3个Vue中常用的生命周期钩子函数?</p><ul><li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li><li>mounted:  el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li><li>activated: keep-alive组件激活时调用</li></ul></li><li><p>####7.请简述下Vuex的原理和使用方法</p><ul><li><p>数据单向流动</p></li><li><p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</p></li><li><p>Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</p></li><li><p>上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p><ul><li>state中保存着共有数据</li><li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li><li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>网络基础面试题</title>
      <link href="/interview/net/basic.html"/>
      <url>/interview/net/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul><li><ol><li>TCP报头格式</li></ol></li><li><ol start="2"><li>UDP报头格式</li></ol></li><li><ol start="3"><li>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</li></ol></li><li><ol start="4"><li>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</li></ol></li><li><ol start="5"><li>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</li></ol></li><li><ol start="6"><li>OSI协议、TCP/IP协议以及每层对应的协议。</li></ol></li><li><ol start="7"><li>SESSION机制、cookie机制</li></ol></li><li><ol start="8"><li>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</li></ol></li><li><ol start="9"><li>打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</li></ol></li><li><ol start="10"><li>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</li></ol></li><li><ol start="11"><li>IP地址子网划分</li></ol></li><li><ol start="12"><li>POST和GET区别</li></ol></li><li><ol start="13"><li>DNS解析过程</li></ol></li></ul><h2 id="深入部分"><a href="#深入部分" class="headerlink" title="深入部分"></a>深入部分</h2><ul><li><ol start="14"><li>TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）</li></ol></li><li><ol start="15"><li>地址解析协议ARP</li></ol></li><li><ol start="16"><li>交换机和路由器的区别</li></ol></li></ul><h3 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h3><h3 id="端口个数为什么是65535个？"><a href="#端口个数为什么是65535个？" class="headerlink" title="端口个数为什么是65535个？"></a>端口个数为什么是65535个？</h3><ul><li>在TCP、UDP协议的开头，会分别有16位来存储源端口号和目标端口号，所以端口个数是2^16-1=65535个。</li><li>端口被设计出来主要是为了给协议栈和应用对应：<ul><li>协议栈用端口号将数据分配给不同的应用层程序</li><li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li></ul></li></ul><h3 id="端口状态有哪些"><a href="#端口状态有哪些" class="headerlink" title="端口状态有哪些"></a>端口状态有哪些</h3><ul><li>1、LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。</li><li>2、ESTABLISHED状态。ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li><li>3、CLOSE_WAIT。对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li><li>4、TIME_WAIT<ul><li>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</li><li>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li></ul></li><li>5、SYN_SENT状态<ul><li>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</li></ul></li></ul><h3 id="http的s加密是在哪一层，如何处理的。"><a href="#http的s加密是在哪一层，如何处理的。" class="headerlink" title="http的s加密是在哪一层，如何处理的。"></a>http的s加密是在哪一层，如何处理的。</h3><ul><li>s指的是SSL或TLS加密。因为http是明文传输，为了数据安全，在应用层与传输层中间添加一个加密层来加密数据的传输。</li><li>这个加密用了对称加密和非对称加密的结合。</li></ul><h3 id="什么是socket，为什么要有socket。"><a href="#什么是socket，为什么要有socket。" class="headerlink" title="什么是socket，为什么要有socket。"></a>什么是socket，为什么要有socket。</h3><ul><li>socket是传输层协议的分装，让应用层更方便的进行网络编程。</li></ul><h3 id="urlencode和urldecode何时使用，有什么作用？"><a href="#urlencode和urldecode何时使用，有什么作用？" class="headerlink" title="urlencode和urldecode何时使用，有什么作用？"></a>urlencode和urldecode何时使用，有什么作用？</h3><ul><li>url中合法的字符有两大类<ul><li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li><li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（），圆括号（()`）</li></ul></li><li>用来传输中文编码，转换成统一安全字符格式。</li></ul><h3 id="python中如何使用urlencode和urldecode。"><a href="#python中如何使用urlencode和urldecode。" class="headerlink" title="python中如何使用urlencode和urldecode。"></a>python中如何使用urlencode和urldecode。</h3><ul><li>urllib.parse.quote(str,  safe=’/‘)<ul><li>http%3A//<a href="http://www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>urllib.parse.quote(str,  safe=’/:?=’)<ul><li><a href="http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li></ul></li><li>如上，默认会处理一些非中文字符串情况，所以可以对中文进行单独转义既可</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>http面试题</title>
      <link href="/interview/net/http.html"/>
      <url>/interview/net/http.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP-Keep-Alive的作用及应用场景"><a href="#HTTP-Keep-Alive的作用及应用场景" class="headerlink" title="HTTP Keep-Alive的作用及应用场景"></a>HTTP Keep-Alive的作用及应用场景</h3><ul><li>作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。</li><li>缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。</li><li>解决：Keep-Alive: timeout=5, max=100。timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</li></ul><h3 id="表单中-get与post提交方法的区别"><a href="#表单中-get与post提交方法的区别" class="headerlink" title="表单中 get与post提交方法的区别?"></a>表单中 get与post提交方法的区别?</h3><ul><li>get是发送请求HTTP协议通过url参数传递进行接收；数据量小；不太安全</li><li>post是实体数据,可以通过表单提交大量信息；数据量大；安全</li></ul><h3 id="下列HTTP状态码出现的可能原因-如何处理"><a href="#下列HTTP状态码出现的可能原因-如何处理" class="headerlink" title="下列HTTP状态码出现的可能原因, 如何处理"></a>下列HTTP状态码出现的可能原因, 如何处理</h3><ul><li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li><li>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li><li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li><li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li><li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>数据库基础面试题</title>
      <link href="/interview/storage/basic.html"/>
      <url>/interview/storage/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h3><ul><li>唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</li><li>为什么要用 B+tree 作为 MySql 索引的数据结构</li><li>聚集索引与非聚集索引的区别</li><li>DDL、DML、DCL 分别指什么</li><li>explain 命令</li><li>数据库的几大范式</li><li>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</li><li>什么是自适应哈希索引（AHI）</li><li>limit 20000 加载很慢怎么解决</li><li>常见的几种分布式 ID 的设计方案<br>基础部分<ul><li><ol><li>事务四大特性（ACID）</li></ol></li><li><ol start="2"><li>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别</li></ol></li><li><ol start="3"><li>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</li></ol></li><li><ol start="4"><li>数据库的优化（从sql语句优化和索引两个部分回答）</li></ol></li><li><ol start="5"><li>索引有B+索引和hash索引，各自的区别</li></ol></li><li><ol start="6"><li>B+索引数据结构，和B树的区别</li></ol></li><li><ol start="7"><li>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</li></ol></li><li><ol start="8"><li>聚集索引和非聚集索引区别。</li></ol></li><li><ol start="9"><li>有哪些锁（乐观锁悲观锁），select时怎么加排它锁</li></ol></li><li><ol start="10"><li>关系型数据库和非关系型数据库区别</li></ol></li><li><ol start="11"><li>了解nosql</li></ol></li><li><ol start="12"><li>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</li></ol></li><li><ol start="13"><li>数据库的主从复制</li></ol></li><li><ol start="14"><li>使用explain优化sql和索引</li></ol></li><li><ol start="15"><li>long_query怎么解决</li></ol></li><li><ol start="16"><li>内连接、外连接、交叉连接、笛卡儿积等<br>深入</li></ol></li><li><ol><li>MVCC机制</li></ol></li><li><ol start="2"><li>根据具体场景，说明版本控制机制</li></ol></li><li><ol start="3"><li>死锁怎么解决</li></ol></li><li><ol start="4"><li>varchar和char的使用场景。</li></ol></li><li><ol start="5"><li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li></ol></li></ul></li></ul><h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><ul><li>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li></ul><h3 id="优化MYSQL数据库的方法"><a href="#优化MYSQL数据库的方法" class="headerlink" title="优化MYSQL数据库的方法?"></a>优化MYSQL数据库的方法?</h3><ul><li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM</li><li>使用连接（JOIN）来代替子查询</li><li>使用联合(UNION)来代替手动创建的临时表</li><li>建立索引</li></ul><p>varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</p><h3 id="优化数据库的方法。说说-SQL-优化之道"><a href="#优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="优化数据库的方法。说说 SQL 优化之道"></a>优化数据库的方法。说说 SQL 优化之道</h3><ul><li>主机性能</li><li>内存使用性能</li><li>网络传输性能</li><li>SQL语句执行性能</li></ul><h3 id="ACID规则"><a href="#ACID规则" class="headerlink" title="ACID规则"></a>ACID规则</h3><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p><ul><li>1、A (Atomicity) 原子性<ul><li>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li><li>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li></ul></li><li>2、C (Consistency) 一致性<ul><li>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li></ul></li><li>3、I (Isolation) 独立性<ul><li>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</li><li>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li></ul></li><li>4、D (Durability) 持久性<ul><li>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql面试题</title>
      <link href="/interview/storage/mysql.html"/>
      <url>/interview/storage/mysql.html</url>
      
        <content type="html"><![CDATA[<h3 id="Mysql存储引擎有哪些？有什么区别？"><a href="#Mysql存储引擎有哪些？有什么区别？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？"></a>Mysql存储引擎有哪些？有什么区别？</h3><ul><li>innodb、myisam</li><li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li><li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li></ul><h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><ul><li>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。</li><li>char 固定长度，所以在处理速度上要比</li></ul><h3 id="1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？"><a href="#1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？" class="headerlink" title="1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？"></a>1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？</h3><ul><li><p>数据库事务</p><ul><li>将一组相关操作组合为一个要么全部成功要么全部失败的单元</li><li>具有ACID（原子性、一致性、隔离性和持久性）属性<ul><li>原子性(Atomicity)：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li><li>一致性(Consistent)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须于一致性状态</li><li>隔离性(Isolation)：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所扰，多个并发事务之间要相互隔离。</li><li>持久性(Duration)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li></ul></li></ul></li><li><p>事物隔离级别</p><ul><li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li><li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li><li>Read committed (读已提交)：可避免脏读的发生。</li><li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li></ul></li><li><p>脏读、幻读、不可重复读</p><ul><li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</li><li>不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li><li>幻读：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li></ul></li><li><p>备注：</p><ul><li>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</li><li>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</li><li>当前事务的隔离级别：select @@tx_isolation;<a id="more"></a><h3 id="2-优化数据库的方法。说说-SQL-优化之道"><a href="#2-优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="2.优化数据库的方法。说说 SQL 优化之道"></a>2.优化数据库的方法。说说 SQL 优化之道</h3></li></ul></li><li><p>主机性能</p></li><li><p>内存使用性能</p></li><li><p>网络传输性能</p></li><li><p>SQL语句执行性能</p></li></ul><h3 id="3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别"><a href="#3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别" class="headerlink" title="3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别"></a>3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</h3><h3 id="为什么要用-B-tree-作为-MySql-索引的数据结构"><a href="#为什么要用-B-tree-作为-MySql-索引的数据结构" class="headerlink" title="为什么要用 B+tree 作为 MySql 索引的数据结构"></a>为什么要用 B+tree 作为 MySql 索引的数据结构</h3><h3 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h3><h3 id="Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？"><a href="#Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？"></a>Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？</h3><h3 id="varchar和char有什么区别-1"><a href="#varchar和char有什么区别-1" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><h3 id="DDL、DML、DCL-分别指什么"><a href="#DDL、DML、DCL-分别指什么" class="headerlink" title="DDL、DML、DCL 分别指什么"></a>DDL、DML、DCL 分别指什么</h3><h3 id="explain-命令"><a href="#explain-命令" class="headerlink" title="explain 命令"></a>explain 命令</h3><h3 id="数据库的几大范式"><a href="#数据库的几大范式" class="headerlink" title="数据库的几大范式"></a>数据库的几大范式</h3><h3 id="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"><a href="#说说分库与分表设计，分库与分表带来的分布式困境与对应之策" class="headerlink" title="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"></a>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</h3><h3 id="什么是自适应哈希索引（AHI）"><a href="#什么是自适应哈希索引（AHI）" class="headerlink" title="什么是自适应哈希索引（AHI）"></a>什么是自适应哈希索引（AHI）</h3><h3 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h3><h3 id="常见的几种分布式-ID-的设计方案"><a href="#常见的几种分布式-ID-的设计方案" class="headerlink" title="常见的几种分布式 ID 的设计方案"></a>常见的几种分布式 ID 的设计方案</h3>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/django/model.html"/>
      <url>/man/django/model.html</url>
      
        <content type="html"><![CDATA[<p>django model operate</p><h2 id="0x02、model"><a href="#0x02、model" class="headerlink" title="0x02、model"></a>0x02、model</h2><ul><li><p>model模型</p><ul><li>每个一个model都是要继承model.Model类的。</li><li>Model类封装了</li></ul></li><li><p>进行group_by并且做Max聚合，此时用的Max函数是下面引用的</p><ul><li>前边的values是要group_by的字段，annotate是需要聚合的字段，后续进行order_by。</li><li>没有group_by函数</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db.models.aggregates <span class="keyword">import</span> Max</span><br><span class="line"></span><br><span class="line">item = MetaJson.objects.filter(is_deleted=<span class="number">0</span>).values(<span class="string">'project_name'</span>,<span class="string">'item_type'</span>).annotate(max_id=Max(<span class="string">'id'</span>))</span><br><span class="line">model = MetaJson.objects.filter(id__in=[item[<span class="string">'max_id'</span>] <span class="keyword">for</span> item <span class="keyword">in</span> items]).values(<span class="string">"id"</span>,</span><br><span class="line">    <span class="string">'table_id'</span>, <span class="string">'table__name'</span>, <span class="string">'table__db__name'</span>, <span class="string">'table__db__type'</span>, <span class="string">'project_name'</span>).order_by(<span class="string">'-id'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为null</span></span><br><span class="line">ResourceModel.objects.filter(parent__isnull=<span class="literal">False</span>).values(<span class="string">''</span>).all()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算数量</span></span><br><span class="line">Book.objects.count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">Book.objects.filter(date_published__gte=datetime.now() - timedelta(days=<span class="number">90</span>)).count()</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line">Book.objects.exclude(date_published__gte=datetime.now() - timedelta(days=<span class="number">90</span>)).count()</span><br><span class="line"></span><br><span class="line">Book.objects.filter(author__isnull=<span class="literal">True</span>).count()</span><br><span class="line">Book.objects.filter(title__exact=<span class="string">''</span>).count()</span><br><span class="line"></span><br><span class="line">Book.objects.exclude(author__isnull=<span class="literal">True</span>).exclude(title__exact=<span class="string">''</span>).count()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 倒序排列</span></span><br><span class="line">ActivityHelp.objects.values(<span class="string">'user_id'</span>).filter(share_id=share_id).order_by(<span class="string">'-create_time'</span>).get()</span><br><span class="line"></span><br><span class="line"><span class="comment"># limit</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 原生sql</span></span><br><span class="line">Person.objects.raw(<span class="string">'SELECT * FROM myapp_person'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment"># django.db.models.query_utils.InvalidQuery: Raw query must include the primary key</span></span><br></pre></td></tr></table></figure><h4 id="2-字段查询"><a href="#2-字段查询" class="headerlink" title="2.字段查询"></a>2.字段查询</h4><p>相当于sql语句中where子句，它可以为filter、exclude和get方法提供参数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名称__比较运算符=值   #是两个下划线</span><br></pre></td></tr></table></figure><p><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p8508" alt="e159615aeedcafe4a55a073a7196afac.png"></p><h4 id="3-字段类型"><a href="#3-字段类型" class="headerlink" title="3.字段类型"></a>3.字段类型</h4><ul><li><p><code>AutoField</code>：一个自动递增的整型字段，添加记录时它会自动增长。你通常不需要直接使用这个字段；如果你不指定主键的话，系统会自动添加一个主键字段到你的model。(参阅自动主键字段)</p></li><li><p><code>BooleanField</code>：布尔字段,管理工具里会自动将其描述为checkbox。</p></li><li><p><code>CharField</code>：字符串字段，单行输入，用于较短的字符串，如要保存大量文本, 使用 TextField，CharField有一个必填参数：CharField.max_length：字符的最大长度，django会根据这个参数在数据库层和校验层限制该字段所允许的最大字符数。</p></li><li><p><code>TextField</code>：一个容量很大的文本字段， admin 管理界面用 <textarea>多行编辑框表示该字段数据。</textarea></p></li><li><p><code>CommaSeparatedIntegerField</code>：用于存放逗号分隔的整数值。类似 CharField，必须maxlength 参数。</p></li><li><p><code>DateField</code>：日期字段，admin 用一个文本框 <input type="”text”"> 来表示该字段数据(附带一个 JavaScript 日历和一个”Today”快捷按键。有下列额外的可选参数：</p><ul><li>auto_now：当对象被保存时,自动将该字段的值设置为当前时间.通常用于表示 “last-modified” 时间戳；</li><li>auto_now_add：当对象首次被创建时,自动将该字段的值设置为当前时间.通常用于表示对象创建时间。</li></ul></li><li><p><code>DateTimeField</code>：类似 DateField 支持同样的附加选项。</p></li><li><p><code>EmailField</code>：一个带有检查 Email 合法性的 CharField，不接受 maxlength 参数。</p></li><li><p><code>FileField</code>：一个文件上传字段。 要求一个必须有的参数： upload_to， 一个用于保存上载文件的本地文件系统路径。 这个路径必须包含 strftime formatting， 该格式将被上载文件的 date/time 替换(so that uploaded files don’t fill up the given directory)。在一个 model 中使用 FileField 或 ImageField 需要以下步骤：在你的 settings 文件中， 定义一个完整路径给 MEDIA_ROOT 以便让 Django在此处保存上传文件。 (出于性能考虑，这些文件并不保存到数据库。) 定义 MEDIA_URL 作为该目录的公共 URL。 要确保该目录对 WEB 服务器用户帐号是可写的。在你的 model 中添加 FileField 或 ImageField， 并确保定义了 upload_to 选项，以告诉 Django 使用 MEDIA_ROOT 的哪个子目录保存上传文件。你的数据库中要保存的只是文件的路径(相对于 MEDIA_ROOT)。 出于习惯你一定很想使用 Django 提供的 get_&lt;fieldname_url 函数。举例来说，如果你的 ImageField 叫作 mug_shot， 你就可以在模板中以  这样的方式得到图像的绝对路径。</p></li><li><p><code>FilePathField</code>：选择指定目录按限制规则选择文件，有三个参数可选， 其中”path”必需的，这三个参数可以同时使用， 参数描述：</p><ul><li><code>path</code>：必需参数，一个目录的绝对文件系统路径。 FilePathField 据此得到可选项目。 Example： “/home/images”；</li><li><code>match</code>：可选参数， 一个正则表达式， 作为一个字符串， FilePathField 将使用它过滤文件名。 注意这个正则表达式只会应用到 base filename 而不是路径全名。 Example： “foo。*\。txt^”， 将匹配文件 foo23.txt 却不匹配 bar.txt 或 foo23.gif；</li><li><code>recursive</code>：可选参数， 是否包括 path 下全部子目录，True 或 False，默认值为 False。</li><li><code>match</code> 仅应用于 base filename， 而不是路径全名。 如：FilePathField(path=”/home/images”， match=”foo.”， recursive=True)…会匹配 /home/images/foo.gif 而不匹配 /home/images/foo/bar.gif</li></ul></li><li><p><code>FloatField</code>：浮点型字段。 必须提供两个 参数， 参数描述：</p><ul><li><code>max_digits</code>：总位数(不包括小数点和符号)</li><li><code>decimal_places</code>：小数位数。如：要保存最大值为 999 (小数点后保存2位)，你要这样定义字段：models.FloatField(…，max_digits=5， decimal_places=2)，要保存最大值一百万(小数点后保存10位)的话，你要这样定义：models.FloatField(…，max_digits=19， decimal_places=10)</li></ul></li><li><p><code>ImageField</code>：类似 FileField， 不过要校验上传对象是否是一个合法图片。它有两个可选参数：height_field 和 width_field，如果提供这两个参数，则图片将按提供的高度和宽度规格保存。 该字段要求 Python Imaging 库。</p></li><li><p><code>IntegerField</code>：用于保存一个整数。</p></li><li><p><code>IPAddressField</code>：一个字符串形式的 IP 地址， (如 “202.1241.30″)。</p></li><li><p><code>NullBooleanField</code>：类似 BooleanField， 不过允许 NULL 作为其中一个选项。 推荐使用这个字段而不要用 BooleanField 加 null=True 选项。 admin 用一个选择框 <select> (三个可选择的值： “Unknown”， “Yes” 和 “No” ) 来表示这种字段数据。</select></p></li><li><p><code>PhoneNumberField</code>：一个带有合法美国风格电话号码校验的 CharField(格式：XXX-XXX-XXXX)。</p></li><li><p><code>PositiveIntegerField</code>：类似 IntegerField， 但取值范围为非负整数（这个字段应该是允许0值的…可以理解为无符号整数）</p></li><li><p><code>PositiveSmallIntegerField</code>：正小整型字段，类似 PositiveIntegerField， 取值范围较小(数据库相关)SlugField“Slug” 是一个报纸术语。 slug 是某个东西的小小标记(短签)， 只包含字母，数字，下划线和连字符。它们通常用于URLs。 若你使用 Django 开发版本，你可以指定 maxlength。 若 maxlength 未指定， Django 会使用默认长度： 50，它接受一个额外的参数：</p><ul><li><code>prepopulate_from</code>: 来源于slug的自动预置列表</li></ul></li><li><p><code>SlugField</code>：是一个报纸术语. slug 是某个东西的小小标记(短签), 只包含字母,数字,下划线和连字符.它们通常用于URLs。</p></li><li><p><code>SmallIntegerField</code>：类似 IntegerField， 不过只允许某个取值范围内的整数。(依赖数据库)</p></li><li><p><code>TimeField</code>：时间字段，类似于 DateField 和 DateTimeField。</p></li><li><p><code>URLField</code>：用于保存 URL。 若 verify_exists 参数为 True (默认)， 给定的 URL 会预先检查是否存在(即URL是否被有效装入且没有返回404响应)。</p></li><li><p><code>USStateField</code>：美国州名缩写，由两个字母组成（天朝人民无视）。</p></li><li><p><code>XMLField</code>：XML字符字段，校验值是否为合法XML的 TextField，必须提供参数：</p></li><li><p>schema_path：校验文本的 RelaxNG schema 的文件系统路径。</p></li><li><p><code>Field 选项</code></p><ul><li>null ：缺省设置为false.通常不将其用于字符型字段上，比如CharField,TextField上.字符型字段如果没有值会返回空字符串。</li><li>blank：该字段是否可以为空。如果为假，则必须有值</li><li>choices：一个用来选择值的2维元组。第一个值是实际存储的值，第二个用来方便进行选择。如SEX_CHOICES= ((‘F’,’Female’),(‘M’,’Male’),)</li><li>core：db_column，db_index 如果为真将为此字段创建索引</li><li>default：设定缺省值</li><li>editable：如果为假，admin模式下将不能改写。缺省为真</li><li>help_text：admin模式下帮助文档</li><li>primary_key：设置主键，如果没有设置django创建表时会自动加上：</li></ul><p>id = meta.AutoField(‘ID’, primary_key=True)<br>primary_key=True implies blank=False, null=False and unique=True. Only one primary key is allowed on an object.</p><ul><li>radio_admin：用于admin模式下将select转换为radio显示。只用于ForeignKey或者设置了choices</li><li>unique：数据唯一</li><li>unique_for_date：日期唯一，如下例中系统将不允许title和pub_date两个都相同的数据重复出现</li><li>title = meta.CharField(maxlength=30,unique_for_date=’pub_date’)</li><li>unique_for_month / unique_for_year：用法同上</li><li>validator_list：有效性检查。非有效产生 django.core.validators.ValidationError 错误</li></ul></li></ul><h4 id="4-关联数据"><a href="#4-关联数据" class="headerlink" title="4.关联数据"></a>4.关联数据</h4><p>on_delete=None,               # 删除关联表中的数据时,当前表与其关联的field的行为<br>on_delete=models.CASCADE,     # 删除关联数据,与之关联也删除<br>on_delete=models.DO_NOTHING,  # 删除关联数据,什么也不做<br>on_delete=models.PROTECT,     # 删除关联数据,引发错误ProtectedError<br>models.ForeignKey(‘关联表’, on_delete=models.SET_NULL, blank=True, null=True)<br>on_delete=models.SET_NULL,    # 删除关联数据,与之关联的值设置为null（前提FK字段需要设置为可空,一对一同理）<br>models.ForeignKey(‘关联表’, on_delete=models.SET_DEFAULT, default=’默认值’)<br>on_delete=models.SET_DEFAULT, # 删除关联数据,与之关联的值设置为默认值（前提FK字段需要设置默认值,一对一同理）<br>on_delete=models.SET,         # 删除关联数据,<br> a. 与之关联的值设置为指定值,设置：models.SET(值)<br> b. 与之关联的值设置为可执行对象的返回值,设置：models.SET(可执行对象)</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Docker常用命令</title>
      <link href="/man/docker/commands.html"/>
      <url>/man/docker/commands.html</url>
      
        <content type="html"><![CDATA[<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ul><li><p>Management Commands:</p><ul><li><strong><code>config</code></strong>      Manage Docker configs</li><li><strong><code>container</code></strong>   Manage containers</li><li><strong><code>image</code></strong>       Manage images</li><li><strong><code>network</code></strong>     Manage networks</li><li><strong><code>node</code></strong>        Manage Swarm nodes</li><li><strong><code>plugin</code></strong>      Manage plugins</li><li><strong><code>secret</code></strong>      Manage Docker secrets</li><li><strong><code>service</code></strong>     Manage services</li><li><strong><code>stack</code></strong>       Manage Docker stacks</li><li><strong><code>swarm</code></strong>       Manage Swarm</li><li><strong><code>system</code></strong>      Manage Docker</li><li><strong><code>volume</code></strong>      Manage volumes<br></li></ul></li><li><p>Commands:</p><ul><li><strong><code>attach</code></strong>      Attach local standard input, output, and error streams to a running container</li><li><strong><code>build</code></strong>       Build an image from a Dockerfile</li><li><strong><code>commit</code></strong>      Create a new image from a container’s changes</li><li><strong><code>cp</code></strong>          Copy files/folders between a container and the local filesystem</li><li><strong><code>create</code></strong>      Create a new container</li><li><strong><code>diff</code></strong>        Inspect changes to files or directories on a container’s filesystem</li><li><strong><code>events</code></strong>      Get real time events from the server</li><li><strong><code>exec</code></strong>        Run a command in a running container</li><li><strong><code>export</code></strong>      Export a container’s filesystem as a tar archive</li><li><strong><code>history</code></strong>     Show the history of an image</li><li><strong><code>images</code></strong>      List images</li><li><strong><code>import</code></strong>      Import the contents from a tarball to create a filesystem image</li><li><strong><code>info</code></strong>        Display system-wide information</li><li><strong><code>inspect</code></strong>     Return low-level information on Docker objects</li><li><strong><code>kill</code></strong>        Kill one or more running containers</li><li><strong><code>load</code></strong>        Load an image from a tar archive or STDIN</li><li><strong><code>login</code></strong>       Log in to a Docker registry</li><li><strong><code>logout</code></strong>      Log out from a Docker registry</li><li><strong><code>logs</code></strong>        Fetch the logs of a container</li><li><strong><code>pause</code></strong>       Pause all processes within one or more containers</li><li><strong><code>port</code></strong>        List port mappings or a specific mapping for the container</li><li><strong><code>ps</code></strong>          List containers</li><li><strong><code>pull</code></strong>        Pull an image or a repository from a registry</li><li><strong><code>push</code></strong>        Push an image or a repository to a registry</li><li><strong><code>rename</code></strong>      Rename a container</li><li><strong><code>restart</code></strong>     Restart one or more containers</li><li><strong><code>rm</code></strong>          Remove one or more containers</li><li><strong><code>rmi</code></strong>         Remove one or more images</li><li><strong><code>run</code></strong>         Run a command in a new container</li><li><strong><code>save</code></strong>        Save one or more images to a tar archive (streamed to STDOUT by default)</li><li><strong><code>search</code></strong>      Search the Docker Hub for images</li><li><strong><code>start</code></strong>       Start one or more stopped containers</li><li><strong><code>stats</code></strong>       Display a live stream of container(s) resource usage statistics</li><li><strong><code>stop</code></strong>        Stop one or more running containers</li><li><strong><code>tag</code></strong>         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</li><li><strong><code>top</code></strong>         Display the running processes of a container</li><li><strong><code>unpause</code></strong>     Unpause all processes within one or more containers</li><li><strong><code>update</code></strong>      Update configuration of one or more containers</li><li><strong><code>version</code></strong>     Show the Docker version information</li><li><strong><code>wait</code></strong>        Block until one or more containers stop, then print their exit codes</li></ul></li></ul><br><ul><li><strong><code>docker images</code></strong>       // 查看存在多少镜像</li><li><strong><code>docker ps</code></strong>           // 查看镜像运行情况</li><li><strong><code>docker run -t -i</code></strong>    // 运行镜像。并进行交互模式。</li><li><strong><code>docker stop</code></strong>         // 停止运行镜像，后边跟镜像ID或name</li><li><strong><code>docker search</code></strong>       // 搜索镜像仓库</li><li><strong><code>docker pull</code></strong>         // 拉取镜像</li><li><strong><code>docker inspect</code></strong>      // 查看镜像的json文件，即全部详细信息</li><li><strong><code>docker port</code></strong>         // 查看docker与宿主机的端口映射关系</li><li><strong><code>docker commit</code></strong>       // 用来生成新的版本</li><li><strong><code>docker build</code></strong>        // 用docker file来创建镜像</li><li><strong><code>docker tag</code></strong>          // 设置镜像标签</li></ul><br><ul><li>容器生命周期管理<ul><li><strong><code>create</code></strong></li><li><strong><code>run</code></strong></li><li><strong><code>start/stop/restart</code></strong></li><li><strong><code>pause/unpause</code></strong></li><li><strong><code>exec</code></strong></li><li><strong><code>rm</code></strong></li><li><strong><code>kill</code></strong></li></ul></li></ul><ul><li><p>容器操作</p><ul><li><strong><code>ps</code></strong></li><li><strong><code>inspect</code></strong></li><li><strong><code>top</code></strong></li><li><strong><code>attach</code></strong></li><li><strong><code>events</code></strong></li><li><strong><code>logs</code></strong></li><li><strong><code>wait</code></strong></li><li><strong><code>export</code></strong></li><li><strong><code>port</code></strong></li></ul></li><li><p>容器rootfs命令</p><ul><li><strong><code>commit</code></strong></li><li><strong><code>cp</code></strong></li><li><strong><code>diff</code></strong></li></ul></li><li><p>镜像仓库</p><ul><li><strong><code>login</code></strong></li><li><strong><code>pull</code></strong></li><li><strong><code>push</code></strong></li><li><strong><code>search</code></strong></li></ul></li><li><p>本地镜像管理</p><ul><li><strong><code>images</code></strong></li><li><strong><code>rmi</code></strong></li><li><strong><code>tag</code></strong></li><li><strong><code>build</code></strong></li><li><strong><code>history</code></strong></li><li><strong><code>save</code></strong></li><li><strong><code>import</code></strong></li></ul></li><li><p>信息</p><ul><li><strong><code>info</code></strong></li><li><strong><code>version</code></strong></li></ul></li></ul><ul><li>查看容器重启次数<ul><li>docker inspect -f “ .RestartCount “ container_id</li></ul></li><li>查看容器最后一次的启动时间<ul><li>docker inspect -f “ .State.StartedAt ” container_id</li></ul></li><li>commit一个镜像<ul><li>docker run –name=”python_env_l” -it image_name /bin/bash</li><li>docker commit -m=”msg” -a=”user_name” 4631e1627784 image_name:2.1</li><li>docker tag  image_name:2.1 image_name:latest</li><li>docker push image_name</li></ul></li><li>Docker构建镜像<ul><li>docker build -t imageName .</li></ul></li><li>打标签<ul><li>Docker tag image user/newName:tag</li></ul></li><li>批量删除无用镜像<ul><li>docker image rm <code>docker images|grep none|awk {&#39;print $3&#39;}</code></li></ul></li><li>批量删除无用容器<ul><li>sudo docker rm <code>sudo docker ps -a |grep Exited| awk {&#39;print $1&#39;}</code></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>Git常用命令</title>
      <link href="/man/git/commands.html"/>
      <url>/man/git/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li><strong><code>git init</code></strong>                                #git 初始化仓库</li><li><strong><code>git clone remote_url</code></strong>                    #git 克隆远程库</li><li><strong><code>git add .</code></strong>                               #git  添加所有文件</li><li><strong><code>git commit -m &quot;批注&quot;</code></strong>                     #git 提交</li><li><strong><code>git push &lt;remoteName&gt; &lt;localName&gt;</code></strong>       #git推送至远程</li><li><strong><code>git remote add origin &lt;server&gt;</code></strong>          #远程没有创建仓库，将本地推送到远程仓库</li><li><strong><code>git checkout -b branch_name</code></strong>             #创建分支，并切换到分支</li><li><strong><code>git checkout master</code></strong>                     #切换到主分支</li><li><strong><code>git branch -d &lt;branch_name&gt;</code></strong>             #删除分支</li><li><strong><code>git pull &lt;remoteName&gt; &lt;localName&gt;</code></strong>        #将本地仓库更新至最新</li><li><strong><code>git merge branch_name</code></strong>                    #将其他分支合并到本地主分支</li><li><strong><code>git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</code></strong> #比对分支</li><li><strong><code>git tag &lt;tag_name&gt;</code></strong>                      #创建标签</li><li><strong><code>git show</code></strong></li><li><strong><code>git status</code></strong>                              #查看当前状态</li><li><strong><code>git fetch</code></strong>                               #合并</li><li><strong><code>git config --list</code></strong>                       #查看配置信息</li><li><strong><code>git rm &lt;file_name&gt;</code></strong>                      #删除文件</li><li><strong><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code></strong>            #重命名文件</li><li><strong><code>git log</code></strong>                                 #查看日志</li><li><strong><code>git rebase HEAD &lt;file_name&gt;</code></strong>             #重置</li><li><strong><code>git remote -v</code></strong>                           #查看远程仓库</li><li><strong><code>git remote rm &lt;file_name&gt;</code></strong>               #删除远程仓库</li><li><strong><code>git branch</code></strong>                              #查看本地分支</li><li><strong><code>git branch -r</code></strong>                           #查看远程分支</li><li><strong><code>git branch &lt;branch_name&gt;</code></strong>                #创建本地分支</li><li><strong><code>git config --global user.name NEWNAME</code></strong>   #修改用户名</li><li><strong><code>git config --global user.email NEWEMAIL</code></strong> #修改用户邮箱</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>linux终端命令</title>
      <link href="/man/linux/commands.html"/>
      <url>/man/linux/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li>autojump</li><li><ul><li>自动跳转文件夹，不用cd</li></ul></li><li>tree</li><li><ul><li>以树状图列出当前目录结构</li></ul></li><li>you-get</li><li><ul><li>视频下载</li></ul></li><li>tldr</li><li><ul><li>命令示例文档</li></ul></li><li>htop</li><li><ul><li>更强大的top</li></ul></li><li>git</li><li><ul><li>版本控制工具</li></ul></li><li>vim</li><li><ul><li>编辑器</li></ul></li><li>tmux</li><li><ul><li>终端复用神器</li></ul></li><li>thefuck<ul><li>命令出错自动完善</li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>crontab表示法</title>
      <link href="/man/linux/crontab.html"/>
      <url>/man/linux/crontab.html</url>
      
        <content type="html"><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>crontab是linux上的定时任务工具，用来做定时管理服务。其常用的命令如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab -l <span class="comment"># 罗列出当前用户的所有定时任务列表</span></span><br><span class="line">crontab -e <span class="comment"># 编辑定时任务</span></span><br><span class="line">crontab -r <span class="comment"># 删除定时任务</span></span><br></pre></td></tr></table></figure><p>当然，最重要的还是如何使用cron来表示什么时候什么频次来执行任务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*  *  * *  *   <span class="built_in">command</span></span><br><span class="line">分 时 日 月 周   命令</span><br></pre></td></tr></table></figure><a id="more"></a><p>如上表示，有5个位置符来表示，后边跟需要执行的命令。</p><ul><li>第一列：分(0-59)</li><li>第二列：时(0-23)</li><li>第三列：日(1-31)</li><li>第四列：月(1-12)</li><li>第五列：周(0-6,0为星期天)</li></ul><p>除了以上的表示方法，还可以结合一些特殊的符号来表示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* ：   表示任何时刻</span><br><span class="line">, ：   表示在这几个选项内</span><br><span class="line">－ ：  表示一个范围，如第二列里： 3-5，就表示3到5点</span><br><span class="line">/n ：  表示每个n的单位执行一次，如第二列里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.</span><br></pre></td></tr></table></figure><h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">* * * * *                           每分钟执行一次</span><br><span class="line">0 */1 * * *                         每分钟执行一次</span><br><span class="line">43 21 * * *                         21:43 执行</span><br><span class="line">15 05 * * *                         05:15 执行</span><br><span class="line">0 17 * * *                          17:00 执行</span><br><span class="line">0 17 * * 1                          每周一的 17:00 执行</span><br><span class="line">0,10 17 * * 0,2,3                   每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="line">0-10 17 1 * *                       毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="line">0 0 1,15 * 1                        毎月1日和 15日和 一日的 0:00 执行</span><br><span class="line">42 4 1 * *                          毎月1日的 4:42分 执行</span><br><span class="line">0 21 * * 1-6                        周一到周六 21:00 执行</span><br><span class="line">0,10,20,30,40,50 * * * *            每隔10分 执行</span><br><span class="line">*/10 * * * *                        每隔10分 执行</span><br><span class="line">* 1 * * *                           从1:0到1:59 每隔1分钟 执行</span><br><span class="line">0 1 * * *                           1:00 执行</span><br><span class="line">0 * * * *                           毎时0分 每隔1小时 执行</span><br><span class="line">2 8-20/3 * * *                      8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="line">30 5 1,15 * *                       1日 和 15日的 5:30 执行</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常用手册</title>
      <link href="/man/mysql/index.html"/>
      <url>/man/mysql/index.html</url>
      
        <content type="html"><![CDATA[<ul><li>1.<a href="basic.html">架构介绍</a></li><li>2.<a href="commands.html">常用命令</a></li><li>3.<a href="character.html">编码类型</a></li><li>4.<a href="column_type.html">字段类型</a></li><li>5.<a href="transaction.html">事务处理</a></li><li>6.<a href="indexed.html">索引介绍</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常用语句</title>
      <link href="/man/mysql/commands.html"/>
      <url>/man/mysql/commands.html</url>
      
        <content type="html"><![CDATA[<h2 id="一、权限登录类"><a href="#一、权限登录类" class="headerlink" title="一、权限登录类"></a>一、权限登录类</h2><ul><li><p>1.授权用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授权用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某个用户的权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> username;</span><br></pre></td></tr></table></figure></li><li><p>2.远程连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -h192.168.1.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure></li><li><p>3.导出数据库</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqldump -h192.168.1.1-P3306 -uroot -p db_name &gt; db_name.sql</span><br></pre></td></tr></table></figure></li><li><p>4.导入数据库</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql -uroot -p db_name &lt; db_name.sql</span><br></pre></td></tr></table></figure></li><li><p>5.分析查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure></li><li><p>6.查询所有的进程</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> procelist;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> procelist;</span><br></pre></td></tr></table></figure></li></ul><h2 id="二、DDL"><a href="#二、DDL" class="headerlink" title="二、DDL"></a>二、DDL</h2><blockquote><p>数据库</p></blockquote><ul><li><p>1.建数据库语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure></li><li><p>3.删除数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_name;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>表操作</p></blockquote><ul><li><p>2.创建数据表语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_user`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC <span class="keyword">COMMENT</span>=<span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure></li><li><p>3.查看数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"><span class="comment">-- 查看表字段及描述</span></span><br><span class="line">desc table_name;</span><br></pre></td></tr></table></figure></li><li><p>4.查看字段</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>5.查看索引</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>6.删除表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 删除表结构，表结构和数据全部删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure></li><li><p>7.新增字段</p></li><li><p>8.修改字段</p></li><li><p>9.删除字段</p></li><li><p>10.添加索引</p></li><li><p>11.删除索引</p></li></ul><h2 id="三、DML"><a href="#三、DML" class="headerlink" title="三、DML"></a>三、DML</h2><ul><li><p>1.查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>2.新增</p></li><li><p>3.修改</p></li></ul><ul><li>4.删除<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 全部删除数据，不删表结构。不做表优化</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件限制删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据，并优化表空间</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure></li></ul><p>*</p><h2 id="四、参数状态"><a href="#四、参数状态" class="headerlink" title="四、参数状态"></a>四、参数状态</h2><ul><li><p>1.查看参数</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看所有参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span>;</span><br><span class="line"><span class="comment">-- 过滤参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sql%'</span>;</span><br></pre></td></tr></table></figure></li><li><p>2.查看事件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">events</span>;</span><br></pre></td></tr></table></figure></li><li><p>3.查看触发器</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure></li><li><p>4.查看所有状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>5.查看打开表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure></li><li><p>6.查看表状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 在某个db下执行</span></span><br><span class="line"><span class="comment">-- 可以查看表的存储引擎，表空间，自增主键，创建和更新时间等</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>7.查看数据库状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 查看主库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- 查看从库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>8.查看函数状态</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">function</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure></li><li><p>9.查看插件</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure></li><li><p>10.查看错误</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span>;</span><br></pre></td></tr></table></figure></li><li><p>11.查看存储引擎</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql编码</title>
      <link href="/man/mysql/character.html"/>
      <url>/man/mysql/character.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql索引介绍</title>
      <link href="/man/mysql/indexed.html"/>
      <url>/man/mysql/indexed.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql字段类型</title>
      <link href="/man/mysql/column_type.html"/>
      <url>/man/mysql/column_type.html</url>
      
        <content type="html"><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>char</li><li>varchar</li><li>text</li></ul><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul><li>int</li><li>smallint</li><li>bigint</li></ul><h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ul><li>json</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>VIM使用文档总结</title>
      <link href="/man/vim/commands.html"/>
      <url>/man/vim/commands.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>向下添加一行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">o</span><br></pre></td></tr></table></figure></li><li><p>向下翻页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+f</span><br></pre></td></tr></table></figure></li><li><p>向上翻页</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+b</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><ul><li><p>下一个词</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure></li><li><p>行尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$</span><br></pre></td></tr></table></figure></li><li><p>第一个字符行首</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^</span><br></pre></td></tr></table></figure></li><li><p>行首</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure></li><li><p>撤销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure></li><li><p>文件首</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gg</span><br></pre></td></tr></table></figure></li><li><p>文件尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">G</span><br></pre></td></tr></table></figure></li><li><p>屏首</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+h</span><br></pre></td></tr></table></figure></li><li><p>屏中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+m</span><br></pre></td></tr></table></figure></li><li><p>屏尾</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ctrl+l</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql架构介绍</title>
      <link href="/man/mysql/basic.html"/>
      <url>/man/mysql/basic.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>mysql事务</title>
      <link href="/man/mysql/transaction.html"/>
      <url>/man/mysql/transaction.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>算法基础</title>
      <link href="/algorithms/basic.html"/>
      <url>/algorithms/basic.html</url>
      
        <content type="html"><![CDATA[<ul><li>第一：复杂度估算和排序算法（上）<ul><li>1) 时间复杂度和空间复杂度</li><li>2）认识对数器</li><li>3）冒泡排序</li><li>4）选择排序</li><li>5）插入排序</li><li>6）如何分析递归过程的时间复杂度</li><li>7）归并排序</li><li>8）小和问题</li></ul></li><li>第二：复杂度估算和排序算法（下）<ul><li>1）荷兰国旗问题</li><li>2）随机快速排序</li><li>3）堆结构与堆排序</li><li>4）认识排序算法的稳定性</li><li>5）认识比较器</li><li>6）桶排序</li><li>7）计数排序</li><li>8）基数排序</li><li>9）数组排序后的最大差值问题</li><li>10）排序算法在工程中的应用</li></ul></li><li>第三：章栈、队列、链表、数组和矩阵结构<br>  1）栈结构<br>  2）队列结构<br>  3）链表结构<br>  4）数组结构<br>  5）矩阵结构<br>  6）二分搜索的扩展</li><li>第四：二叉树结构<ul><li>1）二叉树结构</li><li>2）二叉树的递归与非递归遍历</li><li>3）打印二叉树</li><li>4）判断搜索二叉树</li><li>5）判断完全二叉树</li><li>6）判断平衡二叉树</li><li>7）折纸问题</li><li>8）二叉树节点的前驱节点与后继节点</li><li>9）二叉树的序列化和反序列化</li></ul></li><li>第五：和哈希函数有关的三个结构与并查集<br>  1）哈希函数与哈希表<br>  2）布隆过滤器详解<br>  3）一致性哈希结构<br>  4）并查集结构与应用（岛问题）</li><li>第六：章图算法<br>  1）图结构的表示方法<br>  2）图的深度优先遍历与宽度优先遍历<br>  3）拓扑排序问题<br>  4）最小生成树问题<br>  5）单源最短路径问题</li><li>第七：前缀树、堆结构和贪心算法<br>  1）前缀树<br>  2）堆结构的扩展与应用<br>  3）介绍贪心算法及其相关题目<br>  4）在面试中如何快速的尝试出贪心策略</li><li>第八：暴力递归到动态规划<br>  1）递归<br>  2）动态规划<br>  3）如何把暴力递归套路的变成动态规划<br>算法高级：<br>第一：KMP算法和Manacher算法<br>  1）KMP算法及其扩展面试题目<br>  2）Manacher算法及其扩展面试题目<br>第二：窗口内最大值的更新结构和单调栈结构<br>  1）窗口内最大值的更新结构<br>  2）单调栈结构<br>第三：Morris遍历和sortedMap<br>  1）二叉树的Morris遍历<br>  2）跳表结构<br>  3）AVL树和红黑树结构<br>【今日头条、拼多多题目】<br>分类算法的理解<ul><li>决策树的原理</li><li>支持向量机</li><li>逻辑斯蒂回归<br>聚类算法的理解</li><li>均值聚类，可选的参数，如果确定聚类个数</li><li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li><li>xgboost</li><li>gbdt<br>【面试题目】</li><li><ol><li>二叉树前序递归遍历算法（手写代码）</li></ol></li><li><ol start="2"><li>二叉树的前中后遍历</li></ol></li><li><ol start="3"><li>二叉树的文件存储，也就是序列化。</li></ol></li><li><ol start="4"><li>二叉树遍历，描述下层序遍历。</li></ol></li><li><ol start="5"><li>二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。</li></ol></li><li><ol start="6"><li>二维数组，每行递增，每列递增，实现查找。</li></ol></li><li><ol start="7"><li>二维数组，每行递增，每列递增，求第k大的数。</li></ol></li><li><ol start="8"><li>什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。</li></ol></li><li><ol start="9"><li>介绍二叉树前序遍历非递归遍历算法（手写代码）</li></ol></li><li><ol start="10"><li>介绍大顶堆和小顶堆</li></ol></li><li><ol start="11"><li>从一组数中找出和为sum的三个数（leetcode）</li></ol></li><li><ol start="12"><li>冒泡排序(手写代码)</li></ol></li><li><ol start="13"><li>写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）</li></ol></li><li><ol start="14"><li>写一个二叉树的非递归的后续遍历</li></ol></li><li><ol start="15"><li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)</li></ol></li><li><ol start="16"><li>写个动态规划，最长公共子序列</li></ol></li><li><ol start="17"><li>判断一个字符串是否为另外一个字符串旋转之后的字符串</li></ol></li><li><ol start="18"><li>前k大的数</li></ol></li><li><ol start="19"><li>单链表的翻转</li></ol></li><li><ol start="20"><li>去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。</li></ol></li><li><ol start="21"><li>去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’。（Code）</li></ol></li><li><ol start="22"><li>合法括号匹配</li></ol></li><li><ol start="23"><li>在一个字符串中，找出最长的无重复字符的字串</li></ol></li><li><ol start="24"><li>在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）</li></ol></li><li><ol start="25"><li>堆排序(手写代码)</li></ol></li><li><ol start="26"><li>堆是怎么调整的。</li></ol></li><li><ol start="27"><li>复杂链表的复制<br>【大数据题目】</li></ol></li><li><ol><li>100亿数字，怎么统计前100大的？</li></ol></li><li><ol start="2"><li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li></ol></li><li><ol start="3"><li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li></ol></li><li><ol start="4"><li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li></ol></li><li><ol start="5"><li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li></ol></li><li><ol start="6"><li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li></ol></li><li><ol start="7"><li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li></ol></li><li><ol start="8"><li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li></ol></li><li><ol start="9"><li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li></ol></li><li><ol start="10"><li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li></ol></li><li><ol start="11"><li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li></ol></li><li><ol start="12"><li>海量数据的topk问题。</li></ol></li></ul></li></ul><ul><li><ol start="2"><li>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</li></ol><ul><li><ol start="3"><li>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</li></ol></li><li><ol start="4"><li>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</li></ol></li><li><ol start="5"><li>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</li></ol></li><li><ol start="6"><li>二分查找（一般会深入，如寻找数组总和为K的两个数字）</li></ol></li><li><ol start="7"><li>两个栈实现队列。</li></ol></li><li><ol start="8"><li>图（深度广度优先遍历、单源最短路径、最小生成树）</li></ol></li><li><ol start="9"><li>动态规划问题。</li></ol></li><li><ol start="10"><li>深入</li></ol></li><li><ol start="11"><li>红黑树性质</li></ol></li><li><ol start="12"><li>分治法和动态规划的区别</li></ol></li><li><ol start="13"><li>计算时间复杂度</li></ol></li><li><ol start="14"><li>二叉树和哈希表查找的时间复杂度</li></ol></li></ul></li></ul><ul><li><p>常用的数据结构有哪些？</p><ul><li>Arrays</li><li>Binary Trees</li><li>Graphs</li><li>Linked Lists</li><li>Matrixes</li><li>Stacks</li><li>Queues</li><li>Heaps</li><li>Hash Tables</li></ul></li><li><p>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。<br>&lt;？php<br>function fuhuan($allnum, $ti){<br>   $arr = array();<br>   for($i = 0; $i &lt; $allnum; $i++){</p><pre><code>$arr[$i] = $i;</code></pre><p>   }</p><p>   $nums = 1;<br>   while(count($arr) &gt; 1){</p><pre><code> foreach ($arr as $key =&gt; $value) {     if($nums == $ti){         unset($arr[$key]);         $nums = 1;     }else{         $nums++;     }}</code></pre><p>   }<br>   $new_arr = array_values($arr);<br>   var_dump($new_arr[0] + 1);<br>}<br>fuhuan(10,10);</p></li></ul><ul><li>常用的数据结构有哪些？</li><li>Graph Data Structure Interview Questions<ul><li>Breadth First Search</li><li>Depth First Search</li><li>A* Search</li><li>Dijkstra Algorithm</li><li>Comparing BFS, DFS, A* and Dijkstra</li></ul></li><li>Linked List Interview Questions (coming soon)<ul><li>Inserting and Removing nodes</li><li>Comparing Strings</li><li>Reversing a List</li><li>Selecting a Random Node</li></ul></li><li>Dynamic Programming Interview Questions (coming soon)<ul><li>Fibonacci Number Sequence</li><li>Longest Common Subsequence</li></ul></li><li>Sorting an Searching Interview Questions (coming soon)<ul><li>Binary Search</li><li>Bubble Sort</li><li>Insertion Sort</li><li>Merge Sort</li><li>Heap Sort</li><li>Quick Sort</li><li>Interpolation</li><li>Tree/Binary Search Tree</li><li>Minimum Depth</li><li>Maximum Path Sum</li></ul></li><li>Number Theory Interview Questions (coming soon)<ul><li>Euclid’s GCD Algorithm</li><li>Extending Euclid’s GCD Algorithm</li><li>Diophantine Equation</li><li>Chinese Remainder Theorem</li><li>Modular Inverse</li><li>Semi-Perfect Numbers</li></ul></li><li>String Interview Questions (coming soon)<ul><li>Reversing a String</li><li>Checking if String contains only digits</li><li>Finding Duplicate Characters in a String</li><li>How to Convert a String to Integer</li><li>Removing Duplicate Characters in a String</li><li>Finding the Maximum Occuring Character in a String</li><li>Find the First Non-Repeating Character in a String</li><li>Checking if Two Strings are Anagrams of Each Other</li><li>Counting the Number of Words in a String</li></ul></li><li>Array Interview Questions (coming soon)<ul><li>Finding the Missing Number from Array</li><li>Finding Duplicate Integers in an Array</li><li>Finding the Largest and Smallest Number in Unsorted Array</li><li>Removing Duplicates from an Array</li><li>Reversing an Array</li><li>Finding the k-th Smallest Integer in an Unsorted Array</li><li>Finding Common Elements Between Multiple Arrays</li></ul></li></ul><ul><li>基本数据结构<ul><li>数组</li><li>链表</li><li>树<ul><li>红黑树</li><li>二叉树</li></ul></li><li>图<ul><li>无环图</li><li>有环图</li><li>有向图</li><li>无向图</li></ul></li><li>Hash</li><li>跳跃表</li></ul></li></ul><ul><li>排序算法<ul><li>冒泡排序</li><li>归并排序(MERGE SORT)</li><li>快速排序(QUICK SORT)</li><li>堆积排序(HEAP SORT)</li></ul></li></ul><ul><li>查找算法<ul><li>二分查找</li></ul></li></ul><ul><li>分布式<ul><li>Raft 或者 Paxos 这样的分布式一致性算法</li></ul></li></ul><ul><li>文本相关<ul><li>textrank。自动提取文本摘要</li></ul></li></ul><ul><li>加密安全算法<ul><li>sha256</li><li>md5</li><li>RSA非对称加密算法</li><li>哈希安全算法(Secure Hash Algorithm)</li><li>整数质因子分解算法(Integer factorization)</li><li>Diffie-Hellman密钥交换算法<ul><li>一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。</li></ul></li><li>RSA<ul><li>公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。</li></ul></li></ul></li></ul><ul><li><p>链接分析算法(Link Analysis)</p></li><li><p>比例微积分算法(Proportional Integral Derivative Algorithm)</p></li><li><p>数据压缩算法</p></li><li><p>随机数生成算法</p></li><li><p>推荐算法</p></li><li><p>决策树算法</p></li><li><p>人工智能算法</p><ul><li>C4.5算法。<ul><li>C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42395865" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42395865</a></li></ul></li><li>CART算法。<ul><li>CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42558235" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42558235</a></li></ul></li><li>KNN(K最近邻)算法。<ul><li>给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42613011" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42613011</a></li></ul></li><li>Naive Bayes(朴素贝叶斯)算法。<ul><li>朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。</a></li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42680161" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42680161</a></li></ul></li><li>SVM(支持向量机)算法。<ul><li>支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42780439" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42780439</a></li></ul></li><li>EM(期望最大化)算法。<ul><li>期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42921789" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42921789</a></li></ul></li><li>Apriori算法。<ul><li>Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43059211" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43059211</a></li></ul></li><li>FP-Tree(频繁模式树)算法。<ul><li>这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43234309" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43234309</a></li></ul></li><li>PageRank(网页重要性/排名)算法。<ul><li>PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link Span攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li></ul></li><li>HITS算法。<ul><li>HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li></ul></li><li>K-Means(K均值)算法。<ul><li>K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43373159" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43373159</a></li></ul></li><li>BIRCH算法。<ul><li>BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43532111" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43532111</a></li></ul></li><li>AdaBoost算法。<ul><li>AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43635115" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43635115</a></li></ul></li><li>GSP算法。<ul><li>GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43699083" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43699083</a></li></ul></li><li>PreFixSpan算法。<ul><li>PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43766253" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43766253</a></li></ul></li><li>CBA(基于关联规则分类)算法。<ul><li>CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43818787" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43818787</a></li></ul></li><li>RoughSets(粗糙集)算法。<ul><li>粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43876001" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43876001</a></li></ul></li><li>gSpan算法。<ul><li>gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。</li><li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/4392427" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/4392427</a></li></ul></li></ul></li></ul><ul><li>其他算法<ul><li>傅立叶变换<ul><li>实现时间域函数与频率域函数之间的相互转化</li></ul></li><li>快速傅立叶变换</li><li>代克思托演算法 (Dijkstra’s algorithm)<ul><li>解决最短路径问题</li></ul></li><li>A* 搜索算法<ul><li>图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。</li></ul></li><li>集束搜索（又名定向搜索，Beam Search）<ul><li>最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。</li></ul></li><li>分支界定算法（Branch and Bound）<ul><li>在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。</li></ul></li><li>Buchberger算法<ul><li>一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化</li></ul></li><li>离散微分算法（Discrete differentiation）</li><li>动态规划算法（Dynamic Programming）<ul><li>展示互相覆盖的子问题和最优子架构算法</li></ul></li><li>欧几里得算法（Euclidean algorithm）<ul><li>计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。</li></ul></li><li>期望-最大算法（Expectation-maximization algorithm，又名EM-Training）<ul><li>在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。</li></ul></li><li>梯度下降（Gradient descent）<ul><li>一种数学上的最优化算法。</li></ul></li><li>Karatsuba乘法<ul><li>需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。</li></ul></li><li>LLL算法（Lenstra-Lenstra-Lovasz  lattice reduction）<ul><li>以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。</li></ul></li><li>最大流量算法（Maximum flow）<ul><li>该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。</li></ul></li><li>牛顿法（Newton’s method）<ul><li>求非线性方程（组）零点的一种重要的迭代法。</li></ul></li><li>Q-learning学习算法<ul><li>这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。</li></ul></li><li>两次筛法（Quadratic Sieve）<ul><li>现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。</li></ul></li><li>RANSAC<ul><li>是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。</li></ul></li><li>Schönhage-Strassen算法<ul><li>在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。</li></ul></li><li>单纯型算法（Simplex Algorithm）<ul><li>在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。</li></ul></li><li>奇异值分解（Singular value decomposition，简称SVD）<ul><li>在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。</li></ul></li><li>求解线性方程组（Solving a system of linear equations）<ul><li>线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</li></ul></li><li>Strukturtensor算法<ul><li>应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。</li></ul></li><li>合并查找算法（Union-find）<ul><li>给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：<ul><li>查找：判断某特定元素属于哪个组。</li><li>合并：联合或合并两个组为一个组。</li></ul></li></ul></li><li>维特比算法（Viterbi algorithm）<ul><li>寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>计算机基础面试</title>
      <link href="/interview/cs/basic.html"/>
      <url>/interview/cs/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-对于软件运行机制的理解。"><a href="#1-对于软件运行机制的理解。" class="headerlink" title="1.对于软件运行机制的理解。"></a>1.对于软件运行机制的理解。</h3><ul><li>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</li><li>具体的工作流程是<ul><li>1.在控制器指挥下，从存储器上取出指令；</li><li>2.分析指令，得到计算命令和待操作的数；</li><li>3.从存储器上取出待计算的数放入运算器；</li><li>4.运算器计算结果；</li><li>5.输出到存储器或输出设备。</li></ul></li></ul><h3 id="2-对于好的代码架构的理解？或者好的代码结构是怎样的？"><a href="#2-对于好的代码架构的理解？或者好的代码结构是怎样的？" class="headerlink" title="2.对于好的代码架构的理解？或者好的代码结构是怎样的？"></a>2.对于好的代码架构的理解？或者好的代码结构是怎样的？</h3><ul><li>高内聚、低耦合</li><li>易扩展，维护方便</li><li>避免过度设计</li><li>可读性高，结构清晰</li><li>代码风格统一</li><li>低复杂性，简练</li></ul><h3 id="3-对于编码规范的理解，有哪些好的编程规范"><a href="#3-对于编码规范的理解，有哪些好的编程规范" class="headerlink" title="3.对于编码规范的理解，有哪些好的编程规范"></a>3.对于编码规范的理解，有哪些好的编程规范</h3><ul><li>变量命名规范</li><li>代码缩进规范</li><li>大小写规范</li><li>注释规范</li><li>可读性强</li></ul><h3 id="4-编程安全应该注意哪些问题"><a href="#4-编程安全应该注意哪些问题" class="headerlink" title="4.编程安全应该注意哪些问题"></a>4.编程安全应该注意哪些问题</h3><ul><li>表单数据验证</li><li>防范SQL语句注入攻击</li><li>程序资源的释放。例如内存泄漏、数据库连接、文件句柄等资源</li><li>线程安全性</li><li>数据类型校验</li></ul><h3 id="5-如何提升开发效率？提升开发效率的方法有哪些？"><a href="#5-如何提升开发效率？提升开发效率的方法有哪些？" class="headerlink" title="5.如何提升开发效率？提升开发效率的方法有哪些？"></a>5.如何提升开发效率？提升开发效率的方法有哪些？</h3><ul><li>大显示器</li><li>机械键盘</li><li>编辑器快捷键</li><li>快速文档查询能力</li><li>需求的准确理解，防止可能的返工</li></ul><h3 id="6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"><a href="#6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？" class="headerlink" title="6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"></a>6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</h3><ul><li>保证开发结果与需求相符</li><li>保证代码的正确性、可靠性</li><li>新的功能是否影响旧有的功能</li></ul><h3 id="7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"><a href="#7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？" class="headerlink" title="7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"></a>7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</h3><h3 id="对于软件运行机制的理解。"><a href="#对于软件运行机制的理解。" class="headerlink" title="对于软件运行机制的理解。"></a>对于软件运行机制的理解。</h3><ul><li><p>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</p></li><li><p>具体的工作流程是</p><ul><li>1在控制器指挥下，从存储器上取出指令；</li><li>2分析指令，得到计算命令和待操作的数；</li><li>3从存储器上取出待计算的数放入运算器；</li><li>4运算器计算结果；</li><li>5输出到存储器或输出设备。</li></ul></li><li><p>因此存储器是关键。存储器分为：寄存器（CPU内部，用于存放待操作数和结果）；高速缓存（通常在CPU内部，用做数据缓冲区）；内存；外存。</p></li><li><p>接下来是具体的命令执行，这需要预先定义好CPU能执行的命令，即CPU的指令集，用来计算和控制计算机系统的一套指令的集合，典型的有Intel X86指令集和ARM指令集。具体的指令以二进制码表示，包含一个或多个字节，也包含指令码（具体命令）和操作数（要操作的数或地址）。在具体的执行中，把宏观层次的命令转换为满足指令集要求的二进制代码，然后才能在计算机上运行；参见CPU的具体组成成分运算器 ALU和寄存器和控制器的工作流程。</p></li><li><p>最后程序的执行就是在以上基础进行的，一开始使用机器语言的时候，具体的命令形式是1001010101010011 00011110这样的。这个虽然足够底层能够直接与计算机进行交互，但不是一般人能够搞得定的，于是就有更高层次的抽象，汇编语言，变成add 0 1这种相对来说比较友好的语言；接着就是高级语言了，更加抽象，但接近我们一般人的思维习惯，如d = a*b+c;当然，这是前人的工作成果，他们把很多的细节封装起来，我们这些后人之间调用就行，不用管其具体的转换即具体的编译，不然一句程序有可能转换为多句指令，而且其执行的次序和次数之类的细节，各种内存地址和数据的调用足够使人发疯。</p></li><li><p>对于设计模式的理解，为什么要有设计模式，用过什么设计模式，每个的应用场景是怎样的？</p><ul><li>设计模式主要分三个类型:创建型、结构型和行为型。<br>创建型：<br>一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 ；<br>应用场景：一个无状态的类使用单例模式节省内存资源。<br>二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br>应用场景：一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。<br>三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。     应用场景：由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义 一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。<br>四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br>应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。<br>五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br>应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限</li></ul></li></ul><p>行为型：<br>    六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br>  应用场景：迭代。<br>    七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br>应用场景： 某个实例的变化将影响其他多个对象。<br>    八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。<br>应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类<br>     九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。<br>应用场景：将命令者与执行者完全解耦。<br>    十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br>应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。<br>    十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。       应用场景：<br>   十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系<br>    十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。<br>    十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。<br>    十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>    十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p><p>结构型：<br>    十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。<br>    十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。<br>    十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问<br>    二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。<br>    二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。<br>    二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br>    二十三、Flyweight，享元模式</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/interview/cs/os.html"/>
      <url>/interview/cs/os.html</url>
      
        <content type="html"><![CDATA[<h3 id="core文件是什么，有什么用？"><a href="#core文件是什么，有什么用？" class="headerlink" title="core文件是什么，有什么用？"></a>core文件是什么，有什么用？</h3><ul><li>core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</li></ul><h3 id="什么是core-dump"><a href="#什么是core-dump" class="headerlink" title="什么是core dump"></a>什么是core dump</h3><ul><li>Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容出来生成的，它可以做为调试程序的参考.</li><li>core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。</li><li>如何使用core文件<ul><li>gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 哪个函数中.</li></ul></li></ul><h3 id="为什么没有core文件生成呢"><a href="#为什么没有core文件生成呢" class="headerlink" title="为什么没有core文件生成呢?"></a>为什么没有core文件生成呢?</h3><ul><li>core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.</li><li>ulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号</li></ul><h3 id="不用core文件，程序出了问题产生信号是否知道？"><a href="#不用core文件，程序出了问题产生信号是否知道？" class="headerlink" title="不用core文件，程序出了问题产生信号是否知道？"></a>不用core文件，程序出了问题产生信号是否知道？</h3><ul><li>内核向进程发信号嘛。</li></ul><h3 id="共享内存除了文件映射还有什么方式？二者有什么区别"><a href="#共享内存除了文件映射还有什么方式？二者有什么区别" class="headerlink" title="共享内存除了文件映射还有什么方式？二者有什么区别"></a>共享内存除了文件映射还有什么方式？二者有什么区别</h3><ul><li>共享内存对象映射。</li><li>区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</li></ul><h3 id="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"><a href="#请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc" class="headerlink" title="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"></a>请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc</h3><ul><li>top：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</li><li>ps：查看进程</li><li>mv：移动或者更改文件</li><li>find：在子目录中搜索匹配的文件</li><li>df：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。</li><li>cat：把一个或多个文件内容显示到标准输出</li><li>chmod：改变文件属性</li><li>chgrp：改变用户分组</li><li>grep：在文件内进行搜索</li><li>wc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</li></ul><h3 id="Linux文件属性有哪些？（共十位）"><a href="#Linux文件属性有哪些？（共十位）" class="headerlink" title="Linux文件属性有哪些？（共十位）"></a>Linux文件属性有哪些？（共十位）</h3><ul><li>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</li><li>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录 （directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</li><li>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</li><li>一个文件aaa具有完全空的权限- — — —。<ul><li>chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</li><li>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</li><li>chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</li></ul></li><li>如果aaa具有满权限- rwx rwx rwx。<ul><li>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</li></ul></li><li>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<ul><li>chmod u=rwx，go=rx aaa</li></ul></li></ul><h3 id="linux查询命令"><a href="#linux查询命令" class="headerlink" title="linux查询命令"></a>linux查询命令</h3><ul><li>find / -name “文件名”    在目录结构中搜索文件，并执行指定的操作。</li><li>grep</li><li>local 文件名  —他是 ‘find -name’ 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</li><li>whereis —是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li><li>which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li></ul><h3 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h3><ul><li>select<ul><li>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</li><li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</li><li>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</li><li>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</li></ul></li><li>poll<ul><li>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</li><li>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li><li>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</li></ul></li><li>epoll<ul><li>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</li><li>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</li><li>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术这样  彻底省掉了 这些文件描述符在系统调用时复制的开销。</li><li>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callbac的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li></ul></li></ul><h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h3><ul><li><ol><li>内存的页面置换算法</li></ol></li><li><ol start="2"><li>进程调度算法</li></ol></li><li><ol start="3"><li>进程间通信方式</li></ol></li><li><ol start="4"><li>进程和线程定义，区别和联系</li></ol></li><li><ol start="5"><li>进程之间的通信</li></ol></li><li><ol start="6"><li>父子进程、孤儿进程</li></ol></li><li><ol start="7"><li>fork进程时的操作，</li></ol></li><li><ol start="11"><li>硬链接和软连接区别</li></ol></li><li><ol start="12"><li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li></ol></li><li><ol start="13"><li>linux用过的命令</li></ol></li><li><ol start="14"><li>系统管理命令（如查看内存使用、网络情况）</li></ol></li><li><ol start="15"><li>管道的使用 |</li></ol></li><li><ol start="16"><li>grep的使用，一定要掌握，每次都会问在文件中查找</li></ol></li><li><ol start="17"><li>shell脚本</li></ol></li><li><ol start="19"><li>awk使用</li></ol></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>js面试题</title>
      <link href="/interview/frontend/js.html"/>
      <url>/interview/frontend/js.html</url>
      
        <content type="html"><![CDATA[<ul><li>基本数据类型？<ul><li>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li></ul></li><li>介绍js有哪些内置对象？<ul><li>Object 是 JavaScript 中所有对象的父对象</li><li>数据封装类对象：Object、Array、Boolean、Number 和 String</li><li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li></ul></li><li>null，undefined 的区别？<ul><li>null         表示一个对象是“没有值”的值，也就是值为“空”；</li><li>undefined     表示一个变量声明了没有初始化(赋值)；</li><li>undefined不是一个有效的JSON，而null是；</li><li>undefined的类型(typeof)是undefined；</li><li>null的类型(typeof)是object；</li><li>Javascript将未赋值的变量默认值设为undefined；</li><li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</li><li>注意：<ul><li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li><li>null == undefined // true</li><li>null === undefined // false</li></ul></li></ul></li><li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>//使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：<br>let obj = {};<br>let arr = [];<br>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>//从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br>let obj = {};<br>let arr = [];<br>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]<br>//而 [] === false 是返回 false 的。</li><li></li></ul><ul><li><h4 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h4><ul><li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li><li>堆：引用数据类型（对象、数组和函数）</li><li>两种类型的区别是：存储位置不同；<ul><li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li><li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li></ul></li></ul></li><li><h4 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h4><ul><li>parseFloat(‘12.3b’);</li><li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li><li>如何验证非空</li></ul></li><li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li><li><h4 id="异步与同步请求如何实现？"><a href="#异步与同步请求如何实现？" class="headerlink" title="异步与同步请求如何实现？"></a>异步与同步请求如何实现？</h4></li><li><h4 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h4><ul><li>window对象是指浏览器打开的窗口。</li><li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</li></ul></li><li><h4 id="cookie-和session-的区别？"><a href="#cookie-和session-的区别？" class="headerlink" title="cookie 和session 的区别？"></a>cookie 和session 的区别？</h4><ul><li>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。</li><li>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li><li>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。</li><li>4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li><li>5.所以个人建议：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li></ul></li><li><h4 id="cookie、sessionStorage、localStorage区别？"><a href="#cookie、sessionStorage、localStorage区别？" class="headerlink" title="cookie、sessionStorage、localStorage区别？"></a>cookie、sessionStorage、localStorage区别？</h4><ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li><li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li><li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li><li>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li><li>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li><li><h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><ul><li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</li><li>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</li><li>指一段脚本只能读取来自同一来源的窗口和文档的属性。</li></ul></li><li><h4 id="如何判断在数组中是否存在"><a href="#如何判断在数组中是否存在" class="headerlink" title="如何判断在数组中是否存在"></a>如何判断在数组中是否存在</h4>indexOf</li><li><h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><ul><li>使用instanceof</li></ul></li><li><h4 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h4></li><li><h4 id="数组转字符串-join-；字符串转数组-split-‘’"><a href="#数组转字符串-join-；字符串转数组-split-‘’" class="headerlink" title="数组转字符串(join)；字符串转数组(split(‘’))"></a>数组转字符串(join)；字符串转数组(split(‘’))</h4></li><li><h4 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h4>*(1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>*（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>*（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>*（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>*（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>*（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>*（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br>*（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<ul><li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</li></ul></li><li><h4 id="jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4></li><li><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><ul><li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li></ul></li><li><h4 id="axios有哪些方法、参数？"><a href="#axios有哪些方法、参数？" class="headerlink" title="axios有哪些方法、参数？"></a>axios有哪些方法、参数？</h4></li><li><h4 id="ajax请求头部携带cookie"><a href="#ajax请求头部携带cookie" class="headerlink" title="ajax请求头部携带cookie"></a>ajax请求头部携带cookie</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true;//让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure></li></ul><h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ul><li><h4 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h4></li><li><h4 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h4><ul><li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</li></ul></li><li><h4 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h4><ul><li>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</li></ul></li><li><h4 id="组件的生命周期有哪些？"><a href="#组件的生命周期有哪些？" class="headerlink" title="组件的生命周期有哪些？"></a>组件的生命周期有哪些？</h4><ul><li>组件的声明周期有三种阶段，一种是初始化阶段（Mounting），一种是更新阶段（Updating）最后一种是析构阶段（Unmounting）。而这两个阶段的声明周期函数都是相似且有一一对应的关系的</li></ul></li><li><h4 id="什么时候使用-Class-Component-而非-Functional-Component"><a href="#什么时候使用-Class-Component-而非-Functional-Component" class="headerlink" title="什么时候使用 Class Component 而非 Functional Component?"></a>什么时候使用 Class Component 而非 Functional Component?</h4><ul><li>如果你的组件有state或者使用了生命周期函数，那么请使用Class component。 否则，使用Functional component。</li></ul></li><li>什么是keys 而且为什么他们很重要<ul><li>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li></ul></li></ul><ul><li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul><li>1）创建新节点<ul><li>createDocumentFragment() //创建一个DOM</li><li>createElement() //创建一个具体的</li><li>createTextNode() //创建一个文本节点</li></ul></li><li>2）添加、移除、替换、插入<ul><li>appendChild()</li><li>removeChild()</li><li>replaceChild()</li><li>insertBefore() //并没有insertAfter()</li></ul></li><li>3）查找<ul><li>getElementsByTagName() //通过标签名</li><li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li><li>getElementById() //通过元素Id，唯一性</li></ul></li></ul></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python面试题</title>
      <link href="/interview/backend/python.html"/>
      <url>/interview/backend/python.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>装饰器的写法，并打印出方法名</p></li><li><p>定义一个字典，如果有动态的数据是不能够定义的，比如list. Tuple、字符串、数字是可以的</p></li><li><p>b树，b+树</p></li><li><p>深浅拷贝</p></li><li><p>redis数据类型，缓存失效方案</p></li><li><p>mysql存储引擎，索引方案</p></li><li><p>有序list合并成一个</p></li><li><p>协程</p></li><li><p>grpc</p></li><li><p><a href="https://github.com/leeguandong/Interview-code-practice-python" target="_blank" rel="noopener">https://github.com/leeguandong/Interview-code-practice-python</a></p></li><li><p><a href="https://github.com/princewen/leetcode_python" target="_blank" rel="noopener">https://github.com/princewen/leetcode_python</a></p></li><li><p><a href="http://bookshadow.com/leetcode/" target="_blank" rel="noopener">http://bookshadow.com/leetcode/</a></p></li><li><p>子类初始化父类</p><ul><li>子类必须显示的调用父类的构造方法赖初始化父类才行。</li></ul></li><li><p>python性能分析</p><ul><li>python -m cProfile -o profile.out main.py</li><li>brew install graphviz</li><li>pip install gprof2dot</li><li>gprof2dot -f pstats profile.out | dot -Tpng -o profile.png<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Stats对象</span></span><br><span class="line">p = pstats.Stats(<span class="string">"profile/profile.out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></span><br><span class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></span><br><span class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></span><br><span class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"sum_num"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></span><br><span class="line">p.print_callees(<span class="string">"topic"</span>)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>语言特性<br>1.谈谈对 Python 和其他语言的区别<br>2.简述解释型和编译型编程语言<br>3.Python 的解释器种类以及相关特点？<br>4.说说你知道的Python3 和 Python2 之间的区别？<br>5.Python3 和 Python2 中 int 和 long 区别？<br>6.xrange 和 range 的区别？<br>编码规范<br>7.什么是 PEP8?<br>8.了解 Python 之禅么？<br>9.了解 dosctring 么？<br>10.了解类型注解么？<br>11.例举你知道 Python 对象的命名规范，例如方法或者类等<br>12.Python 中的注释有几种？<br>13.如何优雅的给一个函数加注释？<br>14.如何给变量加注释？<br>15.Python 代码缩进中是否支持 Tab 键和空格混用。<br>16.是否可以在一句 import 中导入多个库?<br>17.在给 Py 文件命名的时候需要注意什么?<br>18.例举几个规范 Python 代码风格的工具<br>数据类型<br>字符串<br>19.列举 Python 中的基本数据类型？<br>20.如何区别可变数据类型和不可变数据类型<br>21.将”hello world”转换为首字母大写”Hello World”<br>22.如何检测字符串中只含有数字?<br>23.将字符串”ilovechina”进行反转<br>24.Python 中的字符串格式化方式你知道哪些？<br>25.有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。<br>26.获取字符串”123456“最后的两个字符。<br>27.一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？<br>28.s=”info:xiaoZhang 33 shandong”,用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]<br>27.怎样将字符串转换为小写？<br>28.单引号、双引号、三引号的区别？<br>29.a = “你好     中国  “,去除多余空格只留一个空格。<br>列表<br>30.已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。<br>31.如何实现 “1,2,3” 变成 [“1”,”2”,”3”]<br>32.给定两个 list，A 和 B，找出相同元素和不同元素<br>33.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]<br>34.合并列表[1,5,7,9]和[2,2,6,8]<br>35.如何打乱一个列表的元素？<br>字典<br>36.字典操作中 del 和 pop 有什么区别<br>37.按照字典的内的年龄排序<br>d1 = [<br>    {‘name’:’alice’, ‘age’:38},<br>    {‘name’:’bob’, ‘age’:18},<br>    {‘name’:’Carl’, ‘age’:28},<br>]<br>38.请合并下面两个字典 a = {“A”:1,”B”:2},b = {“C”:3,”D”:4}<br>39.如何使用生成式的方式生成一个字典，写一段功能代码。<br>40.如何把元组(“a”,”b”)和元组(1,2)，变为字典{“a”:1,”b”:2}<br>综合<br>41.Python 常用的数据结构的类型及其特性？<br>A：{1:0,2:0,3:0}<br>B：{“a”:0, “b”:0, “c”:0}<br>C: {(1,2):0, (2,3):0}<br>D: {[1,2]:0, [2,3]:0}<br>42.如何将元组(“A”,”B”)和元组(1,2),合并成字典{“A”:1,”B”:2}<br>43.Python 里面如何实现 tuple 和 list 的转换？<br>44.我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？<br>45.请将[i for i in range(3)]改成生成器<br>46.a=”hello”和 b=”你好”编码成 bytes 类型<br>47.下面的代码输出结果是什么？<br>a = (1,2,3,[4,5,6,7],8)<br>a[2] = 2<br>48.下面的代码输出的结果是什么?<br>a = (1,2,3,[4,5,6,7],8)<br>a[5] = 2<br>操作类题目<br>49.Python 交换两个变量的值<br>50.在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的左右<br>51.json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？<br>52.json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？<br>53.有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。<br>54.如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。<br>55.写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。<br>56.下面代码会存在什么问题，如何改进？<br>def strappend(num):<br>    str=’first’<br>    for i in range(num):<br>        str+=str(i)<br>    return str<br>57.一行代码输出 1-100 之间的所有偶数。<br>58.with 语句的作用，写一段代码？<br>59.python 字典和 json 字符串相互转化方法<br>60.请写一个 Python 逻辑，计算一个文件中的大写字母数量<br>高级特效<br>70.函数装饰器有什么作用？请列举说明？<br>71.Python 垃圾回收机制？<br>72.魔法函数 <strong>call</strong>怎么使用?<br>73.如何判断一个对象是函数还是方法？<br>74.@classmethod 和@staticmethod 用法和区别<br>75.Python 中的接口如何实现？<br>76.Python 中的反射了解么?<br>77.metaclass 作用？以及应用场景？<br>78.hasattr() getattr() setattr()的用法<br>79.请列举你知道的 Python 的魔法方法及用途。<br>80.如何知道一个 Python 对象的类型？<br>81.Python 的传参是传值还是传址？</p><p>82.Python 中的元类(metaclass)使用举例 什么是元类(meta_class)?<br>元类就是用来创建类的“东西”</p><p>83.简述 any()和 all()方法<br>84.filter 方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>85.什么是猴子补丁？<br>86.在 Python 中是如何管理内存的？<br>87.当退出 Python 时是否释放所有内存分配？<br>正则表达式<br>88.使用正则表达式匹配出<html><h1><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h1></html>中的地址<br>a=”张明 98 分”，用 re.sub，将 98 替换为 100<br>89.正则表达式匹配中(.<em>)和(.</em>?)匹配区别？<br>90.写一段匹配邮箱的正则表达式<br>其他内容<br>91.解释一下 python 中 pass 语句的作用？<br>92.简述你对 input()函数的理解<br>93.python 中的 is 和==<br>94.Python 中的作用域<br>95.三元运算写法和应用场景？<br>96.了解 enumerate 么？<br>97.列举 5 个 Python 中的标准模块<br>98.如何在函数中设置一个全局变量<br>99.pathlib 的用法举例<br>100.Python 中的异常处理，写一个简单的应用场景<br>101.Python 中递归的最大次数，那如何突破呢？<br>102.什么是面向对象的 mro<br>103.isinstance 作用以及应用场景？<br>104.什么是断言？应用场景？</p><p>105.lambda 表达式格式以及应用场景？<br>函数使用:</p><ol><li>代码块重复，这时候必须考虑到函数，降低程序的冗余度</li><li>代码块复杂，这时候必须考虑到函数，降低程序的复杂度<br>Python有两种函数,一种是def定义，一种是lambda函数()<br>当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数这个概念</li></ol><p>106.新式类和旧式类的区别<br>107.dir()是干什么用的？<br>108.一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。<br>109.列举 5 个 Python 中的异常类型以及其含义<br>110.copy 和 deepcopy 的区别是什么？<br>111.代码中经常遇到的*args, **kwargs 含义及用法。<br>112.Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?<br>113.w、a+、wb 文件写入模式的区别<br>114.举例 sort 和 sorted 的区别<br>115.什么是负索引？<br>116.pprint 模块是干什么的？<br>117.解释一下 Python 中的赋值运算符<br>118.解释一下 Python 中的逻辑运算符<br>119.讲讲 Python 中的位运算符<br>120.在 Python 中如何使用多进制数字？<br>121.怎样声明多个变量并赋值？<br>算法和数据结构<br>122.已知：<br>AList = [1,2,3]<br>BSet = {1,2,3}<br>(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？<br>(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？<br>123.用 Python 实现一个二分查找的函数</p><p>124.python 单例模式的实现方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- encoding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法1--------------------------'</span></span><br><span class="line"><span class="comment">#方法1,实现__new__方法</span></span><br><span class="line"><span class="comment">#并在将一个类的实例绑定到类变量_instance上,</span></span><br><span class="line"><span class="comment">#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回</span></span><br><span class="line"><span class="comment">#如果cls._instance不为None,直接返回cls._instance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass()</span><br><span class="line">two = MyClass()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#one和two完全相同,可以用id(), ==, is检测</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法2--------------------------'</span></span><br><span class="line"><span class="comment">#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)</span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),</span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可</span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="comment">#可参看:http://code.activestate.com/recipes/66531/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass2()</span><br><span class="line">two = MyClass2()</span><br><span class="line"></span><br><span class="line"><span class="comment">#one和two是两个不同的对象,id, ==, is对比结果可看出</span></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#28873680</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#28873712</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="comment">#但是one和two具有相同的（同一个__dict__属性）,见:</span></span><br><span class="line"><span class="keyword">print</span> id(one.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"><span class="keyword">print</span> id(two.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法3--------------------------'</span></span><br><span class="line"><span class="comment">#方法3:本质上是方法1的升级（或者说高级）版</span></span><br><span class="line"><span class="comment">#使用__metaclass__（元类）的高级python用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dict)</span>:</span></span><br><span class="line">        super(Singleton2, cls).__init__(name, bases, dict)</span><br><span class="line">        cls._instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = super(Singleton2, cls).__call__(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass3</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton2</span><br><span class="line"></span><br><span class="line">one = MyClass3()</span><br><span class="line">two = MyClass3()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法4--------------------------'</span></span><br><span class="line"><span class="comment">#方法4:也是方法1的升级（高级）版本,</span></span><br><span class="line"><span class="comment">#使用装饰器(decorator),</span></span><br><span class="line"><span class="comment">#这是一种更pythonic,更elegant的方法,</span></span><br><span class="line"><span class="comment">#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass4</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">one = MyClass4()</span><br><span class="line">two = MyClass4()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line">one.x = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> one.x</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">print</span> two.x</span><br><span class="line"><span class="comment">#1</span></span><br></pre></td></tr></table></figure><p>125.使用 Python 实现一个斐波那契数列<br>126.找出列表中的重复数字<br>127.找出列表中的单个数字<br>128.写一个冒泡排序<br>129.写一个快速排序<br>130.写一个拓扑排序<br>131.python 实现一个二进制计算<br>132.有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。<br>133.单链表反转<br>134.交叉链表求交点<br>135.用队列实现栈<br>136.找出数据流的中位数<br>137.二叉搜索树中第 K 小的元素<br>爬虫相关<br>138.在 requests 模块中，requests.content 和 requests.text 什么区别<br>139.简要写一下 lxml 模块的使用方法框架<br>140.说一说 scrapy 的工作流程<br>141.scrapy 的去重原理<br>142.scrapy 中间件有几种类，你用过哪些中间件<br>143.你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？<br>144.为什么会用到代理？<br>145.代理失效了怎么处理？<br>146.列出你知道 header 的内容以及信息<br>147.说一说打开浏览器访问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 获取到结果，整个流程。<br>148.爬取速度过快出现了验证码怎么处理<br>149.scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？<br>150.分布式爬虫主要解决什么问题<br>151.写爬虫是用多进程好？还是多线程好？为什么？<br>152.解析网页的解析器使用最多的是哪几个<br>153.需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？<br>154.验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）<br>155.使用最多的数据库（mysql，mongodb，redis 等），对他的理解？<br>网络编程<br>156.TCP 和 UDP 的区别？<br>157.简要介绍三次握手和四次挥手<br>158.什么是粘包？socket 中造成粘包的原因是什么？哪些情况会发生粘包现象？<br>并发<br>159.举例说明 conccurent.future 的中线程池的用法<br>160.说一说多线程，多进程和协程的区别。</p><p>161.简述 GIL.什么是GIL?<br>每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.<br>那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行,<br>多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.<br>从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能</p><p>162.进程之间如何通信<br>163.IO 多路复用的作用？<br>164.select、poll、epoll 模型的区别？<br>165.什么是并发和并行？<br>167.解释什么是异步非阻塞？<br>168.threading.local 的作用？<br>Git 面试题<br>169.说说你知道的 git 命令<br>170.git 如何查看某次提交修改的内容x</p><p>180.说说你对zen of python的理解，你有什么办法看到它?<br>Python之禅,Python秉承一种独特的简洁和可读行高的语法，以及高度一致的编程模式，符合“大脑思维习惯”，使Python易于学习、理解和记忆。Python同时采用了一条极简主义的设计理念，了解完整的Python哲学理念，可以在任何一个Python交互解释器中键入import this命令，这是Python隐藏的一个彩蛋:描绘了一系列Python设计原则。如今已是Python社区内流行的行话”EIBTI”，明了胜于晦涩这条规则的简称. 在Python的思维方式中，明了胜于晦涩，简洁胜于复杂</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>181.说说你对pythonic的看法，尝试解决下面的小问题<br>简洁，明了，严谨，灵活</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#交换两个变量值</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="comment">#去掉list中的重复元素</span></span><br><span class="line">old_list = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">new_list = list(set(old_list))</span><br><span class="line"><span class="comment">#翻转一个字符串</span></span><br><span class="line">s = <span class="string">'abcde'</span></span><br><span class="line">ss = s[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#用两个元素之间有对应关系的list构造一个dict</span></span><br><span class="line">names = [<span class="string">'jianpx'</span>, <span class="string">'yue'</span>]</span><br><span class="line">ages = [<span class="number">23</span>, <span class="number">40</span>]</span><br><span class="line">m = dict(zip(names,ages))</span><br><span class="line"><span class="comment">#将数量较多的字符串相连，如何效率较高，为什么</span></span><br><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line">result = <span class="string">''</span>.join(fruits)</span><br></pre></td></tr></table></figure><p>182.你调试python代码的方法有哪些?<br>具体IDE都有调试，比如:IDLE, Eclipse+Pydev都可以设置断点调试。<br>pdb模块也可以做调试。<br>还有PyChecker和Pylint<br>PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告<br>Pylint   是另外一个工具可以进行coding standard检查。</p><p>Q: When will the else part of try-except-else be executed?<br>Q: What are metaclasses in Python?<br>Q: What is monkey patching? How to use in Python? Example?<br>Q: What are the tools that help to find bugs or perform static analysis? What static code analyzers do you know/used?<br>Q: Whenever Python exits, why isn’t all the memory de-allocated?<br>Q: Explain how can you access a module written in Python from C? Vise versa?<br>Q: What do these mean to you: @classmethod, @staticmethod, @property?<br>Q: Is Python a functional language?<br>Q: What is the attribute <strong>slots</strong>?<br>Q: Is it possible to use the construction True = False?<br>Q: How to create a class without the class statement?<br>Q: Give an example of filter and reduce over an iterable object<br>Q: Is it possible to have a producer thread reading from the network and a consumer thread writing to a file, really work in parallel? What about GIL?<br>Q: How do you create a dictionary which can preserve the order of pairs?<br>Q: What does the PYTHONOPTIMIZE flag do?<br>Q: What are descriptors? Code example?<br>Q: What is MRO in Python? How does it work?<br>Q: Mention what is the difference between Django, Pyramid, and Flask?<br>Q: Specify the requirements for code written in a functional style.<br>Q: Identify the pitfalls/limitations in the function code.<br>Q: How to package code in Python?<br>Q:What is wheels and eggs? What is the difference?<br>Q: How to package binary dependencies in Python?<br>Q: How can I reload a previously imported <code>module</code> module? (we assume that the module is a file with module.py)<br>Q: What advantages do NumPy arrays offer over (nested) Python lists?<br>Q: What is the process of compilation and linking in python?<br>Q: What id() function in Python is for?<br>Q: Is Python call-by-value or call-by-reference?<br>Q: Explain how you reverse a generator?<br>Q: Let A and B be objects of class Foo. What methods and in what order are called when “print (A + B)” is executed?<br>Q: Place the following functions below in order of their efficiency. How would you test your answer?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = sorted(lIn)</span><br><span class="line">    l2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> lIn <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> lIn]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;(<span class="number">0.5</span>*<span class="number">0.5</span>)]</span><br></pre></td></tr></table></figure><p>Q: Write a one-liner that will count the number of capital letters in a file. Your code should work even if the file is too big to fit in memory.<br>Q: Output? Why? Is this inheritance?</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">type (C ())</span><br><span class="line">type (C)</span><br><span class="line">Q: What<span class="string">'s the output we get from running the following?</span></span><br><span class="line"><span class="string">big_num_1   = 1000</span></span><br><span class="line"><span class="string">big_num_2   = 1000</span></span><br><span class="line"><span class="string">small_num_1 = 1</span></span><br><span class="line"><span class="string">small_num_2 = 1</span></span><br><span class="line"><span class="string">big_num_1 is big_num_2</span></span><br><span class="line"><span class="string">small_num_1 is small_num_2</span></span><br><span class="line"><span class="string">Q: How is this possible?</span></span><br><span class="line"><span class="string">_MangledGlobal__mangled = 23</span></span><br><span class="line"><span class="string">class MangledGlobal:</span></span><br><span class="line"><span class="string">     def test(self):</span></span><br><span class="line"><span class="string">         return __mangled</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MangledGlobal().test()</span></span><br><span class="line"><span class="string">23</span></span><br></pre></td></tr></table></figure><p>1.Python这么好，说说它的特性吧<br>关键特性<br>Python是一种解释型语言，这意味着，与C，C++不同，Python不需要在运行之前进行编译。它是边运行边解释的。<br>Python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x=1 ，然后x=”abc”是没有错误。<br>Python非常适合面向对象编程，因为它允许定义类以及组合和继承。Python没有访问修饰符。<br>在Python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。<br>Python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，Python允许包含基于C的扩展，所以瓶颈可以被优化掉。</p><p>2.单引号、双引号和三引号之间的区别<br>关于怎么快速学python，可以加下小编的python学习群:611+530+101，不管你是小白还是大牛，小编我都欢迎，不定期分享干货<br>每天晚上20:00都会开直播给大家分享python学习知识和路线方法，群里会不定期更新最新的教程和学习方法，大家都是学习python的，或是转行，或是大学生，还有工作中想提升自己能力的，如果你是正在学习python的小伙伴可以加入学习。最后祝所有程序员都能够走上人生巅峰，让代码将梦想照进现实<br>单引号和双引号主要是用来表示字符串<br>比如:<br>单引号:’python’<br>双引号:”python”<br>区别:<br>若你的字符串里面本身包含单引号,必须用双引号包裹。<br>比如:”can’t find the log “<br>三引号<br>三单引号:’’’python ‘’’,也可以表示字符串一般用来输入多行文本,或者用于大段的注释。<br>三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档。</p><p>3.Python里面如何拷贝一个对象？<br>标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象.<br>使用deepcopy方法,对象中的属性也被复制</p><p>4.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p><p>5.什么是lambda函数？它的好处是什么?<br>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br>lambda函数：首要用途是指点短小的回调函数。<br>lambda [arguments]:expression</p><blockquote><blockquote><blockquote><p>a=lambdax,y:x+y<br>a(3,11)<br>好处：<br>lambda能和def做同样种类的工作，特别是对于那些逻辑简单的函数，直接用lambda会更简洁，而且省去取函数名的麻烦。</p></blockquote></blockquote></blockquote><p>6.字符串格式化: %和 .format的区别是什么？<br>字符串的format函数非常灵活，很强大,可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如:填充、对齐、精度等)。</p><p>7.Python是如何进行内存管理的？<br>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放<br>内存池（memory pool）的概念：<br>当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>内存池的实现方式有很多，性能和适用范围也不一样。<br>python中的内存管理机制——Pymalloc：<br>python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。 关于释放内存方面，当一个对象的引用计数变为0时，python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作。</p><p>8.如何用Python来进行查询和替换一个文本字符串？<br>可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0])<br>replacement是被替换成的文本<br>string是需要被替换的文本<br>count是一个可选参数，指最大被替换的数量</p><p>9.Python里面search()和match()的区别？<br>match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配, 也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none 。</p><p>10.线程如何在Python中实现<br>Python有一个多线程包threading，可以使用多线程来加快你的代码。但是Python有一个叫做Global Interpreter Lock（GIL）的构造。GIL确保只有一个’线程’可以在任何时候执行。<br>线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在使得Python中的多线程无法真正的利用多核的优势来提高性能。<br>对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速！但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。</p><p>11.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p><p>12.数据仓库是什么？<br>数据仓库是一个面向主题的、集成的、稳定的、反映历史变化的、随着时间的流逝发生变化的数据集合。它主要支持管理人员的决策分析。<br>数据仓库收集了企业相关内部和外部各个业务系统数据源、归档文件等一系列历史数据，最后转化成企业需要的战略决策信息。<br>特点：<br> 面向主题 ：根据业务的不同而进行的内容划分；<br> 集成特性 ：因为不同的业务源数据具有不同的数据特点，当业务源数据进入到数据仓库时，需要采用统一的编码格式进行数据加载，从而保证数据仓库中数据的唯一性；<br> 非易失性 ：数据仓库通过保存数据不同历史的各种状态，并不对数据进行任何更新操作。<br> 历史特性 ：数据保留时间戳字段，记录每个数据在不同时间内的各种状态。</p><p>1、一行代码实现1–100之和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum(range(<span class="number">0</span>,<span class="number">101</span>)</span><br></pre></td></tr></table></figure><p>2.如何在一个函数内部修改全局变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">fn()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure><p>3.字典如何删除键和合并两个字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span></span><br><span class="line">update</span><br></pre></td></tr></table></figure><p>4.python实现列表去重的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = []</span><br><span class="line">list(set(a))</span><br></pre></td></tr></table></figure><p>5.fun(<em>args,*</em>kwargs)中的<em>args,*</em>kwargs什么意思？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>6.python2和python3的range（100）的区别<br>python2返回列表，python3返回迭代器，节约内存</p><p>7.一句话解释什么样的语言能够用装饰器?<br>函数可以作为参数传递的语言，可以使用装饰器</p><p>8.python内建数据类型有哪些<br>整型–int<br>布尔型–bool<br>字符串–str<br>列表–list<br>元组–tuple<br>字典–dict</p><p>9.简述面向对象中<strong>new</strong>和<strong>init</strong>区别<br><strong>init</strong>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数<br>1、<strong>new</strong>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别<br>2、<strong>new</strong>必须要有返回值，返回实例化出来的实例，这点在自己实现<strong>new</strong>时要特别注意，可以return父类（通过super(当前类名, cls)）<strong>new</strong>出来的实例，或者直接是object的<strong>new</strong>出来的实例<br>3、<strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值<br>4、如果<strong>new</strong>创建的是当前类的实例，会自动调用<strong>init</strong>函数，通过return语句里面调用的<strong>new</strong>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<strong>init</strong>函数，也不会调用其他类的<strong>init</strong>函数。</p><p>10.简述with方法打开处理文件帮我我们做了什么？<br>自带上下文管理器</p><p>11.列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a**<span class="number">2</span></span><br><span class="line">res = map(fn, a)</span><br><span class="line">res = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure><p>12.python中生成随机整数、随机小数、0–1之间小数方法<br>随机整数：random.randint(a,b),生成区间内的整数<br>随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数<br>0-1随机小数：random.random(),括号中不传参</p><p>13.避免转义给字符串加哪个字母表示原始字符串？<br>r,表示需要原始字符串，不转义特殊字符</p><p>14.<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'&lt;div class="nam"&gt;中国&lt;/div&gt;'</span></span><br><span class="line">res = re.findall(<span class="string">r'&lt;div class=".*"0&gt;(.*?)&lt;/div&gt;'</span>, str)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><p>15.python中断言方法举例<br>assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错</p><p>16.列出python中可变数据类型和不可变数据类型，并简述原理<br>不可变数据类型：数值型、字符串型string和元组tuple<br>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p><p>可变数据类型：列表list和字典dict；<br>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p><p>17.字典根据键从小到大排序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted(a.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>], reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>18.正则re.complie作用<br>re.compile是将正则表达式编译成一个对象，加快速度，并重复使用</p><p>19.a=（1，）b=(1)，c=(“1”) 分别是什么类型的数据？<br>tuple,int,str</p><p>20.两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">a + b</span><br><span class="line"></span><br><span class="line">a.sort()</span><br></pre></td></tr></table></figure><p>21.正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？<br>（.<em>）是贪婪匹配，会把满足正则的尽可能多的往后匹配<br>（.</em>?）是非贪婪匹配，会把满足正则的尽可能少匹配</p><p>22.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.array(a).flatten().tolist()</span><br></pre></td></tr></table></figure><p>23.提高python运行效率的方法<br>1、使用生成器，因为可以节约大量内存<br>2、循环代码优化，避免过多重复代码的执行<br>3、核心模块用Cython  PyPy等，提高效率<br>4、多进程、多线程、协程<br>5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p><p>24.写一个单列模式<br>因为创建对象时<strong>new</strong>方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _instance:</span><br><span class="line">            cls._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure><p>25.保留两位小数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">123.23423</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>26.分别从前端、后端、数据库阐述web项目的性能优化<br>前端优化：<br>1、减少http请求、例如制作精灵图<br>2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差</p><p>后端优化：<br>1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。<br>2、异步方式，如果有耗时操作，可以采用异步，比如celery<br>3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况</p><p>数据库优化：<br>1、如有条件，数据可以存放于redis，读取速度快<br>2、建立索引、外键等</p><p>27.列出常见MYSQL数据存储引擎<br>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。<br>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。<br>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p><p>29.简述多线程、多进程<br>进程：<br>1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立<br>2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制</p><p>线程：<br>1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源<br>2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃<br>应用：<br>IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间<br>CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势</p><p>30.IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常<br>IOError：输入输出异常<br>AttributeError：试图访问一个对象没有的属性<br>ImportError：无法引入模块或包，基本是路径问题<br>IndentationError：语法错误，代码没有正确的对齐<br>IndexError：下标索引超出序列边界<br>KeyError:试图访问你字典里不存在的键<br>SyntaxError:Python代码逻辑语法出错，不能执行<br>NameError:使用一个还未赋予对象的变量</p><p>31.python中copy和deepcopy区别<br>1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同<br>2、复制的值是可变对象（列表和字典）<br>浅拷贝copy有两种情况：<br>第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。<br>第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。<br>深拷贝deepcopy：完全复制独立，包括内层列表和字典</p><p>32.请将[i for i in range(3)]改成生成器<br>生成器是特殊的迭代器，<br>1、列表表达式的[]改为（）即可变成生成器<br>2、函数在返回值得时候出现yield就变成生成器，而不是函数了；<br>中括号换成小括号即可，有没有惊呆了</p><p>33.int(“1.4”),int(1.4)输出结果？<br>int(“1.4”)报错，int(1.4)输出1</p><p>34.列举3条以上PEP8编码规范<br>1、顶级定义之间空两行，比如函数或者类定义。<br>2、方法定义、类定义与第一个方法之间，都应该空一行<br>3、三引号进行注释<br>4、使用Pycharm、Eclipse一般使用4个空格来缩进代码</p><p>35.简述乐观锁和悲观锁<br>悲观锁, 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p><p>乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</p><p>36.Linux命令重定向 &gt; 和 &gt;&gt;<br>Linux 允许将命令执行结果 重定向到一个 文件<br>将本应显示在终端上的内容 输出／追加 到指定文件中</p><blockquote><p>表示输出，会覆盖文件原有的内容</p><blockquote><p>表示追加，会将内容追加到已有文件的末尾</p></blockquote></blockquote><p>37.python传参数是传值还是传址？<br>Python中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。</p><p>38.求两个列表的交集、差集、并集</p><p>39.python正则中search和match</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>资源</title>
      <link href="/resource/index.html"/>
      <url>/resource/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="0x00、电子书"><a href="#0x00、电子书" class="headerlink" title="0x00、电子书"></a>0x00、电子书</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">现代操作系统_第三版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf" target="_blank" rel="noopener">Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">Linux内核设计与实现_第三版.pdf</a></li></ul><h3 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h3><h4 id="2-1-python"><a href="#2-1-python" class="headerlink" title="2.1 python"></a>2.1 python</h4><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">python核心编程.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86.pdf" target="_blank" rel="noopener">Python网络数据采集.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/OReilly.Web.Scraping.with.Python.2015.6.pdf" target="_blank" rel="noopener">OReilly.Web.Scraping.with.Python.2015.6.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Machine%20Learning%20in%20Python.pdf" target="_blank" rel="noopener">Machine Learning in Python.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/The%20Django%20Book%202.0%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">The Django Book 2.0中文版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/%E3%80%8APython%20Cookbook%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E4%B8%AD%E6%96%87.pdf" target="_blank" rel="noopener">《Python Cookbook》第三版中文.pdf</a></li></ul><h4 id="2-2-golang"><a href="#2-2-golang" class="headerlink" title="2.2 golang"></a>2.2 golang</h4><ul><li><a href="http://www.gopl.io/" target="_blank" rel="noopener">go语言开发设计(原版)</a>, <a href="https://docs.hacknode.org/gopl-zh/" target="_blank" rel="noopener">go语言开发设计(中文版)</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/build-web-application-with-golang-en.pdf" target="_blank" rel="noopener">build-web-application-with-golang-en.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/effective-go-zh-en.pdf" target="_blank" rel="noopener">effective-go-zh-en.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">go高级编程.pdf</a></li></ul><h4 id="2-3-c"><a href="#2-3-c" class="headerlink" title="2.3 c++"></a>2.3 c++</h4><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/C%2B%2B/C%2B%2BPrimer%E7%AC%AC%E4%BA%94%E7%89%88.pdf" target="_blank" rel="noopener">C++Primer第五版.pdf</a></li></ul><h3 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3.数据库"></a>3.数据库</h3><h3 id="4-架构"><a href="#4-架构" class="headerlink" title="4.架构"></a>4.架构</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.pdf" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">Web性能权威指南.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Recommender%2BSystems%2BHandbook.pdf" target="_blank" rel="noopener">Recommender+Systems+Handbook.pdf</a></li><li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念及设计(第五版)</a></li></ul><h3 id="5-前端"><a href="#5-前端" class="headerlink" title="5.前端"></a>5.前端</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/javascript/%5BJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC6%E7%89%88)%5D.(JavaScript%EF%BC%9AThe.Definitive.Guide).David.Flanagan.%E6%96%87%E5%AD%97%E7%89%88.pdf" target="_blank" rel="noopener">JavaScript权威指南(第6版)</a></li></ul><h3 id="6-大数据"><a href="#6-大数据" class="headerlink" title="6.大数据"></a>6.大数据</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%9F%BA%E7%A1%80.pdf" target="_blank" rel="noopener">数据仓库基础.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E7%AC%AC%E5%9B%9B%E7%89%88.pdf" target="_blank" rel="noopener">数据仓库_第四版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/DW2.0%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%9E%84%E6%9E%B6.pdf" target="_blank" rel="noopener">DW2.0下一代数据仓库的构架.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The%20Data%20Warehouse%20Toolkit%2C%203rd%20Edition.pdf" target="_blank" rel="noopener">The Data Warehouse Toolkit, 3rd Edition.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The_Data_Warehouse_Lifecycle_Toolkit(Second%20Edition).pdf" target="_blank" rel="noopener">The_Data_Warehouse_Lifecycle_Toolkit(Second Edition).pdf</a></li></ul><h3 id="7-人工智能"><a href="#7-人工智能" class="headerlink" title="7.人工智能"></a>7.人工智能</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">神经网络与机器学习（原书第3版）.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%AE%BA.pdf" target="_blank" rel="noopener">自然语言处理综论.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%AF%AD%E4%B9%89%E7%BD%91%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.pdf" target="_blank" rel="noopener">语义网基础教程.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/AI/PYTHON%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86.pdf" target="_blank" rel="noopener">PYTHON自然语言处理.pdf</a></li></ul><h3 id="8-网络"><a href="#8-网络" class="headerlink" title="8.网络"></a>8.网络</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">HTTP权威指南.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷1：协议.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B72%EF%BC%9A%E5%AE%9E%E7%8E%B0.pdf" target="_blank" rel="noopener">TCP_IP详解卷2：实现.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B73%EF%BC%9ATCP%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%AE%AE%EF%BC%8CHTTP%EF%BC%8CNNTP%E5%92%8CUNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷3：TCP事务协议，HTTP，NNTP和UNIX域协议.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP.pdf" target="_blank" rel="noopener">图解HTTP.pdf</a></li></ul><h3 id="9-算法"><a href="#9-算法" class="headerlink" title="9.算法"></a>9.算法</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/Algorithms%2C%204th%20Edition(%E7%AE%97%E6%B3%95%EF%BC%8C%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%8C%E8%8B%B1%E6%96%87%E7%89%88).pdf" target="_blank" rel="noopener">Algorithms, 4th Edition(算法，第四版，英文版).pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80_%E7%AC%AC3%E7%89%88.pdf" target="_blank" rel="noopener">算法设计与分析基础_第3版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/leetcode-solution.pdf" target="_blank" rel="noopener">leetcode-solution.pdf</a></li></ul><h3 id="99-数学"><a href="#99-数学" class="headerlink" title="99.数学"></a>99.数学</h3><ul><li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%20%E5%8E%9F%E4%B9%A6%E7%AC%AC5%E7%89%88.pdf" target="_blank" rel="noopener">组合数学 原书第5版.pdf</a></li><li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E5%AD%A6/%5B%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8(%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%83%E7%89%88)%5DDiscrete%20Mathematics%20and%20Its%20Applications%20(7th).pdf" target="_blank" rel="noopener">离散数学及其应用(英文第七版)</a></li></ul><h2 id="0x01、视频教程"><a href="#0x01、视频教程" class="headerlink" title="0x01、视频教程"></a>0x01、视频教程</h2><h2 id="0x02、论文"><a href="#0x02、论文" class="headerlink" title="0x02、论文"></a>0x02、论文</h2><ul><li><a href="https://github.com/papers-we-love/papers-we-love" target="_blank" rel="noopener">papers-we-love</a></li></ul><h3 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1.分布式"></a>1.分布式</h3><ul><li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li></ul><h2 id="0x02、github图书库"><a href="#0x02、github图书库" class="headerlink" title="0x02、github图书库"></a>0x02、github图书库</h2><ul><li><a href="https://github.com/xsoer/learn-files" target="_blank" rel="noopener">https://github.com/xsoer/learn-files</a></li><li><a href="https://github.com/royeo/free-programming-books.pdf" target="_blank" rel="noopener">https://github.com/royeo/free-programming-books.pdf</a></li><li><a href="https://github.com/threerocks/studyFiles" target="_blank" rel="noopener">https://github.com/threerocks/studyFiles</a></li><li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></li><li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="noopener">https://github.com/it-ebooks/it-ebooks-archive</a></li><li><a href="https://github.com/shivam-jha/DockerBooks" target="_blank" rel="noopener">https://github.com/shivam-jha/DockerBooks</a></li><li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md</a></li><li><a href="https://github.com/zhiwoeryi/eBook-3" target="_blank" rel="noopener">https://github.com/zhiwoeryi/eBook-3</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>go语言程序设计</title>
      <link href="/books/gopl.html"/>
      <url>/books/gopl.html</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="http://www.gopl.io/" target="_blank" rel="noopener">图书地址</a>，<a href="https://docs.hacknode.org/gopl-zh/" target="_blank" rel="noopener">中文版地址</a></p></blockquote><h2 id="0x00、基础"><a href="#0x00、基础" class="headerlink" title="0x00、基础"></a>0x00、基础</h2><ul><li>如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了</li><li>只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。</li><li>import声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）</li><li>一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成</li></ul><ol><li>%d 十进制整数</li><li>%x, %o, %b 十六进制，八进制，二进制整数。</li><li>%f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00</li><li>%t 布尔：true或false</li><li>%c 字符（rune） (Unicode码点)</li><li>%s 字符串</li><li>%q 带双引号的字符串”abc”或带单引号的字符’c’</li><li>%v 变量的自然形式（natural format）</li><li>%T 变量的类型</li><li>%% 字面上的百分号标志（无操作数）</li></ol><ul><li><p>关键字</p><ol><li>break default func interface select</li><li>case defer go map struct</li><li>chan else goto package switch</li><li>const fallthrough if range type</li><li>continue for import return var</li></ol></li><li><p>预定义的名字</p><ol><li>内建常量: true false iota nil</li><li>内建类型: int int8 int16 int32 int64</li><li>uint uint8 uint16 uint32 uint64 uintptr</li><li>float32 float64 complex128 complex64</li><li>bool byte rune string error</li><li>内建函数: make len cap new append copy close delete</li><li>complex real imag</li><li>panic recover</li></ol></li><li><p>命令行</p><ul><li>get</li><li>run</li><li>clear</li><li>test</li><li>build</li><li>env</li><li>version</li><li>doc</li></ul></li><li><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问。包本身的名字一般总是用小写字母</p></li><li><p>Go语言程序员推荐使用 驼峰式 命名</p></li><li><p>主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明</p></li><li><p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）</p></li><li><p>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</p></li><li><p>变量声明</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure></li><li><p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p></li><li><p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为</p></li><li><p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span> <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">"four"</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure></li><li><p>初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。</p></li><li><p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure></li><li><p>自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的</p></li><li><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure></li><li><p>map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v = m[key] <span class="comment">// map查找，失败时返回零值</span></span><br><span class="line">v = x.(T) <span class="comment">// type断言，失败时panic异常</span></span><br><span class="line">v = &lt;-ch <span class="comment">// 管道接收，失败时返回零值（阻塞不算是失败）</span></span><br><span class="line">_, ok = m[key] <span class="comment">// map返回2个值</span></span><br><span class="line">_, ok = mm[<span class="string">""</span>], <span class="literal">false</span> <span class="comment">// map返回1个值</span></span><br><span class="line">_ = mm[<span class="string">""</span>] <span class="comment">// map返回1个值</span></span><br></pre></td></tr></table></figure></li><li><p>和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) <span class="comment">// 丢弃字节数</span></span><br><span class="line">_, ok = x.(T) <span class="comment">// 只检测类型，忽略具体值</span></span><br></pre></td></tr></table></figure></li><li><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br></pre></td></tr></table></figure></li><li><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的</p></li><li><p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p></li><li><p>对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。</p></li><li><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure></li><li><p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</p></li><li><p>对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。</p></li><li><p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型.只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</p></li><li><p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的</p></li><li><p>每个包都对应一个独立的名字空间</p></li><li><p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p></li><li><p>在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。</p></li><li><p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p></li><li><p>不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。</p></li><li><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p></li><li><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p></li><li><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p></li><li><p>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p></li><li><p>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p></li><li><p>句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的</p></li><li><p>我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p></li><li><p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p></li><li><p>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</p></li><li><p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系.但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</p></li><li><p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问</p></li><li><p>在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p></li><li><p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p></li><li><p>Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。</p></li><li><p>将数据类型分为四类：基础类型、复合类型、引用类型和接口类型</p></li></ul><h2 id="0x01、函数"><a href="#0x01、函数" class="headerlink" title="0x01、函数"></a>0x01、函数</h2><ul><li><p>函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用</p></li><li><p>函数的机制可以让我们将一个大的工作分解为小的任务，这样的小任务可以让不同程序员在不同时间、不同地方独立完成</p></li><li><p>一个函数同时对用户隐藏了其实现细节</p></li><li><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>形式参数列表描述了函数的参数名以及参数类型。</p></li><li><p>这些参数作为局部变量，其值由参数调用者提供</p></li><li><p>返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值</p></li><li><p>如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。</p></li><li><p>如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>, k <span class="keyword">int</span>, s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p></li><li><p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p></li><li><p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</p></li><li><p>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</p></li><li><p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float</span> //<span class="title">implemented</span> <span class="title">in</span> <span class="title">assembly</span> <span class="title">language</span></span></span><br></pre></td></tr></table></figure></li><li><p>函数可以是递归的，这意味着函数可以直接或间接的调用自身.通过遍历二叉树来实现简单的插入排序.使用它来处理HTML文件。</p></li><li><p>golang.org/x/… 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p></li><li><p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。</p></li><li><p>一个函数可以返回多个值</p></li><li><p>如果某个值不被使用，可以将其分配给blank identifier:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">links, _ := findLinks(url) <span class="comment">// errors ignored</span></span><br></pre></td></tr></table></figure></li><li><p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</p></li><li><p>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CountWordsAndImages does an HTTP GET request for the HTML</span></span><br><span class="line"><span class="comment">// document url and returns the number of words and images in it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(words, images <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    err = fmt.Errorf(<span class="string">"parsing HTML: %s"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">words, images = countWordsAndImages(doc)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countWordsAndImages</span><span class="params">(n *html.Node)</span> <span class="params">(words, images <span class="keyword">int</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure></li><li><p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words, image, nil。基于以上原因，不宜过度使用bare return。</p></li><li><p>在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。</p></li><li><p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</p></li><li><p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p></li><li><p>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。比如，cache.Lookup失败的唯一原因是key不存在，那么代码可以按照下面的方式组织：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">value, ok := cache.Lookup(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// ...cache[key] does not exist…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, err)</span><br></pre></td></tr></table></figure></li><li><p>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</p></li><li><p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p></li><li><p>最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当对html.Parse的调用失败时，findLinks不会直接返回html.Parse的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</p></li><li><p>函数内错误处理</p><ul><li>错误注意项<ul><li>确保错误信息对问题细节的描述是详尽的</li><li>错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</li></ul></li><li>处理逻辑<ul><li>检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</li></ul></li><li>五种错误处理方案<ul><li>传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</li><li>重试逻辑。第二种是 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</li><li>输出错误并结束运行。如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</li><li>Log记录错误。 有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</li><li>忽略错误。我们可以直接忽略掉错误。</li></ul></li><li>panic异常</li><li>recover场景</li></ul></li><li><p>函数赋值</p><ul><li>函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</li><li>函数类型的零值是nil。调用值为nil的函数值会引起panic错误</li><li>函数值可以与nil比较</li><li>但是函数值之间是不可比较的，也不能用函数值作为map的key</li><li>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为</li></ul></li><li><p>匿名函数</p><ul><li>函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数</li><li>可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量</li><li>函数值不仅仅是一串代码，还记录了状态</li><li>函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</li></ul></li><li><p>一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到html.Parse返回的错误中。</p></li><li><p>第二种是 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// WaitForServer attempts to contact the server of a URL.</span></span><br><span class="line"><span class="comment">// It tries for one minute using exponential back-off.</span></span><br><span class="line"><span class="comment">// It reports an error if all attempts fail.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">deadline := time.Now().Add(timeout)</span><br><span class="line"><span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">    _, err := http.Head(url)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"server not responding (%s);retrying…"</span>, err)</span><br><span class="line">    time.Sleep(time.Second &lt;&lt; <span class="keyword">uint</span>(tries)) <span class="comment">// exponential back-off</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"server %s failed to respond after %s"</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p></li><li><p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</p></li><li><p>第五种，也是最后一种策略：我们可以直接忽略掉错误。</p></li><li><p>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</p></li><li><p>函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"><span class="comment">// EOF is the error returned by Read when no more input is available.</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"read failed:%v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// "9"</span></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// "-3"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, f) <span class="comment">// "func(int) int"</span></span><br><span class="line">f = product <span class="comment">// compile error: can't assign func(int, int) int to func(int) int</span></span><br></pre></td></tr></table></figure></li><li><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(3)</span> // 此处<span class="title">f</span>的值为<span class="title">nil</span>, 会引起<span class="title">panic</span>错误</span></span><br></pre></td></tr></table></figure></li><li><p>函数值可以与nil比较：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">f</span> != <span class="title">nil</span></span> &#123;</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>但是函数值之间是不可比较的，也不能用函数值作为map的key。</p></li><li><p>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"HAL-9000"</span>)) <span class="comment">// "IBM.:111"</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"VMS"</span>)) <span class="comment">// "WNT"</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"Admix"</span>)) <span class="comment">// "Benjy"</span></span><br></pre></td></tr></table></figure></li><li><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）</p></li><li><p>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对strings.Map的调用：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">strings.Map(<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;, <span class="string">"HAL-9000"</span>)</span><br></pre></td></tr></table></figure></li><li><p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// squares返回一个匿名函数。</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p></li><li><p>变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p></li><li><p>当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 visitAll），再将匿名函数赋值给这个变量。如果不分成两部，函数字面量无法与visitAll绑定，我们也无法递归调用该匿名函数。</p></li><li><p>参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。</p></li><li><p>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p></li><li><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。在下面的代码中，一条defer语句替代了之前的所有resp.Body.Close</p></li><li><p>defer</p><ul><li>调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法</li><li>当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束</li><li>在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</li><li>经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁</li></ul></li><li><p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</p></li><li><p>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// "12"</span></span><br></pre></td></tr></table></figure></li><li><p>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file descriptors</span></span><br><span class="line">    <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> f.Close()</span><br><span class="line">     <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p></li><li><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine</p></li><li><p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Spades"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Hearts"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Diamonds"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Clubs"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"invalid suit %q"</span>, s)) <span class="comment">// Joker?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制</p></li><li><p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> printStack()</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">4096</span>]<span class="keyword">byte</span></span><br><span class="line">    n := runtime.Stack(buf[:], <span class="literal">false</span>)</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p></li><li><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p></li><li><p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="params">(s *Syntax, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"internal error: %v"</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</p></li><li><p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p></li><li><p>有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</p></li><li><p>为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// soleTitle returns the text of the first non-empty title element</span></span><br><span class="line"><span class="comment">// in doc, and an error if there was not exactly one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span> <span class="params">(title <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">// no panic</span></span><br><span class="line">            <span class="keyword">case</span> bailout&#123;&#125;: <span class="comment">// "expected" panic</span></span><br><span class="line">                err = fmt.Errorf(<span class="string">"multiple title elements"</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">panic</span>(p) <span class="comment">// unexpected panic; carry on panicking</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="comment">// Bail out of recursion if we find more than one nonempty title.</span></span><br><span class="line">     forEachNode(doc, <span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">"title"</span> &amp;&amp;</span><br><span class="line">        n.FirstChild != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> title != <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(bailout&#123;&#125;) <span class="comment">// multiple titleelements</span></span><br><span class="line">        &#125;</span><br><span class="line">        title = n.FirstChild.Data</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="literal">nil</span>)</span><br><span class="line">     <span class="keyword">if</span> title == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"no title element"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> title, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="0x02、方法"><a href="#0x02、方法" class="headerlink" title="0x02、方法"></a>0x02、方法</h2><ul><li><p>一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p></li><li><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</p></li><li><p>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// "5", function call</span></span><br><span class="line">fmt.Println(p.Distance(q)) <span class="comment">// "5", method call</span></span><br></pre></td></tr></table></figure></li><li><p>这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义</p></li><li><p>在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型(译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型)不是指针或者interface。</p></li><li><p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gopl.io/ch6/geometry"</span></span><br><span class="line">perim := geometry.Path&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">fmt.Println(geometry.PathDistance(perim)) <span class="comment">// "12", standalone function</span></span><br><span class="line">fmt.Println(perim.Distance()) <span class="comment">// "12", method of geometry.Path</span></span><br></pre></td></tr></table></figure></li><li><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>这个方法的名字是(Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为(Point.ScaleBy)。</p></li><li><p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已</p></li><li><p>只有类型(Point)和指向他们的指针(*Point)，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P)</span> <span class="title">f</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure></li><li><p>想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针即可，像下面这样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// "&#123;2, 4&#125;"</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure></li><li><p>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p></li></ul><h2 id="0x03、接口"><a href="#0x03、接口" class="headerlink" title="0x03、接口"></a>0x03、接口</h2><ul><li><p>一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p></li><li><p>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p></li><li><p>fmt.Printf，它会把结果写到标准输出，和fmt.Sprintf，它会把结果以字符串的形式返回。这两个函数都使用了另一个函数fmt.Fprintf来进行封装，fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。Fprintf函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值</p></li><li><p>因为fmt.Fprintf函数没有对具体操作的值做任何假设，而是仅仅通过io.Writer接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足io.Writer接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。</p></li><li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多实现的接口可以赋值给少实现的接口;但是反过来就不行</span></span><br><span class="line">w = rwc <span class="comment">// OK: io.ReadWriteCloser has Write method</span></span><br><span class="line">rwc = w <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure></li><li><p>抽象对于go来说是非常适合的，只有抽象的恰当，才是好语言。go的接口抽象的非常好。</p></li><li><p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p></li><li><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p></li><li><p>在进行框架该进行，go的接口抽象特别重要</p></li><li><p>你可以使用导出机制(§6.6)来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p></li><li><p>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</p></li><li><p>interface是一组method的组合，我们通过interface来定义对象的一组行为。</p></li><li><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口</p></li><li><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p></li><li><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。</p></li><li><p>反射就是能检查程序在运行时的状态</p></li><li><p>接口相当于是一份契约，它规定了一个对象所能提供的一组操作</p></li></ul><h2 id="0x04、并发"><a href="#0x04、并发" class="headerlink" title="0x04、并发"></a>0x04、并发</h2><ul><li><p>两种手段来实现，goroutine和channe</p></li><li><p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f() <span class="comment">// call f(); wait for it to return</span></span><br><span class="line"><span class="keyword">go</span> f() <span class="comment">// create a new goroutine that calls f(); don't wait</span></span><br></pre></td></tr></table></figure></li><li><p>主函数返回时，所有的goroutine都会被直接打断，程序退出</p></li><li><p>除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</p></li><li><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure></li><li><p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用&lt;-运算符。在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure></li><li><p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">\\ 使用内置的<span class="built_in">close</span>函数就可以关闭一个channel：</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure></li><li><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure></li><li><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作</p></li></ul><ol><li>在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</li><li>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</li></ol><ul><li><p>首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done &lt;- 1语句也比done &lt;- struct{}{}更短。</p></li><li><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; ; x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := &lt;-naturals</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类型chan&lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。</p></li><li><p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">        out &lt;- x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// "3"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// "2" 有效元素数</span></span><br></pre></td></tr></table></figure></li><li><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p></li><li><p>Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了</p></li><li><p>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p></li><li><p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</p></li><li><p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p></li><li><p>一个只能为1和0的信号量叫做二元信号量(binary semaphore)。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python常用库</title>
      <link href="/man/python/lib.html"/>
      <url>/man/python/lib.html</url>
      
        <content type="html"><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.random()</span><br><span class="line"></span><br><span class="line">random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">random.uniform(<span class="number">2.5</span>, <span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line">random.choice()</span><br><span class="line"></span><br><span class="line">random.shuffle()</span><br></pre></td></tr></table></figure><h2 id="常用库"><a href="#常用库" class="headerlink" title="常用库"></a>常用库</h2><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://requests.readthedocs.io/en/master/" target="_blank" rel="noopener">requests</a></li></ul><h3 id="web开发"><a href="#web开发" class="headerlink" title="web开发"></a>web开发</h3><ul><li><a href="https://docs.djangoproject.com/en/3.0/" target="_blank" rel="noopener">django</a></li><li><a href="https://palletsprojects.com/p/flask/" target="_blank" rel="noopener">flask</a></li><li><a href="https://www.tornadoweb.org/en/stable/" target="_blank" rel="noopener">torando</a></li><li><a href="https://gunicorn.org/" target="_blank" rel="noopener">gunicorn</a>-Gunicorn ‘Green Unicorn’ is a Python WSGI HTTP Server for UNIX<h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3></li><li><a href="https://nameko.readthedocs.io/en/stable/" target="_blank" rel="noopener">nameko</a></li></ul><h3 id="运营"><a href="#运营" class="headerlink" title="运营"></a>运营</h3><ul><li><a href="https://psutil.readthedocs.io/en/latest/" target="_blank" rel="noopener">psutil</a> - 一个跨平台的第三方库，能够轻松实现获取系统运行的进程和系统利用率（包扩CPU、内存、磁盘、网络等）信息。它主要用于系统监控、分析、限制系统资源和进程的管理。</li></ul><h3 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h3><ul><li><a href="https://eventlet.net/" target="_blank" rel="noopener">eventlet</a></li></ul><h3 id="压缩及解压缩"><a href="#压缩及解压缩" class="headerlink" title="压缩及解压缩"></a>压缩及解压缩</h3><ul><li>zipfile</li></ul><h3 id="uuid"><a href="#uuid" class="headerlink" title="uuid"></a>uuid</h3><ul><li><p>几种uuid<br>1、uuid1()——基于时间戳<br>  由MAC地址、当前时间戳、随机数生成。可以保证全球范围内的唯一性，<br>  但MAC的使用同时带来安全性问题，局域网中可以使用IP来代替MAC。<br>2、uuid2()——基于分布式计算环境DCE（Python中没有这个函数）<br>  算法与uuid1相同，不同的是把时间戳的前4位置换为POSIX的UID。<br>  实际中很少用到该方法。<br>3、uuid3()——基于名字的MD5散列值<br>  通过计算名字和命名空间的MD5散列值得到，保证了同一命名空间中不同名字的唯一性，<br>  和不同命名空间的唯一性，但同一命名空间的同一名字生成相同的uuid。<br>4、uuid4()——基于随机数<br>  由伪随机数得到，有一定的重复概率，该概率可以计算出来。<br>5、uuid5()——基于名字的SHA-1散列值<br>  算法与uuid3相同，不同的是使用 Secure Hash Algorithm 1 算法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> uuid</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID based on the host ID and current time</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid1()</span><br><span class="line">UUID(<span class="string">'a8098c1a-f86e-11da-bd1a-00112444be1e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using an MD5 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid3(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'6fa459ea-ee8a-3ca4-894e-db77e160355e'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a random UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line">UUID(<span class="string">'16fd2706-8baf-433b-82eb-8c7fada847da'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID using a SHA-1 hash of a namespace UUID and a name</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid5(uuid.NAMESPACE_DNS, <span class="string">'python.org'</span>)</span><br><span class="line">UUID(<span class="string">'886313e1-3b8a-5372-9b90-0c9aee199e5d'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a string of hex digits (braces and hyphens ignored)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = uuid.UUID(<span class="string">'&#123;00010203-0405-0607-0809-0a0b0c0d0e0f&#125;'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># convert a UUID to a string of hex digits in standard form</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>str(x)</span><br><span class="line"><span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># get the raw 16 bytes of the UUID</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.bytes</span><br><span class="line"><span class="string">b'\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0b\x0c\r\x0e\x0f'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="comment"># make a UUID from a 16-byte string</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.UUID(bytes=x.bytes)</span><br><span class="line">UUID(<span class="string">'00010203-0405-0607-0809-0a0b0c0d0e0f'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4()</span><br><span class="line"><span class="string">'36a98670-d9bb-458d-8670-da24e545ca64'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除-</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>uuid.uuid4().hex</span><br><span class="line"><span class="string">'2b15216124ae4476a96bd7707c9e1a34'</span></span><br></pre></td></tr></table></figure></li><li><p>uuid的常用只读方法</p><ul><li>UUID.hex The UUID as a 32-character hexadecimal string</li><li>UUID.int The UUID as a 128-bit integer.</li></ul></li><li><p>生成全局唯一id，可以依据MAC地址、网卡、时间戳、随机数</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python基础</title>
      <link href="/man/python/basic.html"/>
      <url>/man/python/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="1-语言设计原则"><a href="#1-语言设计原则" class="headerlink" title="1.语言设计原则"></a>1.语言设计原则</h3><ul><li>python设计之蝉<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> this</span><br><span class="line">The Zen of Python, by Tim Peters</span><br><span class="line"></span><br><span class="line">Beautiful <span class="keyword">is</span> better than ugly.</span><br><span class="line">Explicit <span class="keyword">is</span> better than implicit.</span><br><span class="line">Simple <span class="keyword">is</span> better than complex.</span><br><span class="line">Complex <span class="keyword">is</span> better than complicated.</span><br><span class="line">Flat <span class="keyword">is</span> better than nested.</span><br><span class="line">Sparse <span class="keyword">is</span> better than dense.</span><br><span class="line">Readability counts.</span><br><span class="line">Special cases aren<span class="string">'t special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you'</span>re Dutch.</span><br><span class="line">Now <span class="keyword">is</span> better than never.</span><br><span class="line">Although never <span class="keyword">is</span> often better than *right* now.</span><br><span class="line">If the implementation <span class="keyword">is</span> hard to explain, it<span class="string">'s a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let'</span>s do more of those!</span><br></pre></td></tr></table></figure></li></ul><h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><ul><li><a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">官方pep8规范</a></li><li><a href="https://zh-google-styleguide.readthedocs.io/en/latest/google-python-styleguide/python_style_rules/" target="_blank" rel="noopener">google规范文档</a></li></ul><h3 id="注释、文档"><a href="#注释、文档" class="headerlink" title="注释、文档"></a>注释、文档</h3><ul><li>用#号进行单行注释</li><li>文档注释用“”“ ”“”来进行</li></ul><h3 id="关键字有哪些，有什么作用"><a href="#关键字有哪些，有什么作用" class="headerlink" title="关键字有哪些，有什么作用"></a>关键字有哪些，有什么作用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">help&gt; keywords</span><br><span class="line"></span><br><span class="line">Here <span class="keyword">is</span> a list of the Python keywords.  Enter any keyword to get more help.</span><br><span class="line"></span><br><span class="line"><span class="literal">False</span>               <span class="class"><span class="keyword">class</span>               <span class="title">from</span>                <span class="title">or</span></span></span><br><span class="line"><span class="class"><span class="title">None</span>                <span class="title">continue</span>            <span class="title">global</span>              <span class="title">pass</span></span></span><br><span class="line"><span class="class"><span class="title">True</span>                <span class="title">def</span>                 <span class="title">if</span>                  <span class="title">raise</span></span></span><br><span class="line"><span class="class"><span class="title">and</span>                 <span class="title">del</span>                 <span class="title">import</span>              <span class="title">return</span></span></span><br><span class="line"><span class="class"><span class="title">as</span>                  <span class="title">elif</span>                <span class="title">in</span>                  <span class="title">try</span></span></span><br><span class="line"><span class="class"><span class="title">assert</span>              <span class="title">else</span>                <span class="title">is</span>                  <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">async</span>               <span class="title">except</span>              <span class="title">lambda</span>              <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">await</span>               <span class="title">finally</span>             <span class="title">nonlocal</span>            <span class="title">yield</span></span></span><br><span class="line"><span class="class"><span class="title">break</span>               <span class="title">for</span>                 <span class="title">not</span></span></span><br></pre></td></tr></table></figure><h3 id="关键字赋值"><a href="#关键字赋值" class="headerlink" title="关键字赋值"></a>关键字赋值</h3><ul><li><p>关键字不可以赋值，会报<code>invalid syntax</code>错误</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">if</span>=<span class="number">123</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>=<span class="number">123</span></span><br><span class="line">      ^</span><br><span class="line">SyntaxError: invalid syntax</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span>=<span class="string">'abc'</span></span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span>=<span class="string">'abc'</span></span><br><span class="line">         ^</span><br><span class="line">SyntaxError: invalid syntax</span><br></pre></td></tr></table></figure></li><li><p>但是内部的函数名是可以当作变量来赋值的，但是这样的话，就不能当作内部函数来使用了。只有把这个变量删除，然后才能正常使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id=<span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(id)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">'int'</span> object <span class="keyword">is</span> <span class="keyword">not</span> callable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(type(id))</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">int</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">del</span> <span class="title">id</span></span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">id</span></span></span><br><span class="line"><span class="class">&lt;<span class="title">built</span>-<span class="title">in</span> <span class="title">function</span> <span class="title">id</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="基础数据类型"><a href="#基础数据类型" class="headerlink" title="基础数据类型"></a>基础数据类型</h3><ul><li>Numbers（数字）<ul><li>int（有符号整型）</li><li>long（长整型[也可以代表八进制和十六进制]）</li><li>float（浮点型）</li><li>complex（复数）</li><li>小整数对象——小整型对象池<ul><li>在实际编程中，数值比较小的整数，比如1,2,29等，可能会非常频繁的出现。而在python中，所有的对象都存在于系统堆上。想想？如果某个小整数出现的次数非常多，那么Python将会出现大量的malloc/free操作，这样大大降低了运行效率，而且会造成大量的内存碎片，严重影响Python的整体性能。</li></ul></li></ul></li><li>String（字符串）</li><li>List（列表）</li><li>Tuple（元组）</li><li>Dictionary（字典）</li></ul><h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul><li>一共有四种<ul><li>L （Local） 局部作用域</li><li>E （Enclosing） 闭包函数外的函数中</li><li>G （Global） 全局作用域</li><li>B （Built-in） 内建作用域</li></ul></li><li>以 L –&gt; E –&gt; G –&gt;B 的规则查找，即：在局部找不到，便会去局部外的局部找（例如闭包），再找不到就会去全局找，再者去内建中找</li><li>除了def/class/lambda 外，其他如: if/elif/else/ try/except for/while并不能改变其作用域。定义在他们之内的变量，外部还是可以访问。</li><li>在 def/class/lambda内进行赋值，就变成了其局部的作用域，局部作用域会覆盖全局作用域，但不会影响全局作用域</li><li>闭包的定义：如果在一个内部函数里，对在外部函数内（但不是在全局作用域）的变量进行引用，那么内部函数就被认为是闭包(closure)</li><li>global 和 globals() 是不同的，global 是关键字用来声明一个局部变量为全局变量。globals() 和 locals() 提供了基于字典的访问全局和局部变量的方式</li></ul><h3 id="普通打印"><a href="#普通打印" class="headerlink" title="普通打印"></a>普通打印</h3><ul><li>数字、字符串、函数、类、结构体、枚举值、关键字、未定义值</li><li>多个变量同时打印</li><li>换行打印，同行打印</li><li>以不同的结尾符打印<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">123</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">'aaa'</span>)</span><br><span class="line">aaa</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="number">123</span>,<span class="number">456</span>)</span><br><span class="line"><span class="number">123</span> <span class="number">456</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"abc"</span>,<span class="number">123</span>)</span><br><span class="line">abc <span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="keyword">print</span>)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="keyword">print</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dir)</span><br><span class="line">&lt;built-<span class="keyword">in</span> function dir&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(print())</span><br><span class="line"></span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(dir())</span><br><span class="line">[<span class="string">'__annotations__'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__loader__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'__spec__'</span>]</span><br></pre></td></tr></table></figure></li></ul><h3 id="结构化打印"><a href="#结构化打印" class="headerlink" title="结构化打印"></a>结构化打印</h3><ul><li>把数据按照可读的方式打印出来<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> pprint</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(&#123;<span class="string">'a'</span>:<span class="number">123</span>,<span class="string">'b'</span>:[<span class="string">'abc'</span>,<span class="string">'def'</span>],<span class="string">'c'</span>:&#123;<span class="string">'x'</span>:<span class="number">456</span>,<span class="string">'y'</span>:<span class="number">789</span>&#125;&#125;,width=<span class="number">30</span>)</span><br><span class="line">&#123;<span class="string">'a'</span>: <span class="number">123</span>,</span><br><span class="line"> <span class="string">'b'</span>: [<span class="string">'abc'</span>, <span class="string">'def'</span>],</span><br><span class="line"> <span class="string">'c'</span>: &#123;<span class="string">'x'</span>: <span class="number">456</span>, <span class="string">'y'</span>: <span class="number">789</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="如何区别可变数据类型和不可变数据类型"><a href="#如何区别可变数据类型和不可变数据类型" class="headerlink" title="如何区别可变数据类型和不可变数据类型"></a>如何区别可变数据类型和不可变数据类型</h3><ul><li>数字、字符串、元组是不可变的<ul><li>对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象</li><li>对于不可变类型int，无论创建多少个不可变类型，只要值相同，都指向同个内存地址。同样情况的还有比较短的字符串。</li></ul></li><li>列表、字典是可变的<ul><li>以list为例。list在append之后，还是指向同个内存地址，因为list是可变类型，可以在原处修改。</li><li>当存在多个值相同的不可变类型变量时，看看它们是不是跟可变类型一样指向同个内存地址</li></ul></li></ul><h3 id="如何判断变量是否相等"><a href="#如何判断变量是否相等" class="headerlink" title="如何判断变量是否相等"></a>如何判断变量是否相等</h3><ul><li>is:比较对象地址是否相同</li><li>== 用来判断两个对象的值是否相等</li></ul><h3 id="变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？"><a href="#变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？" class="headerlink" title="变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？"></a>变量重新赋值给另一个变量，原变量如何？修改新赋值的变量，原变量又如何？修改原变量，新变量如何？</h3><ul><li>python的变量可以分为基本类型和集合类型<ul><li>基本类型为：int、float、bool、str</li><li>集合类型为：set、list、dict</li></ul></li><li>基本类型在进行赋值为同一个值时，其指向的内存是一样的<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">12345678</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473808</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==b</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c</span><br><span class="line"><span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">87654321</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473936</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4430473104</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=<span class="number">12345678</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(c)</span><br><span class="line"><span class="number">4430473904</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c=a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c==a</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>c <span class="keyword">is</span> a</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b=<span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(a)</span><br><span class="line"><span class="number">4376446368</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>id(b)</span><br><span class="line"><span class="number">4376446400</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 字符串</span></span><br><span class="line"></span><br><span class="line">* 常用操作</span><br><span class="line">```python</span><br><span class="line">site = <span class="string">"www.abc.com"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有字符中的小写字母转换成大写字母</span></span><br><span class="line">print(site.upper())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有字符中的大写字母转换成小写字母</span></span><br><span class="line">print(site.lower())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把第一个字母转化为大写字母，其余小写</span></span><br><span class="line">print(site.capitalize())</span><br><span class="line"></span><br><span class="line"><span class="comment">#  把每个单词的第一个字母转化为大写，其余小写</span></span><br><span class="line">print(site.title())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除空格</span></span><br><span class="line">print(site.strip())</span><br><span class="line"></span><br><span class="line"><span class="comment"># 截取。开头包含，结尾不包含</span></span><br><span class="line">print(site[<span class="number">5</span>:])</span><br><span class="line">print(site[:<span class="number">-3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换</span></span><br><span class="line">print(site.replace(<span class="string">'w'</span>,<span class="string">''</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切割为数组</span></span><br><span class="line">print(site.split(<span class="string">'.'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 是否包含</span></span><br><span class="line">print(<span class="string">'www'</span> <span class="keyword">in</span> site)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以什么开头</span></span><br><span class="line">print(site.startswith(<span class="string">'www'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以什么结尾</span></span><br><span class="line">print(site.endswith(<span class="string">'com'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接</span></span><br><span class="line">print(site+<span class="string">'/s=aaa'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 长度</span></span><br><span class="line">print(len(site))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转</span></span><br><span class="line">print(site[::<span class="number">-1</span>])</span><br><span class="line">print(site[::<span class="number">100</span>]) <span class="comment"># 不会报错，正常打印</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找，返回元素位置.未找到返回-1</span></span><br><span class="line">print(site.find(<span class="string">'w'</span>)) <span class="comment"># 0</span></span><br><span class="line">print(site.find(<span class="string">'.'</span>)) <span class="comment"># 3</span></span><br></pre></td></tr></table></figure><h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><ul><li>声明<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h2><ul><li>定义<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一个元素需要以逗号结尾</span></span><br><span class="line">a = (<span class="number">1</span>,)</span><br><span class="line"><span class="comment"># 包含多个元素</span></span><br><span class="line">b = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 允许重复</span></span><br><span class="line">c = (<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 以逗号结尾的都是tuple</span></span><br><span class="line">d = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br></pre></td></tr></table></figure></li></ul><h2 id="list"><a href="#list" class="headerlink" title="list"></a>list</h2><ul><li><p>常用操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否存在</span></span><br><span class="line">print(<span class="number">1</span> <span class="keyword">in</span> a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第2到5个元素</span></span><br><span class="line">print(a[<span class="number">2</span>:<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印倒数元素</span></span><br><span class="line">print(a[:<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 翻转</span></span><br><span class="line">print(a.reverse()) <span class="comment"># 原地翻转，改变原数组的值</span></span><br><span class="line">print(a[::<span class="number">-1</span>]) <span class="comment"># 返回新的翻转后的值，原数组不变</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组某元素的数量</span></span><br><span class="line">a.count(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含元素个数</span></span><br><span class="line">len(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数组的排序</span></span><br><span class="line">list.sort(keys=)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加</span></span><br><span class="line">a.append(<span class="number">5</span>)</span><br><span class="line">a.extend([<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure></li><li><p>取差集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>]</span><br><span class="line">print(list(set(a).difference(set(b))))</span><br></pre></td></tr></table></figure></li></ul><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><ul><li><p>dict</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">a = dict()</span><br><span class="line">a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">a[<span class="string">'k'</span>] = <span class="string">'v'</span></span><br><span class="line">a.update(&#123;<span class="string">'k'</span>:<span class="string">'v'</span>&#125;) <span class="comment"># 没有返回值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### 条件判断有哪些</span></span><br><span class="line">* <span class="keyword">if</span></span><br><span class="line">* <span class="keyword">elif</span></span><br><span class="line">* <span class="keyword">else</span></span><br><span class="line">* <span class="keyword">and</span> <span class="keyword">or</span> <span class="keyword">not</span></span><br><span class="line">* || &amp;&amp;</span><br><span class="line">* 条件优先级</span><br><span class="line">    * <span class="keyword">not</span> &gt; <span class="keyword">and</span> &gt; <span class="keyword">or</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 循环遍历有哪些？各有什么好用处？循环遍历时如何改变遍历对象的值</span></span><br><span class="line">* <span class="keyword">for</span></span><br><span class="line">```python</span><br><span class="line"><span class="comment"># 遍历range</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(a)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历数组</span></span><br><span class="line">rows = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> rows:</span><br><span class="line">    print(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历对象</span></span><br><span class="line">dict_rows = &#123;<span class="string">'a'</span>:<span class="number">1</span>,<span class="string">'b'</span>:<span class="number">2</span>,<span class="string">'c'</span>:<span class="number">3</span>,<span class="string">'d'</span>:<span class="number">4</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> dict_rows.items():</span><br><span class="line">    print(k,v)</span><br></pre></td></tr></table></figure></li><li><p>while</p></li></ul><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul><li>round<ul><li>保留几位小数<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">round(<span class="number">1.245</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 1.24</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="操作符可否重载？哪些情况可以重载？为什么要有重载？"><a href="#操作符可否重载？哪些情况可以重载？为什么要有重载？" class="headerlink" title="操作符可否重载？哪些情况可以重载？为什么要有重载？"></a>操作符可否重载？哪些情况可以重载？为什么要有重载？</h3><ul><li>运算符重载就是通过重写这些Python内置魔法方法实现的。这些魔法方法都是以双下划线开头和结尾的，类似于<strong>X</strong>的形式，python通过这种特殊的命名方式来拦截操作符，以实现重载。当Python的内置操作运用于类对象时，Python会去搜索并调用对象中指定的方法完成操作。</li></ul><table><thead><tr><th>方法</th><th>重载</th><th>调用</th></tr></thead><tbody><tr><td><code>__init__</code></td><td>构造函数</td><td>对象建立：X = Class(args)</td></tr><tr><td><code>__del__</code></td><td>析构函数</td><td>X对象收回</td></tr><tr><td><code>__add__</code></td><td>运算符+</td><td>如果没有<em>iadd</em>,X+Y,X+=Y</td></tr><tr><td><code>__or__</code></td><td>运算符</td><td>(位OR)</td></tr><tr><td><code>__repr__,__str__</code></td><td>打印、转换</td><td>print（X）、repr(X),str(X)</td></tr><tr><td><code>__call__</code></td><td>函数调用</td><td>X(*args,**kargs)</td></tr><tr><td><code>__getattr__</code></td><td>点号运算</td><td>X.undefined</td></tr><tr><td><code>__setattr__</code></td><td>属性赋值语句</td><td>X.any = value</td></tr><tr><td><code>__delattr__</code></td><td>属性删除</td><td>del X.any</td></tr><tr><td><code>__getattribute__</code></td><td>属性获取</td><td>X.any</td></tr><tr><td><code>__getitem__</code></td><td>索引运算</td><td>X[key],X[i:j],没<strong>iter</strong>时的for循环和其他迭代器</td></tr><tr><td><code>__setitem__</code></td><td>索引赋值语句</td><td>X[key] = value,X[i:j] = sequence</td></tr><tr><td><code>__delitem__</code></td><td>索引和分片删除</td><td>del X[key],del X[i:j]</td></tr><tr><td><code>__len__</code></td><td>长度</td><td>len(X),如果没有<strong>bool</strong>,真值测试</td></tr><tr><td><code>__bool__</code></td><td>布尔测试</td><td>bool(X),真测试</td></tr><tr><td><code>__lt__,__gt__</code></td><td>特定的比较</td><td>X &lt; Y,X &gt; Y</td></tr><tr><td><code>__le__,__ge__</code></td><td></td><td>X&lt;=Y,X &gt;= Y</td></tr><tr><td><code>__eq__,__ne__</code></td><td></td><td>X == Y,X != Y</td></tr><tr><td><code>__radd__</code></td><td>右侧加法</td><td>Other+X</td></tr><tr><td><code>__iadd__</code></td><td>实地（增强的）加法</td><td>X += Y （or else __add__）</td></tr><tr><td><code>__iter__,__next__</code></td><td>迭代环境</td><td>I = iter(X),next(I)</td></tr><tr><td><code>__contains__</code></td><td>成员关系测试</td><td>item in X （任何可迭代的）</td></tr><tr><td><code>__index__</code></td><td>整数值</td><td>hex(X),bin(X),oct(X),O[X],O[X:]</td></tr><tr><td><code>__enter__,__exit__</code></td><td>环境管理器</td><td>with obj as var:</td></tr><tr><td><code>__get__,__set__</code></td><td>描述符属性</td><td>X.attr,X.attr = value,del X.attr</td></tr><tr><td><code>__new__</code></td><td>创建</td><td>在<strong>init</strong>之前创建对象</td></tr></tbody></table><ul><li>构造函数和析构函数：<code>__init__</code>和<code>__del__</code><ul><li>主要作用是进行对象的创建和回收，当实例创建时，就会调用<strong>init</strong>构造方法。当实例对象被收回时，析构函数<strong>del</strong>会自动执行</li></ul></li><li>加减运算：<code>__add__</code>、<code>__sub__</code>、<code>__mul__</code>、<code>__truediv__</code>、<code>__mod__</code>、<code>__pow__</code><ul><li>重载这四个方法就可以在普通的对象上添加＋－ * / 求余 乘方运算符操作</li></ul></li><li>对象的字符串表达形式：<code>__repr__</code>和<code>__str__</code><ul><li>这两个方法都是用来表示对象的字符串表达形式：print()、str()方法会调用到<strong>str</strong>方法，print()、str()和repr()方法会调用<code>__repr__</code>方法</li></ul></li><li>索引取值和赋值：<code>__getitem__</code>,<code>__setitem__</code><ul><li>通过实现这两个方法，可以通过诸如 X[i] 的形式对对象进行取值和赋值，还可以对对象使用切片操作</li></ul></li><li>设置和访问属性：<code>__getattr__</code>、<code>__setattr__</code><ul><li>通过重载<strong>getattr</strong>和<strong>setattr</strong>来拦截对对象成员的访问。<strong>getattr</strong>在访问对象中不存在的成员时会自动调用。<strong>setattr</strong>方法用于在初始化对象成员的时候调用，即在设置<strong>dict</strong>的item时就会调用<strong>setattr</strong>方法</li></ul></li><li>迭代器对象: <code>__iter__</code>, <code>__next__</code><ul><li>迭代，可以直接通过重载<strong>getitem</strong>方法来实现</li><li>Python的迭代操作会优先尝试调用<code>__iter_</code>_方法，再尝试<code>__getitem__</code>。迭代环境是通过iter去尝试寻找<code>__iter__</code>方法来实现，而这种方法返回一个迭代器对象。如果这个方法已经提供，Python会重复调用迭代器对象的next()方法，直到发生StopIteration异常。如果没有找到<code>__iter__</code>，Python才会尝试使用<code>__getitem__</code>机制</li><li>可见实现了<code>__iter__</code>和<code>__next__</code>方法后，可以通过for in的方式迭代遍历对象，也可以通过iter()和next()方法迭代遍历对象。<ul><li><a href="https://github.com/11dimension/SukieTalk/issues/9" target="_blank" rel="noopener">python运算符重载</a></li><li><a href="https://blog.csdn.net/gavin_john/article/details/50717695" target="_blank" rel="noopener">Python——运算符重载(1)</a></li><li><a href="https://blog.csdn.net/gavin_john/article/details/50725572" target="_blank" rel="noopener">Python——运算符重载(2)</a></li></ul></li></ul></li></ul><h3 id="是否有深浅拷贝，都是做什么的，适用场景是什么？"><a href="#是否有深浅拷贝，都是做什么的，适用场景是什么？" class="headerlink" title="是否有深浅拷贝，都是做什么的，适用场景是什么？"></a>是否有深浅拷贝，都是做什么的，适用场景是什么？</h3><ul><li>浅拷贝：不管多么复杂的数据结构，只copy对象最外层本身，该对象引用的其他对象不copy， 内存里两个变量的地址是一样的，一个改变另一个也改变。</li><li>深拷贝：完全复制原变量的所有数据，内存中生成一套完全一样的内容；只是值一样，内存地址不一样，一方修改另一方不受影响</li><li><a href="https://www.cnblogs.com/eva-j/p/5534037.html" target="_blank" rel="noopener">python——赋值与深浅拷贝</a></li></ul><h3 id="查看所有已定义的变量"><a href="#查看所有已定义的变量" class="headerlink" title="查看所有已定义的变量"></a>查看所有已定义的变量</h3><ul><li>locals()方法可以查看截止当前定义的变量、导入的包</li><li>globals()</li><li>vars()</li><li>dir()</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>《深入分布式缓存:从原理到实践》读书笔记</title>
      <link href="/books/deep-analysis-distributed-cache.html"/>
      <url>/books/deep-analysis-distributed-cache.html</url>
      
        <content type="html"><![CDATA[<h2 id="第1章-缓存为王"><a href="#第1章-缓存为王" class="headerlink" title="第1章 缓存为王"></a>第1章 缓存为王</h2><h3 id="1-1-什么是缓存？"><a href="#1-1-什么是缓存？" class="headerlink" title="1.1 什么是缓存？"></a>1.1 什么是缓存？</h3><p>我们平时在编程的时候，接触到的都是虚拟地址而不是真实的物理地址，这是虚拟内存的主要功能之一。假如请求一个页的地址，需要将页的虚拟地址转化为页的物理地址。页表（pagetable）和内存管理单元（MMU）就负责将页的虚拟地址映射到物理地址。页表负责记录哪些是物理页，哪些是虚拟页，以及这些页的页表条目（PTE）。而MMU是一个物理硬件，MMU负责进行虚拟地址到物理地址的翻译，翻译过程中需要从页表获取页的PTE, MMU也会使用翻译后备缓存器（TLB）的缓存页号。可见，在操作系统层面都有缓存。</p><ul><li>根据在软件系统中所处位置的不同，缓存大体可以分为三类：<ul><li>客户端缓存；</li><li>服务端缓存；</li><li>网络中的缓存。</li></ul></li><li>根据规模和部署方式缓存也可以分为：<ul><li>单体缓存；</li><li>缓存集群；</li><li>分布式缓存。</li></ul></li></ul><h3 id="1-2-为什么使用缓存？"><a href="#1-2-为什么使用缓存？" class="headerlink" title="1.2 为什么使用缓存？"></a>1.2 为什么使用缓存？</h3><blockquote><p> 关于系统的性能</p></blockquote><ul><li>系统性能的指标一般包括响应时间、延迟时间、吞吐量，并发用户数和资源利用率等几个方面。<ul><li>响应时间是指系统对用户请求做出响应的时间</li><li>吞吐量是指系统在单位时间内处理请求的数量。</li><li>并发用户数是指系统可以同时承载的正常使用系统功能的用户数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。而资源利用率反映的是在一段时间内资源平均被占用的情况。</li></ul></li></ul><p>从浏览器到网络，再到应用服务器，甚至到数据库，通过在各个层面应用缓存技术，整个系统的性能将大幅提高</p><p>使用缓存技术，可以降低系统的响应时间，减少网络传输时间和应用延迟时间，进而提高了系统的吞吐量，增加了系统的并发用户数。</p><h3 id="1-3-从网站的架构发展看缓存"><a href="#1-3-从网站的架构发展看缓存" class="headerlink" title="1.3 从网站的架构发展看缓存"></a>1.3 从网站的架构发展看缓存</h3><p><img data-src="assets/img/dadc/web-architecture.png" alt="架构图"></p><h3 id="1-4-客户端缓存"><a href="#1-4-客户端缓存" class="headerlink" title="1.4 客户端缓存"></a>1.4 客户端缓存</h3><h4 id="1-4-1-页面缓存"><a href="#1-4-1-页面缓存" class="headerlink" title="1.4.1 页面缓存"></a>1.4.1 页面缓存</h4><p>页面缓存有两层含义：一个是页面自身对某些元素或全部元素进行缓存；另一层意思是服务端将静态页面或动态页面的元素进行缓存，然后给客户端使用。</p><p>HTML5中使用本地缓存的方法也很简单，示例代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">localStorage.setItem()</span><br><span class="line">localStorage.getItem()</span><br></pre></td></tr></table></figure><p>HTML5提供的离线应用缓存机制，使得网页应用可以离线使用，这种机制在浏览器上支持度非常广，可以放心地使用该特性来加速页面的访问。开启离线缓存的步骤如下：</p><ul><li>1）准备用于描述页面需要缓存的资源列表清单文件（manifest text/cache-manifest）。</li><li>2）在需要离线使用的页面中添加manifest属性，指定缓存清单文件的路径。</li></ul><h4 id="1-4-2-浏览器缓存"><a href="#1-4-2-浏览器缓存" class="headerlink" title="1.4.2 浏览器缓存"></a>1.4.2 浏览器缓存</h4><p>浏览器缓存是根据一套与服务器约定的规则进行工作的，工作规则很简单：检查以确保副本是最新的，通常只要一次会话。</p><p>HTTP1.0提供了一些很基本的缓存特性。服务器侧设置Expires的HTTP头来告诉客户端在重新请求文件之前缓存多久是安全的，可以通过if-modified-since的条件请求来使用缓存。其中，发送的时间是文件最初被下载的时间，而不是即将过期的时间，如果文件没有改变，服务器可以用304-Not Modified来应答。客户端收到304代码，就可以使用缓存的文件版本了。</p><p>HTTP 1.1有了较大的增强，缓存系统被形式化了，引入了实体标签e-tag。e-tag是文件或对象的唯一标识，这意味着可以请求一个资源，以及提供所持有的文件，然后询问服务器这个文件是否有变化。如果某一个文件的e-tag是有效的，那么服务器会生成304-Not Modified应答，并提供正确文件的e-tag，否则，发送200-OK应答</p><p>Last-Modified/ETag与Cache-Control/Expires的作用是不一样的，如果检测到本地的缓存还在有效的时间范围内，浏览器则直接使用本地缓存，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（e-tag）了。</p><p>Cache-Control与Expires的功能一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p><p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间，当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用服务端的返回码304，从而减少响应开销。</p><h4 id="1-4-3-APP上的缓存"><a href="#1-4-3-APP上的缓存" class="headerlink" title="1.4.3 APP上的缓存"></a>1.4.3 APP上的缓存</h4><p>APP可以将内容缓存在内存、文件或本地数据库（例如SQLite）中，但基于内存的缓存要谨慎使用。</p><h3 id="1-5-网络中的缓存"><a href="#1-5-网络中的缓存" class="headerlink" title="1.5 网络中的缓存"></a>1.5 网络中的缓存</h3><p>网络中的缓存位于客户端和服务端之间，代理或响应客户端的网络请求，从而对重复的请求返回缓存中的数据资源。同时，接受服务端的请求，更新缓存中的内容。</p><h4 id="1-5-1-Web代理缓存"><a href="#1-5-1-Web代理缓存" class="headerlink" title="1.5.1 Web代理缓存"></a>1.5.1 Web代理缓存</h4><p>Web代理几乎是伴随着互联网诞生的，常用的Web代理分为正向代理、反向代理和透明代理。Web代理缓存是将Web代理作为缓存的一种技术。</p><p>反向代理与正向代理相反，对于客户端而言代理服务器就像是源服务器，并且客户端不需要进行设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处转发请求，并将从源服务器获得的内容返回给客户端。</p><p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，由代理服务器改变客户端请求的报文字段，并会传送真实的IP地址。<br>加密的透明代理属于匿名代理，不用设置就可以使用代理了。透明代理的例子就是时下很多公司使用的行为管理软件。</p><p>对于Web代理缓存而言，较流行的是Squid，它支持建立复杂的缓存层级结构，拥有详细的日志、高性能缓存以及用户认证支持</p><h4 id="1-5-2-边缘缓存"><a href="#1-5-2-边缘缓存" class="headerlink" title="1.5.2 边缘缓存"></a>1.5.2 边缘缓存</h4><p>如果这些反向代理服务器能够做到和用户来自同一个网络，那么用户访问反向代理服务器，就会得到很高质量的响应速度，所以可以将这样的反向代理缓存称为边缘缓存。</p><p>边缘缓存在网络上位于靠近用户的一侧，可以处理来自不同用户的请求，主要用于向用户提供静态的内容，以减少应用服务器的介入</p><p>边缘缓存中典型的商业化服务就是CDN了</p><p>CDN边缘节点的缓存策略因服务商不同而有所变化，但一般都会遵循HTTP标准协议，通过HTTP响应头中的Cache-control: max-age的字段来设置CDN边缘节点的数据缓存时间</p><p>一般地，CDN边缘节点对开发者来说是透明的，开发者可以通过CDN服务商提供的“刷新缓存”接口来清理位于CDN边缘节点上的缓存数据</p><h3 id="1-6-服务端缓存"><a href="#1-6-服务端缓存" class="headerlink" title="1.6 服务端缓存"></a>1.6 服务端缓存</h3><h4 id="1-6-1-数据库缓存"><a href="#1-6-1-数据库缓存" class="headerlink" title="1.6.1 数据库缓存"></a>1.6.1 数据库缓存</h4><p>数据库缓存是一类特殊的缓存，是数据库自身的缓存机制。</p><p>大多数数据库不需要配置就可以快速运行，但并没有为特定的需求进行优化。在数据库调优的时候，缓存优化是一项很重要的工作。</p><blockquote><ol><li>MySQL的查询缓存</li></ol></blockquote><p>Query cache作用于整个MySQL实例，主要用于缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。</p><ul><li>Query Cache的使用需要多个参数配合，其中最为关键的是query_cache_size和query_cache_type，前者设置用于缓存ResultSet的内存大小，后者设置在何种场景下使用Query Cache。这可以通过计算Query Cache的命中率来进行调整。query_cache_type可以设置为0（OFF）,1（ON）或者2（DEMAND），分别表示完全不使用Query Cache，除显式要求不使用Query Cache之外的所有select都使用Query Cache，以及只有显式要求才使用Query Cache。</li></ul><blockquote><p>2．检验Query Cache的合理性</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query_cache%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure><p>通过调节以下几个参数可以知道query_cache_size设置得是否合理：</p><ul><li>Qcache inserts</li><li>Qcache hits<ul><li>如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；</li></ul></li><li>Qcache lowmem prunes<ul><li>如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况</li></ul></li><li>Qcache free blocks<ul><li>Qcache_free_blocks值非常大，则表明缓存区中的碎片很多，可能需要寻找合适的机会进行整理。</li></ul></li></ul><p>其中Qcache_hits表示多少次命中，通过这个参数我们可以查看到Query Cache的基本效果；而Qcache_inserts表示多少次未命中然后插入。通过“Qcache_hits”和“Qcache_inserts”两个参数可以算出Query Cache的命中率：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Query Cache 命中率=Qcache_hits/(Qcache_hits + Qcache_inserts)</span><br></pre></td></tr></table></figure><p>Qcache_lowmem_prunes表示多少条Query因为内存不足而被清除出Query Cache。通过Qcache_lowmem_prunes和Qcache_free_memory相互结合，能够更清楚地了解到系统中Query Cache的内存大小是否真的足够，是否频繁的出现因为内存不足而有Query被换出的情况。</p><blockquote><ol start="3"><li>InnoDB的缓存性能</li></ol></blockquote><p>当使用InnoDB存储引擎的时候，innodb_buffer_pool_size参数可能是影响性能的最为关键的一个参数了，用来设置用于缓存InnoDB索引及数据块的内存区域大小，更像是Oracle数据库的db_cache_size</p><p>可以通过<code>(Innodb_buffer_pool_read_requests - Innodb_buffer_pool_reads) /Innodb_buffer_pool_read_requests*100%</code>计算缓存命中率，并根据命中率来调整<code>innodb_buffer_pool_size</code>参数大小进行优化</p><p>table_cache是一个非常重要的MySQL性能参数，主要用于设置table高速缓存的数量。由于每个客户端连接都会至少访问一个表，因此该参数与max_connections有关。</p><p>在执行缓存操作之前，table_cache参数用于限制缓存表的最大数目：如果当前已经缓存的表未达到table_cache数目，则会将新表添加进来；若已经达到此值，MySQL将根据缓存表的最后查询时间、查询率等规则释放之前的缓存。</p><h4 id="1-6-2-平台级缓存"><a href="#1-6-2-平台级缓存" class="headerlink" title="1.6.2 平台级缓存"></a>1.6.2 平台级缓存</h4><p>平台级缓存在这里指的是用来写带有缓存特性的应用框架，或者可用于缓存功能的专用库（如PHP中的Smarty模板库）。</p><p>在Java语言中，缓存框架更多，例如Ehcache, Cacheonix, Voldemort, JBoss Cache,OSCache等等。</p><h4 id="1-6-3-应用级缓存"><a href="#1-6-3-应用级缓存" class="headerlink" title="1.6.3 应用级缓存"></a>1.6.3 应用级缓存</h4><p>应用级缓存，需要开发者通过代码来实现缓存机制。这里是NoSQL的胜场，不论是Redis还是MongoDB，以及Memcached都可以作为应用级缓存的重要技术。一种典型的方式是每分钟或一段时间后统一生成某类页面存储在缓存中，或者可以在热数据变化时更新缓存。</p><blockquote><p>1．面向Redis的缓存应用</p></blockquote><p>Redis集群采用无中心节点方式实现，无需proxy代理，客户端直接与Redis集群的每个节点连接，根据同样的哈希算法计算出key对应的slot，然后直接在slot对应的Redis上执行命令。在Redis看来，响应时间是最苛刻的条件，增加一层带来的开销是不能接受的。因此，Redis实现了客户端对节点的直接访问，为了去中心化，节点之间通过Gossip协议交换相互的状态，以及探测新加入的节点信息</p><p>所有的Redis节点通过PING-PONG机制彼此互联，内部使用二进制协议优化传输速度和带宽。节点故障是通过集群中超过半数的节点检测失效时才会生效。</p><blockquote><p>2．多级缓存实例</p></blockquote><p>多级缓存示例<br><img data-src="assets/img/dadc/mulit_level_cache.png" alt="多级缓存"></p><blockquote><p>3．缓存算法</p></blockquote><p>在实现缓存应用的时候，需要了解缓存技术中的几个术语。</p><ul><li>缓存命中：当客户发起一个请求时，系统接收到这个请求，如果该请求的数据是在缓存中，这一数据就会被使用，这一行为叫作缓存命中。</li><li>没有命中：cache miss是没有命中。如果缓存中还有存储空间，那么没有命中的对象会被存储到缓存中来。</li><li>存储成本：当没有缓存命中时，系统会从数据库或其他数据源取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。</li><li>缓存失效：当存储在缓存中的数据需要更新时，就意味着缓存中的这一数据失效了。❑ 替代策略：当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中去除一条旧数据，然后加入一条新数据，而到底应该去除哪些数据，就是由替代策略决定的。</li></ul><p>替代策略的具体实现就是缓存算法，这里简要介绍一下主流的缓存算法：</p><ul><li>（1）Least-Recently-Used（LRU）<ul><li>替换掉最近被请求最少的对象，这种传统策略在实际中应用最广。</li><li>在CPU缓存淘汰和虚拟内存系统中效果很好。然而在直接应用与代理缓存中效果欠佳，因为Web访问的时间局部性常常变化很大。</li><li>浏览器就一般使用了LRU作为缓存算法。新的对象会被放在缓存的顶部，</li></ul></li><li>（2）Least-Frequently-Used（LFU）<ul><li>替换掉访问次数最少的缓存，这一策略意图是保留最常用的、最流行的对象，替换掉很少使用的那些数据。</li></ul></li><li>（3）Least Recently Used 2（LRU2）<ul><li>LRU的变种，把被两次访问过的对象放入缓存池，当缓存池满了之后，会把有两次最少使用的缓存对象去除。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。</li></ul></li><li>（4）Two Queues（2Q）<ul><li>Two Queues是LRU的另一个变种，把被访问的数据放到LRU的缓存中，如果这个对象再一次被访问，就把他转移到第二个、更大的LRU缓存，使用了多级缓存的方式。去除缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把LRU换成LRU2，就比增加缓存的容量更好。</li></ul></li><li>（5）SIZE<ul><li>替换占用空间最大的对象，这一策略通过淘汰一个大对象而不是多个小对象来提高命中率。不过，可能有些进入缓存的小对象永远不会再被访问。SIZE策略没有提供淘汰这类对象的机制，也会导致“缓存污染”。</li></ul></li><li>（6）LRU-Threshold<ul><li>不缓存超过某一size的对象，其他与LRU相同。</li></ul></li><li>（7）Log(Size)+LRU<ul><li>替换size最大的对象，当size相同时，按LRU进行替换。</li></ul></li><li>（8）Hyper-G<ul><li>LFU的改进版，同时考虑上次访问时间和对象size。</li></ul></li><li>（9）Pitkow/Recker<ul><li>替换最近最少使用的对象，除非所有对象都是今天访问过的。如果是这样，则替换掉最大的对象。这一策略试图符合每日访问Web网页的特定模式。这一策略也被建议在每天结束时运行，以释放被“旧的”、最近最少使用的对象占用的空间。</li></ul></li><li>（10）Lowest-Latency-First<ul><li>替换下载时间最少的文档。显然它的目标是最小化平均延迟。</li></ul></li><li>（11）Hybrid Hybrid<ul><li>有一个目标是减少平均延迟。对缓存中的每个文档都会计算一个保留效用，保留效用最低的对象会被替换掉</li></ul></li><li>（12）Lowest Relative Value（LRV）<ul><li>LRV也是基于计算缓存中文档的保留效用，然后替换保留效用最低的文档。</li></ul></li><li>（13）Adaptive Replacement Cache（ARC）<ul><li>ARC介于LRU和LFU之间，为了提高效果，由2个LRU组成，第一个包含的条目是最近只被使用过一次的，而第二个LRU包含的是最近被使用过两次的条目，因此，得到了新的对象和常用的对象。ARC能够自我调节，并且是低负载的。</li></ul></li><li>（14）Most Recently Used（MRU）<ul><li>MRU与LRU是相对，移除最近最多被使用的对象。当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这时会考虑MRU，在数据库内存缓存中比较常见。</li></ul></li><li>（15）First in First out（FIFO）<ul><li>FIFO通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。</li></ul></li><li>（16）Random Cache<ul><li>随机缓存就是随意的替换缓存数据，比FIFO机制好，在某些情况下，甚至比LRU好，但是通常LRU都会比随机缓存更好些。</li></ul></li></ul><blockquote><p>4．使用公有云的缓存服务</p></blockquote><p>基于Redis的云存储服务</p><ul><li>动态扩容</li><li>数据多备</li><li>自动容灾</li><li>成本较低</li></ul><h2 id="第2章-分布式系统理论"><a href="#第2章-分布式系统理论" class="headerlink" title="第2章 分布式系统理论"></a>第2章 分布式系统理论</h2><p>分布式理论体系宏大精深，先从分布式系统理论，比如Paxos、分布式系统设计策略、心跳检测、分布式系统设计实践、全局ID生成几个方面讲。</p><h3 id="2-1-分布式系统概论"><a href="#2-1-分布式系统概论" class="headerlink" title="2.1 分布式系统概论"></a>2.1 分布式系统概论</h3><p>深入地讨论了以下几个方面：</p><ul><li>分布式程序设计语言：基本结构。</li><li>理论基础：全局状态和事件排序；逻辑时钟和物理时钟。</li><li>分布式操作系统：互斥和选举；死锁的检测和解决方法；自稳定；任务调度和负载平衡。</li><li>分布式通信：一对一通信；组（collective）通信。</li><li>可靠性：一致性；错误恢复；可靠通信。</li><li>分布式数据管理：复制数据的一致性；分布式并发控制。</li><li>应用：分布式操作系统；分布式文件系统；分布式数据库系统；分布式共享存储器；异型处理。</li></ul><p>综上所述，分布式系统是一个内涵极度丰富的领域，单就应用层次而言就涉及分布式缓存、分布式存储、分布式文件系统、分布式锁、分布式事务、分布式调度任务、分布式调度计算、分布式消息、分布式采集等等，</p><h3 id="2-2-分布式系统概念"><a href="#2-2-分布式系统概念" class="headerlink" title="2.2 分布式系统概念"></a>2.2 分布式系统概念</h3><h4 id="2-2-1-进程与线程"><a href="#2-2-1-进程与线程" class="headerlink" title="2.2.1 进程与线程"></a>2.2.1 进程与线程</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p><p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><h4 id="2-2-2-并发"><a href="#2-2-2-并发" class="headerlink" title="2.2.2 并发"></a>2.2.2 并发</h4><p>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其他线程处于挂起状态。这种方式我们称之为并发（Concurrent）。</p><p>应用层的并发：定义为单位时间内对于共享资源的访问。</p><h4 id="2-2-3-锁"><a href="#2-2-3-锁" class="headerlink" title="2.2.3 锁"></a>2.2.3 锁</h4><p>锁（lock）作为用于保护临界区（critical section）的一种机制，被广泛应用在多线程程序中</p><p>减少或规避锁争用的几种策略：</p><ul><li>分拆锁；</li><li>分离锁；</li><li>避免共享变量缓存；</li><li>使用并发容器如Amino；</li><li>使用Immutable数据和ThreadLocal中的数据</li></ul><h4 id="2-2-4-并行"><a href="#2-2-4-并行" class="headerlink" title="2.2.4 并行"></a>2.2.4 并行</h4><p>当系统有一个以上的CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p><p>并发与并行的区别</p><ul><li>并行是指两个或者多个事件在同一时刻发生；</li><li>并发是指两个或多个事件在同一时间间隔内发生。</li></ul><h4 id="2-2-5-集群"><a href="#2-2-5-集群" class="headerlink" title="2.2.5 集群"></a>2.2.5 集群</h4><p>集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。</p><p>分布式系统可以表达为很多机器组成的集群，靠彼此之间的网络通信，担当的角色可能不同，共同完成同一件事情的系统</p><p>可以划分为以下几种类型：</p><ul><li>节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器。</li><li>网络：系统的数据传输通道，用来彼此通信。通信是具有方向性的。</li><li>存储：系统中持久化数据的数据库或者文件存储。</li></ul><p>根据典型的集群体系结构，集群中涉及的关键技术可以归属于四个层次：</p><ul><li>网络层：网络互联结构、通信协议、信号技术等。</li><li>节点机及操作系统层高性能客户机、分层或基于微内核的操作系统等。</li><li>集群系统管理层：资源管理、资源调度、负载平衡、并行IPO、安全等。</li><li>应用层：并行程序开发环境、串行应用、并行应用等</li></ul><h4 id="2-2-6-状态特性"><a href="#2-2-6-状态特性" class="headerlink" title="2.2.6 状态特性"></a>2.2.6 状态特性</h4><p>分布式环境中的任何节点（Node）也是无状态的。无状态是指不保存存储状态，则可以随意重启和替代，便于做扩展。</p><h4 id="2-2-7-系统重发与幂等性"><a href="#2-2-7-系统重发与幂等性" class="headerlink" title="2.2.7 系统重发与幂等性"></a>2.2.7 系统重发与幂等性</h4><p>系统重发示例<br><img data-src="assets/img/dadc/net-service-retry.jpeg" alt="系统重发"></p><p>所谓幂等性就是调用1次和调用N次要返回一样的结果。<br>比如一次转账动作，A账户转账1000到B账户，由于网络调用超时，客户端client基于上述保障成功率的原因发起了retry，那么最终应该转账1000还是2000呢，客户的意愿是1000。只需要在设计上加上调用订单号就可以规避这个问题，多次重发，调用的订单号一样，则在服务提供方内部只做一次真实转账动作就行了。</p><h4 id="2-2-8-硬件异常"><a href="#2-2-8-硬件异常" class="headerlink" title="2.2.8 硬件异常"></a>2.2.8 硬件异常</h4><blockquote><p>1．服务器宕机</p></blockquote><p>引发服务器宕机的原因可能是服务器停电、内存错误等等故障，换言之，服务器故障是大概率事件。</p><p>在分布式环境下，采用低廉的PC Server代替高大上的服务器已是常态。我们把宕机时不能提供服务的节点，称为不可用。</p><p>服务器宕机时，节点将丢失所有内部信息，因此设计时需要考虑存储系统的持久化，在重启系统后，可以进行相关存储内容的恢复</p><blockquote><p>2．网络异常</p></blockquote><p>网络异常的原因可能是消息丢失、网络包数据错误。</p><p>设计容错系统的一个方案是，任何消息只有收到对方回复才可以认为发送成功。</p><blockquote><p>3．磁盘故障</p></blockquote><p>在分布式环境中，需要把数据存储在多台服务器，一旦一台出现故障，也能从其他服务器恢复。</p><blockquote><p>4．机房级异常</p></blockquote><p>对容灾而言也有同城灾备和异地机房的做法。当发生机房级异常比如光纤出了问题，异地机房可以继续提供服务</p><h3 id="2-3-分布式系统理论"><a href="#2-3-分布式系统理论" class="headerlink" title="2.3 分布式系统理论"></a>2.3 分布式系统理论</h3><p>CAP理论提出了一致性、可用性、分区容忍性的取舍问题；<br>Paxos、Raft、2PC、3PC分别给出了一致性的解决方案；<br>Lease机制主要针对网络拥塞或瞬断的情况下，出现双主情况的解法；<br>Quorum NWR和MVCC主要解决分布式存储领域的一致性问题；<br>Gossip是一种去中心化、容错而又最终一致性的算法</p><h4 id="2-3-1-CAP理论"><a href="#2-3-1-CAP理论" class="headerlink" title="2.3.1 CAP理论"></a>2.3.1 CAP理论</h4><p>分布式系统的CAP理论：首先将分布式系统中的三个特性进行如下归纳：</p><ul><li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否有同样的值。（等同于所有节点访问同一份最新的数据副本）</li><li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li><li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在一定时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li></ul><blockquote><p>（1）CA without P</p></blockquote><p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。</p><p>CA的系统更多的是允许分区后各子系统依然保持CA。</p><p>典型放弃分区容忍性的例子有关系型数据库、LDAP等。</p><blockquote><p>（2）CP without A</p></blockquote><p>如果不要求A（可用性），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的</p><blockquote><p>（3）AP wihtout C</p></blockquote><p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性</p><p>现在众多的NoSQL都属于此类</p><h4 id="2-3-3-Paxos"><a href="#2-3-3-Paxos" class="headerlink" title="2.3.3 Paxos"></a>2.3.3 Paxos</h4><blockquote><ol><li>Paxos是什么</li></ol></blockquote><p>一言以蔽之，Paxos协议是一个解决分布式系统中，多个节点之间就某个值（提案）达成一致（决议）的通信协议。它能够处理在少数节点离线的情况下，剩余的多数节点仍然能够达成一致。</p><blockquote><ol start="2"><li>Paxos协议简介</li></ol></blockquote><p>Paxos协议是一个两阶段协议，分为Prepare阶段和Accept阶段</p><p>Proposer是提议提案的服务器，而Acceptor是批准提案的服务器。二者在物理上可以是同一台机器。</p><ul><li>Prepare阶段（1）Prepare阶段1:Proposer发送Prepare</li></ul><h4 id="2-3-4-2PC"><a href="#2-3-4-2PC" class="headerlink" title="2.3.4 2PC"></a>2.3.4 2PC</h4><p>在事务处理、关系型数据库及计算机网络中，2阶段提交协议（2PC）是一种典型的原子提交协议（atomic commitment protocol）。它是一种由协调器来处理分布式原子参与者是提交或者回滚事务的分布式算法。</p><p>该协议包括2个阶段：</p><ul><li>（1）提交请求阶段或者叫投票阶段该阶段的任务是确定相关参与者对于事务处理是否准备就绪，YES代表可以commit, NO则反之。</li><li>（2）提交阶段基于投票结果，由协调器决定提交事务抑或是退出事务处理；各事务参与者遵循指示，对本地事务资源做需要的动作。</li></ul><h4 id="2-3-5-3PC"><a href="#2-3-5-3PC" class="headerlink" title="2.3.5 3PC"></a>2.3.5 3PC</h4><p>第一阶段，投票，事务协调器询问参与者是否能提交（canCommit），都得到肯定回答后，继续第二阶段。<br>第二阶段是预提交，都确认预提交成功后，进行第三阶段。<br>第三阶段就是真实的提交，成功则完成事务；失败则继续重试</p><h4 id="2-3-6-Raft"><a href="#2-3-6-Raft" class="headerlink" title="2.3.6 Raft"></a>2.3.6 Raft</h4><p>在Raft中，任何时候一个服务器可以扮演下面角色之一：</p><ul><li>领导者：处理所有客户端交互、日志复制等动作，一般一次只有一个领导者。</li><li>选民：类似选民，完全被动的角色，这样的服务器等待被通知投票。</li><li>候选人：候选人就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者。</li></ul><h4 id="2-3-7-Lease机制"><a href="#2-3-7-Lease机制" class="headerlink" title="2.3.7 Lease机制"></a>2.3.7 Lease机制</h4><p>Lease英文含义是“租期”、“承诺”</p><h4 id="2-3-8-解决“脑裂”问题"><a href="#2-3-8-解决“脑裂”问题" class="headerlink" title="2.3.8 解决“脑裂”问题"></a>2.3.8 解决“脑裂”问题</h4><p>主备是实现高可用的有效方式，但存在一个脑裂问题。脑裂（split-brain），指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源，结果会导致系统混乱，数据损坏</p><p>有一种做法称为设置仲裁机制，例如设置第三方检测服务器（Monitor），当Slave确定准备接管Master时，让Monitor也ping一下Master，如果没有通讯，则判断其“死亡”；同时Master在对外提供服务时，每隔一段时间比如10s由Master服务器ping Slave服务器和Monitor，如果均出现异常，则暂定业务操作，重试。重试多次之后则退出程序执行或者执行服务器重启操作。</p><h4 id="2-3-9-Quorum-NWR"><a href="#2-3-9-Quorum-NWR" class="headerlink" title="2.3.9 Quorum NWR"></a>2.3.9 Quorum NWR</h4><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。在Amazon的Dynamo云存储系统中，就应用NWR来控制一致性</p><ul><li>N：同一份数据的拷贝份数；</li><li>W：是更新一个数据对象的时候需要确保成功更新的份数；</li><li>R：读取一个数据需要读取的拷贝的份数。</li></ul><h4 id="2-3-10-MVCC"><a href="#2-3-10-MVCC" class="headerlink" title="2.3.10 MVCC"></a>2.3.10 MVCC</h4><p>MVCC，全称Multiversion concurrency control，翻译为基于多版本并发控制。人们一般把基于锁（比如行级锁）的并发控制机制称成为悲观机制，而把MVCC机制称为乐观机制.</p><p>由于MVCC是一种宽松的设计，读写相互不阻塞，可以获得较好的并发性能。</p><h4 id="2-3-11-Gossip"><a href="#2-3-11-Gossip" class="headerlink" title="2.3.11 Gossip"></a>2.3.11 Gossip</h4><p>Gossip就是一种去中心化思路的分布式协议，解决状态在集群中的传播和状态一致性的保证两个问题</p><p>Gossip的核心是在去中心化结构下，通过信息的部分传递，达到全集群的状态信息传播，传播的时间收敛在O(Log(N))以内，其中N是节点的数量。同时基于Gossip协议，可以构建出状态一致的各种解决方案。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h4 id="A-后续阅读"><a href="#A-后续阅读" class="headerlink" title="A.后续阅读"></a>A.后续阅读</h4><ul><li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念与设计(原书第5版).pdf</a></li><li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li><li><a href="https://kdocs.cn/l/sVgDvD5mY" target="_blank" rel="noopener">从PAXOS到ZOOKEEPER分布式一致性原理与实践.pdf</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/chip/index.html"/>
      <url>/man/chip/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/cs/basic.html"/>
      <url>/man/cs/basic.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/cs/index.html"/>
      <url>/man/cs/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/man/rust/lib.html"/>
      <url>/man/rust/lib.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-reids</title>
      <link href="/man/python/lib-redis.html"/>
      <url>/man/python/lib-redis.html</url>
      
        <content type="html"><![CDATA[<ul><li>批量删除Keys</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">keys = redis_conn.keys(<span class="string">'iproxy:*'</span>)</span><br><span class="line">redis_conn.delete(*keys)</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python手册</title>
      <link href="/man/python/index.html"/>
      <url>/man/python/index.html</url>
      
        <content type="html"><![CDATA[<ul><li><a href="basic.html">基础</a></li><li><a href="os.html">操作系统</a></li><li><a href="thread.html">线程与进程</a></li><li><a href="net.html">网络</a></li><li><a href="class.html">面向对象</a></li><li><a href="async.html">异步</a></li><li><a href="lib.html">库</a></li><li><a href="lib-collection.html">库-集合</a></li><li><a href="lib-dbutils.html">库-DBUtils</a></li><li><a href="lib-nameko.html">库-nameko</a></li><li><a href="lib-pymysql.html">库-pymysql</a></li><li><a href="lib-redis.html">库-redis</a></li><li><a href="lib-sqlalchemy.html">库-sqlalchemy</a></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>llvm</title>
      <link href="/man/cs/llvm.html"/>
      <url>/man/cs/llvm.html</url>
      
        <content type="html"><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul><li><p><a href="https://llvm.org/" target="_blank" rel="noopener">官网</a></p></li><li><p><a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener">github</a></p></li><li><p><a href="https://www.infoworld.com/article/3247799/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html" target="_blank" rel="noopener">What is LLVM? </a></p></li></ul><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LLVM 全称是 Low Level Virtual Machine，它是源自 the University of Illinois 的一个研究项目，该项目旨在提供一个现代化的编译机制，使得对任何编程语言既可以做到静态编译也可以动态编译，而且非常高效。后来 LLVM 项目逐渐发展，并孵化了许多子项目，比如 Clang，LLDB， OpenMP 等。</p><p>一般来说，编译器会将源语言翻译为一种“中间语言(IR)”，之后再由 中间语言 利用后端程序和设备翻译为目标平台的汇编语言。不同编译器的中间语言IR是不一样的，IR集中体现了编译器的主要特征——算法，优化方式，汇编流程等等。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>nameko使用</title>
      <link href="/man/python/lib-nameko.html"/>
      <url>/man/python/lib-nameko.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust手册</title>
      <link href="/man/rust/index.html"/>
      <url>/man/rust/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust的基础</title>
      <link href="/man/rust/basic.html"/>
      <url>/man/rust/basic.html</url>
      
        <content type="html"><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>Rust中的闭包, 按照对捕获变量的使用方式, 将闭包分为三个类型: Fn, FnMut, FnOnce. 其中Fn类型的闭包, 在闭包内部以共享借用的方式使用环境变量; FnMut类型的闭包, 在闭包内部以独占借用的方式使用环境变量; 而FnOnce类型的闭包, 在闭包内部以所有者的身份使用环境变量. 由此可见, 根据闭包内使用环境变量的方式, 即可判断创建出来的闭包的类型.</p><p>注意, 对于Copy类型的环境变量, 如果以传值的方式使用, 其默认的闭包类型是Fn, 而非FnOnce, 而对非Copy的环境变量, 其闭包类型只能是FnOnce.</p><p>闭包中环境变量最终的捕获方式 (即, 是借用, 是复制, 还是转移所有权), 还与环境变量本身的语义, 以及闭包是否强制获取环境变量的所有权有关.</p><p>在闭包的管道符前面加上move关键字, 会强制以传值的方式捕获变量. 至于是复制还是移动, 则与环境变量类型的语义有关. 我们知道, 一个类型实现Copy, 即为复制语义. 在作为右值使用时会将值按位复制. 而未实现Copy的类型即为移动语义, 作右值使用时会转移所有权.</p><p>move 闭包，其经常与 thread::spawn 一起使用，因为它允许我们在一个线程中使用另一个线程的数据。可以在参数列表前使用 move 关键字强制闭包获取其使用的环境值的所有权。这个技巧在创建新线程将值的所有权从一个线程移动到另一个线程时最为实用。</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust与llvm</title>
      <link href="/man/rust/llvm.html"/>
      <url>/man/rust/llvm.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>rust的ffi使用</title>
      <link href="/man/rust/ffi.html"/>
      <url>/man/rust/ffi.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>芯片简介</title>
      <link href="/man/chip/basic.html"/>
      <url>/man/chip/basic.html</url>
      
        <content type="html"><![CDATA[<h3 id="芯片分类"><a href="#芯片分类" class="headerlink" title="芯片分类"></a>芯片分类</h3><ul><li><p>按照功能分类</p><ul><li>计算的</li><li>控制的</li><li>存储的</li></ul></li><li><p>按照集成电路规模</p><ul><li>有超大规模</li><li>大规模</li><li>中规模</li><li>小规模</li></ul></li><li><p>具体到了类型</p><ul><li>CPU</li><li>SoC</li><li>DSP</li></ul></li></ul><h3 id="CPU结构和功能"><a href="#CPU结构和功能" class="headerlink" title="CPU结构和功能"></a>CPU结构和功能</h3><p>结构：</p><ul><li>1) 控制器：完成指令的读入、寄存、译码和执行。</li><li>2) 寄存器：暂存用于寻址和计算过程的产生的地址和数据。</li><li>3) I/O控制逻辑：负责CPU中与输入/输出操作有关的逻辑。</li><li>4) 算数逻辑运算单元（Arithmetic &amp; Logic Unit, ALU）：运算器核心，负责进行算术运算、逻辑运算和移位操作，用来进行数值计算和产生存储器访问地址。</li></ul><p>功能：</p><ul><li>1) 与存储器之间交换信息。</li><li>2) 和I/O设备之间交换信息。</li><li>3) 为了使系统正常工作而接收和输出必要的信号，如复位信号、电源、输入时钟脉冲等。</li></ul><h3 id="微处理系统"><a href="#微处理系统" class="headerlink" title="微处理系统"></a>微处理系统</h3><p>1) CPU的外部特征就是数量有限的输入输出引脚。<br>2) 数据总线：用于CPU和存储器或I/O接口之间传送数据，双向通信；数据总线的条数决定了CPU和存储器或I/O设备一次最多能交换数据的位数，是微处理器的位数的判据，例如：Intel 386DX、ARM Cortex-M3是32位微处理器；Intel采用了IA-64架构的处理器、PowerPC 970是64位处理器；类似地，还有更加古老的8位、16位处理器等。<br>3) 地址总线：CPU通过地址总线输出地址码用以选择某一存储单元或某一成为I/O端口的寄存器，单向通信；地址总线的条数决定了地址码的位数，进而决定了存储空间的大小，例如：地址总线宽度（条数）为8，则可以标记2^8 = 256个存储单元，若每个存储单元的字长为8 bit，则最大可以接入系统的存储空间为256kB。<br>4) 控制总线：用来传送自CPU发出的控制信息或外设送到CPU的状态信息，双向通信；</p><h3 id="专用集成电路"><a href="#专用集成电路" class="headerlink" title="专用集成电路"></a>专用集成电路</h3><p>专用的集成电路（Application Specific Integrated Circuit, ASIC）是一种为专门目的而设计的集成电路。是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路<br>ASIC的特点是面向特定用户的需求，ASIC在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点</p><h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>可编程逻辑器件（Programmable Logic Device, PLD）是一种通用集成电路，它是ASIC的一个子集，逻辑功能可以按照用户对器件编程来确定。<br>PLD与一般数字芯片不同的是：PLD内部的数字电路可以在出厂后才规划决定，甚至可以无限制改变，而一般数字芯片在出厂前就已经决定其内部电路，无法在出厂后再次改变，事实上一般的模拟芯片、通信芯片、微控制器也都一样，出厂后就无法再对其内部电路进行更改。</p><blockquote><p>可编程逻辑器件的发展历程</p></blockquote><ul><li>最早的可编程逻辑器件（PLD）是1970年制成的可编程只读存储器（PROM），它由固定的与阵列和可编程的或阵列组成</li><li>可编程逻辑阵列（PLA）于20世纪70年代中期出现，它是由可编程的与阵列和可编程的或阵列组成，但由于器件的价格比较贵、编程复杂、资源利用率低，因而没有得到广泛应用。</li><li>可编程阵列逻辑（PAL）是1977年美国MMI公司率先推出的，它采用熔丝编程方式，由可编程的与阵列和固定的或阵列组成，采用双极性工艺制造，器件的工作速度很高。由于它的设计很灵活，输出结构种类很多，因而成为第一个得到普遍应用的可编程逻辑器件</li><li>通用阵列逻辑（GAL）是1985年Lattice公司最先发明的可电擦写、可重复编程、可设置加密位的PLD。GAL在PAL的基础上，采用了输出逻辑宏单元形式（EECMOS）工艺结构。在实际应用中，GAL对PAL仿真具有百分之百的兼容性，所以GAL几乎完全代替了PAL，并可以取代大部分标准SSI、MSI集成芯片，因而获得广泛应用</li><li>可擦除可编程逻辑器件（EPLD）是20世纪80年代中期Altera公司推出的基于UVEPROM和CMOS技术的PLD，后来发展到采用EECMOS工艺制作的PLD，EPLD的基本逻辑单元是宏单元，宏单元是由可编程的与阵列、可编程寄存器和可编程I/O三部分组成的</li><li>复杂可编程逻辑器件（CPLD）是20世纪80年代末Lattice公司提出了在线可编程技术（SP）以后于20世纪90年代初推出的。CPLD至少包含三种结构：可编程逻辑宏单元可编程I/O单元和可编程内部连线，它是在EPLD的基础上发展起来的，采用EECMOS工艺制作，与EPLD相比，增加了内部连线，对逻辑宏单元和I/O单元也有很大改进。</li><li>现场可编程门阵列（FPGA）器件是Xilinx公司1985年首家推出的，它是一种新型的高密度PLD，采用CMOS-SRAM工艺制作。FPGA的结构与门阵列PLD不同，其内部由许多独立的可编程逻辑模块（CLB）组成，逻辑块之间可以灵活地相互连接，CLB的功能很强，不仅能够实现逻辑函数，还可以配置成RAM等复杂的形式。配置数据存放在芯片内的SRAM中，设计人员可现场修改器件的逻辑功能，即所谓的现场可编程。FPGA出现后受到电子设计工程师的普遍欢迎，发展十分迅速。</li></ul><h3 id="硬件描述语言"><a href="#硬件描述语言" class="headerlink" title="硬件描述语言"></a>硬件描述语言</h3><p>硬件描述语言（Hardware Deion Language, HDL）是一种用形式化方法描述逻辑电路和系统的语言。利用这种语言，逻辑电路系统的设计可以从上层到下层（从抽象到具体）逐层描述自己的设计思想，用一系列分层次的模块来表示极其复杂的逻辑系统。然后，利用电子设计自动化（EDA）工具，逐层进行仿真验证，再把其中需要变为实际电路的模块组合，经过自动综合工具转换到门级电路网表。接下来，再用专用集成电路（ASIC）或现场可编程门阵列（FPGA）自动布局布线工具，把网表转换为要实现的具体电路布线结构。</p><ul><li>VHDL</li><li>Verilog HDL</li><li>System C</li></ul><h3 id="常见的数据处理芯片"><a href="#常见的数据处理芯片" class="headerlink" title="常见的数据处理芯片"></a>常见的数据处理芯片</h3><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p>日常生活中最常见得到的微处理器系统就是我们身边的微型计算机，也就是个人电脑<br>MCU是应用最广泛的一种电子控制芯片，其控制程序可以由特殊的烧录工具下载到ROM中，行使系统的功能。这些ROM可以使以是PROM、UVEPROM、EEPROM等，若MCU上没有集成ROM，也可以外接ROM。按照系统结构，微处理器系统可以分为冯·诺依曼结构（也称普雷斯顿结构）和哈佛结构，其区别是程序与数据的存放方式不同，同样地，MCU芯片也可以分为这两种结构，灵活地满足需要。</p><h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><p>微处理器单元（Micro Processor Unit, MPU），就是把很多CPU集成在一起并行处理数据的芯片。通俗来说，MCU集成了RAM，ROM等设备；MPU则不集成这些设备，是高度集成的通用结构的中央处理器矩阵，也可以认为是去除了集成外设的MCU。</p><h4 id="PLD（CPLD-FPGA）"><a href="#PLD（CPLD-FPGA）" class="headerlink" title="PLD（CPLD/FPGA）"></a>PLD（CPLD/FPGA）</h4><p>因为目前广泛使用的PLD是CPLD和FPGA。<br>CPLD/FPGA的内部结构和CPU完全不同，内部电路可以被多次修改，可以按照用户的编程形成不同的组合逻辑电路、时序逻辑电路结构，是一种“万能”的芯片，CPLD/FPGA看起来像一个CPU，其实不然，因为使用CPLD/FPGA实现控制是纯硬件实现，实质上和使用成千上万基本逻辑门搭建的数字逻辑电路没有区别。</p><h4 id="ADC、DAC"><a href="#ADC、DAC" class="headerlink" title="ADC、DAC"></a>ADC、DAC</h4><p>这就是模数转换电路（Analog Digital Circuit, ADC）,相应的也有数模转换（D/A）和数模转换电路（Digital Analog Circuit, DAC）芯片，进行D/A的时候同样要在数学和信息论上满足相关定理。</p><h4 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h4><p>数字信号处理器（Digital Signal Processor, DSP）是用来高速处理数字信号的专用芯片。<br>常常采用专用的电路来处理数字信号，如数字滤波、快速傅里叶变换、时频分析、语音信号和图像信号的处理加工等。这些运算往往很复杂，很多涉及复数的累加、累乘运算，举个例子：离散傅里叶变换的计算就十分复杂，但是运用时域抽取或频域抽取的快速傅里叶变换算法后就可以大大减少运算量，但是电路较为复杂。将能完成这些复杂运算的电路集成在一块芯片上，能在一个时钟周期完成一次乘加运算，使其能完成如基2-FFT蝶形运算、音频滤波、图像处理等复杂运算，这样的芯片叫做DSP。DSP也是一种特殊的CPU，特别适合信号的处理</p><h4 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h4><p>SoC的全称是System on a Chip，顾名思义，就是在一块芯片上集成一整个信息处理系统，称为片上系统或系统级芯片。<br>SoC也代表着一种技术，是一种以确定系统功能为目标，各个模块的软硬件协同开发，最后把开发成果集成为一块芯片的技术。由于功能丰富，又要求有不俗的性能发挥，SoC已然是功能最为丰富的硬件，其上集成了CPU、GPU、RAM、ADC/DAC、Modem、高速DSP等各种芯片，有的SoC上还必须集成电源管理模块，各种外部设备的控制模块，充分考虑各总线的分布利用……现如今，智能手机里的SoC上就集成了以上的部件和基带处理器等很多相关的通信模块。<br>SoC在无人机技术、自动驾驶，深度学习等行业也有越来越多的应用，用一块单芯片就能实现完整的电子系统，是半导体行业、IC产业未来的发展方向</p><h3 id="半导体IP核"><a href="#半导体IP核" class="headerlink" title="半导体IP核"></a>半导体IP核</h3><p>IP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。[1]IP核可以通过协议由一方提供给另一方，或由一方独自占有。IP核的概念源于产品设计的专利证书和源代码的版权等。设计人员能够以IP核为基础进行专用集成电路或现场可编程逻辑门阵列的逻辑设计，以减少设计周期。</p><p>IP核分为软核、硬核和固核。</p><ul><li>软核通常是与工艺无关、具有寄存器传输级硬件描述语言描述的设计代码，可以进行后续设计；</li><li>硬核是前者通过逻辑综合、布局、布线之后的一系列表征文件，具有特定的工艺形式、物理实现方式；</li><li>固核则通常介于上面两者之间，它已经通过功能验证、时序分析等过程，设计人员可以以逻辑门级网表的形式获取。</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python异步</title>
      <link href="/man/python/async.html"/>
      <url>/man/python/async.html</url>
      
        <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义异步函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line"> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> loop.run_until_complete(hello())</span><br><span class="line"></span><br><span class="line">loop = asyncio.get_event_loop()</span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">'__main__'</span>:</span><br><span class="line"> run()</span><br></pre></td></tr></table></figure><p>如果需要并发http请求怎么办呢，通常是用requests，但requests是同步的库，如果想异步的话需要引入aiohttp。这里引入一个类，from aiohttp import ClientSession，首先要建立一个session对象，然后用session对象去打开网页。session可以进行多项操作，比如post, get, put, head等。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> response = <span class="keyword">await</span> response.read()</span><br><span class="line"> print(response)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> loop.run_until_complete(hello(url))</span><br></pre></td></tr></table></figure><p>首先async def 关键字定义了这是个异步函数，await 关键字加在需要等待的操作前面，response.read()等待request响应，是个耗IO操作。然后使用ClientSession类发起http请求。<br>多链接异步访问<br>如果我们需要请求多个URL该怎么办呢，同步的做法访问多个URL只需要加个for循环就可以了。但异步的实现方式并没那么容易，在之前的基础上需要将hello()包装在asyncio的Future对象中，然后将Future对象列表作为任务传递给事件循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> response = <span class="keyword">await</span> response.read()</span><br><span class="line"><span class="comment"># print(response)</span></span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> task = asyncio.ensure_future(hello(url.format(i)))</span><br><span class="line"> tasks.append(task)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> run()</span><br><span class="line"> loop.run_until_complete(asyncio.wait(tasks))</span><br></pre></td></tr></table></figure><p>好了，上面介绍了访问不同链接的异步实现方式，但是我们只是发出了请求，如果要把响应一一收集到一个列表中，最后保存到本地或者打印出来要怎么实现呢，可通过asyncio.gather(*tasks)将响应全部收集起来，具体通过下面实例来演示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"></span><br><span class="line">tasks = []</span><br><span class="line">url = <span class="string">"https://www.baidu.com/&#123;&#125;"</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"><span class="comment"># print(response)</span></span><br><span class="line"> print(<span class="string">'Hello World:%s'</span> % time.time())</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line"> task = asyncio.ensure_future(hello(url.format(i)))</span><br><span class="line"> tasks.append(task)</span><br><span class="line"> result = loop.run_until_complete(asyncio.gather(*tasks))</span><br><span class="line"> print(result)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> run()</span><br></pre></td></tr></table></figure><p>异常解决<br>假如你的并发达到2000个，程序会报错：ValueError: too many file descriptors in select()。报错的原因字面上看是 Python 调取的 select 对打开的文件有最大数量的限制，这个其实是操作系统的限制，linux打开文件的最大数默认是1024，windows默认是509，超过了这个值，程序就开始报错。这里我们有三种方法解决这个问题：<br>1.限制并发数量。（一次不要塞那么多任务，或者限制最大并发数量）<br>2.使用回调的方式。<br>3.修改操作系统打开文件数的最大限制，在系统里有个配置文件可以修改默认值，具体步骤不再说明了。<br>不修改系统默认配置的话，个人推荐限制并发数的方法，设置并发数为500，处理速度更快。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> time,asyncio,aiohttp</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://www.baidu.com/'</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(url,semaphore)</span>:</span></span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> semaphore:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> aiohttp.ClientSession() <span class="keyword">as</span> session:</span><br><span class="line"> <span class="keyword">async</span> <span class="keyword">with</span> session.get(url) <span class="keyword">as</span> response:</span><br><span class="line"> <span class="keyword">return</span> <span class="keyword">await</span> response.read()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">()</span>:</span></span><br><span class="line"> semaphore = asyncio.Semaphore(<span class="number">500</span>) <span class="comment"># 限制并发量为500</span></span><br><span class="line"> to_get = [hello(url.format(),semaphore) <span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>)] <span class="comment">#总共1000任务</span></span><br><span class="line"> <span class="keyword">await</span> asyncio.wait(to_get)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment"># now=lambda :time.time()</span></span><br><span class="line"> loop = asyncio.get_event_loop()</span><br><span class="line"> loop.run_until_complete(run())</span><br><span class="line"> loop.close()</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python面向对象</title>
      <link href="/man/python/class.html"/>
      <url>/man/python/class.html</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><ul><li>继承</li><li>多态</li><li>封装</li><li>对象序列化传输，反序列化执行</li><li>判断某个实例是不是属于某个类</li></ul><ul><li>1.类本身就是对象   <ul><li>2.global    nonlocal   </li><li>3._ _ init_ _ 类在实例化时调用该函数   </li><li>4.继承：isinstance()检查实例类型  issubclass()检查类的关系     可以多重继承   </li><li>5.私有变量<br>  #1.以 _  _开头   </li><li><ol start="6"><li>_ <em>del</em> _ 析构方法 删除内存</li></ol></li></ul></li></ul><h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h3 id="类的介绍"><a href="#类的介绍" class="headerlink" title="类的介绍"></a>类的介绍</h3><h3 id="类的应用"><a href="#类的应用" class="headerlink" title="类的应用"></a>类的应用</h3><h2 id="类的方法"><a href="#类的方法" class="headerlink" title="类的方法"></a>类的方法</h2><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法"></a>魔术方法</h3><h3 id="私有方法"><a href="#私有方法" class="headerlink" title="私有方法"></a>私有方法</h3><ul><li><p>Python不像C++、Java、C#等有明确的公共、私有或受保护的关键字来定义成员函数或属性，它使用约定的单下划线“<em>“和”_</em>“双下划线作为函数或属性的前缀来标识。使用单下划线还是双下划线，是有很大的区别的。</p><ul><li><ol><li>单下划线的函数或属性，在类定义中可以调用和访问，类的实例可以直接访问，子类中可以访问；</li></ol></li><li><ol start="2"><li>双下划线的函数或属性，在类定义中可以调用和访问，类的实例不可以直接访问，子类不可访问。</li></ol></li><li><p>注意：对于双下划线的函数或属性，Python解释器使用了名字混淆的方法， 将私有的方法”<strong>method”变成了”_classname</strong>method”了，具体看下文示例。</p></li></ul></li><li><p>不要定义Python的混淆类方法名称</p><ul><li><p>Python解释器对于类（ClassName）双下划线的私有方法（<strong>method），会进行名称混淆（Name Mangle），规则为 _ClassName</strong>method。所以不要在类方法中同时存在<strong>method和 _ClassName</strong>method。</p></li><li><p>可以看出 <strong>hide 已经被 _Base</strong>hide方法替换掉了。外部也可以直接通过 Base()._Base__hide()方式调用（但千万别用这种方式实现，比较混乱！）。</p></li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_secret</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Base secret"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__hide</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Normal __hide"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_Base__hide</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Special _Base__hide"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">public</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"From public method"</span>)</span><br><span class="line">        self.__hide()</span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> dir(Base())</span><br><span class="line">print(<span class="string">"="</span>*<span class="number">80</span>)</span><br><span class="line">Base().public()</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">[&lt;span style="color:#FF0000;"&gt;'_Base__hide'&lt;/span&gt;, '__class__', '__delattr__', '__dict__', '__doc__', '__format__', '__getattribute__', '__hash__', '__init__', '__module__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_secret', 'public']</span></span><br><span class="line"><span class="string">================================================================================</span></span><br><span class="line"><span class="string">From public method</span></span><br><span class="line"><span class="string">&lt;span style="color:#FF0000;"&gt;Special _Base__hide&lt;/span&gt; """</span></span><br></pre></td></tr></table></figure><h3 id="self、cls、staticmethod，classmethod-区别"><a href="#self、cls、staticmethod，classmethod-区别" class="headerlink" title="self、cls、staticmethod，classmethod 区别"></a>self、cls、staticmethod，classmethod 区别</h3><ul><li><p>类的方法有三种</p><ul><li><p>一是通过def定义的 普通的一般的，需要至少传递一个参数，一般用self，这样的方法必须通过一个类的实例去访问，类似于c++中通过对象去访问；</p></li><li><p>二是在def前面加上@classmethod，这种类方法的一个特点就是可以通过类名去调用，但是也必须传递一个参数，一般用cls表示class，表示可以通过类直接调用；</p></li><li><p>三是在def前面加上@staticmethod，这种类方法是静态的类方法，类似于c++的静态函数，他的一个特点是参数可以为空，同样支持类名和对象两种调用方式；</p></li></ul></li><li><p>三种方法解释</p><ul><li>普通的方法，第一个参数需要是self，它表示一个具体的实例本身。</li><li>如果用了staticmethod，那么就可以无视这个self，而将这个方法当成一个普通的函数使用。如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。</li><li>而对于classmethod，它的第一个参数不是self，是cls，它表示这个类本身。而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等，避免硬编码。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    bar = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'foo'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">static_foo</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'static_foo'</span></span><br><span class="line">        <span class="keyword">print</span> A.bar</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">class_foo</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'class_foo'</span></span><br><span class="line">        <span class="keyword">print</span> cls.bar</span><br><span class="line">        cls().foo()</span><br><span class="line"></span><br><span class="line">A.static_foo()</span><br><span class="line">A.class_foo()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">static_foo</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">class_foo</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">foo</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><ul><li>其实self，cls不是关键字，例如</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    member = <span class="string">"this is a test."</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print1</span><span class="params">(cls)</span>:</span></span><br><span class="line">        print(<span class="string">"print 1: "</span>, cls.membe)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"print 2: "</span>, self.member)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Print3</span><span class="params">(paraTest)</span>:</span></span><br><span class="line">        print(<span class="string">"print 3: "</span>, paraTest.member)</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-collection</title>
      <link href="/man/python/lib-collection.html"/>
      <url>/man/python/lib-collection.html</url>
      
        <content type="html"><![CDATA[<ul><li><p>OrderedDict类：排序字典，是字典的子类。引入自2.7。</p></li><li><p>namedtuple()函数：命名元组，是一个工厂函数。引入自2.6。</p></li><li><p>Counter类：为hashable对象计数，是字典的子类。引入自2.7。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">c = Counter()  <span class="comment"># 创建一个空的Counter类</span></span><br><span class="line">c = Counter(<span class="string">'gallahad'</span>)  <span class="comment"># 从一个可iterable对象（list、tuple、dict、字符串等）创建</span></span><br><span class="line">c = Counter(&#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)  <span class="comment"># 从一个字典对象创建</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>)  <span class="comment"># 从一组键值对创建</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### update方法</span></span><br><span class="line">c = Counter(<span class="string">'which'</span>)</span><br><span class="line">c.update(<span class="string">'witch'</span>)  <span class="comment"># 使用另一个iterable对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">d = Counter(<span class="string">'watch'</span>)</span><br><span class="line">c.update(d)  <span class="comment"># 使用另一个Counter对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## subtract</span></span><br><span class="line">c = Counter(<span class="string">'which'</span>)</span><br><span class="line">c.subtract(<span class="string">'witch'</span>)  <span class="comment"># 使用另一个iterable对象更新</span></span><br><span class="line">c[<span class="string">'h'</span>]</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">d = Counter(<span class="string">'watch'</span>)</span><br><span class="line">c.subtract(d)  <span class="comment"># 使用另一个Counter对象更新</span></span><br><span class="line">c[<span class="string">'a'</span>]</span><br><span class="line"><span class="comment"># -1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">## 键的删除</span></span><br><span class="line">c = Counter(<span class="string">"abcdcba"</span>)</span><br><span class="line"><span class="comment"># Counter(&#123;'a': 2, 'c': 2, 'b': 2, 'd': 1&#125;)</span></span><br><span class="line">c[<span class="string">"b"</span>] = <span class="number">0</span></span><br><span class="line"><span class="comment"># Counter(&#123;'a': 2, 'c': 2, 'd': 1, 'b': 0&#125;)</span></span><br><span class="line"><span class="keyword">del</span> c[<span class="string">"a"</span>]</span><br><span class="line"><span class="comment"># Counter(&#123;'c': 2, 'b': 2, 'd': 1&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## elements</span></span><br><span class="line">c = Counter(a=<span class="number">4</span>, b=<span class="number">2</span>, c=<span class="number">0</span>, d=<span class="number">-2</span>)</span><br><span class="line">list(c.elements())</span><br><span class="line"><span class="comment"># ['a', 'a', 'a', 'a', 'b', 'b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## most_common</span></span><br><span class="line">c = Counter(<span class="string">'abracadabra'</span>)</span><br><span class="line">c.most_common()</span><br><span class="line"><span class="comment"># [('a', 5), ('r', 2), ('b', 2), ('c', 1), ('d', 1)]</span></span><br><span class="line">c.most_common(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># [('a', 5), ('r', 2), ('b', 2)]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 算术操作</span></span><br><span class="line">c = Counter(a=<span class="number">3</span>, b=<span class="number">1</span>)</span><br><span class="line">d = Counter(a=<span class="number">1</span>, b=<span class="number">2</span>)</span><br><span class="line">c + d  <span class="comment"># c[x] + d[x]</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">4</span>, <span class="string">'b'</span>: <span class="number">3</span>&#125;)</span><br><span class="line">c - d  <span class="comment"># subtract（只保留正数计数的元素）</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">2</span>&#125;)</span><br><span class="line">c &amp; d  <span class="comment"># 交集:  min(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">1</span>, <span class="string">'b'</span>: <span class="number">1</span>&#125;)</span><br><span class="line">c | d  <span class="comment"># 并集:  max(c[x], d[x])</span></span><br><span class="line">Counter(&#123;<span class="string">'a'</span>: <span class="number">3</span>, <span class="string">'b'</span>: <span class="number">2</span>&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 常用操作</span></span><br><span class="line">sum(c.values())  <span class="comment"># 所有计数的总数</span></span><br><span class="line">c.clear()  <span class="comment"># 重置Counter对象，注意不是删除</span></span><br><span class="line">list(c)  <span class="comment"># 将c中的键转为列表</span></span><br><span class="line">set(c)  <span class="comment"># 将c中的键转为set</span></span><br><span class="line">dict(c)  <span class="comment"># 将c中的键值对转为字典</span></span><br><span class="line">c.items()  <span class="comment"># 转为(elem, cnt)格式的列表</span></span><br><span class="line">Counter(dict(list_of_pairs))  <span class="comment"># 从(elem, cnt)格式的列表转换为Counter类对象</span></span><br><span class="line">c.most_common()[:-n:<span class="number">-1</span>]  <span class="comment"># 取出计数最少的n个元素</span></span><br><span class="line">c += Counter()  <span class="comment"># 移除0和负值</span></span><br></pre></td></tr></table></figure></li><li><p>deque：双向队列。引入自2.4。</p></li><li><p>defaultdict：使用工厂函数创建字典，使不用考虑缺失的字典键。引入自2.5。</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-DBUtils</title>
      <link href="/man/python/lib-dbutils.html"/>
      <url>/man/python/lib-dbutils.html</url>
      
        <content type="html"><![CDATA[<p>有两个类型：PooledDB, PersistentDB<br>如果是多线程，可以用PooledDB<br>如果是单线程，可以用PersistentDB</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">数据库连接工具类</span></span><br><span class="line"><span class="string"># """</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">from</span> DBUtils.PooledDB <span class="keyword">import</span> PooledDB, SharedDBConnection</span><br><span class="line"><span class="keyword">from</span> DBUtils.PersistentDB <span class="keyword">import</span> PersistentDB, PersistentDBError, NotSupportedError</span><br><span class="line">config = &#123;</span><br><span class="line">    <span class="string">'host'</span>: <span class="string">'192.168.0.101'</span>,</span><br><span class="line">    <span class="string">'port'</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">'database'</span>: <span class="string">'wedo'</span>,</span><br><span class="line">    <span class="string">'user'</span>: <span class="string">'wedo'</span>,</span><br><span class="line">    <span class="string">'password'</span>: <span class="string">'xxxxxxxx'</span>,</span><br><span class="line">    <span class="string">'charset'</span>: <span class="string">'utf8'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_db_pool</span><span class="params">(is_mult_thread)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_mult_thread:</span><br><span class="line">        poolDB = PooledDB(</span><br><span class="line">            <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            creator=pymysql,</span><br><span class="line">            <span class="comment"># 连接池允许的最大连接数,0和None表示没有限制</span></span><br><span class="line">            maxconnections=<span class="number">3</span>,</span><br><span class="line">            <span class="comment"># 初始化时,连接池至少创建的空闲连接,0表示不创建</span></span><br><span class="line">            mincached=<span class="number">2</span>,</span><br><span class="line">            <span class="comment"># 连接池中空闲的最多连接数,0和None表示没有限制</span></span><br><span class="line">            maxcached=<span class="number">5</span>,</span><br><span class="line">            <span class="comment"># 连接池中最多共享的连接数量,0和None表示全部共享(其实没什么卵用)</span></span><br><span class="line">            maxshared=<span class="number">3</span>,</span><br><span class="line">            <span class="comment"># 连接池中如果没有可用共享连接后,是否阻塞等待,True表示等等,</span></span><br><span class="line">            <span class="comment"># False表示不等待然后报错</span></span><br><span class="line">            blocking=<span class="literal">True</span>,</span><br><span class="line">            <span class="comment"># 开始会话前执行的命令列表</span></span><br><span class="line">            setsession=[],</span><br><span class="line">            <span class="comment"># ping Mysql服务器检查服务是否可用</span></span><br><span class="line">            ping=<span class="number">0</span>,</span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        poolDB = PersistentDB(</span><br><span class="line">            <span class="comment"># 指定数据库连接驱动</span></span><br><span class="line">            creator=pymysql,</span><br><span class="line">            <span class="comment"># 一个连接最大复用次数,0或者None表示没有限制,默认为0</span></span><br><span class="line">            maxusage=<span class="number">1000</span>,</span><br><span class="line">            **config</span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">return</span> poolDB</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 以单线程的方式初始化数据库连接池</span></span><br><span class="line">    db_pool = get_db_pool(<span class="literal">False</span>)</span><br><span class="line">    <span class="comment"># 从数据库连接池中取出一条连接</span></span><br><span class="line">    conn = db_pool.connection()</span><br><span class="line">    cursor = conn.cursor()</span><br><span class="line">    <span class="comment"># 随便查一下吧</span></span><br><span class="line">    cursor.execute(<span class="string">'select * from books'</span>)</span><br><span class="line">    <span class="comment"># 随便取一条查询结果</span></span><br><span class="line">    result = cursor.fetchone()</span><br><span class="line">    print(result)</span><br><span class="line">    <span class="comment"># 把连接返还给连接池</span></span><br><span class="line">    conn.close()</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python系统操作</title>
      <link href="/man/python/os.html"/>
      <url>/man/python/os.html</url>
      
        <content type="html"><![CDATA[<h2 id="系统操作"><a href="#系统操作" class="headerlink" title="系统操作"></a>系统操作</h2><h3 id="获取用户输入"><a href="#获取用户输入" class="headerlink" title="获取用户输入"></a>获取用户输入</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">content = imput()</span><br></pre></td></tr></table></figure><h3 id="获取命令行参数"><a href="#获取命令行参数" class="headerlink" title="获取命令行参数"></a>获取命令行参数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">filename = sys.argv[<span class="number">0</span>]</span><br><span class="line">argv1 = sys.argv[<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h3 id="命令参数化"><a href="#命令参数化" class="headerlink" title="命令参数化"></a>命令参数化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="获取系统环境变量"><a href="#获取系统环境变量" class="headerlink" title="获取系统环境变量"></a>获取系统环境变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">print(os.environ)</span><br></pre></td></tr></table></figure><h3 id="获取硬件信息"><a href="#获取硬件信息" class="headerlink" title="获取硬件信息"></a>获取硬件信息</h3><ul><li>用psutil库可以获取系统很多信息<h3 id="可以取代操作系统特定的路径分割符。"><a href="#可以取代操作系统特定的路径分割符。" class="headerlink" title="可以取代操作系统特定的路径分割符。"></a>可以取代操作系统特定的路径分割符。</h3></li><li>os.sep<h3 id="返回但前目录（’-’"><a href="#返回但前目录（’-’" class="headerlink" title="返回但前目录（’.’)"></a>返回但前目录（’.’)</h3></li><li>os.curdir<h3 id="字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux-Unix用户，它是’posix’。"><a href="#字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux-Unix用户，它是’posix’。" class="headerlink" title="字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。"></a>字符串指示你正在使用的平台。比如对于Windows，它是’nt’，而对于Linux/Unix用户，它是’posix’。</h3></li><li>os.name<h3 id="函数分别用来读取和设置环境变量。"><a href="#函数分别用来读取和设置环境变量。" class="headerlink" title="函数分别用来读取和设置环境变量。"></a>函数分别用来读取和设置环境变量。</h3></li><li>os.getenv()</li><li>os.putenv()<h3 id="函数用来运行shell命令。"><a href="#函数用来运行shell命令。" class="headerlink" title="函数用来运行shell命令。"></a>函数用来运行shell命令。</h3></li><li>os.system()<h3 id="实现从程序外部向程序传递参数。"><a href="#实现从程序外部向程序传递参数。" class="headerlink" title="实现从程序外部向程序传递参数。"></a>实现从程序外部向程序传递参数。</h3></li><li>sys.argv<h3 id="程序中间的退出"><a href="#程序中间的退出" class="headerlink" title="程序中间的退出"></a>程序中间的退出</h3></li><li>sys.exit([arg])</li><li>arg=0为正常退出。<h3 id="获取系统当前编码，一般默认为ascii。"><a href="#获取系统当前编码，一般默认为ascii。" class="headerlink" title="获取系统当前编码，一般默认为ascii。"></a>获取系统当前编码，一般默认为ascii。</h3></li><li>sys.getdefaultencoding()<h3 id="设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload-sys-，在执行-setdefaultencoding-‘utf8’-，此时将系统默认编码设置为utf8。（见设置系统默认编码-）"><a href="#设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload-sys-，在执行-setdefaultencoding-‘utf8’-，此时将系统默认编码设置为utf8。（见设置系统默认编码-）" class="headerlink" title="设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）"></a>设置系统默认编码，执行dir（sys）时不会看到这个方法，在解释器中执行不通过，可以先执行reload(sys)，在执行 setdefaultencoding(‘utf8’)，此时将系统默认编码设置为utf8。（见设置系统默认编码 ）</h3></li><li>sys.setdefaultencoding()<h3 id="获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’"><a href="#获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’" class="headerlink" title="获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’."></a>获取文件系统使用编码方式，Windows下返回’mbcs’，mac下返回’utf-8’.</h3></li><li>sys.getfilesystemencoding()<h3 id="获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。"><a href="#获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。" class="headerlink" title="获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。"></a>获取指定模块搜索路径的字符串集合，可以将写好的模块放在得到的某个路径下，就可以在程序中import时正确找到。</h3></li><li>sys.path<h3 id="获取当前系统平台。"><a href="#获取当前系统平台。" class="headerlink" title="获取当前系统平台。"></a>获取当前系统平台。</h3></li><li>sys.platform<h3 id="包含与标准I-O-流对应的流对象-如果需要更好地控制输出-而print-不能满足你的要求-它们就是你所需要的-你也可以替换它们-这时候你就可以重定向输出和输入到其它设备-device-或者以非标准的方式处理它们"><a href="#包含与标准I-O-流对应的流对象-如果需要更好地控制输出-而print-不能满足你的要求-它们就是你所需要的-你也可以替换它们-这时候你就可以重定向输出和输入到其它设备-device-或者以非标准的方式处理它们" class="headerlink" title="包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们"></a>包含与标准I/O 流对应的流对象. 如果需要更好地控制输出,而print 不能满足你的要求, 它们就是你所需要的. 你也可以替换它们, 这时候你就可以重定向输出和输入到其它设备( device ), 或者以非标准的方式处理它们</h3></li><li>sys.stdin,sys.stdout,sys.stderr<h3 id="获取操作系统类型，windows、linux等"><a href="#获取操作系统类型，windows、linux等" class="headerlink" title="获取操作系统类型，windows、linux等"></a>获取操作系统类型，windows、linux等</h3></li><li>platform.system()<h3 id="获取操作系统，Darwin-9-8-0-i386-32bit"><a href="#获取操作系统，Darwin-9-8-0-i386-32bit" class="headerlink" title="获取操作系统，Darwin-9.8.0-i386-32bit"></a>获取操作系统，Darwin-9.8.0-i386-32bit</h3></li><li>platform.platform()<h3 id="获取系统版本信息-6-2-0"><a href="#获取系统版本信息-6-2-0" class="headerlink" title="获取系统版本信息 6.2.0"></a>获取系统版本信息 6.2.0</h3></li><li>platform.version()</li><li>platform.mac_ver()</li><li>platform.win32_ver() (‘post2008Server’, ‘6.2.9200’, ”, u’Multiprocessor Free’)</li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python函数</title>
      <link href="/man/python/func.html"/>
      <url>/man/python/func.html</url>
      
        <content type="html"><![CDATA[<h4 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h4><ul><li><p>all</p><ul><li>判断其内所有值都为真<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all([<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>]) <span class="comment">#列表list，存在一个为0的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all((<span class="number">0</span>, <span class="number">1</span>，<span class="number">2</span>, <span class="number">3</span>)) <span class="comment">#元组tuple，存在一个为0的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">all([]) <span class="comment"># 空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">all(()) <span class="comment"># 空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>any</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">any([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>]) <span class="comment">#列表list，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any([<span class="number">0</span>, <span class="string">''</span>, <span class="literal">False</span>]) <span class="comment">#列表list,元素全为0,'',false</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，元素都不为空或0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any((<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">''</span>, <span class="string">'d'</span>)) <span class="comment">#元组tuple，存在一个为空的元素</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">any((<span class="number">0</span>, <span class="string">''</span>, <span class="literal">False</span>)) <span class="comment">#元组tuple，元素全为0,'',false</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any([]) <span class="comment"># 空列表</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">any(()) <span class="comment"># 空元组</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br></pre></td></tr></table></figure><ul><li>bool</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bool(<span class="number">0</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool(<span class="string">"abc"</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line">bool(<span class="string">""</span>) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool([]) <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">bool() <span class="comment">#</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line">issubclass(bool, int) <span class="comment">#bool是一个subclass int</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><ul><li><p>len</p><ul><li>求数据长度。</li><li>数组为所包含的元素个数</li></ul></li><li><p>sorted</p><ul><li>排序</li></ul></li><li><p>print</p></li><li><p>type</p><ul><li>判断一个对象是否是一个已知的类型</li></ul></li><li><p>dir</p></li><li><p>isinstance</p><ul><li>判断一个对象是否是一个已知的类型</li></ul></li><li><p>callable函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">callable(<span class="number">0</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line">callable(<span class="string">"mystring"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">callable(add)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span><span class="params">(self)</span>:</span> <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">callable(A)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line">callable(a)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">callable(B)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line">callable(b)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure></li><li><p>chr和ord函数 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">chr(<span class="number">97</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'a'</span></span><br><span class="line"></span><br><span class="line">chr(<span class="number">98</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'b'</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">97</span></span><br><span class="line"></span><br><span class="line">ord(<span class="string">'b'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">98</span></span><br></pre></td></tr></table></figure></li><li><p>classmethod</p><ul><li>类方法既可以直接类调用(C.f())，也可以进行实例调用(C().f())。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is a class method"</span></span><br><span class="line">C.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line">c = C()</span><br><span class="line">c.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">D</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">" This is not a class method "</span></span><br><span class="line">D.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Traceback (most recent call last):  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;TypeError: unbound method f() must be called <span class="keyword">with</span> D instance <span class="keyword">as</span> first argument (got nothing instead)</span><br><span class="line"></span><br><span class="line">d = D()</span><br><span class="line">d.f()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>This <span class="keyword">is</span> <span class="keyword">not</span> a <span class="class"><span class="keyword">class</span> <span class="title">method</span></span></span><br></pre></td></tr></table></figure><ul><li><p>complex</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">complex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">2j</span>)<span class="comment">#数字</span></span><br><span class="line"></span><br><span class="line">complex(<span class="number">1</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">0j</span>)<span class="comment">#当做字符串处理</span></span><br><span class="line"></span><br><span class="line">complex(<span class="string">"1"</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">0j</span>)</span><br><span class="line"></span><br><span class="line">complex(<span class="string">"1+2j"</span>) <span class="comment">#注意：这个地方在“+”号两边不能有空格，也就是不能写成"1 + 2j"，应该是"1+2j"，否则会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">1</span> + <span class="number">2j</span>)</span><br></pre></td></tr></table></figure></li><li><p>dir函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">dir()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">dir()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'struct'</span>]</span><br><span class="line"></span><br><span class="line">dir(struct)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Struct'</span>, <span class="string">'__builtins__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__file__'</span>, <span class="string">'__name__'</span>, <span class="string">'__package__'</span>, <span class="string">'_clearcache'</span>, <span class="string">'calcsize'</span>, <span class="string">'error'</span>, <span class="string">'pack'</span>, <span class="string">'pack_into'</span>, <span class="string">'unpack'</span>, <span class="string">'unpack_from'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__dir__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> [<span class="string">"name"</span>, <span class="string">"age"</span>, <span class="string">"country"</span>]</span><br><span class="line">dir(Person)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__class__'</span>, <span class="string">'__delattr__'</span>, <span class="string">'__dict__'</span>, <span class="string">'__dir__'</span>, <span class="string">'__doc__'</span>, <span class="string">'__format__'</span>, <span class="string">'__getattribute__'</span>, <span class="string">'__hash__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'__new__'</span>, <span class="string">'__reduce__'</span>,<span class="string">'__reduce_ex__'</span>, <span class="string">'__repr__'</span>, <span class="string">'__setattr__'</span>, <span class="string">'__sizeof__'</span>, <span class="string">'__str__'</span>, <span class="string">'__subclasshook__'</span>, <span class="string">'__weakref__'</span>]</span><br><span class="line"></span><br><span class="line">tom = Person()</span><br><span class="line">dir(tom)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'age'</span>, <span class="string">'country'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li><li><p>delattr函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">tom = Person(<span class="string">"Tom"</span>, <span class="number">35</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir(tom)[<span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'age'</span>, <span class="string">'name'</span>]</span><br><span class="line"></span><br><span class="line">delattr(tom, <span class="string">"age"</span>)</span><br><span class="line">dir(tom)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'__doc__'</span>, <span class="string">'__init__'</span>, <span class="string">'__module__'</span>, <span class="string">'name'</span>]</span><br></pre></td></tr></table></figure></li><li><p>divmod函数</p><ul><li>divmod(a,b)方法返回的是a//b（除法取整）以及a对b的余数；返回结果类型为tuple</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">divmod(<span class="number">9</span>,<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">divmod(<span class="number">11</span>,<span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">3</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">divmod(<span class="number">1</span>+<span class="number">2j</span>,<span class="number">1</span>+<span class="number">0.5j</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>((<span class="number">1</span>+<span class="number">0j</span>), <span class="number">1.5j</span>)</span><br></pre></td></tr></table></figure><ul><li><p>id函数</p><ul><li>返回的是对象的“身份证号”，唯一且不变，但在不重合的生命周期里，可能会出现相同的id值。此处所说的对象应该特指复合类型的对象(如类、list等)，对于字符串、整数等类型，变量的id是随值的改变而改变的。</li><li>用is判断两个对象是否相等时，依据就是这个id值；is与==的区别就是，is是内存中的比较，而==是值的比较<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Obj</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,arg)</span>:</span></span><br><span class="line">        self.x=arg  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:     </span><br><span class="line">    obj=Obj(<span class="number">1</span>)     </span><br><span class="line">    <span class="keyword">print</span> id(obj) <span class="comment">#32754432     </span></span><br><span class="line">    obj.x=<span class="number">2</span>     </span><br><span class="line">    <span class="keyword">print</span> id(obj) <span class="comment">#32754432     </span></span><br><span class="line">    s=<span class="string">"abc"</span>     </span><br><span class="line">    <span class="keyword">print</span> id(s) <span class="comment">#140190448953184     </span></span><br><span class="line">    s=<span class="string">"bcd"</span>     </span><br><span class="line">    <span class="keyword">print</span> id(s) <span class="comment">#32809848     </span></span><br><span class="line">    x=<span class="number">1</span>     </span><br><span class="line">    <span class="keyword">print</span> id(x) <span class="comment">#15760488     </span></span><br><span class="line">    x=<span class="number">2</span>     </span><br><span class="line">    <span class="keyword">print</span> id(x) <span class="comment">#15760464</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>int函数</p><ul><li>函数的作用是将一个数字或base类型的字符串转换成整数。<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1. x 是数字的情况：</span></span><br><span class="line">int(<span class="number">3.14</span>)</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line">int(<span class="number">2e2</span>) <span class="comment"># 200</span></span><br><span class="line">int(<span class="number">100</span>, <span class="number">2</span>) <span class="comment"># 出错，base 被赋值后函数只接收字符串# 2. x 是字符串的情况：int('23', 16) # 35int('Pythontab', 8) # 出错，Pythontab不是个8进制数# 3. base 可取值范围是 2~36，囊括了所有的英文字母(不区分大小写)，十六进制中F表示15，那么G将在二十进制中表示16，依此类推....Z在三十六进制中表示35int('FZ', 16) # 出错，FZ不能用十六进制表示int('FZ', 36) # 575# 4. 字符串 0x 可以出现在十六进制中，视作十六进制的符号，同理 0b 可以出现在二进制中，除此之外视作数字 0 和字母 xint('0x10', 16) # 16，0x是十六进制的符号int('0x10', 17) # 出错，'0x10'中的 x 被视作英文字母 xint('0x10', 36) # 42804，36进制包含字母 x</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>enumerate函数<ul><li>enumerate(sequence, [start=0])</li><li>将可循环序列sequence以start开始分别列出序列数据和数据下标</li></ul></li></ul><ul><li>pow</li><li>abs</li><li>round</li><li>hex</li><li>bin</li><li>range</li><li>lambda</li><li>map</li><li>zip</li><li>getattr()　　获取对象的属性</li><li>globals()　　返回一个描述当前全局变量的字典</li><li>hasattr()</li><li>hash()　　哈希值</li><li>issubclass()　　检查一个类是否是另一个类的子类。返回True或False</li><li>iter()</li><li>locals()　　打印当前可用的局部变量的字典</li><li>max()　　返回给定元素里最大值</li><li>min()　　返回给定元素里最小值</li><li>meoryview()</li><li>next()　　返回一个可迭代数据结构（如列表）中的下一项</li><li>open()　　打开文件</li><li>pow()　　幂函数</li><li>print()</li><li>property()</li><li>repr()　　将任意值转换为字符串，供计时器读取的形式</li><li>reversed()　　　反转，逆序对象</li><li>round()</li><li>set()    class set([iterable])  返回一个新的set对象，可以选择从iterable取得的元素，set是一个内置的类</li><li>setattr()　　与getattr()相对应，setattr(object,name,value) 参数是一个对象，一个字符串和一个任意值。字符串可以命名现有属性或新属性。如果对象允许，该函数将赋值给该属性</li><li>slice()　　切片功能,  slice(start, stop[, step])</li><li>sorted()　　排序</li><li>vars()　vars([object])  使用<strong>dict</strong>属性返回模块，类，实例或任何其他对象的<strong>dict</strong>属性。</li><li>type()　　显示对象所属的类型</li><li>tuple()　　元组构造函数</li><li>super()　　调用父类的方法</li><li>str()</li><li>sum()</li><li>staticmethod()  在类中定义一个静态方法的函数，通常@staticmethod 下面接一个函数，如此使用</li><li>list()</li><li>len()</li><li>input()　　获取用户输入内容</li><li>id()</li><li>help()　　返回对象的帮助文档</li><li>frozenset()　　创建一个不可修改的集合。</li><li>format()</li><li>float()　　讲一个字符串或整数转换为浮点数。</li><li>filter()　　过滤器，构造一个序列，等价于[ item for item in iterables if function(item)]，在函数中设定过滤条件，逐一循环迭代器中的元素，将返回值为True时的元素留下，形成一个filter类型数据</li><li>exec()　　执行字符串或complie方法编译过的字符串，没有返回值</li><li>evel()</li><li>enumerate()　　返回一个可以枚举的对象，该对象的next()方法将返回一个元组</li><li>delattr()　　删除对象的属性</li><li>classmethod()　　用来指定一个方法为类的方法，由类直接调用执行，只有一个cls参数,执行雷的方法时，自动将调用该方法的类赋值给cls.没有此参数指定的类的方法为实例方法。</li></ul><blockquote><h6 id="type和isinstance两个方法的异同点？"><a href="#type和isinstance两个方法的异同点？" class="headerlink" title="type和isinstance两个方法的异同点？"></a>type和isinstance两个方法的异同点？</h6></blockquote><ul><li><p>1.type() 不会认为子类是一种父类类型，不考虑继承关系。isinstance() 会认为子类是一种父类类型，考虑继承关系。</p></li><li><p>2.如果要判断两个类型是否相同推荐使用 isinstance()。</p></li><li><p>例如下面</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">2</span></span><br><span class="line">isinstance (a,int) <span class="comment">#True</span></span><br><span class="line">isinstance (a,str) <span class="comment">#False</span></span><br><span class="line">isinstance (a,(str,int,list)) <span class="comment"># 是元组中的一个返回 TrueTrue</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span>   </span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">isinstance(A(), A) <span class="comment"># returns True</span></span><br><span class="line">type(A()) == A <span class="comment"># returns True</span></span><br><span class="line">isinstance(B(), A) <span class="comment"># returns True</span></span><br><span class="line">type(B()) == A <span class="comment"># returns False</span></span><br></pre></td></tr></table></figure></li><li><p>1.参数赋值：按位置，键值传参，按位置和键值传参</p></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-pymysql</title>
      <link href="/man/python/lib-pymysql.html"/>
      <url>/man/python/lib-pymysql.html</url>
      
        <content type="html"><![CDATA[<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>MysqlDB</li><li>pymysql</li><li>mysqlconnet<h3 id="MysqlDB"><a href="#MysqlDB" class="headerlink" title="MysqlDB"></a>MysqlDB</h3></li><li>(1) 什么是MySQLdb？<ul><li>MySQLdb 是用于 Python 连接 MySQL 数据库的接口，它实现了 Python 数据库 API 规范 V2.0，基于 MySQL C API 上建立的。</li></ul></li><li>使用<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> MySQLdb</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = MySQLdb.connect(<span class="string">"localhost"</span>,<span class="string">"hp"</span>,<span class="string">"Hp12345."</span>,<span class="string">"TESTDB"</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="PyMySQL"><a href="#PyMySQL" class="headerlink" title="PyMySQL"></a>PyMySQL</h3><ul><li>安装：pip install PyMysql</li><li>操作<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = pymysql.connect(<span class="string">"localhost"</span>,<span class="string">"hp"</span>,<span class="string">"Hp12345."</span>,<span class="string">"TESTDB"</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><h3 id="mysql-connector-的使用"><a href="#mysql-connector-的使用" class="headerlink" title="mysql.connector 的使用"></a>mysql.connector 的使用</h3><ul><li><p>(1) 什么是 mysql.connector？</p><ul><li>由于 MySQL 服务器以独立的进程运行，并通过网络对外服务，所以，需要支持 Python 的 MySQL 驱动来连接到 MySQL 服务器。</li><li>目前，有两个 MySQL 驱动：<ul><li>mysql-connector-python：是 MySQL 官方的纯 Python 驱动；</li><li>MySQL-python ：是封装了 MySQL C驱动的 Python 驱动。</li></ul></li></ul></li><li><p>安装 mysql.connector:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install mysql-connector-python</span><br><span class="line">pip install MySQL-python</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line">!/usr/bin/env python</span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> mysql.connector</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">connectdb</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'连接到mysql服务器...'</span>)</span><br><span class="line">    <span class="comment"># 打开数据库连接</span></span><br><span class="line">    <span class="comment"># 用户名:hp, 密码:Hp12345.,用户名和密码需要改成你自己的mysql用户名和密码，并且要创建数据库TESTDB，并在TESTDB数据库中创建好表Student</span></span><br><span class="line">    db = mysql.connector.connect(user=<span class="string">"hp"</span>, passwd=<span class="string">"Hp12345."</span>, database=<span class="string">"TESTDB"</span>, use_unicode=<span class="literal">True</span>)</span><br><span class="line">    print(<span class="string">'连接上了!'</span>)</span><br><span class="line">    <span class="keyword">return</span> db</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createtable</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># 如果存在表Sutdent先删除</span></span><br><span class="line">    cursor.execute(<span class="string">"DROP TABLE IF EXISTS Student"</span>)</span><br><span class="line">    sql = <span class="string">"""CREATE TABLE Student (</span></span><br><span class="line"><span class="string">            ID CHAR(10) NOT NULL,</span></span><br><span class="line"><span class="string">            Name CHAR(8),</span></span><br><span class="line"><span class="string">            Grade INT )"""</span></span><br><span class="line">    <span class="comment"># 创建Sutdent表</span></span><br><span class="line">    cursor.execute(sql)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insertdb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 插入语句</span></span><br><span class="line">    sql = <span class="string">"""INSERT INTO Student</span></span><br><span class="line"><span class="string">         VALUES ('001', 'CZQ', 70),</span></span><br><span class="line"><span class="string">                ('002', 'LHQ', 80),</span></span><br><span class="line"><span class="string">                ('003', 'MQ', 90),</span></span><br><span class="line"><span class="string">                ('004', 'WH', 80),</span></span><br><span class="line"><span class="string">                ('005', 'HP', 70),</span></span><br><span class="line"><span class="string">                ('006', 'YF', 66),</span></span><br><span class="line"><span class="string">                ('007', 'TEST', 100)"""</span></span><br><span class="line">    <span class="comment">#sql = "INSERT INTO Student(ID, Name, Grade) \</span></span><br><span class="line">    <span class="comment"># VALUES ('%s', '%s', '%d')" % \</span></span><br><span class="line">    <span class="comment"># ('001', 'HP', 60)</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行sql语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="comment"># Rollback in case there is any error</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">'插入数据失败!'</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">querydb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 查询语句</span></span><br><span class="line">    <span class="comment">#sql = "SELECT * FROM Student \</span></span><br><span class="line">    <span class="comment"># WHERE Grade &gt; '%d'" % (80)</span></span><br><span class="line">    sql = <span class="string">"SELECT * FROM Student"</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 获取所有记录列表</span></span><br><span class="line">        results = cursor.fetchall()</span><br><span class="line">        <span class="keyword">for</span> row <span class="keyword">in</span> results:</span><br><span class="line">            ID = row[<span class="number">0</span>]</span><br><span class="line">            Name = row[<span class="number">1</span>]</span><br><span class="line">            Grade = row[<span class="number">2</span>]</span><br><span class="line">            <span class="comment"># 打印结果</span></span><br><span class="line">            <span class="keyword">print</span> <span class="string">"ID: %s, Name: %s, Grade: %d"</span> % \</span><br><span class="line">                (ID, Name, Grade)</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"Error: unable to fecth data"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deletedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 删除语句</span></span><br><span class="line">    sql = <span class="string">"DELETE FROM Student WHERE Grade = '%d'"</span> % (<span class="number">100</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">       <span class="comment"># 执行SQL语句</span></span><br><span class="line">       cursor.execute(sql)</span><br><span class="line">       <span class="comment"># 提交修改</span></span><br><span class="line">       db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'删除数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">updatedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    <span class="comment"># 使用cursor()方法获取操作游标</span></span><br><span class="line">    cursor = db.cursor()</span><br><span class="line">    <span class="comment"># SQL 更新语句</span></span><br><span class="line">    sql = <span class="string">"UPDATE Student SET Grade = Grade + 3 WHERE ID = '%s'"</span> % (<span class="string">'003'</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 执行SQL语句</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        <span class="comment"># 提交到数据库执行</span></span><br><span class="line">        db.commit()</span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'更新数据失败!'</span></span><br><span class="line">        <span class="comment"># 发生错误时回滚</span></span><br><span class="line">        db.rollback()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">closedb</span><span class="params">(db)</span>:</span></span><br><span class="line">    db.close()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    db = connectdb() <span class="comment"># 连接MySQL数据库</span></span><br><span class="line">    createtable(db) <span class="comment"># 创建表</span></span><br><span class="line">    insertdb(db) <span class="comment"># 插入数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n插入数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    deletedb(db) <span class="comment"># 删除数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n删除数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    updatedb(db) <span class="comment"># 更新数据</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'\n更新数据后:'</span></span><br><span class="line">    querydb(db)</span><br><span class="line">    closedb(db) <span class="comment"># 关闭数据库</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_func</span><span class="params">(url)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> requests.Session() <span class="keyword">as</span> r:</span><br><span class="line">        r.get(url)</span><br><span class="line">ThreadPool(<span class="number">128</span>).map(my_func, open(<span class="string">'urls.txt'</span>))</span><br></pre></td></tr></table></figure>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python库-sqlalchemy</title>
      <link href="/man/python/lib-sqlalchemy.html"/>
      <url>/man/python/lib-sqlalchemy.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h4 id="1-字段类型"><a href="#1-字段类型" class="headerlink" title="1.字段类型"></a>1.字段类型</h4><ul><li>整形.<ul><li>Integer/BigInteger/SmallInteger</li></ul></li><li>布尔类型. Python 中表现为 True/False , 数据库根据支持情况, 表现为 BOOLEAN 或SMALLINT . 实例化时可以指定是否创建约束(默认创建).<ul><li>Boolean</li></ul></li><li>日期类型, Time 和 DateTime 实例化时可以指定是否带时区信息.<ul><li>Date/DateTime/Time (timezone=False)</li></ul></li><li>时间偏差类型. 在 Python 中表现为 datetime.timedelta() , 数据库不支持此类型则存为日期.<ul><li>Interval</li></ul></li><li>枚举类型, 根据数据库支持情况, SQLAlchemy 会使用原生支持或者使用 VARCHAR 类型附加约束的方式实现. 原生支持中涉及新类型创建, 细节在实例化时控制.<ul><li>Enum</li></ul></li><li>浮点小数.<ul><li>Float</li></ul></li><li>定点小数, Python 中表现为 Decimal .<ul><li>Numeric (precision=None, scale=None, decimal_return_scale=None, …)</li></ul></li><li>字节数据. 根据数据库实现, 在实例化时可能需要指定大小.<ul><li>LargeBinary (length=None)</li></ul></li><li>Python 对象的序列化类型.<ul><li>PickleType</li></ul></li><li>字符串类型, Python 中表现为 Unicode , 数据库表现为 VARCHAR , 通常都需要指定长度.<ul><li>String (length=None, collation=None, …)</li></ul></li><li>类似与字符串类型, 在某些数据库实现下, 会明确表示支持非 ASCII 字符. 同时输入输出也强制是 Unicode 类型.<ul><li>Unicode</li></ul></li><li>长文本类型, Python 表现为 Unicode , 数据库表现为 TEXT .<ul><li>Text</li></ul></li><li>参考 Unicode .<ul><li>UnicodeText</li></ul></li></ul><h4 id="2-查询方式"><a href="#2-查询方式" class="headerlink" title="2.查询方式"></a>2.查询方式</h4><ul><li><p>建立表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, create_engine, Integer, DateTime</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.ext.declarative <span class="keyword">import</span> declarative_base</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建对象的基类:</span></span><br><span class="line">Base = declarative_base()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span><span class="params">(Base)</span>:</span></span><br><span class="line">    <span class="comment"># 表的名字:</span></span><br><span class="line">    __tablename__ = <span class="string">'user'</span></span><br><span class="line"></span><br><span class="line">    id = Column(Integer, primary_key=<span class="literal">True</span>)</span><br><span class="line">    name = Column(String(<span class="number">20</span>))</span><br><span class="line">    <span class="comment"># 数据库设置默认值 需是字符串</span></span><br><span class="line">    is_vip = Column(Integer, server_default=<span class="string">'0'</span>)</span><br><span class="line">    <span class="comment"># 默认值是创建时间 不自动更新</span></span><br><span class="line">    create_time = Column(DateTime, nullable=<span class="literal">False</span>, server_default=func.now())</span><br><span class="line">    <span class="comment"># 自动更新 需要设置nullable=False</span></span><br><span class="line">    update_time = Column(TIMESTAMP, nullable=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化数据库连接:</span></span><br><span class="line">engine = create_engine(<span class="string">'mysql+pymysql://root:111111@localhost:3306/testdb'</span>)</span><br><span class="line">Base.metadata.create_all(engine)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> Column, String, Integer, DateTime, TIMESTAMP</span><br><span class="line"><span class="keyword">from</span> sqlalchemy.sql <span class="keyword">import</span> func</span><br></pre></td></tr></table></figure></li><li><p>常见查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> and_, or_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#简单查询</span></span><br><span class="line">print(session.query(User).all())</span><br><span class="line">print(session.query(User.name, User.fullname).all())</span><br><span class="line">print(session.query(User, User.name).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#带条件查询</span></span><br><span class="line">print(session.query(User).filter_by(name=<span class="string">'user1'</span>).all())</span><br><span class="line">print(session.query(User).filter(User.name == <span class="string">"user"</span>).all())</span><br><span class="line">print(session.query(User).filter(User.name.like(<span class="string">"user%"</span>)).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#多条件查询</span></span><br><span class="line">print(session.query(User).filter(and_(User.name.like(<span class="string">"user%"</span>), User.fullname.like(<span class="string">"first%"</span>))).all())</span><br><span class="line">print(session.query(User).filter(or_(User.name.like(<span class="string">"user%"</span>), User.password != <span class="literal">None</span>)).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#sql过滤</span></span><br><span class="line">print(session.query(User).filter(<span class="string">"id&gt;:id"</span>).params(id=<span class="number">1</span>).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#关联查询</span></span><br><span class="line">print(session.query(User, Address).filter(User.id == Address.user_id).all())</span><br><span class="line">print(session.query(User).join(User.addresses).all())</span><br><span class="line">print(session.query(User).outerjoin(User.addresses).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#聚合查询</span></span><br><span class="line">print(session.query(User.name, func.count(<span class="string">'*'</span>).label(<span class="string">"user_count"</span>)).group_by(User.name).all())</span><br><span class="line">print(session.query(User.name, func.sum(User.id).label(<span class="string">"user_id_sum"</span>)).group_by(User.name).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#子查询</span></span><br><span class="line">stmt = session.query(Address.user_id, func.count(<span class="string">'*'</span>).label(<span class="string">"address_count"</span>)).group_by(Address.user_id).subquery()</span><br><span class="line">print(session.query(User, stmt.c.address_count).outerjoin((stmt, User.id == stmt.c.user_id)).order_by(User.id).all())</span><br><span class="line"></span><br><span class="line"><span class="comment">#exists</span></span><br><span class="line">print(session.query(User).filter(exists().where(Address.user_id == User.id)))</span><br><span class="line">print(session.query(User).filter(User.addresses.any())</span><br><span class="line"></span><br><span class="line"><span class="comment"># in查询</span></span><br><span class="line">query = Account.query.filter(Account.id.in_(account_ids)).order_by(Account.date_created.desc())</span><br><span class="line"></span><br><span class="line"><span class="comment"># between and</span></span><br><span class="line">qry = DBSession.query(User).filter(User.birthday.between(<span class="string">'1985-01-17'</span>, <span class="string">'1988-01-17'</span>))</span><br><span class="line">qry = DBSession.query(User).filter(and_(User.birthday &lt;= <span class="string">'1988-01-17'</span>, User.birthday &gt;= <span class="string">'1985-01-17'</span>))</span><br></pre></td></tr></table></figure></li><li><p>限制返回字段查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">person = session.query(Person.name, Person.created_at,                 Person.updated_at).filter_by(name=<span class="string">"zhongwei"</span>).order_by(Person.created_at).first()</span><br></pre></td></tr></table></figure></li><li><p>记录总数查询</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># count User records, without</span></span><br><span class="line"><span class="comment"># using a subquery.</span></span><br><span class="line">session.query(func.count(User.id))</span><br><span class="line"></span><br><span class="line"><span class="comment"># return count of user "id" grouped</span></span><br><span class="line"><span class="comment"># by "name"</span></span><br><span class="line">session.query(func.count(User.id)).group_by(User.name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> sqlalchemy <span class="keyword">import</span> distinct</span><br><span class="line"></span><br><span class="line"><span class="comment"># count distinct "name" values</span></span><br><span class="line">session.query(func.count(distinct(User.name)))</span><br></pre></td></tr></table></figure><ul><li><p>根据唯一键操作：有就不插入，没有有就插入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">insert_stmt = insert(IpDisabled).values(disabled_ips) <span class="comment"># 可以list或dict</span></span><br><span class="line">on_duplicate_key_stmt = insert_stmt.on_duplicate_key_update(</span><br><span class="line">    site=insert_stmt.inserted.site,</span><br><span class="line">    ip=insert_stmt.inserted.ip)</span><br><span class="line">session.execute(on_duplicate_key_stmt)</span><br><span class="line">session.commit()</span><br></pre></td></tr></table></figure></li><li><p>单个添加</p><ul><li>session.add()</li></ul></li><li><p>批量添加</p><ul><li>session.add_all()</li><li>如果有一个插入报错了，其他的都会插入吗?<ul><li>有一个报错，全部都不写入了。</li></ul></li></ul></li></ul><p>进阶<br>from sqlalchemy import create_engine<br>from sqlalchemy.orm import sessionmaker<br>DB_CONNECT_STRING = ‘mysql+mysqldb://root:123@localhost/ooxx?charset=utf8’<br>engine = create_engine(DB_CONNECT_STRING, echo=True)<br>DB_Session = sessionmaker(bind=engine)<br>session = DB_Session()<br>这里的 DB_CONNECT_STRING 就是连接数据库的路径。“mysql+mysqldb”指定了使用 MySQL-Python 来连接，“root”和“123”分别是用户名和密码，“localhost”是数据库的域名，“ooxx”是使用的数据库名（可省略），“charset”指定了连接时使用的字符集（可省略）。<br>create_engine() 会返回一个数据库引擎，echo 参数为 True 时，会显示每条执行的 SQL 语句，生产环境下可关闭。<br>sessionmaker() 会生成一个数据库会话类。这个类的实例可以当成一个数据库连接，它同时还记录了一些查询的数据，并决定什么时候执行 SQL 语句。由于 SQLAlchemy 自己维护了一个数据库连接池（默认 5 个连接），因此初始化一个会话的开销并不大。对 Tornado 而言，可以在 BaseHandler 的 initialize() 里初始化：<br>class BaseHandler(tornado.web.RequestHandler):<br>    def initialize(self):<br>        self.session = models.DB_Session()</p><pre><code>def on_finish(self):    self.session.close()</code></pre><p>对其他 Web 服务器来说，可以使用 sqlalchemy.orm.scoped_session，它能保证每个线程获得的 session 对象都是唯一的。不过 Tornado 本身就是单线程的，如果使用了异步方式，就可能会出现问题，因此并没使用它。</p><p>拿到 session 后，就可以执行 SQL 了：<br>session.execute(‘create database abc’)<br>print session.execute(‘show databases’).fetchall()<br>session.execute(‘use abc’)</p><h1 id="建-user-表的过程略"><a href="#建-user-表的过程略" class="headerlink" title="建 user 表的过程略"></a>建 user 表的过程略</h1><p>print session.execute(‘select * from user where id = 1’).first()<br>print session.execute(‘select * from user where id = :id’, {‘id’: 1}).first()<br>不过这和直接使用 MySQL-Python 没啥区别；ORM 的方式，这也是采用 SQLAlchemy 的唯一原因。</p><p>于是来定义一个表：<br>from sqlalchemy import Column<br>from sqlalchemy.types import CHAR, Integer, String<br>from sqlalchemy.ext.declarative import declarative_base</p><p>BaseModel = declarative_base()</p><p>def init_db():<br>    BaseModel.metadata.create_all(engine)</p><p>def drop_db():<br>    BaseModel.metadata.drop_all(engine)</p><p>class User(BaseModel):<br>    <strong>tablename</strong> = ‘user’</p><pre><code>id = Column(Integer, primary_key=True)name = Column(CHAR(30)) # or Column(String(30))</code></pre><p>init_db()<br>declarative_base() 创建了一个 BaseModel 类，这个类的子类可以自动与一个表关联。<br>以 User 类为例，它的 <strong>tablename</strong> 属性就是数据库中该表的名称，它有 id 和 name 这两个字段，分别为整型和 30 个定长字符。Column 还有一些其他的参数，我就不解释了。<br>最后，BaseModel.metadata.create_all(engine) 会找到 BaseModel 的所有子类，并在数据库中建立这些表；drop_all() 则是删除这些表。</p><p>接着就开始使用这个表吧：<br>from sqlalchemy import func, or_, not_</p><p>user = User(name=’a’)<br>session.add(user)<br>user = User(name=’b’)<br>session.add(user)<br>user = User(name=’a’)<br>session.add(user)<br>user = User()<br>session.add(user)<br>session.commit()</p><p>query = session.query(User)<br>print query # 显示SQL 语句<br>print query.statement # 同上<br>for user in query: # 遍历时查询<br>    print user.name<br>print query.all() # 返回的是一个类似列表的对象<br>print query.first().name # 记录不存在时，first() 会返回 None<br>print query.one().name # 不存在，或有多行记录时会抛出异常<br>print query.filter(User.id == 2).first().name<br>print query.get(2).name # 以主键获取，等效于上句<br>print query.filter(‘id = 2’).first().name # 支持字符串</p><p>query2 = session.query(User.name)<br>print query2.all() # 每行是个元组<br>print query2.limit(1).all() # 最多返回 1 条记录<br>print query2.offset(1).all() # 从第 2 条记录开始返回<br>print query2.order_by(User.name).all()<br>print query2.order_by(‘name’).all()<br>print query2.order_by(User.name.desc()).all()<br>print query2.order_by(‘name desc’).all()<br>print session.query(User.id).order_by(User.name.desc(), User.id).all()</p><p>print query2.filter(User.id == 1).scalar() # 如果有记录，返回第一条记录的第一个元素<br>print session.query(‘id’).select_from(User).filter(‘id = 1’).scalar()<br>print query2.filter(User.id &gt; 1, User.name != ‘a’).scalar() # and<br>query3 = query2.filter(User.id &gt; 1) # 多次拼接的 filter 也是 and<br>query3 = query3.filter(User.name != ‘a’)<br>print query3.scalar()<br>print query2.filter(or_(User.id == 1, User.id == 2)).all() # or<br>print query2.filter(User.id.in_((1, 2))).all() # in</p><p>query4 = session.query(User.id)<br>print query4.filter(User.name == None).scalar()<br>print query4.filter(‘name is null’).scalar()<br>print query4.filter(not_(User.name == None)).all() # not<br>print query4.filter(User.name != None).all()</p><p>print query4.count()<br>print session.query(func.count(‘<em>‘)).select_from(User).scalar()<br>print session.query(func.count(‘1’)).select_from(User).scalar()<br>print session.query(func.count(User.id)).scalar()<br>print session.query(func.count(‘</em>‘)).filter(User.id &gt; 0).scalar() # filter() 中包含 User，因此不需要指定表<br>print session.query(func.count(‘*’)).filter(User.name == ‘a’).limit(1).scalar() == 1 # 可以用 limit() 限制 count() 的返回数<br>print session.query(func.sum(User.id)).scalar()<br>print session.query(func.now()).scalar() # func 后可以跟任意函数名，只要该数据库支持<br>print session.query(func.current_timestamp()).scalar()<br>print session.query(func.md5(User.name)).filter(User.id == 1).scalar()</p><p>query.filter(User.id == 1).update({User.name: ‘c’})<br>user = query.get(1)<br>print user.name</p><p>user.name = ‘d’<br>session.flush() # 写数据库，但并不提交<br>print query.get(1).name</p><p>session.delete(user)<br>session.flush()<br>print query.get(1)</p><p>session.rollback()<br>print query.get(1).name<br>query.filter(User.id == 1).delete()<br>session.commit()<br>print query.get(1)</p><p>二、进阶的知识。<br>1）如何批量插入大批数据？<br>可以使用非 ORM 的方式：<br>session.execute(<br>    User.<strong>table</strong>.insert(),<br>    [{‘name’: <code>randint(1, 100)</code>,’age’: randint(1, 100)} for i in xrange(10000)]<br>)<br>session.commit()</p><p>如何批量插入大批数据？<br>可以使用非 ORM 的方式：<br>session.execute(<br>    User.<strong>table</strong>.insert(),<br>    [{‘name’: <code>randint(1, 100)</code>,’age’: randint(1, 100)} for i in xrange(10000)]<br>)<br>session.commit()<br>上面批量插入了 10000 条记录，半秒内就执行完了；而 ORM 方式会花掉很长时间。</p><p>2）如何让执行的 SQL 语句增加前缀？<br>使用 query 对象的 prefix_with() 方法：<br>session.query(User.name).prefix_with(‘HIGH_PRIORITY’).all()<br>session.execute(User.<strong>table</strong>.insert().prefix_with(‘IGNORE’), {‘id’: 1, ‘name’: ‘1’})</p><p>3）如何替换一个已有主键的记录？<br>使用 session.merge() 方法替代 session.add()，其实就是 SELECT + UPDATE：<br>user = User(id=1, name=’ooxx’)<br>session.merge(user)<br>session.commit()<br>或者使用 MySQL 的 INSERT … ON DUPLICATE KEY UPDATE，需要用到 @compiles 装饰器，有点难懂，自己看吧：《SQLAlchemy ON DUPLICATE KEY UPDATE》 和 sqlalchemy_mysql_ext。</p><p>4）如何使用无符号整数？<br>可以使用 MySQL 的方言：<br>from sqlalchemy.dialects.mysql import INTEGER</p><p>id = Column(INTEGER(unsigned=True), primary_key=True)</p><p>5）模型的属性名需要和表的字段名不一样怎么办？<br>开发时遇到过一个奇怪的需求，有个其他系统的表里包含了一个“from”字段，这在 Python 里是关键字，于是只能这样处理了：<br>from_ = Column(‘from’, CHAR(10))</p><p>6）如何获取字段的长度？<br>Column 会生成一个很复杂的对象，想获取长度比较麻烦，这里以 User.name 为例：<br>User.name.property.columns[0].type.length</p><p>7）如何指定使用 InnoDB，以及使用 UTF-8 编码？<br>最简单的方式就是修改数据库的默认配置。如果非要在代码里指定的话，可以这样：<br>class User(BaseModel):<br>    <strong>table_args</strong> = {<br>        ‘mysql_engine’: ‘InnoDB’,<br>        ‘mysql_charset’: ‘utf8’<br>    }<br>MySQL 5.5 开始支持存储 4 字节的 UTF-8 编码的字符了，iOS 里自带的 emoji（如</p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python网络操作</title>
      <link href="/man/python/net.html"/>
      <url>/man/python/net.html</url>
      
        <content type="html"><![CDATA[<h2 id="网络操作"><a href="#网络操作" class="headerlink" title="网络操作"></a>网络操作</h2><ul><li>http请求</li><li>socket编程</li></ul><h2 id="IO多路复用之epoll"><a href="#IO多路复用之epoll" class="headerlink" title="IO多路复用之epoll"></a>IO多路复用之epoll</h2><h4 id="1、内核EPOLL模型讲解"><a href="#1、内核EPOLL模型讲解" class="headerlink" title="1、内核EPOLL模型讲解"></a>1、内核EPOLL模型讲解</h4><p>首先我们来定义流的概念，一个流可以是文件，socket，pipe等可以进行I/O操作的内核对象。不管是文件，还是套接字(socket)，还是管道(pipe)，我们都可以把他们看作流。</p><p>之后我们来讨论I/O操作，通过read，我们可以从流中读入数据；通过write，我们可以往流中写入数据。现在假定1种情形，我们需要从流中读数据，但是流中还没有数据，（典型的例子为，客户端要从socket读数据，但是服务器端还没有把数据传回来），这时候该怎么办？</p><p>阻塞：阻塞是个什么概念呢？比如某个时候你在等快递，但是你还不知道快递什么时候过来，而且你也没有别的事可以干（或者说接下来的事要等快递来了才能做）；那么你可以去睡觉了，因为你知道快递把货送来时一定会给你打电话（假定一定能叫醒你）。</p><p>非阻塞忙轮询：接着上面等快递的例子，如果用忙轮询的方法，那么你需要知道快递员的手机号，然后每分钟给他打个电话：“你到了没？”</p><p>很明显一般人不会用第二种做法，不仅显得无脑，浪费话费不说，还占用了快递员大量的时间。</p><p>大部分程序也不会用第二种做法，因为第一种方法经济而简单，经济是指消耗很少的CPU时间，如果线程睡眠了，就掉出了系统的调度队列，暂时不会去瓜分CPU宝贵的时间片。</p><p>为了了解阻塞是如何进行的，我们来讨论缓冲区，以及内核缓冲区，最终把I/O事件解释清楚。缓冲区的引入是为了减少频繁I/O操作而引起频繁的系统调用（你知道它很慢的），当你操作一个流时，更多的是以缓冲区为单位进行操作，这是相对于用户空间而言。对于内核来说，也<br>需要缓冲区。</p><p>假设有一个管道，进程A为管道的写入方，B为管道的读出方。假设一开始内核缓冲区是空的，B作为读出方，被阻塞着。然后首先A往管道写入，这时候内核缓冲区由空的状态变到非空状态，内核就会产生一个事件告诉B该醒来了，这个事件姑且称之为“缓冲区非空”。但是“缓冲区非空”事件通知B后，B却还没有读出数据；且内核许诺了不能把写入管道中的数据丢掉这个时候，Ａ写入的数据会滞留在内核缓冲区中，如果内核也缓冲区满了，B仍未开始读数据，最终内核缓冲区会被填满，这个时候会产生一个I/O事件，告诉进程A，你该等等（阻塞）了，我们把这个事件定义为“缓冲区满”。假设后来Ｂ终于开始读数据了，于是内核的缓冲区空了出来，这时候内核会告诉A，内核缓冲区有空位了，你可以从长眠中醒来了，继续写数据了，我们把这个事件叫做“缓冲区非满”。也许事件Y1已经通知了A，但是A也没有数据写入了，而Ｂ继续读出数据，知道内核缓冲区空了。这个时候内核就告诉B，你需要阻塞了！，我们把这个时间定为“缓冲区空”。</p><p>这四种情形涵盖了四个I/O事件，内核缓冲区满，内核缓冲区空，内核缓冲区非空，内核缓冲区非满。这四个I/O事件是进行阻塞同步的根本。（如果不能理解“同步”是什么概念，请学习操作系统的锁，信号量，条件变量等任务同步方面的相关知识）。</p><p>然后我们来说说阻塞I/O的缺点。但是阻塞I/O模式下，一个线程只能处理一个流的I/O事件。如果想要同时处理多个流，要么多进程(fork)，要么多线程(pthread_create)，很不幸这两种方法效率都不高。于是再来考虑非阻塞忙轮询的I/O方式，我们发现可以同时处理多个流（把一个流从阻塞模式切换到非阻塞模式再此不予讨论）：</p><p>我们只要不停的把所有流从头到尾问一遍，又从头开始。这样就可以处理多个流了，但这样的做法显然不好，因为如果所有的流都没有数据，那么只会白白浪费CPU。这里要补充一点，阻塞模式下，内核对于I/O事件的处理是阻塞或者唤醒，而非阻塞模式下则把I/O事件交给其他对象（后文介绍的select以及epoll）处理甚至直接忽略。</p><p>为了避免CPU空转，可以引进一个代理（一开始有一位叫做select的代理，后来又有一位叫做poll的代理，不过两者的本质是一样的）。这个代理比较厉害，可以同时观察许多流的I/O事件，在空闲的时候，会把当前线程阻塞掉，当有一个或多个流有I/O事件时，就从阻塞态中醒来，于是我们的程序就会轮询一遍所有的流（于是我们可以把“忙”字去掉了）。</p><p>于是，如果没有I/O事件产生，我们的程序就会阻塞在select处。但是依然有个问题，我们从select那里仅仅知道了，有I/O事件发生了，但却并不知道是那几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。</p><p>但是使用select，我们有O(n)的无差别轮询复杂度，同时处理的流越多，每一次无差别轮询时间就越长。再次说了这么多，终于能好好解释epoll了。</p><p>epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll只会把哪个流发生了怎样的I/O事件通知我们。此时我们对这些流的操作都是有意义的（复杂度降低到了O(1)）。</p><p>linux下的多路复用<br>(1)select<br>    select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。<br>    select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。<br>    select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。<br>    另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟使得大 量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。<br>(2)poll<br>    poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。<br>    poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。<br>    另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll()的时候 将 再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。<br>(3)epoll<br>    直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。<br>    epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。<br>    epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表就绪描 述符数量的 值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术，这样便彻底省掉了这些文件描述符在 系统调用时复制的开销。<br>    另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll 中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某 个文件描述符就绪时，内核会采用类似callback的回调机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</p><p>python下的<br>Python中有一个select模块，其中提供了：select、poll、epoll三个方法，分别调用系统的 select，poll，epoll从而实现IO多路复用。<br>    Windows Python：提供： select<br>    Mac Python：提供： select<br>    Linux Python：提供： select、poll、epoll</p><h4 id="2-python中的epoll"><a href="#2-python中的epoll" class="headerlink" title="2. python中的epoll"></a>2. python中的epoll</h4><p>从以上可知，epoll是对select、poll模型的改进，提高了网络编程的性能，广泛应用于大规模并发请求的C/S架构中。<br>1、触发方式：<br>边缘触发/水平触发，只适用于Unix/Linux操作系统</p><p>2、原理图<br><img data-src="evernotecid://44669F3E-2F32-40F7-B5DC-DC9BDFBA5A31/appyinxiangcom/19062149/ENResource/p10811" alt="cf9f373f3bfe59a5cd0c7ef35c562f4b.jpeg"></p><p>3、一般步骤<br>    1. Create an epoll object——创建1个epoll对象<br>    2. Tell the epoll object to monitor specific events on specific sockets——告诉epoll对象，在指定的socket上监听指定的事件<br>    3. Ask the epoll object which sockets may have had the specified event since the last query——询问epoll对象，从上次查询以来，哪些socket发生了哪些指定的事件<br>    4. Perform some action on those sockets——在这些socket上执行一些操作<br>    5. Tell the epoll object to modify the list of sockets and/or events to monitor——告诉epoll对象，修改socket列表和（或）事件，并监控<br>    6. Repeat steps 3 through 5 until finished——重复步骤3-5，直到完成<br>    7. Destroy the epoll object——销毁epoll对象</p><p>4.相关用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> select 导入select模块</span><br><span class="line"></span><br><span class="line">epoll = select.epoll() 创建一个epoll对象</span><br><span class="line"></span><br><span class="line">epoll.register(文件句柄,事件类型) 注册要监控的文件句柄和事件</span><br><span class="line"></span><br><span class="line">事件类型:</span><br><span class="line"></span><br><span class="line">　　select.EPOLLIN    可读事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLOUT   可写事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLERR   错误事件</span><br><span class="line"></span><br><span class="line">　　select.EPOLLHUP   客户端断开事件</span><br><span class="line"></span><br><span class="line">epoll.unregister(文件句柄)   销毁文件句柄</span><br><span class="line"></span><br><span class="line">epoll.poll(timeout)  当文件句柄发生变化，则会以列表的形式主动报告给用户进程,timeout</span><br><span class="line"></span><br><span class="line">                     为超时时间，默认为<span class="number">-1</span>，即一直等待直到文件句柄发生变化，如果指定为<span class="number">1</span></span><br><span class="line"></span><br><span class="line">                     那么epoll每<span class="number">1</span>秒汇报一次当前文件句柄的变化情况，如果无变化则返回空</span><br><span class="line"></span><br><span class="line">epoll.fileno() 返回epoll的控制文件描述符(Return the epoll control file descriptor)</span><br><span class="line"></span><br><span class="line">epoll.modfiy(fineno,event) fineno为文件描述符 event为事件类型  作用是修改文件描述符所对应的事件</span><br><span class="line"></span><br><span class="line">epoll.fromfd(fileno) 从<span class="number">1</span>个指定的文件描述符创建<span class="number">1</span>个epoll对象</span><br><span class="line"></span><br><span class="line">epoll.close()   关闭epoll对象的控制文件描述符</span><br></pre></td></tr></table></figure><p>5 实例：客户端发送数据 服务端将接收的数据返回给客户端</p><ul><li><p>服务端代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建socket对象</span></span><br><span class="line">serversocket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#设置IP地址复用</span></span><br><span class="line">serversocket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line"><span class="comment">#ip地址和端口号</span></span><br><span class="line">server_address = (<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>)</span><br><span class="line"><span class="comment">#绑定IP地址</span></span><br><span class="line">serversocket.bind(server_address)</span><br><span class="line"><span class="comment">#监听，并设置最大连接数</span></span><br><span class="line">serversocket.listen(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">print</span>  <span class="string">"服务器启动成功，监听IP："</span> , server_address</span><br><span class="line"><span class="comment">#服务端设置非阻塞</span></span><br><span class="line">serversocket.setblocking(<span class="literal">False</span>)</span><br><span class="line"><span class="comment">#超时时间</span></span><br><span class="line">timeout = <span class="number">10</span></span><br><span class="line"><span class="comment">#创建epoll事件对象，后续要监控的事件添加到其中</span></span><br><span class="line">epoll = select.epoll()</span><br><span class="line"><span class="comment">#注册服务器监听fd到等待读事件集合</span></span><br><span class="line">epoll.register(serversocket.fileno(), select.EPOLLIN)</span><br><span class="line"><span class="comment">#保存连接客户端消息的字典，格式为&#123;&#125;</span></span><br><span class="line">message_queues = &#123;&#125;</span><br><span class="line"><span class="comment">#文件句柄到所对应对象的字典，格式为&#123;句柄：对象&#125;</span></span><br><span class="line">fd_to_socket = &#123;serversocket.fileno():serversocket,&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"等待活动连接......"</span></span><br><span class="line">  <span class="comment">#轮询注册的事件集合，返回值为[(文件句柄，对应的事件)，(...),....]</span></span><br><span class="line">  events = epoll.poll(timeout)</span><br><span class="line">  <span class="keyword">if</span> <span class="keyword">not</span> events:</span><br><span class="line">     <span class="keyword">print</span> <span class="string">"epoll超时无活动连接，重新轮询......"</span></span><br><span class="line">     <span class="keyword">continue</span></span><br><span class="line">  <span class="keyword">print</span> <span class="string">"有"</span> , len(events), <span class="string">"个新事件，开始处理......"</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> fd, event <span class="keyword">in</span> events:</span><br><span class="line">     socket = fd_to_socket[fd]</span><br><span class="line">     <span class="comment">#如果活动socket为当前服务器socket，表示有新连接</span></span><br><span class="line">     <span class="keyword">if</span> socket == serversocket:</span><br><span class="line">            connection, address = serversocket.accept()</span><br><span class="line">            <span class="keyword">print</span> <span class="string">"新连接："</span> , address</span><br><span class="line">            <span class="comment">#新连接socket设置为非阻塞</span></span><br><span class="line">            connection.setblocking(<span class="literal">False</span>)</span><br><span class="line">            <span class="comment">#注册新连接fd到待读事件集合</span></span><br><span class="line">            epoll.register(connection.fileno(), select.EPOLLIN)</span><br><span class="line">            <span class="comment">#把新连接的文件句柄以及对象保存到字典</span></span><br><span class="line">            fd_to_socket[connection.fileno()] = connection</span><br><span class="line">            <span class="comment">#以新连接的对象为键值，值存储在队列中，保存每个连接的信息</span></span><br><span class="line">            message_queues[connection]  = Queue.Queue()</span><br><span class="line">     <span class="comment">#关闭事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLHUP:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">'client close'</span></span><br><span class="line">        <span class="comment">#在epoll中注销客户端的文件句柄</span></span><br><span class="line">        epoll.unregister(fd)</span><br><span class="line">        <span class="comment">#关闭客户端的文件句柄</span></span><br><span class="line">        fd_to_socket[fd].close()</span><br><span class="line">        <span class="comment">#在字典中删除与已关闭客户端相关的信息</span></span><br><span class="line">        <span class="keyword">del</span> fd_to_socket[fd]</span><br><span class="line">     <span class="comment">#可读事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLIN:</span><br><span class="line">        <span class="comment">#接收数据</span></span><br><span class="line">        data = socket.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">if</span> data:</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"收到数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername()</span><br><span class="line">           <span class="comment">#将数据放入对应客户端的字典</span></span><br><span class="line">           message_queues[socket].put(data)</span><br><span class="line">           <span class="comment">#修改读取到消息的连接到等待写事件集合(即对应客户端收到消息后，再将其fd修改并加入写事件集合)</span></span><br><span class="line">           epoll.modify(fd, select.EPOLLOUT)</span><br><span class="line">     <span class="comment">#可写事件</span></span><br><span class="line">     <span class="keyword">elif</span> event &amp; select.EPOLLOUT:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">           <span class="comment">#从字典中获取对应客户端的信息</span></span><br><span class="line">           msg = message_queues[socket].get_nowait()</span><br><span class="line">        <span class="keyword">except</span> Queue.Empty:</span><br><span class="line">           <span class="keyword">print</span> socket.getpeername() , <span class="string">" queue empty"</span></span><br><span class="line">           <span class="comment">#修改文件句柄为读事件</span></span><br><span class="line">           epoll.modify(fd, select.EPOLLIN)</span><br><span class="line">        <span class="keyword">else</span> :</span><br><span class="line">           <span class="keyword">print</span> <span class="string">"发送数据："</span> , data , <span class="string">"客户端："</span> , socket.getpeername()</span><br><span class="line">           <span class="comment">#发送数据</span></span><br><span class="line">           socket.send(msg)</span><br><span class="line"></span><br><span class="line"><span class="comment">#在epoll中注销服务端文件句柄</span></span><br><span class="line">epoll.unregister(serversocket.fileno())</span><br><span class="line"><span class="comment">#关闭epoll</span></span><br><span class="line">epoll.close()</span><br><span class="line"><span class="comment">#关闭服务器socket</span></span><br><span class="line">serversocket.close()</span><br></pre></td></tr></table></figure></li><li><p>客户端代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#-*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建客户端socket对象</span></span><br><span class="line">clientsocket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line"><span class="comment">#服务端IP地址和端口号元组</span></span><br><span class="line">server_address = (<span class="string">'127.0.0.1'</span>,<span class="number">8888</span>)</span><br><span class="line"><span class="comment">#客户端连接指定的IP地址和端口号</span></span><br><span class="line">clientsocket.connect(server_address)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment">#输入数据</span></span><br><span class="line">    data = raw_input(<span class="string">'please input:'</span>)</span><br><span class="line">    <span class="comment">#客户端发送数据</span></span><br><span class="line">    clientsocket.sendall(data)</span><br><span class="line">    <span class="comment">#客户端接收数据</span></span><br><span class="line">    server_data = clientsocket.recv(<span class="number">1024</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'客户端收到的数据：'</span>server_data</span><br><span class="line">    <span class="comment">#关闭客户端socket</span></span><br><span class="line">    clientsocket.close()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>python线程与进程</title>
      <link href="/man/python/thread.html"/>
      <url>/man/python/thread.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程-进程"><a href="#线程-进程" class="headerlink" title="线程/进程"></a>线程/进程</h2><h3 id="线程与进程的区别"><a href="#线程与进程的区别" class="headerlink" title="线程与进程的区别"></a>线程与进程的区别</h3><p>*</p><ul><li>多线程执行</li><li>多进程执行</li><li>多进程共享变量</li><li>多线程锁如何使用</li><li>GIL</li></ul><p>看到这里，也许你会疑惑。这很正常，所以让我们带着问题来阅读本文章吧。<br>问题：<br>1、Python 多线程为什么耗时更长？<br>2、为什么在 Python 里面推荐使用多进程而不是多线程？<br>1 基础知识</p><p>现在的 PC 都是多核的，使用多线程能充分利用 CPU 来提供程序的执行效率。<br>1.1 线程</p><p>线程是一个基本的 CPU 执行单元。它必须依托于进程存活。一个线程是一个execution context（执行上下文），即一个 CPU 执行时所需要的一串指令。<br>1.2 进程</p><p>进程是指一个程序在给定数据集合上的一次执行过程，是系统进行资源分配和运行调用的独立单位。可以简单地理解为操作系统中正在执行的程序。也就说，每个应用程序都有一个自己的进程。<br>每一个进程启动时都会最先产生一个线程，即主线程。然后主线程会再创建其他的子线程。<br>1.3 两者的区别</p><ul><li>线程必须在某个进行中执行。</li><li>一个进程可包含多个线程，其中有且只有一个主线程。</li><li>多线程共享同个地址空间、打开的文件以及其他资源。</li><li>多进程共享物理内存、磁盘、打印机以及其他资源。</li></ul><p>1.4 线程的类型</p><p>线程的因作用可以划分为不同的类型。大致可分为：</p><ul><li>主线程</li><li>子线程</li><li>守护线程（后台线程）</li><li>前台线程<br>2 Python 多线程</li></ul><p>2.1 GIL</p><p>其他语言，CPU 是多核时是支持多个线程同时执行。但在 Python 中，无论是单核还是多核，同时只能由一个线程在执行。其根源是 GIL 的存在。<br>GIL 的全称是 Global Interpreter Lock(全局解释器锁)，来源是 Python 设计之初的考虑，为了数据安全所做的决定。某个线程想要执行，必须先拿到 GIL，我们可以把 GIL 看作是“通行证”，并且在一个 Python 进程中，GIL 只有一个。拿不到通行证的线程，就不允许进入 CPU 执行。<br>而目前 Python 的解释器有多种，例如：</p><ul><li>CPython：CPython 是用C语言实现的 Python 解释器。 作为官方实现，它是最广泛使用的 Python 解释器。</li><li>PyPy：PyPy 是用RPython实现的解释器。RPython 是 Python 的子集， 具有静态类型。这个解释器的特点是即时编译，支持多重后端（C, CLI, JVM）。PyPy 旨在提高性能，同时保持最大兼容性（参考 CPython 的实现）。</li><li>Jython：Jython 是一个将 Python 代码编译成 Java 字节码的实现，运行在JVM (Java Virtual Machine) 上。另外，它可以像是用 Python 模块一样，导入 并使用任何Java类。</li><li>IronPython：IronPython 是一个针对 .NET 框架的 Python 实现。它 可以用 Python 和 .NET framewor k的库，也能将 Python 代码暴露给 .NET 框架中的其他语言。<br>GIL 只在 CPython 中才有，而在 PyPy 和 Jython 中是没有 GIL 的。<br>每次释放 GIL锁，线程进行锁竞争、切换线程，会消耗资源。这就导致打印线程执行时长，会发现耗时更长的原因。<br>并且由于 GIL 锁存在，Python 里一个进程永远只能同时执行一个线程(拿到 GIL 的线程才能执行)，这就是为什么在多核CPU上，Python 的多线程效率并不高的根本原因。</li></ul><p>2.2 创建多线程</p><p>Python提供两个模块进行多线程的操作，分别是thread和threading，<br>前者是比较低级的模块，用于更底层的操作，一般应用级别的开发不常用。</p><ul><li>方法1：直接使用threading.Thread()<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这个函数名可随便定义</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=run, args=(<span class="string">"thread 1"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run, args=(<span class="string">"thread 2"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">* 方法<span class="number">2</span>：继承threading.Thread来自定义线程类，重写run方法</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, n)</span>:</span></span><br><span class="line">        super(MyThread, self).__init__()  <span class="comment"># 重构run函数必须要写</span></span><br><span class="line">        self.n = n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"current task："</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = MyThread(<span class="string">"thread 1"</span>)</span><br><span class="line">    t2 = MyThread(<span class="string">"thread 2"</span>)</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure></li></ul><p>2.3 线程合并</p><p>Join函数执行顺序是逐个执行每个线程，执行完毕后继续往下执行。主线程结束后，子线程还在运行，join函数使得主线程等到子线程结束时才退出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        n -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    t1 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t2 = threading.Thread(target=count, args=(<span class="string">"100000"</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 将 t1 和 t2 加入到主线程中</span></span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br></pre></td></tr></table></figure><p>2.4 线程同步与互斥锁</p><p>线程之间数据共享的。当多个线程对某一个共享数据进行操作时，就需要考虑到线程安全问题。threading模块中定义了Lock 类，提供了互斥锁的功能来保证多线程情况下数据的正确性。<br>用法的基本步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment">#锁定</span></span><br><span class="line">mutex.acquire([timeout])</span><br><span class="line"><span class="comment">#释放</span></span><br><span class="line">mutex.release()</span><br><span class="line">其中，锁定方法acquire可以有一个超时时间的可选参数timeout。如果设定了timeout，则在超时后通过返回值可以判断是否得到了锁，从而可以进行一些其他的处理。</span><br><span class="line">具体用法见示例代码：</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">num = <span class="number">0</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> num</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):</span><br><span class="line">            num = num + <span class="number">1</span></span><br><span class="line">            msg = self.name + <span class="string">': num value is '</span> + str(num)</span><br><span class="line">            print(msg)</span><br><span class="line">            mutex.release()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>2.5 可重入锁（递归锁）</p><p>为了满足在同一线程中多次请求同一资源的需求，Python 提供了可重入锁（RLock）。<br> RLock内部维护着一个Lock和一个counter变量，counter 记录了 acquire 的次数，从而使得资源可以被多次 require。直到一个线程所有的 acquire 都被 release，其他的线程才能获得资源。<br>具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建 RLock</span></span><br><span class="line">mutex = threading.RLock()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutex.acquire(<span class="number">1</span>):</span><br><span class="line">            print(<span class="string">"thread "</span> + self.name + <span class="string">" get mutex"</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            mutex.acquire()</span><br><span class="line">            mutex.release()</span><br><span class="line">            mutex.release()</span><br></pre></td></tr></table></figure><p>2.6 守护线程</p><p>如果希望主线程执行完毕之后，不管子线程是否执行完毕都随着主线程一起结束。我们可以使用setDaemon(bool)函数，它跟join函数是相反的。它的作用是设置子线程是否随主线程一起结束，必须在start() 之前调用，默认为False。<br>2.7 定时器</p><p>如果需要规定函数在多少秒后执行某个操作，需要用到Timer类。具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Timer</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Pyhton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定一秒钟之后执行 show 函数</span></span><br><span class="line">t = Timer(<span class="number">1</span>, hello)</span><br><span class="line">t.start()</span><br></pre></td></tr></table></figure><p>3 Python 多进程</p><p>3.1 创建多进程</p><p>Python 要进行多进程操作，需要用到muiltprocessing库，其中的Process类跟threading模块的Thread类很相似。所以直接看代码熟悉多进程。</p><ul><li>方法1：直接使用Process, 代码如下：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"Process name is "</span> + name)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    proc = Process(target=show, args=(<span class="string">'subprocess'</span>,))</span><br><span class="line">    proc.start()</span><br><span class="line">    proc.join()</span><br><span class="line">* 方法<span class="number">2</span>：继承Process来自定义进程类，重写run方法, 代码如下：</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyProcess</span><span class="params">(Process)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        super(MyProcess, self).__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'process name :'</span> + str(self.name))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p = MyProcess(i)</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        p.join()</span><br></pre></td></tr></table></figure></li></ul><p>3.2 多进程通信</p><p>进程之间不共享数据的。如果进程之间需要进行通信，则要用到Queue模块或者Pipi模块来实现。</p><ul><li><p>Queue<br>Queue 是多进程安全的队列，可以实现多进程之间的数据传递。它主要有两个函数,put和get。<br>put() 用以插入数据到队列中，put 还有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，该方法会阻塞 timeout 指定的时间，直到该队列有剩余的空间。如果超时，会抛出 Queue.Full 异常。如果 blocked 为 False，但该 Queue 已满，会立即抛出 Queue.Full 异常。<br>get()可以从队列读取并且删除一个元素。同样，get 有两个可选参数：blocked 和 timeout。如果 blocked 为 True（默认值），并且 timeout 为正值，那么在等待时间内没有取到任何元素，会抛出 Queue.Empty 异常。如果blocked 为 False，有两种情况存在，如果 Queue 有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出 Queue.Empty 异常。<br>具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Queue</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(queue)</span>:</span></span><br><span class="line">    queue.put(<span class="string">'Queue 用法'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line">    pro = Process(target=put, args=(queue,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(queue.get())</span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure></li><li><p>Pipe<br>Pipe的本质是进程之间的用管道数据传递，而不是数据共享，这和socket有点像。pipe() 返回两个连接对象分别表示管道的两端，每端都有send() 和recv()函数。<br>如果两个进程试图在同一时间的同一端进行读取和写入那么，这可能会损坏管道中的数据。<br>具体用法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process, Pipe</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(conn)</span>:</span></span><br><span class="line">    conn.send(<span class="string">'Pipe 用法'</span>)</span><br><span class="line">    conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    parent_conn, child_conn = Pipe()</span><br><span class="line">    pro = Process(target=show, args=(child_conn,))</span><br><span class="line">    pro.start()</span><br><span class="line">    print(parent_conn.recv())</span><br><span class="line">    pro.join()</span><br></pre></td></tr></table></figure></li></ul><p>3.3 进程池</p><p>创建多个进程，我们不用傻傻地一个个去创建。我们可以使用Pool模块来搞定。<br>Pool 常用的方法如下：<br>方法           含义<br>apply()       同步执行（串行）<br>apply_async()   异步执行（并行）<br>terminate()     立刻关闭进程池<br>join()         主进程等待所有子进程执行完毕。必须在close或terminate()之后使用<br>close()         等待所有进程结束后，才关闭进程池<br>具体用法见示例代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">'num : '</span> + str(num))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">"__main__"</span>:</span><br><span class="line">    pool = Pool(processes = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去</span></span><br><span class="line">        pool.apply_async(show, args=(i, ))</span><br><span class="line">    print(<span class="string">'======  apply_async  ======'</span>)</span><br><span class="line">    pool.close()</span><br><span class="line">    <span class="comment">#调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束</span></span><br><span class="line">    pool.join()</span><br></pre></td></tr></table></figure><p>4 选择多线程还是多进程？</p><p>在这个问题上，首先要看下你的程序是属于哪种类型的。一般分为两种 CPU 密集型 和 I/O 密集型。</p><ul><li>CPU 密集型：程序比较偏重于计算，需要经常使用 CPU 来运算。例如科学计算的程序，机器学习的程序等。</li><li>I/O 密集型：顾名思义就是程序需要频繁进行输入输出操作。爬虫程序就是典型的 I/O 密集型程序。<br>如果程序是属于 CPU 密集型，建议使用多进程。而多线程就更适合应用于 I/O 密集型程序。</li></ul>]]></content>
      
    </entry>
    
    
  
</search>
