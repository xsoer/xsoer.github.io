<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>算法</title>
    <url>/algorithms/index.html</url>
    <content><![CDATA[<h1 id="算法汇总"><a href="#算法汇总" class="headerlink" title="算法汇总"></a>算法汇总</h1><ul>
<li><a href="basic.html">基础</a></li>
<li><a href="sort.html">排序算法</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>读书笔记</title>
    <url>/books/index.html</url>
    <content><![CDATA[<h2 id="1-架构"><a href="#1-架构" class="headerlink" title="1.架构"></a>1.架构</h2><ul>
<li><a href="deep-analysis-distributed-cache.html">深入分布式缓存:从原理到实践</a></li>
</ul>
<h2 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h2><ul>
<li><a href="gopl.html">go语言程序设计</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>categories</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>面试</title>
    <url>/interview/index.html</url>
    <content><![CDATA[<h1 id="面试汇总"><a href="#面试汇总" class="headerlink" title="面试汇总"></a>面试汇总</h1><h2 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a><a href="cs/index.html">计算机基础</a></h2><ul>
<li><a href="cs/basic.html">基础</a></li>
<li><a href="cs/os.html">操作系统</a></li>
</ul>
<h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a><a href="backend/index.md">后端</a></h2><ul>
<li><a href="backend/python.html">python</a></li>
</ul>
<h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a><a href="storage/index.html">数据库</a></h2><ul>
<li><a href="storage/basic.html">基础</a></li>
<li><a href="storage/mysql.html">mysql</a></li>
</ul>
<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a><a href="frontend/index.md">前端</a></h2><ul>
<li><a href="frontend/basic.html">大前端</a></li>
<li><a href="frontend/js.html">js</a></li>
<li><a href="frontend/vue.html">vue</a></li>
<li><a href="frontend/css.html">css</a></li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a><a href="net/index.html">网络</a></h2><ul>
<li><a href="net/basic.html">基础</a></li>
<li><a href="net/http.html">http</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>手册</title>
    <url>/man/index.html</url>
    <content><![CDATA[<h2 id="python"><a href="#python" class="headerlink" title="python"></a>python</h2><ul>
<li><a href="python/basic.html">基础</a></li>
<li><a href="python/lib.html">库操作</a></li>
</ul>
<h2 id="rust"><a href="#rust" class="headerlink" title="rust"></a>rust</h2><ul>
<li><a href="rust/basic.html">基础</a></li>
</ul>
<h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><ul>
<li><a href="linux/commands.html">常用命令</a></li>
<li><a href="linux/crontab.html">定时任务</a></li>
</ul>
<h2 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h2><ul>
<li><a href="docker/commands.html">常用命令</a></li>
</ul>
<h2 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h2><ul>
<li>1.<a href="mysql/basic.html">架构介绍</a></li>
<li>2.<a href="mysql/commands.html">常用命令</a></li>
<li>3.<a href="mysql/character.html">编码类型</a></li>
<li>4.<a href="mysql/column_type.html">字段类型</a></li>
<li>5.<a href="mysql/transaction.html">事务处理</a></li>
<li>6.<a href="mysql/indexed.html">索引介绍</a></li>
</ul>
<h2 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h2><ul>
<li><a href="vim/commands.html">常用命令</a></li>
</ul>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><ul>
<li><a href="git/commands.html">常用命令</a></li>
</ul>
<h2 id="Django"><a href="#Django" class="headerlink" title="Django"></a>Django</h2><ul>
<li><a href="django/model.html">django ORM常用操作</a></li>
</ul>
<h2 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h2><ul>
<li><a href="chip/basic.md">芯片</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>tags</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>工具集合</title>
    <url>/tools/index.html</url>
    <content><![CDATA[<h2 id="一、插件"><a href="#一、插件" class="headerlink" title="一、插件"></a>一、插件</h2><ul>
<li>github<ul>
<li>sourcegraph</li>
<li>octotree</li>
</ul>
</li>
<li>剪切网页<ul>
<li>evernote</li>
</ul>
</li>
<li>调试接口<ul>
<li>JSONview</li>
</ul>
</li>
<li>词典<ul>
<li>沙拉查词</li>
</ul>
</li>
<li>广告<ul>
<li>广告终结者</li>
</ul>
</li>
<li>产品原型<ul>
<li>axure</li>
</ul>
</li>
<li>多tab管理<ul>
<li>Toby</li>
</ul>
</li>
</ul>
<h2 id="二、工具网站"><a href="#二、工具网站" class="headerlink" title="二、工具网站"></a>二、工具网站</h2><ul>
<li>json格式化<ul>
<li><a href="https://json.cn" target="_blank" rel="noopener">https://json.cn</a></li>
<li><a href="http://json.parser.online.fr" target="_blank" rel="noopener">http://json.parser.online.fr</a></li>
</ul>
</li>
<li>随机密码生成<ul>
<li><a href="https://www.sexauth.com/" target="_blank" rel="noopener">https://www.sexauth.com/</a></li>
<li><a href="https://suijimimashengcheng.51240.com/" target="_blank" rel="noopener">https://suijimimashengcheng.51240.com/</a></li>
<li><a href="https://www.dashlane.com/zh/features/password-generator" target="_blank" rel="noopener">https://www.dashlane.com/zh/features/password-generator</a></li>
</ul>
</li>
<li>正则表达式<ul>
<li><a href="https://regexr.com/" target="_blank" rel="noopener">https://regexr.com/</a></li>
<li><a href="http://wangwl.net/static/projects/visualRegex" target="_blank" rel="noopener">http://wangwl.net/static/projects/visualRegex</a></li>
</ul>
</li>
<li>问题讨论<ul>
<li><a href="https://stackoverflow.com" target="_blank" rel="noopener">https://stackoverflow.com</a></li>
<li><a href="https://stackexchange.com/" target="_blank" rel="noopener">https://stackexchange.com/</a></li>
</ul>
</li>
<li>文章<ul>
<li><a href="https://medium.com/" target="_blank" rel="noopener">https://medium.com/</a></li>
</ul>
</li>
</ul>
<h2 id="三、前沿科技网站"><a href="#三、前沿科技网站" class="headerlink" title="三、前沿科技网站"></a>三、前沿科技网站</h2><ul>
<li>论文<ul>
<li><a href="https://arxiv.org/" target="_blank" rel="noopener">https://arxiv.org/</a></li>
<li><a href="https://www.nature.com/" target="_blank" rel="noopener">https://www.nature.com/</a></li>
<li><a href="https://paperswelove.org/" target="_blank" rel="noopener">https://paperswelove.org/</a></li>
</ul>
</li>
</ul>
<h3 id="四、github系列"><a href="#四、github系列" class="headerlink" title="四、github系列"></a>四、github系列</h3><ul>
<li><p>awesome系列</p>
<ul>
<li><a href="https://github.com/sindresorhus/awesome" target="_blank" rel="noopener">https://github.com/sindresorhus/awesome</a></li>
</ul>
</li>
<li><p>算法</p>
<ul>
<li><a href="https://github.com/linyiqun/DataMiningAlgorithm" target="_blank" rel="noopener">https://github.com/linyiqun/DataMiningAlgorithm</a></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/backend/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/cs/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/frontend/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/net/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/interview/storage/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/django/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/docker/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/git/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/linux/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/vim/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>排序算法</title>
    <url>/algorithms/sort.html</url>
    <content><![CDATA[<p>本文是常见的排序算法的一个简单总结，也是算法导论第三版的一些摘要记录，以作备忘和查询。</p>
<h2 id="0X00、简介"><a href="#0X00、简介" class="headerlink" title="0X00、简介"></a>0X00、简介</h2><ul>
<li><p>1.排序的定义：</p>
<ul>
<li>输入：n个数的一个序列&lt;a1,a2,…,an&gt;</li>
<li>输出：序列的一个排列&lt;a1’,a2’,…,an’&gt;,满足a1’&lt;=a2’&lt;=…&lt;=an’</li>
</ul>
</li>
<li><p>2.排序算法复杂度概览</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>排序算法</th>
<th>平均时间复杂度</th>
<th>最好情况</th>
<th>最坏情况</th>
<th>空间复杂度</th>
<th>排序方式</th>
<th>稳定性</th>
</tr>
</thead>
<tbody><tr>
<td>冒泡排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>选择排序</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>插入排序</td>
<td>O(n^2)</td>
<td>O(n)</td>
<td>O(n^2)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>稳定</td>
</tr>
<tr>
<td>希尔排序</td>
<td>O(nlogn)</td>
<td>O(nlog2n)</td>
<td>O(nlog2n)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>归并排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>快速排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(n^2)</td>
<td>O(logn)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>堆排序</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(nlogn)</td>
<td>O(1)</td>
<td>In-Place</td>
<td>不稳定</td>
</tr>
<tr>
<td>计数排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>桶排序</td>
<td>O(n+k)</td>
<td>O(n+k)</td>
<td>O(n^2)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
<tr>
<td>基数排序</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n * k)</td>
<td>O(n+k)</td>
<td>Out-place</td>
<td>稳定</td>
</tr>
</tbody></table>
<ul>
<li><p>3.术语解释</p>
<ul>
<li>稳定性：如果a=b，且a在b前面，排序后a仍然在b前面，则说算法是稳定的；否则就是不稳定的。</li>
<li>内排序：所有排序操作都在内存中完成；</li>
<li>外排序：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行；</li>
<li>时间复杂度：一个算法执行所耗费的时间。</li>
<li>空间复杂度：运行完一个程序所需内存的大小。</li>
</ul>
</li>
<li><p>4.关于时间复杂度的排序:</p>
<ul>
<li>(O(n^2))排序:各类简单排序：直接插入、直接选择和冒泡排序；</li>
<li>(O(nlog2n))排序:快速排序、堆排序和归并排序；</li>
<li>O(n1+§))排序，§是介于0和1之间的常数:希尔排序</li>
<li>(O(n))排序:基数排序、桶、箱排序。</li>
</ul>
</li>
<li><p>5.关于稳定性的排序：</p>
<ul>
<li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序</li>
<li>不是稳定的排序算法：选择排序、快速排序、希尔排序、堆排序</li>
</ul>
</li>
</ul>
<h2 id="0X01、冒泡排序"><a href="#0X01、冒泡排序" class="headerlink" title="0X01、冒泡排序"></a>0X01、冒泡排序</h2><p>冒泡排序是一种流行但是低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。</p>
<h4 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li>
<li>2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li>
<li>3.针对所有的元素重复以上的步骤，除了最后一个；</li>
<li>4.重复步骤1~3，直到排序完成。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">BUBBLE-SORT(A)</span><br><span class="line">1  for i = 1 to A.length - 1</span><br><span class="line">2    for j = A.length downto i+1</span><br><span class="line">3       if A[j] &lt; A[j-1]</span><br><span class="line">4           exchange A[j] with A[j-1]</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-复杂度"><a href="#2-复杂度" class="headerlink" title="2.复杂度"></a>2.复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(n^2)</li>
<li>平均情况：T(n) = O(n^2)</li>
</ul>
</li>
<li>空间复杂度：O(1)</li>
</ul>
<h4 id="3-代码实现如下"><a href="#3-代码实现如下" class="headerlink" title="3.代码实现如下"></a>3.代码实现如下</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bubble_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, cnt):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i<span class="number">-1</span>, cnt<span class="number">-1</span>):</span><br><span class="line">            <span class="keyword">if</span> a[j] &gt; a[j+<span class="number">1</span>]:</span><br><span class="line">                a[j], a[j+<span class="number">1</span>] = a[j+<span class="number">1</span>] , a[j]</span><br><span class="line"></span><br><span class="line">    <span class="comment">#for i in range(cnt-2):</span></span><br><span class="line">    <span class="comment">#    for j in range(cnt-1, i, -1):</span></span><br><span class="line">    <span class="comment">#        if a[j] &lt; a[j-1]:</span></span><br><span class="line">    <span class="comment">#            a[j], a[j-1] = a[j-1], a[j]</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bubble_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X02、插入排序"><a href="#0X02、插入排序" class="headerlink" title="0X02、插入排序"></a>0X02、插入排序</h2><p>插入排序(Insertion-Sort)是一种简单有效的排序方法。整体思想就是把后边一个待排的元素和前边已经排序好的元素做比较，如果比这元素大，就把前边的元素依次后移，直到找到一个比待排元素小的值，在其后边插入既可。然后在排序下一个待排元素。</p>
<h4 id="1-算法思路"><a href="#1-算法思路" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li><p>语言描述</p>
<ul>
<li>1.从第一个元素开始，该元素可以认为已经被排序；</li>
<li>2.取出下一个元素，在已经排序的元素序列中从后向前扫描；</li>
<li>3.如果该元素（已排序）大于新元素，将该元素移到下一位置；</li>
<li>4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li>
<li>4.将新元素插入到该位置后；</li>
<li>5.重复步骤2~5。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">INSERTION-SORT(A):</span><br><span class="line">1  for j = 2 to A.length:</span><br><span class="line">2    key = A[j]</span><br><span class="line">3    i = j - 1</span><br><span class="line">4    while i &gt; 0 and A[i] &gt; key:</span><br><span class="line">5        A[i+1] = A[i]</span><br><span class="line">6        i = i - 1</span><br><span class="line">7    A[i+1] = key</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度"><a href="#2-算法复杂度" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度：<ul>
<li>最佳情况：T(n) = O(n)。</li>
<li>最坏情况：T(n) = O(n^2)。</li>
<li>平均情况：T(n) = O(n^2)。</li>
</ul>
</li>
<li>空间复杂度：<ul>
<li>O(1)。因为其要占用一个存储空间来放置key。</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现"><a href="#3-算法实现" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt - <span class="number">1</span>):</span><br><span class="line">        value = a[i+<span class="number">1</span>]</span><br><span class="line">        pre_index = i</span><br><span class="line">        <span class="keyword">while</span> (pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> value &lt; a[pre_index]):</span><br><span class="line">            a[pre_index + <span class="number">1</span>] = a[pre_index]</span><br><span class="line">            pre_index -= <span class="number">1</span></span><br><span class="line">        a[pre_index+<span class="number">1</span>] = value</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    insert_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X03、选择排序"><a href="#0X03、选择排序" class="headerlink" title="0X03、选择排序"></a>0X03、选择排序</h2><p>表现最稳定的排序算法之一，因为无论什么数据进去都是O(n2)的时间复杂度，所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。理论上讲，选择排序可能也是平时排序一般人想到的最多的排序方法了吧。<br>选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p>
<h4 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1.算法分析"></a>1.算法分析</h4><ul>
<li>1.初始状态：无序区为R[1..n]，有序区为空；</li>
<li>2.第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；</li>
<li>3.n-1趟结束，数组有序化了。</li>
</ul>
<h4 id="2-算法复杂度-1"><a href="#2-算法复杂度-1" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(n2)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(n2)</li>
</ul>
<h4 id="3-算法实现-1"><a href="#3-算法实现-1" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selection_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    选择排序</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(cnt):</span><br><span class="line">        minIndex = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(cnt)[i:]:</span><br><span class="line">            <span class="keyword">if</span> a[j] &lt; a[minIndex]:</span><br><span class="line">                a[minIndex], a[j] = a[j], a[minIndex]</span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    selection_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X04、希尔排序"><a href="#0X04、希尔排序" class="headerlink" title="0X04、希尔排序"></a>0X04、希尔排序</h2><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破O(n2）的第一批算法之一。它与插入排序的不同之处在于，它会优先比较距离较远的元素。希尔排序又叫缩小增量排序。<br>希尔排序是把记录按下表的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="1-算法思路-1"><a href="#1-算法思路-1" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为增量序列。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。<br>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p>
<ul>
<li>选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1；</li>
<li>按增量序列个数k，对序列进行k 趟排序；</li>
<li>每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>
</ul>
<h4 id="2-算法复杂度-2"><a href="#2-算法复杂度-2" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>最佳情况：T(n) = O(nlog2 n)</li>
<li>最坏情况：T(n) = O(nlog2 n)</li>
<li>平均情况：T(n) =O(nlog2n)　</li>
</ul>
<h4 id="3-算法实现-2"><a href="#3-算法实现-2" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">shell_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    希尔排序</span></span><br><span class="line"><span class="string">    算法思路：</span></span><br><span class="line"><span class="string">    时间复杂度：O(n^2)，最好：O(n)，最坏：O(n^2)</span></span><br><span class="line"><span class="string">    空间复杂度：O(1)</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> cnt:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    gap = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(gap, cnt, <span class="number">1</span>):</span><br><span class="line">            tmp = a[i]</span><br><span class="line">            pre_index = i - gap</span><br><span class="line">            <span class="keyword">while</span> pre_index &gt;= <span class="number">0</span> <span class="keyword">and</span> a[pre_index] &gt; tmp:</span><br><span class="line">                a[pre_index+gap] = a[pre_index]</span><br><span class="line">                pre_index -= gap</span><br><span class="line">            a[pre_index+gap] = tmp</span><br><span class="line">        gap //= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> a</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    shell_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X05、归并排序"><a href="#0X05、归并排序" class="headerlink" title="0X05、归并排序"></a>0X05、归并排序</h2><p>归并排序是分治思想的一种实现。这里分治模式的每层递归时都有三个步骤：</p>
<ul>
<li>分解原问题为若干子问题，这些子问题是原问题的规模较小的实例。</li>
<li>解决这些子问题，递归的求解各个子问题。然而，若小问题的规模足够小，则直接求解。</li>
<li>合并这些子问题的解成原问题的解。<br>这便是分治模式的思想。把大问题拆分成几个规模较小的子问题，把子问题在拆分成几个在小的问题，直至可以直接求解。然后把所有子问题的解合并就是原问题的解。</li>
</ul>
<h4 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1.算法思想"></a>1.算法思想</h4><p>归并排序完全是分治思想的实现。</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>分解。分解待排序的n个元素的序列成各具n/2个元素的两个子序列。</li>
<li>解决。使用归并排序递归地排序两个子序列。</li>
<li>合并。合并两个已排序的子序列以产生已排序的答案。</li>
</ul>
</li>
<li><p>伪代码描述</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MERGE(A,p,q,r)</span><br><span class="line">1  n1 = p - q + 1</span><br><span class="line">2  n2 = r - q</span><br><span class="line">3  let L[1..n1+1] and R[1..n2+1] to be new arrays</span><br><span class="line">4  for i = 1 to n1</span><br><span class="line">5    L[i] = A[p+i-1]</span><br><span class="line">6  for j = 1 to n2</span><br><span class="line">7    R[j] = A[q+j]</span><br><span class="line">8  L[n1+1] = ∞</span><br><span class="line">9  R[n2+1] = ∞</span><br><span class="line">10 i = 1</span><br><span class="line">11 j = 1</span><br><span class="line">12 for k = p to r</span><br><span class="line">13   if L[i] &lt;= R[j]</span><br><span class="line">14      A[k] = L[i]</span><br><span class="line">15      i = i+1</span><br><span class="line">16   else</span><br><span class="line">17      A[k] = R[j]</span><br><span class="line">18      j = j+1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MERGE-SORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2     q = (p+r)/2</span><br><span class="line">3     MERGE-SORT(A,p,q)</span><br><span class="line">4     MERGE-SORT(A,q+1,r)</span><br><span class="line">5     MERGE(A,p,q,r)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-算法复杂度-3"><a href="#2-算法复杂度-3" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(n)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-3"><a href="#3-算法实现-3" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_sort</span><span class="params">(a: list)</span>:</span></span><br><span class="line">    cnt = len(a)</span><br><span class="line">    <span class="keyword">if</span> cnt &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    mid = cnt // <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> merge(merge_sort(a[:mid]), merge_sort(a[mid:]))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(left: list, right: list)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(left) <span class="keyword">and</span> j &lt; len(right):</span><br><span class="line">        <span class="keyword">if</span> left[i] &lt;= right[j]:</span><br><span class="line">            result.append(left[i])</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(right[j])</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">    result += left[i:]</span><br><span class="line">    result += right[j:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(merge_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X06、快速排序"><a href="#0X06、快速排序" class="headerlink" title="0X06、快速排序"></a>0X06、快速排序</h2><p>通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。</p>
<h4 id="1-算法思路-2"><a href="#1-算法思路-2" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p>
<ul>
<li><p>语言描述</p>
<ul>
<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>
<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li>
<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</li>
</ul>
</li>
<li><p>伪代码描述</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QUICKSORT(A,p,r)</span><br><span class="line">1  if p &lt; r</span><br><span class="line">2    q = PARTITION(A,p,r)</span><br><span class="line">3    QUICKSORT(A,p,q-1)</span><br><span class="line">4    QUICKSORT(A,q+1,r)</span><br><span class="line"></span><br><span class="line">PARTITION(A,p,r)</span><br><span class="line">1  x = A[r]</span><br><span class="line">2  i = p-1</span><br><span class="line">3  for j = p to r-1</span><br><span class="line">4    if A[j] &lt;= x</span><br><span class="line">5        i = i+1</span><br><span class="line">6        exchange A[i] with A[j]</span><br><span class="line">7  exchange A[i+1] with A[r]</span><br><span class="line">8  return i+1</span><br></pre></td></tr></table></figure>

<h4 id="2-算法复杂度-4"><a href="#2-算法复杂度-4" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(n2)</li>
<li>平均情况：T(n) = O(nlogn)　</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-4"><a href="#3-算法实现-4" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quick_sort</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> l &lt; r:</span><br><span class="line">        q = partition(array, l, r)</span><br><span class="line">        quick_sort(array, l, q)</span><br><span class="line">        quick_sort(array, q + <span class="number">1</span>, r)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(array, l, r)</span>:</span></span><br><span class="line">    i = l - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(l, r):</span><br><span class="line">        <span class="keyword">if</span> array[j] &lt;= array[r]:</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">            array[i], array[j] = array[j], array[i]</span><br><span class="line">    array[i+<span class="number">1</span>], array[r] = array[r], array[i+<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quicksort</span><span class="params">(arr)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> arr</span><br><span class="line">    pivot = arr[len(arr) // <span class="number">2</span>]</span><br><span class="line">    left = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &lt; pivot]</span><br><span class="line">    middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</span><br><span class="line">    right = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x &gt; pivot]</span><br><span class="line">    <span class="keyword">return</span> quicksort(left) + middle + quicksort(right)</span><br><span class="line"></span><br><span class="line">print(quicksort([<span class="number">3</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    quick_sort(a, <span class="number">0</span>, len(a) - <span class="number">1</span>)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X07、计数排序"><a href="#0X07、计数排序" class="headerlink" title="0X07、计数排序"></a>0X07、计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。<br>计数排序(Counting sort)是一种稳定的排序算法。计数排序使用一个额外的数组C，其中第i个元素是待排序数组A中值等于i的元素的个数。然后根据数组C来将A中的元素排到正确的位置。它只能对整数进行排序。</p>
<h4 id="1-算法思路-3"><a href="#1-算法思路-3" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>找出待排序的数组中最大和最小的元素；</li>
<li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li>
<li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li>
<li>反向填充目标数组：将每个元素i放在新数组的第C(i)项，每放一个元素就将C(i)减去1。</li>
</ul>
<h4 id="2-算法复杂度-5"><a href="#2-算法复杂度-5" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>当输入的元素是n 个0到k之间的整数时，它的运行时间是 O(n + k)。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组C的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上1），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n+k)</p>
<h4 id="3-算法实现-5"><a href="#3-算法实现-5" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count_sort</span><span class="params">(array)</span>:</span></span><br><span class="line">    leng = len(array)</span><br><span class="line">    c = []</span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, leng):</span><br><span class="line">        c[array[i]] = c[array[i]]+<span class="number">1</span></span><br><span class="line">        res.append(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">100</span>):</span><br><span class="line">        c[i] = c[i<span class="number">-1</span>]+c[i]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(leng<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        res[c[array[i]]<span class="number">-1</span>] = array[i]</span><br><span class="line">        c[array[i]] = c[array[i]]<span class="number">-1</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    print(count_sort(a))</span><br></pre></td></tr></table></figure>

<h2 id="0X08、基数排序"><a href="#0X08、基数排序" class="headerlink" title="0X08、基数排序"></a>0X08、基数排序</h2><p>基数排序也是非比较的排序算法，对每一位进行排序，从最低位开始排序，复杂度为O(kn),为数组长度，k为数组中的数的最大的位数；<br>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p>
<h4 id="1-算法思路-4"><a href="#1-算法思路-4" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>取得数组中的最大数，并取得位数；</li>
<li>arr为原始数组，从最低位开始取每个位组成radix数组；</li>
<li>对radix进行计数排序（利用计数排序适用于小范围数的特点）</li>
</ul>
<h4 id="2-算法复杂度-6"><a href="#2-算法复杂度-6" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>最佳情况：T(n) = O(n * k) 最差情况：T(n) = O(n * k) 平均情况：T(n) = O(n * k)<br>基数排序有两种方法：<br>MSD 从高位开始进行排序 LSD 从低位开始进行排序<br>基数排序 vs 计数排序 vs 桶排序<br>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶</li>
<li>计数排序：每个桶只存储单一键值</li>
<li>桶排序：每个桶存储一定范围的数值</li>
</ul>
<h4 id="3-算法实现-6"><a href="#3-算法实现-6" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">radix_sort</span><span class="params">(lists, radix=<span class="number">10</span>)</span>:</span></span><br><span class="line">    k = int(math.ceil(math.log(max(lists), radix)))</span><br><span class="line">    bucket = [[] <span class="keyword">for</span> i <span class="keyword">in</span> range(radix)]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, k+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> lists:</span><br><span class="line">            bucket[j//(radix**(i<span class="number">-1</span>)) % (radix**i)].append(j)</span><br><span class="line">        <span class="keyword">del</span> lists[:]</span><br><span class="line">        <span class="keyword">for</span> z <span class="keyword">in</span> bucket:</span><br><span class="line">            lists += z</span><br><span class="line">            <span class="keyword">del</span> z[:]</span><br><span class="line">    <span class="keyword">return</span> lists</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    radix_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X09、桶排序"><a href="#0X09、桶排序" class="headerlink" title="0X09、桶排序"></a>0X09、桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。<br>桶排序 (Bucket sort)的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排</p>
<h4 id="1-算法思路-5"><a href="#1-算法思路-5" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>人为设置一个BucketSize，作为每个桶所能放置多少个不同数值（例如当BucketSize==5时，该桶可以存放｛1,2,3,4,5｝这几种数字，但是容量不限，即可以存放100个3）；</li>
<li>遍历输入数据，并且把数据一个一个放到对应的桶里去；</li>
<li>对每个不是空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li>
<li>从不是空的桶里把排好序的数据拼接起来。<br>注意，如果递归使用桶排序为各个桶排序，则当桶数量为1时要手动减小BucketSize增加下一循环桶的数量，否则会陷入死循环，导致内存溢出。</li>
</ul>
<h4 id="2-算法复杂度-7"><a href="#2-算法复杂度-7" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。<br>最佳情况：T(n) = O(n+k) 最差情况：T(n) = O(n+k) 平均情况：T(n) = O(n2)　</p>
<h4 id="3-算法实现-7"><a href="#3-算法实现-7" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">node</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, k)</span>:</span></span><br><span class="line">        self.key = k</span><br><span class="line">        self.next = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bucket_sort</span><span class="params">(lista)</span>:</span></span><br><span class="line">    h = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        h.append(node(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, len(lista)):</span><br><span class="line">        tmp = node(lista[i])</span><br><span class="line">        map = lista[i]//<span class="number">10</span></span><br><span class="line">        p = h[map]</span><br><span class="line">        <span class="keyword">if</span> p.key <span class="keyword">is</span> <span class="number">0</span>:</span><br><span class="line">            h[map].next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">while</span>(p.next != <span class="literal">None</span> <span class="keyword">and</span> p.next.key &lt;= tmp.key):</span><br><span class="line">                p = p.next</span><br><span class="line">            tmp.next = p.next</span><br><span class="line">            p.next = tmp</span><br><span class="line">            h[map].key = h[map].key+<span class="number">1</span></span><br><span class="line">    k = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">10</span>):</span><br><span class="line">        q = h[i].next</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="literal">None</span>):</span><br><span class="line">            lista[k] = q.key</span><br><span class="line">            k = k+<span class="number">1</span></span><br><span class="line">            q = q.next</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    bucket_sort(a)</span><br><span class="line">    print(a)</span><br></pre></td></tr></table></figure>

<h2 id="0X10、堆排序"><a href="#0X10、堆排序" class="headerlink" title="0X10、堆排序"></a>0X10、堆排序</h2><p>堆排序(heap-sort),和归并排序一样，不同于插入排序的是，堆排序的时间复杂度是O(nlogn)。与插入排序相同，不同于堆排序的是，堆排序具有空间原址性：任何时候都需要常数个额外的元素空间来存储临时数据。<br>其思想便是引用一种成为堆的数据结构。常见的有大根堆（最大堆）和小根堆（最小堆）。在排序中一般使用大根堆，小根堆通常构建优先队列。</p>
<ul>
<li>大根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&gt;=A[i]</li>
</ul>
</li>
<li>小根堆：<ul>
<li>除了根以外的所有节点i都满足：A[PARENT(i)]&lt;=A[i]</li>
</ul>
</li>
</ul>
<h4 id="1-算法思路-6"><a href="#1-算法思路-6" class="headerlink" title="1.算法思路"></a>1.算法思路</h4><ul>
<li>伪代码描述<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 用于维护最大根堆的性质</span><br><span class="line"># 对于树高为h的大根堆，其时间复杂度为O(h)</span><br><span class="line">MAX-HEAPIFY(A,i)</span><br><span class="line">1  l = LEFT(i)</span><br><span class="line">2  r = RIGHT(i)</span><br><span class="line">3  if l &lt;= A.heap-size and A[l] &gt; A[i]</span><br><span class="line">4    largest = l</span><br><span class="line">5  else larget = r</span><br><span class="line">6  if r &lt;= A.heap-size and A[r] &gt; A[largest]</span><br><span class="line">7    largest = r</span><br><span class="line">8  if largest != i</span><br><span class="line">9    exchange A[i] with A[largest]</span><br><span class="line">10   MAX-HEAPIFY(A,largest)</span><br><span class="line"></span><br><span class="line"># 建堆</span><br><span class="line">BUILD-MAX-HEAP(A)</span><br><span class="line">1  A.heap-size = A.length</span><br><span class="line">2  for i = ⌊A.length/2⌋ downto 1</span><br><span class="line">3    MAX-HEAPIFY(A, i)</span><br><span class="line"></span><br><span class="line"># 堆排序</span><br><span class="line">HEAP-SORT(A)</span><br><span class="line">1  BUILD-MAX-HEAP(A)</span><br><span class="line">2  for i = A.length downto 2</span><br><span class="line">3    exchange A[1] with A[i]</span><br><span class="line">4    MAX-HEAPIFY(A, 1)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="2-算法复杂度-8"><a href="#2-算法复杂度-8" class="headerlink" title="2.算法复杂度"></a>2.算法复杂度</h4><ul>
<li>时间复杂度<ul>
<li>最佳情况：T(n) = O(nlogn)</li>
<li>最差情况：T(n) = O(nlogn)</li>
<li>平均情况：T(n) = O(nlogn)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
</ul>
<h4 id="3-算法实现-8"><a href="#3-算法实现-8" class="headerlink" title="3.算法实现"></a>3.算法实现</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap_param</span><span class="params">(L, i, j)</span>:</span></span><br><span class="line">    L[i], L[j] = L[j], L[i]</span><br><span class="line">    <span class="keyword">return</span> L</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_adjust</span><span class="params">(L, start, end)</span>:</span></span><br><span class="line">    temp = L[start]</span><br><span class="line"></span><br><span class="line">    i = start</span><br><span class="line">    j = <span class="number">2</span> * i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> j &lt;= end:</span><br><span class="line">        <span class="keyword">if</span> (j &lt; end) <span class="keyword">and</span> (L[j] &lt; L[j + <span class="number">1</span>]):</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> temp &lt; L[j]:</span><br><span class="line">            L[i] = L[j]</span><br><span class="line">            i = j</span><br><span class="line">            j = <span class="number">2</span> * i</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    L[i] = temp</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">heap_sort</span><span class="params">(L)</span>:</span></span><br><span class="line">    L_length = len(L) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    first_sort_count = L_length // <span class="number">2</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(first_sort_count):</span><br><span class="line">        heap_adjust(L, first_sort_count - i, L_length)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(L_length - <span class="number">1</span>):</span><br><span class="line">        L = swap_param(L, <span class="number">1</span>, L_length - i)</span><br><span class="line">        heap_adjust(L, <span class="number">1</span>, L_length - i - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [L[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(L))]</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    a = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">45</span>, <span class="number">76</span>, <span class="number">47</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">23</span>]</span><br><span class="line">    L = deque(a)</span><br><span class="line">    L.appendleft(<span class="number">0</span>)</span><br><span class="line">    print(heap_sort(L))</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>css面试题</title>
    <url>/interview/frontend/css.html</url>
    <content><![CDATA[<ul>
<li><p>display:none和visibility:hidden的区别？</p>
<ul>
<li>display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</li>
<li>visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</li>
</ul>
</li>
<li><p>CSS中link 和@import的区别是？</p>
<ul>
<li>(1) link属于HTML标签，而@import是CSS提供</li>
<li>(2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载;</li>
<li>(3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题;</li>
<li>(4) link方式的样式的权重 高于@import的权重.</li>
</ul>
</li>
<li><p>CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？</p>
<ul>
<li>选择符<ul>
<li>1.id选择器（ # myid）</li>
<li>2.类选择器（.myclassname）</li>
<li>3.标签选择器（div, h1, p）</li>
<li>4.相邻选择器（h1 + p）</li>
<li>5.子选择器（ul &gt; li）</li>
<li>6.后代选择器（li a）</li>
<li>7.通配符选择器（ * ）</li>
<li>8.属性选择器（a[rel = “external”]）</li>
<li>9.伪类选择器（a: hover, li:nth-child）</li>
</ul>
</li>
<li>优先级原则<ul>
<li>优先级就近原则，同权重情况下样式定义最近者为准;</li>
<li>载入样式以最后载入的定位为准;</li>
</ul>
</li>
<li>优先级为:<ul>
<li>同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。</li>
<li>!important &gt; id &gt; class &gt; tag</li>
<li>important 比 内联优先级高</li>
</ul>
</li>
<li>可继承的样式： font-size font-family color, UL LI DL DD DT;</li>
<li>不可继承的样式：border padding margin width height</li>
</ul>
</li>
<li><p>display有哪些值？说明他们的作用。</p>
<ul>
<li>block     块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</li>
<li>none     缺省值。象行内元素类型一样显示。</li>
<li>inline     行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</li>
<li>inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。</li>
<li>list-item     象块类型元素一样显示，并添加样式列表标记。</li>
<li>table     此元素会作为块级表格来显示。</li>
<li>inherit     规定应该从父元素继承 display 属性的值。</li>
</ul>
</li>
<li><p>position属性：指定一个元素（静态的，相对的，绝对或固定）的定位方法的类型</p>
<ul>
<li>默认值：static</li>
<li>可选择值：relative、absolute、fixed、static、sticky、inherit</li>
<li>static:默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</li>
<li>relative:生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</li>
<li>fiexd:生成固定定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
<li>absoluate:生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</li>
<li>sticky:粘性定位，该定位基于用户滚动的位置。它的行为就像 position:relative; 而当页面滚动超出目标区域时，它的表现就像 position:fixed;，它会固定在目标位置。</li>
<li>inherit:规定应该从父元素继承 position 属性的值。</li>
</ul>
</li>
<li><p>display属性：规定元素应该生成的框的类型</p>
<ul>
<li>none:此元素不会被显示</li>
<li>block:此元素将显示为块级元素，此元素前后会带有换行符。</li>
<li>inline:默认。此元素会被显示为内联元素，元素前后没有换行符。</li>
<li>inline-block:行内块元素。（CSS2.1 新增的值）</li>
<li>list-item: 此元素会作为列表显示。</li>
<li>run-in: 此元素会根据上下文作为块级元素或内联元素显示。</li>
<li>compact:CSS 中有值 compact，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li>
<li>marker:CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</li>
<li>table: 此元素会作为块级表格来显示（类似 <table>），表格前后带有换行符。</table></li>
<li>inline-table: 此元素会作为内联表格来显示（类似 <table>），表格前后没有换行符。</table></li>
<li>table-row-group: 此元素会作为一个或多个行的分组来显示（类似 <tbody>）。</tbody></li>
<li>table-header-group: 此元素会作为一个或多个行的分组来显示（类似 <thead>）。</thead></li>
<li>table-footer-group: 此元素会作为一个或多个行的分组来显示（类似 <tfoot>）。</tfoot></li>
<li>table-row: 此元素会作为一个表格行显示（类似 <tr>）。</tr></li>
<li>table-column-group: 此元素会作为一个或多个列的分组来显示（类似 <colgroup>）。</colgroup></li>
<li>table-column: 此元素会作为一个单元格列显示（类似 <col>）</li>
<li>table-cell: 此元素会作为一个表格单元格显示（类似 <td> 和 <th>）</th></td></li>
<li>table-caption: 此元素会作为一个表格标题显示（类似 <caption>）</caption></li>
<li>inherit:规定应该从父元素继承 display 属性的值。</li>
<li>flex:用flex布局</li>
</ul>
</li>
<li><p>盒模型</p>
<ul>
<li>总共有四层，从外到内是：margin、border、padding、content</li>
<li>一个盒子中主要的属性就5个：width、height、padding、border、margin。<ul>
<li>width和height：内容的宽度、高度（不是盒子的宽度、高度）。</li>
<li>padding：内边距。</li>
<li>border：边框。</li>
<li>margin：外边距。<br>如果设置background-color，那么border以内的所有都会有背景色。<br>如果想让盒子保持大小不变，那么就要保证border以内的，也就是padding+content的width和height保持不变。</li>
</ul>
</li>
</ul>
</li>
<li><p>像素</p>
<ul>
<li>基准像素</li>
</ul>
</li>
<li><p>行内元素与块元素</p>
<ul>
<li>块元素</li>
<li>行内元素</li>
</ul>
</li>
</ul>
<h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><ul>
<li>display:flex</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/interview/frontend/basic.html</url>
    <content><![CDATA[<h2 id="0x00、HTML"><a href="#0x00、HTML" class="headerlink" title="0x00、HTML"></a>0x00、HTML</h2><h2 id="0x01、CSS"><a href="#0x01、CSS" class="headerlink" title="0x01、CSS"></a>0x01、CSS</h2><h4 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h4><ul>
<li>display:none和visibility:hidden有什么区别</li>
<li>html引入样式的方式有几种</li>
<li>什么是盒模型</li>
<li>CSS选择符有哪些？哪些属性可以继承？优先级算法如何计算？</li>
<li>CSS什么是伪类，伪类有那些，有什么作用？</li>
<li>flex布局是什么，都有哪些语法，相比grid布局有什么不同？</li>
<li>css如何动态计算高度或宽度？</li>
</ul>
<h4 id="2-sass"><a href="#2-sass" class="headerlink" title="2.sass"></a>2.sass</h4><ul>
<li>什么是SASS？</li>
<li>sass的优缺点</li>
<li>SASS中的嵌套规则是什么？</li>
<li>有哪些运算符，都有什么作用？</li>
<li>如何在SASS中引用父选择器？</li>
</ul>
<h2 id="0x02、JS"><a href="#0x02、JS" class="headerlink" title="0x02、JS"></a>0x02、JS</h2><h4 id="1-基础-1"><a href="#1-基础-1" class="headerlink" title="1.基础"></a>1.基础</h4><ul>
<li>介绍js有哪些内置对象？</li>
<li>null，undefined 的区别？</li>
<li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？</li>
<li>如何将字符串转化为数字，例如’12.3b’</li>
<li>字符串转化为数组，数组转化为字符串</li>
<li>如何判断一个对象中是否存在某个属性。</li>
<li>空数据组的boolean值</li>
<li>字符串替换值用什么方法？全部替换如何做？</li>
<li>什么是原型链</li>
</ul>
<h4 id="2-es6"><a href="#2-es6" class="headerlink" title="2.es6"></a>2.es6</h4><ul>
<li>新增了什么语法</li>
</ul>
<h4 id="3-typescript"><a href="#3-typescript" class="headerlink" title="3.typescript"></a>3.typescript</h4><ul>
<li>您对Typescript中的类有什么了解？列出类的一些功能。</li>
<li>如何从TypeScript中的子类调用基类构造函数？</li>
<li>内部模块和外部模块有什么区别？</li>
<li>请解释Typescript中的装饰器？</li>
<li>TypeScript类中属性/方法的默认可见性是什么？</li>
<li>如何在TypeScript中检查null和undefined？</li>
<li>readonly 和 const 有什么区别？</li>
</ul>
<h2 id="0x03、Vue"><a href="#0x03、Vue" class="headerlink" title="0x03、Vue"></a>0x03、Vue</h2><h2 id="0x04、React"><a href="#0x04、React" class="headerlink" title="0x04、React"></a>0x04、React</h2><ul>
<li>React 中 refs 的作用是什么？</li>
<li>createElement 与 cloneElement 的区别是什么？</li>
<li>组件的生命周期有哪些，生命周期的函数有哪些？</li>
<li>什么情况下组件会被更新</li>
<li>指令有哪些</li>
<li>子父组件如何通信</li>
</ul>
<h2 id="0x05、综合"><a href="#0x05、综合" class="headerlink" title="0x05、综合"></a>0x05、综合</h2><h4 id="1-性能"><a href="#1-性能" class="headerlink" title="1.性能"></a>1.性能</h4><ul>
<li>前端性能优化有哪些？</li>
<li>cookie和session</li>
<li>本地存储类型及限制</li>
<li>webpack打包如何优化</li>
</ul>
<h4 id="2-网络"><a href="#2-网络" class="headerlink" title="2.网络"></a>2.网络</h4><ul>
<li>网络请求流程</li>
</ul>
<h4 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h4><ul>
<li>数据提交</li>
<li>跨域问题如何解决</li>
</ul>
<h4 id="4-业务场景"><a href="#4-业务场景" class="headerlink" title="4.业务场景"></a>4.业务场景</h4><ul>
<li>单点登录实现</li>
</ul>
<h4 id="5-正则表达式"><a href="#5-正则表达式" class="headerlink" title="5.正则表达式"></a>5.正则表达式</h4><ul>
<li>判断是否是数字、正数</li>
<li>替换变量</li>
</ul>
<h2 id="0x06、小程序"><a href="#0x06、小程序" class="headerlink" title="0x06、小程序"></a>0x06、小程序</h2><h4 id="1-uniapp"><a href="#1-uniapp" class="headerlink" title="1.uniapp"></a>1.uniapp</h4><h4 id="2-Taro"><a href="#2-Taro" class="headerlink" title="2.Taro"></a>2.Taro</h4><ul>
<li>为什么要用这个</li>
<li>坑在哪里</li>
<li>设计稿尺寸问题</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>vue面试题</title>
    <url>/interview/frontend/vue.html</url>
    <content><![CDATA[<h2 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h2><ul>
<li><p>####1.请谈谈Vue中的MVVM模式</p>
<ul>
<li>MVVM全称是Model-View-ViewModel</li>
<li>Vue是以数据为驱动的，Vue自身将DOM和数据进行绑定，一旦创建绑定，DOM和数据将保持同步，每当数据发生变化，DOM会跟着变化。 ViewModel是Vue的核心，它是Vue的一个实例。Vue实例时作用域某个HTML元素上的这个HTML元素可以是body，也可以是某个id所指代的元素。</li>
<li>DOMListeners和DataBindings是实现双向绑定的关键。DOMListeners监听页面所有View层DOM元素的变化，当发生变化，Model层的数据随之变化；DataBindings监听Model层的数据，当数据发生变化，View层的DOM元素随之变化。</li>
</ul>
</li>
<li><p>####2.v-show和v-if指令的共同点和不同点?</p>
<ul>
<li>v-show指令是通过修改元素的displayCSS属性让其显示或者隐藏</li>
<li>v-if指令是直接销毁和重建DOM达到让元素显示和隐藏的效果</li>
</ul>
</li>
<li><p>####3.如何让CSS只在当前组件中起作用?</p>
<ul>
<li>将当前组件的<code>&lt;style&gt;</code>修改为<code>&lt;style scoped&gt;</code></li>
</ul>
</li>
<li><p>####4.Vue中引入组件的步骤?</p>
<ul>
<li>1.采用ES6的import … from …语法或CommonJS的require()方法引入组件</li>
<li>2.对组件进行注册,代码如下</li>
<li>3.使用组件<my-component></my-component><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 注册</span></span><br><span class="line">Vue.component(<span class="string">'my-component'</span>, &#123;</span><br><span class="line">  template: <span class="string">'&lt;div&gt;A custom component!&lt;/div&gt;'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><h4 id="组件间如何传递值或调用"><a href="#组件间如何传递值或调用" class="headerlink" title="组件间如何传递值或调用"></a>组件间如何传递值或调用</h4></li>
<li><p>####5.在Vue中使用插件的步骤</p>
<ul>
<li>采用ES6的import … from …语法或CommonJS的require()方法引入插件</li>
<li>使用全局方法Vue.use( plugin )使用插件,可以传入一个选项对象Vue.use(MyPlugin, { someOption: true })</li>
</ul>
</li>
<li><p>####6.请列举出3个Vue中常用的生命周期钩子函数?</p>
<ul>
<li>created: 实例已经创建完成之后调用,在这一步,实例已经完成数据观测, 属性和方法的运算, watch/event事件回调. 然而, 挂载阶段还没有开始, $el属性目前还不可见</li>
<li>mounted:  el被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</li>
<li>activated: keep-alive组件激活时调用</li>
</ul>
</li>
<li><p>####7.请简述下Vuex的原理和使用方法</p>
<ul>
<li><p>数据单向流动</p>
</li>
<li><p>一个应用可以看作是由上面三部分组成: View, Actions,State,数据的流动也是从View =&gt; Actions =&gt; State =&gt;View 以此达到数据的单向流动.但是项目较大的, 组件嵌套过多的时候, 多组件共享同一个State会在数据传递时出现很多问题.Vuex就是为了解决这些问题而产生的.</p>
</li>
<li><p>Vuex可以被看作项目中所有组件的数据中心,我们将所有组件中共享的State抽离出来,任何组件都可以访问和操作我们的数据中心.</p>
</li>
<li><p>上图可以很好的说明Vuex的组成,一个实例化的Vuex.Store由state, mutations和actions三个属性组成:</p>
<ul>
<li>state中保存着共有数据</li>
<li>改变state中的数据有且只有通过mutations中的方法,且mutations中的方法必须是同步的</li>
<li>如果要写异步的方法,需要些在actions中, 并通过commit到mutations中进行state中数据的更改.</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>网络基础面试题</title>
    <url>/interview/net/basic.html</url>
    <content><![CDATA[<h2 id="基础部分"><a href="#基础部分" class="headerlink" title="基础部分"></a>基础部分</h2><ul>
<li><ol>
<li>TCP报头格式</li>
</ol>
</li>
<li><ol start="2">
<li>UDP报头格式</li>
</ol>
</li>
<li><ol start="3">
<li>TCP/UDP区别（不仅是宏观上的，最好能根据各自的机制讲解清楚）</li>
</ol>
</li>
<li><ol start="4">
<li>HTTP状态码（最好结合使用场景，比如在缓存命中时使用哪个）</li>
</ol>
</li>
<li><ol start="5">
<li>HTTP协议（一些报头字段的作用，如cace-control、keep-alive）</li>
</ol>
</li>
<li><ol start="6">
<li>OSI协议、TCP/IP协议以及每层对应的协议。</li>
</ol>
</li>
<li><ol start="7">
<li>SESSION机制、cookie机制</li>
</ol>
</li>
<li><ol start="8">
<li>TCP三次握手、四次挥手（这个问题真的要回答吐了，不过真的是面试官最喜欢问的，建议每天手撸一遍，而且不只是每次请求的过程，各种FIN_WAIT、TIME_WAIT状态也要掌握）。</li>
</ol>
</li>
<li><ol start="9">
<li>打开网页到页面显示之间的过程（涵盖了各个方面，DNS解析过程，Nginx请求转发、连接建立和保持过程、浏览器内容渲染过程，考虑的越详细越好）。</li>
</ol>
</li>
<li><ol start="10">
<li>http和https区别，https在请求时额外的过程，https是如何保证数据安全的</li>
</ol>
</li>
<li><ol start="11">
<li>IP地址子网划分</li>
</ol>
</li>
<li><ol start="12">
<li>POST和GET区别</li>
</ol>
</li>
<li><ol start="13">
<li>DNS解析过程</li>
</ol>
</li>
</ul>
<h2 id="深入部分"><a href="#深入部分" class="headerlink" title="深入部分"></a>深入部分</h2><ul>
<li><ol start="14">
<li>TCP如何保证数据的可靠传输的（这个问题可以引申出很多子问题，拥塞控制慢开始、拥塞避免、快重传、滑动窗口协议、停止等待协议、超时重传机制，最好都能掌握）</li>
</ol>
</li>
<li><ol start="15">
<li>地址解析协议ARP</li>
</ol>
</li>
<li><ol start="16">
<li>交换机和路由器的区别</li>
</ol>
</li>
</ul>
<h3 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h3><h3 id="端口个数为什么是65535个？"><a href="#端口个数为什么是65535个？" class="headerlink" title="端口个数为什么是65535个？"></a>端口个数为什么是65535个？</h3><ul>
<li>在TCP、UDP协议的开头，会分别有16位来存储源端口号和目标端口号，所以端口个数是2^16-1=65535个。</li>
<li>端口被设计出来主要是为了给协议栈和应用对应：<ul>
<li>协议栈用端口号将数据分配给不同的应用层程序</li>
<li>应用层程序用端口号去区分不同的连接，参见之前提到过的“四元组”</li>
</ul>
</li>
</ul>
<h3 id="端口状态有哪些"><a href="#端口状态有哪些" class="headerlink" title="端口状态有哪些"></a>端口状态有哪些</h3><ul>
<li>1、LISTENING状态。FTP服务启动后首先处于侦听（LISTENING）状态。</li>
<li>2、ESTABLISHED状态。ESTABLISHED的意思是建立连接。表示两台机器正在通信。</li>
<li>3、CLOSE_WAIT。对方主动关闭连接或者网络异常导致连接中断，这时我方的状态会变成CLOSE_WAIT 此时我方要调用close()来使得连接正确关闭</li>
<li>4、TIME_WAIT<ul>
<li>我方主动调用close()断开连接，收到对方确认后状态变为TIME_WAIT。TCP协议规定TIME_WAIT状态会一直持续2MSL(即两倍的分 段最大生存期)，以此来确保旧的连接状态不会对新连接产生影响。处于TIME_WAIT状态的连接占用的资源不会被内核释放，所以作为服务器，在可能的情 况下，尽量不要主动断开连接，以减少TIME_WAIT状态造成的资源浪费。</li>
<li>目前有一种避免TIME_WAIT资源浪费的方法，就是关闭socket的LINGER选项。但这种做法是TCP协议不推荐使用的，在某些情况下这个操作可能会带来错误。</li>
</ul>
</li>
<li>5、SYN_SENT状态<ul>
<li>SYN_SENT状态表示请求连接，当你要访问其它的计算机的服务时首先要发个同步信号给该端口，此时状态为SYN_SENT，如果连接成功了就变为 ESTABLISHED，此时SYN_SENT状态非常短暂。但如果发现SYN_SENT非常多且在向不同的机器发出，那你的机器可能中了冲击波或震荡波 之类的病毒了。这类病毒为了感染别的计算机，它就要扫描别的计算机，在扫描的过程中对每个要扫描的计算机都要发出了同步请求，这也是出现许多 SYN_SENT的原因。</li>
</ul>
</li>
</ul>
<h3 id="http的s加密是在哪一层，如何处理的。"><a href="#http的s加密是在哪一层，如何处理的。" class="headerlink" title="http的s加密是在哪一层，如何处理的。"></a>http的s加密是在哪一层，如何处理的。</h3><ul>
<li>s指的是SSL或TLS加密。因为http是明文传输，为了数据安全，在应用层与传输层中间添加一个加密层来加密数据的传输。</li>
<li>这个加密用了对称加密和非对称加密的结合。</li>
</ul>
<h3 id="什么是socket，为什么要有socket。"><a href="#什么是socket，为什么要有socket。" class="headerlink" title="什么是socket，为什么要有socket。"></a>什么是socket，为什么要有socket。</h3><ul>
<li>socket是传输层协议的分装，让应用层更方便的进行网络编程。</li>
</ul>
<h3 id="urlencode和urldecode何时使用，有什么作用？"><a href="#urlencode和urldecode何时使用，有什么作用？" class="headerlink" title="urlencode和urldecode何时使用，有什么作用？"></a>urlencode和urldecode何时使用，有什么作用？</h3><ul>
<li>url中合法的字符有两大类<ul>
<li>URL元字符：分号（;），逗号（’,’），斜杠（/），问号（?），冒号（:），at（@），&amp;，等号（=），加号（+），美元符号（$），井号（#）</li>
<li>语义字符：a-z，A-Z，0-9，连词号（-），下划线（_），点（.），感叹号（!），波浪线（~），星号（*），单引号（），圆括号（()`）</li>
</ul>
</li>
<li>用来传输中文编码，转换成统一安全字符格式。</li>
</ul>
<h3 id="python中如何使用urlencode和urldecode。"><a href="#python中如何使用urlencode和urldecode。" class="headerlink" title="python中如何使用urlencode和urldecode。"></a>python中如何使用urlencode和urldecode。</h3><ul>
<li>urllib.parse.quote(str,  safe=’/‘)<ul>
<li>http%3A//<a href="http://www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">www.example.com/api%3Ftext%3D%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li>
</ul>
</li>
<li>urllib.parse.quote(str,  safe=’/:?=’)<ul>
<li><a href="http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C" target="_blank" rel="noopener">http://www.example.com/api?text=%E4%B8%AD%E6%96%87%E5%9C%A8%E8%BF%99%E9%87%8C</a></li>
</ul>
</li>
<li>如上，默认会处理一些非中文字符串情况，所以可以对中文进行单独转义既可</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>http面试题</title>
    <url>/interview/net/http.html</url>
    <content><![CDATA[<h3 id="HTTP-Keep-Alive的作用及应用场景"><a href="#HTTP-Keep-Alive的作用及应用场景" class="headerlink" title="HTTP Keep-Alive的作用及应用场景"></a>HTTP Keep-Alive的作用及应用场景</h3><ul>
<li>作用：Keep-Alive：使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。Web服务器，基本上都支持HTTP Keep-Alive。</li>
<li>缺点：对于提供静态内容的网站来说，这个功能通常很有用。但是，对于负担较重的网站来说，虽然为客户保留打开的连 接有一定的好处，但它同样影响了性能，因为在处理暂停期间，本来可以释放的资源仍旧被占用。当Web服务器和应用服务器在同一台机器上运行时，Keep- Alive功能对资源利用的影响尤其突出。</li>
<li>解决：Keep-Alive: timeout=5, max=100。timeout：过期时间5秒（对应httpd.conf里的参数是：KeepAliveTimeout），max是最多一百次请求，强制断掉连接。就是在timeout时间内又有新的连接过来，同时max会自动减1，直到为0，强制断掉。</li>
</ul>
<h3 id="表单中-get与post提交方法的区别"><a href="#表单中-get与post提交方法的区别" class="headerlink" title="表单中 get与post提交方法的区别?"></a>表单中 get与post提交方法的区别?</h3><ul>
<li>get是发送请求HTTP协议通过url参数传递进行接收；数据量小；不太安全</li>
<li>post是实体数据,可以通过表单提交大量信息；数据量大；安全</li>
</ul>
<h3 id="下列HTTP状态码出现的可能原因-如何处理"><a href="#下列HTTP状态码出现的可能原因-如何处理" class="headerlink" title="下列HTTP状态码出现的可能原因, 如何处理"></a>下列HTTP状态码出现的可能原因, 如何处理</h3><ul>
<li>200 请求已成功，请求所希望的响应头或数据体将随此响应返回。</li>
<li>301 被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。</li>
<li>404 请求失败，请求所希望得到的资源未被在服务器上发现。</li>
<li>502 作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</li>
<li>503 由于临时的服务器维护或者过载，服务器当前无法处理请求。</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>数据库基础面试题</title>
    <url>/interview/storage/basic.html</url>
    <content><![CDATA[<h3 id="待处理问题"><a href="#待处理问题" class="headerlink" title="待处理问题"></a>待处理问题</h3><ul>
<li>唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</li>
<li>为什么要用 B+tree 作为 MySql 索引的数据结构</li>
<li>聚集索引与非聚集索引的区别</li>
<li>DDL、DML、DCL 分别指什么</li>
<li>explain 命令</li>
<li>数据库的几大范式</li>
<li>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</li>
<li>什么是自适应哈希索引（AHI）</li>
<li>limit 20000 加载很慢怎么解决</li>
<li>常见的几种分布式 ID 的设计方案<br>基础部分<ul>
<li><ol>
<li>事务四大特性（ACID）</li>
</ol>
</li>
<li><ol start="2">
<li>数据库隔离级别，每个级别会引发什么问题，mysql默认是哪个级别</li>
</ol>
</li>
<li><ol start="3">
<li>MYSQL的两种存储引擎区别（事务、锁级别等等），各自的适用场景</li>
</ol>
</li>
<li><ol start="4">
<li>数据库的优化（从sql语句优化和索引两个部分回答）</li>
</ol>
</li>
<li><ol start="5">
<li>索引有B+索引和hash索引，各自的区别</li>
</ol>
</li>
<li><ol start="6">
<li>B+索引数据结构，和B树的区别</li>
</ol>
</li>
<li><ol start="7">
<li>索引的分类（主键索引、唯一索引），最左前缀原则，哪些情况索引会失效</li>
</ol>
</li>
<li><ol start="8">
<li>聚集索引和非聚集索引区别。</li>
</ol>
</li>
<li><ol start="9">
<li>有哪些锁（乐观锁悲观锁），select时怎么加排它锁</li>
</ol>
</li>
<li><ol start="10">
<li>关系型数据库和非关系型数据库区别</li>
</ol>
</li>
<li><ol start="11">
<li>了解nosql</li>
</ol>
</li>
<li><ol start="12">
<li>数据库三范式，根据某个场景设计数据表（可以通过手绘ER图）</li>
</ol>
</li>
<li><ol start="13">
<li>数据库的主从复制</li>
</ol>
</li>
<li><ol start="14">
<li>使用explain优化sql和索引</li>
</ol>
</li>
<li><ol start="15">
<li>long_query怎么解决</li>
</ol>
</li>
<li><ol start="16">
<li>内连接、外连接、交叉连接、笛卡儿积等<br>深入</li>
</ol>
</li>
<li><ol>
<li>MVCC机制</li>
</ol>
</li>
<li><ol start="2">
<li>根据具体场景，说明版本控制机制</li>
</ol>
</li>
<li><ol start="3">
<li>死锁怎么解决</li>
</ol>
</li>
<li><ol start="4">
<li>varchar和char的使用场景。</li>
</ol>
</li>
<li><ol start="5">
<li>mysql并发情况下怎么解决（通过事务、隔离级别、锁）</li>
</ol>
</li>
</ul>
</li>
</ul>
<h3 id="数据库中的事务是什么"><a href="#数据库中的事务是什么" class="headerlink" title="数据库中的事务是什么?"></a>数据库中的事务是什么?</h3><ul>
<li>事务（transaction）是作为一个单元的一组有序的数据库操作。如果组中的所有操作都成功，则认为事务成功，即使只有一个操作失败，事务也不成功。如果所有操作完成，事务则提交，其修改将作用于所有其他数据库进程。如果一个操作失败，则事务将回滚，该事务所有操作的影响都将取消。</li>
</ul>
<h3 id="优化MYSQL数据库的方法"><a href="#优化MYSQL数据库的方法" class="headerlink" title="优化MYSQL数据库的方法?"></a>优化MYSQL数据库的方法?</h3><ul>
<li>选取最适用的字段属性,尽可能减少定义字段长度,尽量把字段设置NOT NULL,例如’省份,性别’,最好设置为ENUM</li>
<li>使用连接（JOIN）来代替子查询</li>
<li>使用联合(UNION)来代替手动创建的临时表</li>
<li>建立索引</li>
</ul>
<p>varchar快速很多，但是浪费存储空间，所以对存储不大，但在速度上有要求的可以使用char类型，反之可以用varchar类型来实例。</p>
<h3 id="优化数据库的方法。说说-SQL-优化之道"><a href="#优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="优化数据库的方法。说说 SQL 优化之道"></a>优化数据库的方法。说说 SQL 优化之道</h3><ul>
<li>主机性能</li>
<li>内存使用性能</li>
<li>网络传输性能</li>
<li>SQL语句执行性能</li>
</ul>
<h3 id="ACID规则"><a href="#ACID规则" class="headerlink" title="ACID规则"></a>ACID规则</h3><p>事务在英文中是transaction，和现实世界中的交易很类似，它有如下四个特性：</p>
<ul>
<li>1、A (Atomicity) 原子性<ul>
<li>原子性很容易理解，也就是说事务里的所有操作要么全部做完，要么都不做，事务成功的条件是事务里的所有操作都成功，只要有一个操作失败，整个事务就失败，需要回滚。</li>
<li>比如银行转账，从A账户转100元至B账户，分为两个步骤：1）从A账户取100元；2）存入100元至B账户。这两步要么一起完成，要么一起不完成，如果只完成第一步，第二步失败，钱会莫名其妙少了100元。</li>
</ul>
</li>
<li>2、C (Consistency) 一致性<ul>
<li>一致性也比较容易理解，也就是说数据库要一直处于一致的状态，事务的运行不会改变数据库原本的一致性约束。<br>例如现有完整性约束a+b=10，如果一个事务改变了a，那么必须得改变b，使得事务结束后依然满足a+b=10，否则事务失败。</li>
</ul>
</li>
<li>3、I (Isolation) 独立性<ul>
<li>所谓的独立性是指并发的事务之间不会互相影响，如果一个事务要访问的数据正在被另外一个事务修改，只要另外一个事务未提交，它所访问的数据就不受未提交事务的影响。</li>
<li>比如现在有个交易是从A账户转100元至B账户，在这个交易还未完成的情况下，如果此时B查询自己的账户，是看不到新增加的100元的。</li>
</ul>
</li>
<li>4、D (Durability) 持久性<ul>
<li>持久性是指一旦事务提交后，它所做的修改将会永久的保存在数据库上，即使出现宕机也不会丢失。</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql面试题</title>
    <url>/interview/storage/mysql.html</url>
    <content><![CDATA[<h3 id="Mysql存储引擎有哪些？有什么区别？"><a href="#Mysql存储引擎有哪些？有什么区别？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？"></a>Mysql存储引擎有哪些？有什么区别？</h3><ul>
<li>innodb、myisam</li>
<li>MyISAM：成熟、稳定、易于管理，快速读取。一些功能不支持（事务等），表级锁。</li>
<li>InnoDB：支持事务、外键等特性、数据行锁定。空间占用大，不支持全文索引等。</li>
</ul>
<h3 id="varchar和char有什么区别"><a href="#varchar和char有什么区别" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><ul>
<li>char 长度是固定的，不管你存储的数据是多少他都会都固定的长度。而varchar则处可变长度但他要在总长度上加1字符，这个用来存储位置。</li>
<li>char 固定长度，所以在处理速度上要比</li>
</ul>
<h3 id="1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？"><a href="#1-数据库中的事务是什么-事务的隔离级别-脏读、幻读、不可重复读是什么意思？" class="headerlink" title="1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？"></a>1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？</h3><ul>
<li><p>数据库事务</p>
<ul>
<li>将一组相关操作组合为一个要么全部成功要么全部失败的单元</li>
<li>具有ACID（原子性、一致性、隔离性和持久性）属性<ul>
<li>原子性(Atomicity)：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚</li>
<li>一致性(Consistent)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须于一致性状态</li>
<li>隔离性(Isolation)：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所扰，多个并发事务之间要相互隔离。</li>
<li>持久性(Duration)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</li>
</ul>
</li>
</ul>
</li>
<li><p>事物隔离级别</p>
<ul>
<li>Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。</li>
<li>Repeatable read (可重复读)：可避免脏读、不可重复读的发生。</li>
<li>Read committed (读已提交)：可避免脏读的发生。</li>
<li>Read uncommitted (读未提交)：最低级别，任何情况都无法保证。</li>
</ul>
</li>
<li><p>脏读、幻读、不可重复读</p>
<ul>
<li>脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据</li>
<li>不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li>
<li>幻读：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。</li>
</ul>
</li>
<li><p>备注：</p>
<ul>
<li>不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。</li>
<li>幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）</li>
<li>当前事务的隔离级别：select @@tx_isolation;<a id="more"></a>
<h3 id="2-优化数据库的方法。说说-SQL-优化之道"><a href="#2-优化数据库的方法。说说-SQL-优化之道" class="headerlink" title="2.优化数据库的方法。说说 SQL 优化之道"></a>2.优化数据库的方法。说说 SQL 优化之道</h3></li>
</ul>
</li>
<li><p>主机性能</p>
</li>
<li><p>内存使用性能</p>
</li>
<li><p>网络传输性能</p>
</li>
<li><p>SQL语句执行性能</p>
</li>
</ul>
<h3 id="3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别"><a href="#3-唯一索引和普通索引的区别，索引类别（B-树索引、全文索引、哈希索引），索引的区别" class="headerlink" title="3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别"></a>3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别</h3><h3 id="为什么要用-B-tree-作为-MySql-索引的数据结构"><a href="#为什么要用-B-tree-作为-MySql-索引的数据结构" class="headerlink" title="为什么要用 B+tree 作为 MySql 索引的数据结构"></a>为什么要用 B+tree 作为 MySql 索引的数据结构</h3><h3 id="聚集索引与非聚集索引的区别"><a href="#聚集索引与非聚集索引的区别" class="headerlink" title="聚集索引与非聚集索引的区别"></a>聚集索引与非聚集索引的区别</h3><h3 id="Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？"><a href="#Mysql存储引擎有哪些？有什么区别？存储引擎的-InnoDB-与-MyISAM区别、优缺点、使用场景？" class="headerlink" title="Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？"></a>Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？</h3><h3 id="varchar和char有什么区别-1"><a href="#varchar和char有什么区别-1" class="headerlink" title="varchar和char有什么区别"></a>varchar和char有什么区别</h3><h3 id="DDL、DML、DCL-分别指什么"><a href="#DDL、DML、DCL-分别指什么" class="headerlink" title="DDL、DML、DCL 分别指什么"></a>DDL、DML、DCL 分别指什么</h3><h3 id="explain-命令"><a href="#explain-命令" class="headerlink" title="explain 命令"></a>explain 命令</h3><h3 id="数据库的几大范式"><a href="#数据库的几大范式" class="headerlink" title="数据库的几大范式"></a>数据库的几大范式</h3><h3 id="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"><a href="#说说分库与分表设计，分库与分表带来的分布式困境与对应之策" class="headerlink" title="说说分库与分表设计，分库与分表带来的分布式困境与对应之策"></a>说说分库与分表设计，分库与分表带来的分布式困境与对应之策</h3><h3 id="什么是自适应哈希索引（AHI）"><a href="#什么是自适应哈希索引（AHI）" class="headerlink" title="什么是自适应哈希索引（AHI）"></a>什么是自适应哈希索引（AHI）</h3><h3 id="limit-20000-加载很慢怎么解决"><a href="#limit-20000-加载很慢怎么解决" class="headerlink" title="limit 20000 加载很慢怎么解决"></a>limit 20000 加载很慢怎么解决</h3><h3 id="常见的几种分布式-ID-的设计方案"><a href="#常见的几种分布式-ID-的设计方案" class="headerlink" title="常见的几种分布式 ID 的设计方案"></a>常见的几种分布式 ID 的设计方案</h3>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/django/model.html</url>
    <content><![CDATA[<p>django model operate</p>
]]></content>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/man/docker/commands.html</url>
    <content><![CDATA[<h1 id="docker常用命令"><a href="#docker常用命令" class="headerlink" title="docker常用命令"></a>docker常用命令</h1><ul>
<li><p>Management Commands:</p>
<ul>
<li><strong><code>config</code></strong>      Manage Docker configs</li>
<li><strong><code>container</code></strong>   Manage containers</li>
<li><strong><code>image</code></strong>       Manage images</li>
<li><strong><code>network</code></strong>     Manage networks</li>
<li><strong><code>node</code></strong>        Manage Swarm nodes</li>
<li><strong><code>plugin</code></strong>      Manage plugins</li>
<li><strong><code>secret</code></strong>      Manage Docker secrets</li>
<li><strong><code>service</code></strong>     Manage services</li>
<li><strong><code>stack</code></strong>       Manage Docker stacks</li>
<li><strong><code>swarm</code></strong>       Manage Swarm</li>
<li><strong><code>system</code></strong>      Manage Docker</li>
<li><strong><code>volume</code></strong>      Manage volumes<br>
</li>
</ul>
</li>
<li><p>Commands:</p>
<ul>
<li><strong><code>attach</code></strong>      Attach local standard input, output, and error streams to a running container</li>
<li><strong><code>build</code></strong>       Build an image from a Dockerfile</li>
<li><strong><code>commit</code></strong>      Create a new image from a container’s changes</li>
<li><strong><code>cp</code></strong>          Copy files/folders between a container and the local filesystem</li>
<li><strong><code>create</code></strong>      Create a new container</li>
<li><strong><code>diff</code></strong>        Inspect changes to files or directories on a container’s filesystem</li>
<li><strong><code>events</code></strong>      Get real time events from the server</li>
<li><strong><code>exec</code></strong>        Run a command in a running container</li>
<li><strong><code>export</code></strong>      Export a container’s filesystem as a tar archive</li>
<li><strong><code>history</code></strong>     Show the history of an image</li>
<li><strong><code>images</code></strong>      List images</li>
<li><strong><code>import</code></strong>      Import the contents from a tarball to create a filesystem image</li>
<li><strong><code>info</code></strong>        Display system-wide information</li>
<li><strong><code>inspect</code></strong>     Return low-level information on Docker objects</li>
<li><strong><code>kill</code></strong>        Kill one or more running containers</li>
<li><strong><code>load</code></strong>        Load an image from a tar archive or STDIN</li>
<li><strong><code>login</code></strong>       Log in to a Docker registry</li>
<li><strong><code>logout</code></strong>      Log out from a Docker registry</li>
<li><strong><code>logs</code></strong>        Fetch the logs of a container</li>
<li><strong><code>pause</code></strong>       Pause all processes within one or more containers</li>
<li><strong><code>port</code></strong>        List port mappings or a specific mapping for the container</li>
<li><strong><code>ps</code></strong>          List containers</li>
<li><strong><code>pull</code></strong>        Pull an image or a repository from a registry</li>
<li><strong><code>push</code></strong>        Push an image or a repository to a registry</li>
<li><strong><code>rename</code></strong>      Rename a container</li>
<li><strong><code>restart</code></strong>     Restart one or more containers</li>
<li><strong><code>rm</code></strong>          Remove one or more containers</li>
<li><strong><code>rmi</code></strong>         Remove one or more images</li>
<li><strong><code>run</code></strong>         Run a command in a new container</li>
<li><strong><code>save</code></strong>        Save one or more images to a tar archive (streamed to STDOUT by default)</li>
<li><strong><code>search</code></strong>      Search the Docker Hub for images</li>
<li><strong><code>start</code></strong>       Start one or more stopped containers</li>
<li><strong><code>stats</code></strong>       Display a live stream of container(s) resource usage statistics</li>
<li><strong><code>stop</code></strong>        Stop one or more running containers</li>
<li><strong><code>tag</code></strong>         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</li>
<li><strong><code>top</code></strong>         Display the running processes of a container</li>
<li><strong><code>unpause</code></strong>     Unpause all processes within one or more containers</li>
<li><strong><code>update</code></strong>      Update configuration of one or more containers</li>
<li><strong><code>version</code></strong>     Show the Docker version information</li>
<li><strong><code>wait</code></strong>        Block until one or more containers stop, then print their exit codes</li>
</ul>
</li>
</ul>
<br>

<ul>
<li><strong><code>docker images</code></strong>       // 查看存在多少镜像</li>
<li><strong><code>docker ps</code></strong>           // 查看镜像运行情况</li>
<li><strong><code>docker run -t -i</code></strong>    // 运行镜像。并进行交互模式。</li>
<li><strong><code>docker stop</code></strong>         // 停止运行镜像，后边跟镜像ID或name</li>
<li><strong><code>docker search</code></strong>       // 搜索镜像仓库</li>
<li><strong><code>docker pull</code></strong>         // 拉取镜像</li>
<li><strong><code>docker inspect</code></strong>      // 查看镜像的json文件，即全部详细信息</li>
<li><strong><code>docker port</code></strong>         // 查看docker与宿主机的端口映射关系</li>
<li><strong><code>docker commit</code></strong>       // 用来生成新的版本</li>
<li><strong><code>docker build</code></strong>        // 用docker file来创建镜像</li>
<li><strong><code>docker tag</code></strong>          // 设置镜像标签</li>
</ul>
<br>

<ul>
<li>容器生命周期管理<ul>
<li><strong><code>create</code></strong></li>
<li><strong><code>run</code></strong></li>
<li><strong><code>start/stop/restart</code></strong></li>
<li><strong><code>pause/unpause</code></strong></li>
<li><strong><code>exec</code></strong></li>
<li><strong><code>rm</code></strong></li>
<li><strong><code>kill</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li><p>容器操作</p>
<ul>
<li><strong><code>ps</code></strong></li>
<li><strong><code>inspect</code></strong></li>
<li><strong><code>top</code></strong></li>
<li><strong><code>attach</code></strong></li>
<li><strong><code>events</code></strong></li>
<li><strong><code>logs</code></strong></li>
<li><strong><code>wait</code></strong></li>
<li><strong><code>export</code></strong></li>
<li><strong><code>port</code></strong></li>
</ul>
</li>
<li><p>容器rootfs命令</p>
<ul>
<li><strong><code>commit</code></strong></li>
<li><strong><code>cp</code></strong></li>
<li><strong><code>diff</code></strong></li>
</ul>
</li>
<li><p>镜像仓库</p>
<ul>
<li><strong><code>login</code></strong></li>
<li><strong><code>pull</code></strong></li>
<li><strong><code>push</code></strong></li>
<li><strong><code>search</code></strong></li>
</ul>
</li>
<li><p>本地镜像管理</p>
<ul>
<li><strong><code>images</code></strong></li>
<li><strong><code>rmi</code></strong></li>
<li><strong><code>tag</code></strong></li>
<li><strong><code>build</code></strong></li>
<li><strong><code>history</code></strong></li>
<li><strong><code>save</code></strong></li>
<li><strong><code>import</code></strong></li>
</ul>
</li>
<li><p>信息</p>
<ul>
<li><strong><code>info</code></strong></li>
<li><strong><code>version</code></strong></li>
</ul>
</li>
</ul>
<ul>
<li>查看容器重启次数<ul>
<li>docker inspect -f “ .RestartCount “ container_id</li>
</ul>
</li>
<li>查看容器最后一次的启动时间<ul>
<li>docker inspect -f “ .State.StartedAt ” container_id</li>
</ul>
</li>
<li>commit一个镜像<ul>
<li>docker run –name=”python_env_l” -it image_name /bin/bash</li>
<li>docker commit -m=”msg” -a=”user_name” 4631e1627784 image_name:2.1</li>
<li>docker tag  image_name:2.1 image_name:latest</li>
<li>docker push image_name</li>
</ul>
</li>
<li>Docker构建镜像<ul>
<li>docker build -t imageName .</li>
</ul>
</li>
<li>打标签<ul>
<li>Docker tag image user/newName:tag</li>
</ul>
</li>
<li>批量删除无用镜像<ul>
<li>docker image rm <code>docker images|grep none|awk {&#39;print $3&#39;}</code></li>
</ul>
</li>
<li>批量删除无用容器<ul>
<li>sudo docker rm <code>sudo docker ps -a |grep Exited| awk {&#39;print $1&#39;}</code></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/man/git/commands.html</url>
    <content><![CDATA[<ul>
<li><strong><code>git init</code></strong>                                #git 初始化仓库</li>
<li><strong><code>git clone remote_url</code></strong>                    #git 克隆远程库</li>
<li><strong><code>git add .</code></strong>                               #git  添加所有文件</li>
<li><strong><code>git commit -m &quot;批注&quot;</code></strong>                     #git 提交</li>
<li><strong><code>git push &lt;remoteName&gt; &lt;localName&gt;</code></strong>       #git推送至远程</li>
<li><strong><code>git remote add origin &lt;server&gt;</code></strong>          #远程没有创建仓库，将本地推送到远程仓库</li>
<li><strong><code>git checkout -b branch_name</code></strong>             #创建分支，并切换到分支</li>
<li><strong><code>git checkout master</code></strong>                     #切换到主分支</li>
<li><strong><code>git branch -d &lt;branch_name&gt;</code></strong>             #删除分支</li>
<li><strong><code>git pull &lt;remoteName&gt; &lt;localName&gt;</code></strong>        #将本地仓库更新至最新</li>
<li><strong><code>git merge branch_name</code></strong>                    #将其他分支合并到本地主分支</li>
<li><strong><code>git diff &lt;sourch_branch&gt; &lt;target_branch&gt;</code></strong> #比对分支</li>
<li><strong><code>git tag &lt;tag_name&gt;</code></strong>                      #创建标签</li>
<li><strong><code>git show</code></strong></li>
<li><strong><code>git status</code></strong>                              #查看当前状态</li>
<li><strong><code>git fetch</code></strong>                               #合并</li>
<li><strong><code>git config --list</code></strong>                       #查看配置信息</li>
<li><strong><code>git rm &lt;file_name&gt;</code></strong>                      #删除文件</li>
<li><strong><code>git mv &lt;old_name&gt; &lt;new_name&gt;</code></strong>            #重命名文件</li>
<li><strong><code>git log</code></strong>                                 #查看日志</li>
<li><strong><code>git rebase HEAD &lt;file_name&gt;</code></strong>             #重置</li>
<li><strong><code>git remote -v</code></strong>                           #查看远程仓库</li>
<li><strong><code>git remote rm &lt;file_name&gt;</code></strong>               #删除远程仓库</li>
<li><strong><code>git branch</code></strong>                              #查看本地分支</li>
<li><strong><code>git branch -r</code></strong>                           #查看远程分支</li>
<li><strong><code>git branch &lt;branch_name&gt;</code></strong>                #创建本地分支</li>
<li><strong><code>git config --global user.name NEWNAME</code></strong>   #修改用户名</li>
<li><strong><code>git config --global user.email NEWEMAIL</code></strong> #修改用户邮箱</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>linux终端命令</title>
    <url>/man/linux/commands.html</url>
    <content><![CDATA[<ul>
<li>autojump</li>
<li><ul>
<li>自动跳转文件夹，不用cd</li>
</ul>
</li>
<li>tree</li>
<li><ul>
<li>以树状图列出当前目录结构</li>
</ul>
</li>
<li>you-get</li>
<li><ul>
<li>视频下载</li>
</ul>
</li>
<li>tldr</li>
<li><ul>
<li>命令示例文档</li>
</ul>
</li>
<li>htop</li>
<li><ul>
<li>更强大的top</li>
</ul>
</li>
<li>git</li>
<li><ul>
<li>版本控制工具</li>
</ul>
</li>
<li>vim</li>
<li><ul>
<li>编辑器</li>
</ul>
</li>
<li>tmux</li>
<li><ul>
<li>终端复用神器</li>
</ul>
</li>
<li>thefuck<ul>
<li>命令出错自动完善</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>crontab表示法</title>
    <url>/man/linux/crontab.html</url>
    <content><![CDATA[<h3 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h3><p>crontab是linux上的定时任务工具，用来做定时管理服务。其常用的命令如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">crontab -l <span class="comment"># 罗列出当前用户的所有定时任务列表</span></span><br><span class="line">crontab -e <span class="comment"># 编辑定时任务</span></span><br><span class="line">crontab -r <span class="comment"># 删除定时任务</span></span><br></pre></td></tr></table></figure>

<p>当然，最重要的还是如何使用cron来表示什么时候什么频次来执行任务。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">*  *  * *  *   <span class="built_in">command</span></span><br><span class="line">分 时 日 月 周   命令</span><br></pre></td></tr></table></figure>

<a id="more"></a>
<p>如上表示，有5个位置符来表示，后边跟需要执行的命令。</p>
<ul>
<li>第一列：分(0-59)</li>
<li>第二列：时(0-23)</li>
<li>第三列：日(1-31)</li>
<li>第四列：月(1-12)</li>
<li>第五列：周(0-6,0为星期天)</li>
</ul>
<p>除了以上的表示方法，还可以结合一些特殊的符号来表示</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* ：   表示任何时刻</span><br><span class="line">, ：   表示在这几个选项内</span><br><span class="line">－ ：  表示一个范围，如第二列里： 3-5，就表示3到5点</span><br><span class="line">/n ：  表示每个n的单位执行一次，如第二列里，*/1, 就表示每隔1个小时执行一次命令。也可以写成1-23/1.</span><br></pre></td></tr></table></figure>

<h3 id="二、示例"><a href="#二、示例" class="headerlink" title="二、示例"></a>二、示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">* * * * *                           每分钟执行一次</span><br><span class="line">0 */1 * * *                         每分钟执行一次</span><br><span class="line">43 21 * * *                         21:43 执行</span><br><span class="line">15 05 * * *                         05:15 执行</span><br><span class="line">0 17 * * *                          17:00 执行</span><br><span class="line">0 17 * * 1                          每周一的 17:00 执行</span><br><span class="line">0,10 17 * * 0,2,3                   每周日,周二,周三的 17:00和 17:10 执行</span><br><span class="line">0-10 17 1 * *                       毎月1日从 17:00到7:10 毎隔1分钟 执行</span><br><span class="line">0 0 1,15 * 1                        毎月1日和 15日和 一日的 0:00 执行</span><br><span class="line">42 4 1 * *                          毎月1日的 4:42分 执行</span><br><span class="line">0 21 * * 1-6                        周一到周六 21:00 执行</span><br><span class="line">0,10,20,30,40,50 * * * *            每隔10分 执行</span><br><span class="line">*/10 * * * *                        每隔10分 执行</span><br><span class="line">* 1 * * *                           从1:0到1:59 每隔1分钟 执行</span><br><span class="line">0 1 * * *                           1:00 执行</span><br><span class="line">0 * * * *                           毎时0分 每隔1小时 执行</span><br><span class="line">2 8-20/3 * * *                      8:02,11:02,14:02,17:02,20:02 执行</span><br><span class="line">30 5 1,15 * *                       1日 和 15日的 5:30 执行</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>mysql常用手册</title>
    <url>/man/mysql/index.html</url>
    <content><![CDATA[<ul>
<li>1.<a href="basic.html">架构介绍</a></li>
<li>2.<a href="commands.html">常用命令</a></li>
<li>3.<a href="character.html">编码类型</a></li>
<li>4.<a href="column_type.html">字段类型</a></li>
<li>5.<a href="transaction.html">事务处理</a></li>
<li>6.<a href="indexed.html">索引介绍</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql常用语句</title>
    <url>/man/mysql/commands.html</url>
    <content><![CDATA[<h2 id="一、权限登录类"><a href="#一、权限登录类" class="headerlink" title="一、权限登录类"></a>一、权限登录类</h2><ul>
<li><p>1.授权用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 授权用户</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">PRIVILEGES</span> <span class="keyword">ON</span> *.* <span class="keyword">TO</span> <span class="string">'username'</span>@<span class="string">'%'</span> <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'password'</span> <span class="keyword">WITH</span> <span class="keyword">GRANT</span> <span class="keyword">OPTION</span>;</span><br><span class="line"><span class="keyword">FLUSH</span> <span class="keyword">PRIVILEGES</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 查看某个用户的权限</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">grants</span> <span class="keyword">for</span> username;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.远程连接</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql -h192.168.1.1 -P3306 -uroot -p</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.导出数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysqldump -h192.168.1.1-P3306 -uroot -p db_name &gt; db_name.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.导入数据库</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p db_name &lt; db_name.sql</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.分析查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> * <span class="keyword">from</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.查询所有的进程</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> procelist;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">full</span> procelist;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="二、DDL"><a href="#二、DDL" class="headerlink" title="二、DDL"></a>二、DDL</h2><blockquote>
<p>数据库</p>
</blockquote>
<ul>
<li><p>1.建数据库语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name <span class="keyword">default</span> <span class="built_in">character</span> <span class="keyword">set</span> utf8mb4 <span class="keyword">collate</span> utf8_general_ci;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.删除数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>表操作</p>
</blockquote>
<ul>
<li><p>2.创建数据表语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`user_info`</span> (</span><br><span class="line">  <span class="string">`id`</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT <span class="keyword">COMMENT</span> <span class="string">'主键ID'</span>,</span><br><span class="line">  <span class="string">`user_id`</span> <span class="built_in">char</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'id'</span>,</span><br><span class="line">  <span class="string">`user_name`</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">COMMENT</span> <span class="string">'姓名'</span>,</span><br><span class="line">  <span class="string">`create_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'创建时间'</span>,</span><br><span class="line">  <span class="string">`update_time`</span> datetime <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">ON</span> <span class="keyword">UPDATE</span> <span class="keyword">CURRENT_TIMESTAMP</span> <span class="keyword">COMMENT</span> <span class="string">'最后更新时间'</span>,</span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>) <span class="keyword">USING</span> BTREE,</span><br><span class="line">  <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> <span class="string">`idx_user`</span> (<span class="string">`user_id`</span>) <span class="keyword">USING</span> BTREE</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8mb4 ROW_FORMAT=DYNAMIC <span class="keyword">COMMENT</span>=<span class="string">'用户信息表'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.查看数据表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有表</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="comment">-- 查看建表语句</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> <span class="keyword">table</span> table_name;</span><br><span class="line"><span class="comment">-- 查看表字段及描述</span></span><br><span class="line">desc table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.查看字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">columns</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.查看索引</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">index</span> <span class="keyword">from</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.删除表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 删除表结构，表结构和数据全部删除</span></span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.新增字段</p>
</li>
<li><p>8.修改字段</p>
</li>
<li><p>9.删除字段</p>
</li>
<li><p>10.添加索引</p>
</li>
<li><p>11.删除索引</p>
</li>
</ul>
<h2 id="三、DML"><a href="#三、DML" class="headerlink" title="三、DML"></a>三、DML</h2><ul>
<li><p>1.查询</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>2.新增</p>
</li>
<li><p>3.修改</p>
</li>
</ul>
<ul>
<li>4.删除<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 全部删除数据，不删表结构。不做表优化</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 按条件限制删除</span></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> table_name <span class="keyword">where</span> is_deleted = <span class="number">1</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除表数据，并优化表空间</span></span><br><span class="line"><span class="keyword">truncate</span> <span class="keyword">table</span> table_name;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>*</p>
<h2 id="四、参数状态"><a href="#四、参数状态" class="headerlink" title="四、参数状态"></a>四、参数状态</h2><ul>
<li><p>1.查看参数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看所有参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span>;</span><br><span class="line"><span class="comment">-- 过滤参数</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%sql%'</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.查看事件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">events</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.查看触发器</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.查看所有状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.查看打开表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">open</span> <span class="keyword">tables</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>6.查看表状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 在某个db下执行</span></span><br><span class="line"><span class="comment">-- 可以查看表的存储引擎，表空间，自增主键，创建和更新时间等</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">table</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.查看数据库状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 查看主库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">master</span> <span class="keyword">status</span>;</span><br><span class="line"><span class="comment">-- 查看从库</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">slave</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>8.查看函数状态</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">function</span> <span class="keyword">status</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>9.查看插件</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> plugins;</span><br></pre></td></tr></table></figure>
</li>
<li><p>10.查看错误</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">errors</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>11.查看存储引擎</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">engines</span>;</span><br></pre></td></tr></table></figure>

</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql编码</title>
    <url>/man/mysql/character.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>mysql索引介绍</title>
    <url>/man/mysql/indexed.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>mysql字段类型</title>
    <url>/man/mysql/column_type.html</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>char</li>
<li>varchar</li>
<li>text</li>
</ul>
<h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><ul>
<li>int</li>
<li>smallint</li>
<li>bigint</li>
</ul>
<h2 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h2><ul>
<li>json</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>VIM使用文档总结</title>
    <url>/man/vim/commands.html</url>
    <content><![CDATA[<ul>
<li><p>向下添加一行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">o</span><br></pre></td></tr></table></figure>
</li>
<li><p>向下翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+f</span><br></pre></td></tr></table></figure>
</li>
<li><p>向上翻页</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+b</span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>
<ul>
<li><p>下一个词</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure>
</li>
<li><p>行尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$</span><br></pre></td></tr></table></figure>
</li>
<li><p>第一个字符行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">^</span><br></pre></td></tr></table></figure>
</li>
<li><p>行首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
</li>
<li><p>撤销</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">u</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gg</span><br></pre></td></tr></table></figure>
</li>
<li><p>文件尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">G</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏首</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+h</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+m</span><br></pre></td></tr></table></figure>
</li>
<li><p>屏尾</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ctrl+l</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>mysql架构介绍</title>
    <url>/man/mysql/basic.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>mysql事务</title>
    <url>/man/mysql/transaction.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>算法基础</title>
    <url>/algorithms/basic.html</url>
    <content><![CDATA[<ul>
<li>第一：复杂度估算和排序算法（上）<ul>
<li>1) 时间复杂度和空间复杂度</li>
<li>2）认识对数器</li>
<li>3）冒泡排序</li>
<li>4）选择排序</li>
<li>5）插入排序</li>
<li>6）如何分析递归过程的时间复杂度</li>
<li>7）归并排序</li>
<li>8）小和问题</li>
</ul>
</li>
<li>第二：复杂度估算和排序算法（下）<ul>
<li>1）荷兰国旗问题</li>
<li>2）随机快速排序</li>
<li>3）堆结构与堆排序</li>
<li>4）认识排序算法的稳定性</li>
<li>5）认识比较器</li>
<li>6）桶排序</li>
<li>7）计数排序</li>
<li>8）基数排序</li>
<li>9）数组排序后的最大差值问题</li>
<li>10）排序算法在工程中的应用</li>
</ul>
</li>
<li>第三：章栈、队列、链表、数组和矩阵结构<br>  1）栈结构<br>  2）队列结构<br>  3）链表结构<br>  4）数组结构<br>  5）矩阵结构<br>  6）二分搜索的扩展</li>
<li>第四：二叉树结构<ul>
<li>1）二叉树结构</li>
<li>2）二叉树的递归与非递归遍历</li>
<li>3）打印二叉树</li>
<li>4）判断搜索二叉树</li>
<li>5）判断完全二叉树</li>
<li>6）判断平衡二叉树</li>
<li>7）折纸问题</li>
<li>8）二叉树节点的前驱节点与后继节点</li>
<li>9）二叉树的序列化和反序列化</li>
</ul>
</li>
<li>第五：和哈希函数有关的三个结构与并查集<br>  1）哈希函数与哈希表<br>  2）布隆过滤器详解<br>  3）一致性哈希结构<br>  4）并查集结构与应用（岛问题）</li>
<li>第六：章图算法<br>  1）图结构的表示方法<br>  2）图的深度优先遍历与宽度优先遍历<br>  3）拓扑排序问题<br>  4）最小生成树问题<br>  5）单源最短路径问题</li>
<li>第七：前缀树、堆结构和贪心算法<br>  1）前缀树<br>  2）堆结构的扩展与应用<br>  3）介绍贪心算法及其相关题目<br>  4）在面试中如何快速的尝试出贪心策略</li>
<li>第八：暴力递归到动态规划<br>  1）递归<br>  2）动态规划<br>  3）如何把暴力递归套路的变成动态规划<br>算法高级：<br>第一：KMP算法和Manacher算法<br>  1）KMP算法及其扩展面试题目<br>  2）Manacher算法及其扩展面试题目<br>第二：窗口内最大值的更新结构和单调栈结构<br>  1）窗口内最大值的更新结构<br>  2）单调栈结构<br>第三：Morris遍历和sortedMap<br>  1）二叉树的Morris遍历<br>  2）跳表结构<br>  3）AVL树和红黑树结构<br>【今日头条、拼多多题目】<br>分类算法的理解<ul>
<li>决策树的原理</li>
<li>支持向量机</li>
<li>逻辑斯蒂回归<br>聚类算法的理解</li>
<li>均值聚类，可选的参数，如果确定聚类个数</li>
<li>聚类和分类的异同，举例说明<br>特征选择算法的理解<br>集成提升的理解</li>
<li>xgboost</li>
<li>gbdt<br>【面试题目】</li>
<li><ol>
<li>二叉树前序递归遍历算法（手写代码）</li>
</ol>
</li>
<li><ol start="2">
<li>二叉树的前中后遍历</li>
</ol>
</li>
<li><ol start="3">
<li>二叉树的文件存储，也就是序列化。</li>
</ol>
</li>
<li><ol start="4">
<li>二叉树遍历，描述下层序遍历。</li>
</ol>
</li>
<li><ol start="5">
<li>二维数组，每行递增，每列递增，任意交换其中的两数，发现并恢复。</li>
</ol>
</li>
<li><ol start="6">
<li>二维数组，每行递增，每列递增，实现查找。</li>
</ol>
</li>
<li><ol start="7">
<li>二维数组，每行递增，每列递增，求第k大的数。</li>
</ol>
</li>
<li><ol start="8">
<li>什么样的数据结构可以满足多次插入删除，取最小数，给出时间复杂度。</li>
</ol>
</li>
<li><ol start="9">
<li>介绍二叉树前序遍历非递归遍历算法（手写代码）</li>
</ol>
</li>
<li><ol start="10">
<li>介绍大顶堆和小顶堆</li>
</ol>
</li>
<li><ol start="11">
<li>从一组数中找出和为sum的三个数（leetcode）</li>
</ol>
</li>
<li><ol start="12">
<li>冒泡排序(手写代码)</li>
</ol>
</li>
<li><ol start="13">
<li>写 find 函数，在目标串中匹配模式串（要考虑中文字符的情况）</li>
</ol>
</li>
<li><ol start="14">
<li>写一个二叉树的非递归的后续遍历</li>
</ol>
</li>
<li><ol start="15">
<li>写一个简单的正则匹配表达式(将文本中的123.4匹配出来)</li>
</ol>
</li>
<li><ol start="16">
<li>写个动态规划，最长公共子序列</li>
</ol>
</li>
<li><ol start="17">
<li>判断一个字符串是否为另外一个字符串旋转之后的字符串</li>
</ol>
</li>
<li><ol start="18">
<li>前k大的数</li>
</ol>
</li>
<li><ol start="19">
<li>单链表的翻转</li>
</ol>
</li>
<li><ol start="20">
<li>去掉连续的重复数字，输出新数组，例如：1，2，2，2，1，3，5——&gt; 3，5。</li>
</ol>
</li>
<li><ol start="21">
<li>去除字符串S1中的字符使得最终的字符串S2不包含’ab’和’c’。（Code）</li>
</ol>
</li>
<li><ol start="22">
<li>合法括号匹配</li>
</ol>
</li>
<li><ol start="23">
<li>在一个字符串中，找出最长的无重复字符的字串</li>
</ol>
</li>
<li><ol start="24">
<li>在二叉树结点结构中加一个指针域，使其指向层次遍历的下一个结点，特别地，每一层的最后一个结点为空。（Code）</li>
</ol>
</li>
<li><ol start="25">
<li>堆排序(手写代码)</li>
</ol>
</li>
<li><ol start="26">
<li>堆是怎么调整的。</li>
</ol>
</li>
<li><ol start="27">
<li>复杂链表的复制<br>【大数据题目】</li>
</ol>
</li>
<li><ol>
<li>100亿数字，怎么统计前100大的？</li>
</ol>
</li>
<li><ol start="2">
<li>10亿个url，每个url大小小于56B，要求去重，内存4G。</li>
</ol>
</li>
<li><ol start="3">
<li>1KW句子算相似度（还是那套分块+hash/建索引，但是因为本人不是做这个的，文本处理根本说一片空白，所以就不误导大家了），之后就是一直围绕大数据的题目不断深化。</li>
</ol>
</li>
<li><ol start="4">
<li>Q1：给定一个1T的单词文件，文件中每一行为一个单词，单词无序且有重复，当前有5台计算机。请问如何统计词频？</li>
</ol>
</li>
<li><ol start="5">
<li>Q2：每台计算机需要计算200G左右的文件，内存无法存放200G内容，那么如何统计这些文件的词频？</li>
</ol>
</li>
<li><ol start="6">
<li>Q3：如何将1T的文件均匀地分配给5台机器，且每台机器统计完词频生成的文件只需要拼接起来即可（即每台机器统计的单词不出现在其他机器中）</li>
</ol>
</li>
<li><ol start="7">
<li>一个大文件A和一个小文件B，里面存的是单词，要求出在文件B中但不在文件A中的单词。然后大文件A是无法直接存到内存中的。</li>
</ol>
</li>
<li><ol start="8">
<li>一道题目是如果有一个人注册一个qq，如何保证这个qq号码和之前已存在的qq号码不重复呢？</li>
</ol>
</li>
<li><ol start="9">
<li>扔硬币，连续出现两次正面即结束，问扔的次数期望</li>
</ol>
</li>
<li><ol start="10">
<li>有100W个集合，每个集合中的word是同义词，同义词具有传递性， 比如集合1中有word a, 集合2中也有word a, 则集合1，2中所有词都是同义词，对这100W个集合进行归并，同义词都在一个集合当中。</li>
</ol>
</li>
<li><ol start="11">
<li>有几个 G 的文本，每行记录了访问 ip 的 log ，如何快速统计 ip 出现次数最高的 10 个 ip，如果只用 linux 指令又该怎么解决；</li>
</ol>
</li>
<li><ol start="12">
<li>海量数据的topk问题。</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><ol start="2">
<li>二叉树相关（层次遍历、求深度、求两个节点距离、翻转二叉树、前中后序遍历）</li>
</ol>
<ul>
<li><ol start="3">
<li>链表相关（插入节点、链表逆置、使用链表进行大数字的加减，双向链表实现队列、寻找链表中的环）</li>
</ol>
</li>
<li><ol start="4">
<li>堆（大量数据中寻找最大N个数字几乎每次都会问，还有堆在插入时进行的调整）</li>
</ol>
</li>
<li><ol start="5">
<li>排序（八大排序，各自的时间复杂度、排序算法的稳定性。快排几乎每次都问）</li>
</ol>
</li>
<li><ol start="6">
<li>二分查找（一般会深入，如寻找数组总和为K的两个数字）</li>
</ol>
</li>
<li><ol start="7">
<li>两个栈实现队列。</li>
</ol>
</li>
<li><ol start="8">
<li>图（深度广度优先遍历、单源最短路径、最小生成树）</li>
</ol>
</li>
<li><ol start="9">
<li>动态规划问题。</li>
</ol>
</li>
<li><ol start="10">
<li>深入</li>
</ol>
</li>
<li><ol start="11">
<li>红黑树性质</li>
</ol>
</li>
<li><ol start="12">
<li>分治法和动态规划的区别</li>
</ol>
</li>
<li><ol start="13">
<li>计算时间复杂度</li>
</ol>
</li>
<li><ol start="14">
<li>二叉树和哈希表查找的时间复杂度</li>
</ol>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>常用的数据结构有哪些？</p>
<ul>
<li>Arrays</li>
<li>Binary Trees</li>
<li>Graphs</li>
<li>Linked Lists</li>
<li>Matrixes</li>
<li>Stacks</li>
<li>Queues</li>
<li>Heaps</li>
<li>Hash Tables</li>
</ul>
</li>
<li><p>一群猴子排成一圈，按1，2，…，n依次编号。然后从第1只开始数，数到第m只,把它踢出圈，从它后面再开始数，再数到第m只，在把它踢出去…，如此不停 的进行下去，直到最后只剩下一只猴子为止，那只猴子就叫做大王。要求编程模拟此过程，输入m、n, 输出最后那个大王的编号(约瑟夫环)。<br>&lt;？php<br>function fuhuan($allnum, $ti){<br>   $arr = array();<br>   for($i = 0; $i &lt; $allnum; $i++){</p>
<pre><code>$arr[$i] = $i;</code></pre><p>   }</p>
<p>   $nums = 1;<br>   while(count($arr) &gt; 1){</p>
<pre><code> foreach ($arr as $key =&gt; $value) {
     if($nums == $ti){
         unset($arr[$key]);
         $nums = 1;
     }else{
         $nums++;
     }
}</code></pre><p>   }<br>   $new_arr = array_values($arr);<br>   var_dump($new_arr[0] + 1);<br>}<br>fuhuan(10,10);</p>
</li>
</ul>
<ul>
<li>常用的数据结构有哪些？</li>
<li>Graph Data Structure Interview Questions<ul>
<li>Breadth First Search</li>
<li>Depth First Search</li>
<li>A* Search</li>
<li>Dijkstra Algorithm</li>
<li>Comparing BFS, DFS, A* and Dijkstra</li>
</ul>
</li>
<li>Linked List Interview Questions (coming soon)<ul>
<li>Inserting and Removing nodes</li>
<li>Comparing Strings</li>
<li>Reversing a List</li>
<li>Selecting a Random Node</li>
</ul>
</li>
<li>Dynamic Programming Interview Questions (coming soon)<ul>
<li>Fibonacci Number Sequence</li>
<li>Longest Common Subsequence</li>
</ul>
</li>
<li>Sorting an Searching Interview Questions (coming soon)<ul>
<li>Binary Search</li>
<li>Bubble Sort</li>
<li>Insertion Sort</li>
<li>Merge Sort</li>
<li>Heap Sort</li>
<li>Quick Sort</li>
<li>Interpolation</li>
<li>Tree/Binary Search Tree</li>
<li>Minimum Depth</li>
<li>Maximum Path Sum</li>
</ul>
</li>
<li>Number Theory Interview Questions (coming soon)<ul>
<li>Euclid’s GCD Algorithm</li>
<li>Extending Euclid’s GCD Algorithm</li>
<li>Diophantine Equation</li>
<li>Chinese Remainder Theorem</li>
<li>Modular Inverse</li>
<li>Semi-Perfect Numbers</li>
</ul>
</li>
<li>String Interview Questions (coming soon)<ul>
<li>Reversing a String</li>
<li>Checking if String contains only digits</li>
<li>Finding Duplicate Characters in a String</li>
<li>How to Convert a String to Integer</li>
<li>Removing Duplicate Characters in a String</li>
<li>Finding the Maximum Occuring Character in a String</li>
<li>Find the First Non-Repeating Character in a String</li>
<li>Checking if Two Strings are Anagrams of Each Other</li>
<li>Counting the Number of Words in a String</li>
</ul>
</li>
<li>Array Interview Questions (coming soon)<ul>
<li>Finding the Missing Number from Array</li>
<li>Finding Duplicate Integers in an Array</li>
<li>Finding the Largest and Smallest Number in Unsorted Array</li>
<li>Removing Duplicates from an Array</li>
<li>Reversing an Array</li>
<li>Finding the k-th Smallest Integer in an Unsorted Array</li>
<li>Finding Common Elements Between Multiple Arrays</li>
</ul>
</li>
</ul>
<ul>
<li>基本数据结构<ul>
<li>数组</li>
<li>链表</li>
<li>树<ul>
<li>红黑树</li>
<li>二叉树</li>
</ul>
</li>
<li>图<ul>
<li>无环图</li>
<li>有环图</li>
<li>有向图</li>
<li>无向图</li>
</ul>
</li>
<li>Hash</li>
<li>跳跃表</li>
</ul>
</li>
</ul>
<ul>
<li>排序算法<ul>
<li>冒泡排序</li>
<li>归并排序(MERGE SORT)</li>
<li>快速排序(QUICK SORT)</li>
<li>堆积排序(HEAP SORT)</li>
</ul>
</li>
</ul>
<ul>
<li>查找算法<ul>
<li>二分查找</li>
</ul>
</li>
</ul>
<ul>
<li>分布式<ul>
<li>Raft 或者 Paxos 这样的分布式一致性算法</li>
</ul>
</li>
</ul>
<ul>
<li>文本相关<ul>
<li>textrank。自动提取文本摘要</li>
</ul>
</li>
</ul>
<ul>
<li>加密安全算法<ul>
<li>sha256</li>
<li>md5</li>
<li>RSA非对称加密算法</li>
<li>哈希安全算法(Secure Hash Algorithm)</li>
<li>整数质因子分解算法(Integer factorization)</li>
<li>Diffie-Hellman密钥交换算法<ul>
<li>一种加密协议，允许双方在事先不了解对方的情况下，在不安全的通信信道中，共同建立共享密钥。该密钥以后可与一个对称密码一起，加密后续通讯。</li>
</ul>
</li>
<li>RSA<ul>
<li>公钥加密算法。首个适用于以签名作为加密的算法。RSA在电商行业中仍大规模使用，大家也相信它有足够安全长度的公钥。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>链接分析算法(Link Analysis)</p>
</li>
<li><p>比例微积分算法(Proportional Integral Derivative Algorithm)</p>
</li>
<li><p>数据压缩算法</p>
</li>
<li><p>随机数生成算法</p>
</li>
<li><p>推荐算法</p>
</li>
<li><p>决策树算法</p>
</li>
<li><p>人工智能算法</p>
<ul>
<li>C4.5算法。<ul>
<li>C4.5算法与ID3算法一样，都是数学分类算法，C4.5算法是ID3算法的一个改进。ID3算法采用信息增益进行决策判断，而C4.5采用的是增益率。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42395865" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42395865</a></li>
</ul>
</li>
<li>CART算法。<ul>
<li>CART算法的全称是分类回归树算法，他是一个二元分类，采用的是类似于熵的基尼指数作为分类决策，形成决策树后之后还要进行剪枝，我自己在实现整个算法的时候采用的是代价复杂度算法，</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42558235" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42558235</a></li>
</ul>
</li>
<li>KNN(K最近邻)算法。<ul>
<li>给定一些已经训练好的数据，输入一个新的测试数据点，计算包含于此测试数据点的最近的点的分类情况，哪个分类的类型占多数，则此测试点的分类与此相同，所以在这里,有的时候可以复制不同的分类点不同的权重。近的点的权重大点，远的点自然就小点。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42613011" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42613011</a></li>
</ul>
</li>
<li>Naive Bayes(朴素贝叶斯)算法。<ul>
<li>朴素贝叶斯算法是贝叶斯算法里面一种比较简单的分类算法，HITS算法。HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943用到了一个比较重要的贝叶斯定理，用一句简单的话概括就是条件概率的相互转换推导。</a></li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42680161" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42680161</a></li>
</ul>
</li>
<li>SVM(支持向量机)算法。<ul>
<li>支持向量机算法是一种对线性和非线性数据进行分类的方法，非线性数据进行分类的时候可以通过核函数转为线性的情况再处理。其中的一个关键的步骤是搜索最大边缘超平面。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42780439" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42780439</a></li>
</ul>
</li>
<li>EM(期望最大化)算法。<ul>
<li>期望最大化算法，可以拆分为2个算法，1个E-Step期望化步骤,和1个M-Step最大化步骤。他是一种算法框架，在每次计算结果之后，逼近统计模型参数的最大似然或最大后验估计。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/42921789" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/42921789</a></li>
</ul>
</li>
<li>Apriori算法。<ul>
<li>Apriori算法是关联规则挖掘算法，通过连接和剪枝运算挖掘出频繁项集，然后根据频繁项集得到关联规则，关联规则的导出需要满足最小置信度的要求。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43059211" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43059211</a></li>
</ul>
</li>
<li>FP-Tree(频繁模式树)算法。<ul>
<li>这个算法也有被称为FP-growth算法，这个算法克服了Apriori算法的产生过多侯选集的缺点，通过递归的产生频度模式树，然后对树进行挖掘，后面的过程与Apriori算法一致。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43234309" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43234309</a></li>
</ul>
</li>
<li>PageRank(网页重要性/排名)算法。<ul>
<li>PageRank算法最早产生于Google,核心思想是通过网页的入链数作为一个网页好快的判定标准，如果1个网页内部包含了多个指向外部的链接，则PR值将会被均分，PageRank算法也会遭到Link Span攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li>
</ul>
</li>
<li>HITS算法。<ul>
<li>HITS算法是另外一个链接算法，部分原理与PageRank算法是比较相似的，HITS算法引入了权威值和中心值的概念，HITS算法是受用户查询条件影响的，他一般用于小规模的数据链接分析，也更容易遭受到攻击。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43311943" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43311943</a></li>
</ul>
</li>
<li>K-Means(K均值)算法。<ul>
<li>K-Means算法是聚类算法，k在在这里指的是分类的类型数，所以在开始设定的时候非常关键，算法的原理是首先假定k个分类点，然后根据欧式距离计算分类，然后去同分类的均值作为新的聚簇中心，循环操作直到收敛。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43373159" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43373159</a></li>
</ul>
</li>
<li>BIRCH算法。<ul>
<li>BIRCH算法利用构建CF聚类特征树作为算法的核心，通过树的形式，BIRCH算法扫描数据库，在内存中建立一棵初始的CF-树，可以看做数据的多层压缩。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43532111" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43532111</a></li>
</ul>
</li>
<li>AdaBoost算法。<ul>
<li>AdaBoost算法是一种提升算法，通过对数据的多次训练得到多个互补的分类器，然后组合多个分类器，构成一个更加准确的分类器。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43635115" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43635115</a></li>
</ul>
</li>
<li>GSP算法。<ul>
<li>GSP算法是序列模式挖掘算法。GSP算法也是Apriori类算法，在算法的过程中也会进行连接和剪枝操作，不过在剪枝判断的时候还加上了一些时间上的约束等条件。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43699083" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43699083</a></li>
</ul>
</li>
<li>PreFixSpan算法。<ul>
<li>PreFixSpan算法是另一个序列模式挖掘算法，在算法的过程中不会产生候选集，给定初始前缀模式，不断的通过后缀模式中的元素转到前缀模式中，而不断的递归挖掘下去。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43766253" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43766253</a></li>
</ul>
</li>
<li>CBA(基于关联规则分类)算法。<ul>
<li>CBA算法是一种集成挖掘算法，因为他是建立在关联规则挖掘算法之上的，在已有的关联规则理论前提下，做分类判断，只是在算法的开始时对数据做处理，变成类似于事务的形式。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43818787" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43818787</a></li>
</ul>
</li>
<li>RoughSets(粗糙集)算法。<ul>
<li>粗糙集理论是一个比较新颖的数据挖掘思想。这里使用的是用粗糙集进行属性约简的算法，通过上下近似集的判断删除无效的属性，进行规制的输出。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/43876001" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/43876001</a></li>
</ul>
</li>
<li>gSpan算法。<ul>
<li>gSpan算法属于图挖掘算法领域。，主要用于频繁子图的挖掘，相较于其他的图算法，子图挖掘算法是他们的一个前提或基础算法。gSpan算法用到了DFS编码，和Edge五元组，最右路径子图扩展等概念，算法比较的抽象和复杂。</li>
<li>详细介绍链接：<a href="http://blog.csdn.net/androidlushangderen/article/details/4392427" target="_blank" rel="noopener">http://blog.csdn.net/androidlushangderen/article/details/4392427</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li>其他算法<ul>
<li>傅立叶变换<ul>
<li>实现时间域函数与频率域函数之间的相互转化</li>
</ul>
</li>
<li>快速傅立叶变换</li>
<li>代克思托演算法 (Dijkstra’s algorithm)<ul>
<li>解决最短路径问题</li>
</ul>
</li>
<li>A* 搜索算法<ul>
<li>图形搜索算法，从给定起点到给定终点计算出路径。其中使用了一种启发式的估算，为每个节点估算通过该节点的最佳路径，并以之为各个地点排定次序。算法以得到的次序访问这些节点。因此，A*搜索算法是最佳优先搜索的范例。</li>
</ul>
</li>
<li>集束搜索（又名定向搜索，Beam Search）<ul>
<li>最佳优先搜索算法的优化。使用启发式函数评估它检查的每个节点的能力。不过，集束搜索只能在每个深度中发现最前面的m个最符合条件的节点，m是固定数字——集束的宽度。</li>
</ul>
</li>
<li>分支界定算法（Branch and Bound）<ul>
<li>在多种最优化问题中寻找特定最优化解决方案的算法，特别是针对离散、组合的最优化。</li>
</ul>
</li>
<li>Buchberger算法<ul>
<li>一种数学算法，可将其视为针对单变量最大公约数求解的欧几里得算法和线性系统中高斯消元法的泛化</li>
</ul>
</li>
<li>离散微分算法（Discrete differentiation）</li>
<li>动态规划算法（Dynamic Programming）<ul>
<li>展示互相覆盖的子问题和最优子架构算法</li>
</ul>
</li>
<li>欧几里得算法（Euclidean algorithm）<ul>
<li>计算两个整数的最大公约数。最古老的算法之一，出现在公元前300前欧几里得的《几何原本》。</li>
</ul>
</li>
<li>期望-最大算法（Expectation-maximization algorithm，又名EM-Training）<ul>
<li>在统计计算中，期望-最大算法在概率模型中寻找可能性最大的参数估算值，其中模型依赖于未发现的潜在变量。EM在两个步骤中交替计算，第一步是计算期望，利用对隐藏变量的现有估计值，计算其最大可能估计值；第二步是最大化，最大化在第一步上求得的最大可能值来计算参数的值。</li>
</ul>
</li>
<li>梯度下降（Gradient descent）<ul>
<li>一种数学上的最优化算法。</li>
</ul>
</li>
<li>Karatsuba乘法<ul>
<li>需要完成上千位整数的乘法的系统中使用，比如计算机代数系统和大数程序库，如果使用长乘法，速度太慢。该算法发现于1962年。</li>
</ul>
</li>
<li>LLL算法（Lenstra-Lenstra-Lovasz  lattice reduction）<ul>
<li>以格规约（lattice）基数为输入，输出短正交向量基数。LLL算法在以下公共密钥加密方法中有大量使用：背包加密系统（knapsack）、有特定设置的RSA加密等等。</li>
</ul>
</li>
<li>最大流量算法（Maximum flow）<ul>
<li>该算法试图从一个流量网络中找到最大的流。它优势被定义为找到这样一个流的值。最大流问题可以看作更复杂的网络流问题的特定情况。最大流与网络中的界面有关，这就是最大流-最小截定理（Max-flow min-cut theorem）。Ford-Fulkerson 能找到一个流网络中的最大流。</li>
</ul>
</li>
<li>牛顿法（Newton’s method）<ul>
<li>求非线性方程（组）零点的一种重要的迭代法。</li>
</ul>
</li>
<li>Q-learning学习算法<ul>
<li>这是一种通过学习动作值函数（action-value function）完成的强化学习算法，函数采取在给定状态的给定动作，并计算出期望的效用价值，在此后遵循固定的策略。Q-leanring的优势是，在不需要环境模型的情况下，可以对比可采纳行动的期望效用。</li>
</ul>
</li>
<li>两次筛法（Quadratic Sieve）<ul>
<li>现代整数因子分解算法，在实践中，是目前已知第二快的此类算法（仅次于数域筛法Number Field Sieve）。对于110位以下的十位整数，它仍是最快的，而且都认为它比数域筛法更简单。</li>
</ul>
</li>
<li>RANSAC<ul>
<li>是“RANdom SAmple Consensus”的缩写。该算法根据一系列观察得到的数据，数据中包含异常值，估算一个数学模型的参数值。其基本假设是：数据包含非异化值，也就是能够通过某些模型参数解释的值，异化值就是那些不符合模型的数据点。</li>
</ul>
</li>
<li>Schönhage-Strassen算法<ul>
<li>在数学中，Schönhage-Strassen算法是用来完成大整数的乘法的快速渐近算法。其算法复杂度为：O(N log(N) log(log(N)))，该算法使用了傅里叶变换。</li>
</ul>
</li>
<li>单纯型算法（Simplex Algorithm）<ul>
<li>在数学的优化理论中，单纯型算法是常用的技术，用来找到线性规划问题的数值解。线性规划问题包括在一组实变量上的一系列线性不等式组，以及一个等待最大化（或最小化）的固定线性函数。</li>
</ul>
</li>
<li>奇异值分解（Singular value decomposition，简称SVD）<ul>
<li>在线性代数中，SVD是重要的实数或复数矩阵的分解方法，在信号处理和统计中有多种应用，比如计算矩阵的伪逆矩阵（以求解最小二乘法问题）、解决超定线性系统（overdetermined linear systems）、矩阵逼近、数值天气预报等等。</li>
</ul>
</li>
<li>求解线性方程组（Solving a system of linear equations）<ul>
<li>线性方程组是数学中最古老的问题，它们有很多应用，比如在数字信号处理、线性规划中的估算和预测、数值分析中的非线性问题逼近等等。求解线性方程组，可以使用高斯—约当消去法（Gauss-Jordan elimination），或是柯列斯基分解（ Cholesky decomposition）。</li>
</ul>
</li>
<li>Strukturtensor算法<ul>
<li>应用于模式识别领域，为所有像素找出一种计算方法，看看该像素是否处于同质区域（ homogenous region），看看它是否属于边缘，还是是一个顶点。</li>
</ul>
</li>
<li>合并查找算法（Union-find）<ul>
<li>给定一组元素，该算法常常用来把这些元素分为多个分离的、彼此不重合的组。不相交集（disjoint-set）的数据结构可以跟踪这样的切分方法。合并查找算法可以在此种数据结构上完成两个有用的操作：<ul>
<li>查找：判断某特定元素属于哪个组。</li>
<li>合并：联合或合并两个组为一个组。</li>
</ul>
</li>
</ul>
</li>
<li>维特比算法（Viterbi algorithm）<ul>
<li>寻找隐藏状态最有可能序列的动态规划算法，这种序列被称为维特比路径，其结果是一系列可以观察到的事件，特别是在隐藏的Markov模型中。</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>计算机基础面试</title>
    <url>/interview/cs/basic.html</url>
    <content><![CDATA[<h3 id="1-对于软件运行机制的理解。"><a href="#1-对于软件运行机制的理解。" class="headerlink" title="1.对于软件运行机制的理解。"></a>1.对于软件运行机制的理解。</h3><ul>
<li>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</li>
<li>具体的工作流程是<ul>
<li>1.在控制器指挥下，从存储器上取出指令；</li>
<li>2.分析指令，得到计算命令和待操作的数；</li>
<li>3.从存储器上取出待计算的数放入运算器；</li>
<li>4.运算器计算结果；</li>
<li>5.输出到存储器或输出设备。</li>
</ul>
</li>
</ul>
<h3 id="2-对于好的代码架构的理解？或者好的代码结构是怎样的？"><a href="#2-对于好的代码架构的理解？或者好的代码结构是怎样的？" class="headerlink" title="2.对于好的代码架构的理解？或者好的代码结构是怎样的？"></a>2.对于好的代码架构的理解？或者好的代码结构是怎样的？</h3><ul>
<li>高内聚、低耦合</li>
<li>易扩展，维护方便</li>
<li>避免过度设计</li>
<li>可读性高，结构清晰</li>
<li>代码风格统一</li>
<li>低复杂性，简练</li>
</ul>
<h3 id="3-对于编码规范的理解，有哪些好的编程规范"><a href="#3-对于编码规范的理解，有哪些好的编程规范" class="headerlink" title="3.对于编码规范的理解，有哪些好的编程规范"></a>3.对于编码规范的理解，有哪些好的编程规范</h3><ul>
<li>变量命名规范</li>
<li>代码缩进规范</li>
<li>大小写规范</li>
<li>注释规范</li>
<li>可读性强</li>
</ul>
<h3 id="4-编程安全应该注意哪些问题"><a href="#4-编程安全应该注意哪些问题" class="headerlink" title="4.编程安全应该注意哪些问题"></a>4.编程安全应该注意哪些问题</h3><ul>
<li>表单数据验证</li>
<li>防范SQL语句注入攻击</li>
<li>程序资源的释放。例如内存泄漏、数据库连接、文件句柄等资源</li>
<li>线程安全性</li>
<li>数据类型校验</li>
</ul>
<h3 id="5-如何提升开发效率？提升开发效率的方法有哪些？"><a href="#5-如何提升开发效率？提升开发效率的方法有哪些？" class="headerlink" title="5.如何提升开发效率？提升开发效率的方法有哪些？"></a>5.如何提升开发效率？提升开发效率的方法有哪些？</h3><ul>
<li>大显示器</li>
<li>机械键盘</li>
<li>编辑器快捷键</li>
<li>快速文档查询能力</li>
<li>需求的准确理解，防止可能的返工</li>
</ul>
<h3 id="6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"><a href="#6-进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？" class="headerlink" title="6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？"></a>6.进行软件设计时会考虑软件测试吗？软件测试是如何影响软件设计的？</h3><ul>
<li>保证开发结果与需求相符</li>
<li>保证代码的正确性、可靠性</li>
<li>新的功能是否影响旧有的功能</li>
</ul>
<h3 id="7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"><a href="#7-作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？" class="headerlink" title="7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？"></a>7.作为一个工程师，你想要既要有创新力，又要产出具有可预测性。采用什么策略才能使这两个目标可以共存呢？</h3><h3 id="对于软件运行机制的理解。"><a href="#对于软件运行机制的理解。" class="headerlink" title="对于软件运行机制的理解。"></a>对于软件运行机制的理解。</h3><ul>
<li><p>程序是一种相对于计算电路的一种升维或者说抽象，不需要在具体的运算中重新组合各种基本的电路，而是通过以电信号表示的命令来控制电脑来运行，通过更改命令的执行顺序来改变计算机的具体功能。这就是冯诺依曼存储程序式体系：控制器，运算器，存储器，输入设备，输出设备。</p>
</li>
<li><p>具体的工作流程是</p>
<ul>
<li>1在控制器指挥下，从存储器上取出指令；</li>
<li>2分析指令，得到计算命令和待操作的数；</li>
<li>3从存储器上取出待计算的数放入运算器；</li>
<li>4运算器计算结果；</li>
<li>5输出到存储器或输出设备。</li>
</ul>
</li>
<li><p>因此存储器是关键。存储器分为：寄存器（CPU内部，用于存放待操作数和结果）；高速缓存（通常在CPU内部，用做数据缓冲区）；内存；外存。</p>
</li>
<li><p>接下来是具体的命令执行，这需要预先定义好CPU能执行的命令，即CPU的指令集，用来计算和控制计算机系统的一套指令的集合，典型的有Intel X86指令集和ARM指令集。具体的指令以二进制码表示，包含一个或多个字节，也包含指令码（具体命令）和操作数（要操作的数或地址）。在具体的执行中，把宏观层次的命令转换为满足指令集要求的二进制代码，然后才能在计算机上运行；参见CPU的具体组成成分运算器 ALU和寄存器和控制器的工作流程。</p>
</li>
<li><p>最后程序的执行就是在以上基础进行的，一开始使用机器语言的时候，具体的命令形式是1001010101010011 00011110这样的。这个虽然足够底层能够直接与计算机进行交互，但不是一般人能够搞得定的，于是就有更高层次的抽象，汇编语言，变成add 0 1这种相对来说比较友好的语言；接着就是高级语言了，更加抽象，但接近我们一般人的思维习惯，如d = a*b+c;当然，这是前人的工作成果，他们把很多的细节封装起来，我们这些后人之间调用就行，不用管其具体的转换即具体的编译，不然一句程序有可能转换为多句指令，而且其执行的次序和次数之类的细节，各种内存地址和数据的调用足够使人发疯。</p>
</li>
<li><p>对于设计模式的理解，为什么要有设计模式，用过什么设计模式，每个的应用场景是怎样的？</p>
<ul>
<li>设计模式主要分三个类型:创建型、结构型和行为型。<br>创建型：<br>一、Singleton，单例模式：保证一个类只有一个实例，并提供一个访问它的全局访问点 ；<br>应用场景：一个无状态的类使用单例模式节省内存资源。<br>二、Abstract Factory，抽象工厂：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们的具体类。<br>应用场景：一系列相互依赖的对象有不同的具体实现。提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合。<br>三、Factory Method，工厂方法：定义一个用于创建对象的接口，让子类决定实例化哪一个类，Factory Method使一个类的实例化延迟到了子类。     应用场景：由于需求的变化，一个类的子类经常面临着剧烈的变化，但他却拥有比较稳定的接口。使用一种封装机制来“隔离这种易变对象的变化”，工厂方法定义 一个用于创建对象的接口，让子类来确定创建哪一个具体类的对象，将对象的实例化延迟。<br>四、Builder，建造模式：将一个复杂对象的构建与他的表示相分离，使得同样的构建过程可以创建不同的表示。<br>应用场景：一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。提供一种封装机制 将稳定的组合算法于易变的各个组成部分隔离开来。<br>五、Prototype，原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型来创建新的对象。<br>应用场景：用new创建一个对象需要非常繁琐的数据准备或者权限</li>
</ul>
</li>
</ul>
<p>行为型：<br>    六、Iterator，迭代器模式：提供一个方法顺序访问一个聚合对象的各个元素，而又不需要暴露该对象的内部表示。<br>  应用场景：迭代。<br>    七、Observer，观察者模式：定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。<br>应用场景： 某个实例的变化将影响其他多个对象。<br>    八、Template Method，模板方法：定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，TemplateMethod使得子类可以不改变一个算法的结构即可以重定义该算法的某些特定步骤。<br>应用场景：一个操作的步骤稳定，而具体细节的改变延迟的子类<br>     九、Command，命令模式：将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求排队和记录请求日志，以及支持可撤销的操作。<br>应用场景：将命令者与执行者完全解耦。<br>    十、State，状态模式：允许对象在其内部状态改变时改变他的行为。对象看起来似乎改变了他的类。<br>应用场景：一个对象的内部状态改变时，他的行为剧烈的变化。<br>    十一、Strategy，策略模式：定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。       应用场景：<br>   十二、China of Responsibility，职责链模式：使多个对象都有机会处理请求，从而避免请求的送发者和接收者之间的耦合关系<br>    十三、Mediator，中介者模式：用一个中介对象封装一些列的对象交互。<br>    十四、Visitor，访问者模式：表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这个元素的新操作。<br>    十五、Interpreter，解释器模式：给定一个语言，定义他的文法的一个表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。<br>    十六、Memento，备忘录模式：在不破坏对象的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<p>结构型：<br>    十七、Composite，组合模式：将对象组合成树形结构以表示部分整体的关系，Composite使得用户对单个对象和组合对象的使用具有一致性。<br>    十八、Facade，外观模式：为子系统中的一组接口提供一致的界面，facade提供了一高层接口，这个接口使得子系统更容易使用。<br>    十九、Proxy，代理模式：为其他对象提供一种代理以控制对这个对象的访问<br>    二十、Adapter,适配器模式：将一类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作那些类可以一起工作。<br>    二十一、Decrator，装饰模式：动态地给一个对象增加一些额外的职责，就增加的功能来说，Decorator模式相比生成子类更加灵活。<br>    二十二、Bridge，桥模式：将抽象部分与它的实现部分相分离，使他们可以独立的变化。<br>    二十三、Flyweight，享元模式</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统</title>
    <url>/interview/cs/os.html</url>
    <content><![CDATA[<h3 id="core文件是什么，有什么用？"><a href="#core文件是什么，有什么用？" class="headerlink" title="core文件是什么，有什么用？"></a>core文件是什么，有什么用？</h3><ul>
<li>core是unix系统的内核。当你的程序出现内存越界的时候，操作系统会中止你的进程，并将当前内存状态倒出到core文件中，以便进一步分析。程序员可以通过core文件来找出问题所在。它记录了程序挂掉时详细的状态描述。</li>
</ul>
<h3 id="什么是core-dump"><a href="#什么是core-dump" class="headerlink" title="什么是core dump"></a>什么是core dump</h3><ul>
<li>Core的意思是内存, Dump的意思是扔出来, 堆出来。开发和使用Unix程序时, 有时程序莫名其妙的down了, 却没有任何的提示(有时候会提示core dumped). 这时候可以查看一下有没有形如core.进程号的文件生成， 这个文件便是操作系统把程序down掉时的内存内容出来生成的，它可以做为调试程序的参考.</li>
<li>core dump又叫核心转储, 当程序运行过程中发生异常, 程序异常退出时, 由操作系统把程序当前的内存状况存储在一个core文件中, 叫core dump。</li>
<li>如何使用core文件<ul>
<li>gdb -c core文件路径 [应用程序的路径]，进去后输入where回车, 就可以显示程序在哪一行当掉的, 哪个函数中.</li>
</ul>
</li>
</ul>
<h3 id="为什么没有core文件生成呢"><a href="#为什么没有core文件生成呢" class="headerlink" title="为什么没有core文件生成呢?"></a>为什么没有core文件生成呢?</h3><ul>
<li>core文件的生成跟你当前系统的环境设置有关系, 可以用下面的语句设置一下, 然后再运行程序便成生成core文件.</li>
<li>ulimit -c unlimited core文件生成的位置一般于运行程序的路径相同, 文件名一般为core.进程号</li>
</ul>
<h3 id="不用core文件，程序出了问题产生信号是否知道？"><a href="#不用core文件，程序出了问题产生信号是否知道？" class="headerlink" title="不用core文件，程序出了问题产生信号是否知道？"></a>不用core文件，程序出了问题产生信号是否知道？</h3><ul>
<li>内核向进程发信号嘛。</li>
</ul>
<h3 id="共享内存除了文件映射还有什么方式？二者有什么区别"><a href="#共享内存除了文件映射还有什么方式？二者有什么区别" class="headerlink" title="共享内存除了文件映射还有什么方式？二者有什么区别"></a>共享内存除了文件映射还有什么方式？二者有什么区别</h3><ul>
<li>共享内存对象映射。</li>
<li>区别：内存映射文件是由一个文件到一块内存的映射，使应用程序可以通过内存指针对磁盘上的文件进行访问，其过程就如同对加载了文件的内存的访问，因此内存文件映射非常适合于用来管理大文件。</li>
</ul>
<h3 id="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"><a href="#请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc" class="headerlink" title="请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc"></a>请解释下列10个shell命令的用途。top、ps、mv、find、df、cat、chmod、chgrp、grep、wc</h3><ul>
<li>top：命令是Linux下常用的性能分析工具，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。</li>
<li>ps：查看进程</li>
<li>mv：移动或者更改文件</li>
<li>find：在子目录中搜索匹配的文件</li>
<li>df：linux中df命令参数功能：检查文件系统的磁盘空间占用情况。</li>
<li>cat：把一个或多个文件内容显示到标准输出</li>
<li>chmod：改变文件属性</li>
<li>chgrp：改变用户分组</li>
<li>grep：在文件内进行搜索</li>
<li>wc：命令的功能为统计指定文件中的字节数、字数、行数, 并将统计结果显示输出。</li>
</ul>
<h3 id="Linux文件属性有哪些？（共十位）"><a href="#Linux文件属性有哪些？（共十位）" class="headerlink" title="Linux文件属性有哪些？（共十位）"></a>Linux文件属性有哪些？（共十位）</h3><ul>
<li>-rw-r–r–那个是权限符号，总共是- — — —这几个位。</li>
<li>第一个短横处是文件类型识别符：-表示普通文件；c表示字符设备（character）；b表示块设备（block）；d表示目录 （directory）；l表示链接文件（link）；后面第一个三个连续的短横是用户权限位（User），第二个三个连续短横是组权限位 （Group），第三个三个续短横是其他权限位（Other）。每个权限位有三个权限，r（读权限），w（写权限），x（执行权限）。如果每个权限位都 有权限存在，那么满权限的情况就是：-rwxrwxrwx；权限为空的情况就是- — — —。</li>
<li>权限的设定可以用chmod命令，其格式位：chmod ugoa+/-/=rwx filename/directory。例如：</li>
<li>一个文件aaa具有完全空的权限- — — —。<ul>
<li>chmod u+rw aaa（给用户权限位设置读写权限，其权限表示为：- rw- — —）</li>
<li>chmod g+r aaa（给组设置权限为可读，其权限表示为：- — r– —）</li>
<li>chmod ugo+rw aaa（给用户，组，其它用户或组设置权限为读写，权限表示为：- rw- rw- rw-）</li>
</ul>
</li>
<li>如果aaa具有满权限- rwx rwx rwx。<ul>
<li>chmod u-x aaa（去掉用户可执行权限，权限表示为：- rw- rwx rwx）</li>
</ul>
</li>
<li>如果要给aaa赋予制定权限- rwx r-x r-x，命令为：<ul>
<li>chmod u=rwx，go=rx aaa</li>
</ul>
</li>
</ul>
<h3 id="linux查询命令"><a href="#linux查询命令" class="headerlink" title="linux查询命令"></a>linux查询命令</h3><ul>
<li>find / -name “文件名”    在目录结构中搜索文件，并执行指定的操作。</li>
<li>grep</li>
<li>local 文件名  —他是 ‘find -name’ 的另一种写法，但要比后者快得多，原因在于它不搜索具体目录，而是搜索一个数据库（/var/lib/locatedb），这个数据库中含 有本地所有文件信息。Linux系统自动创建这个数据库，并且每天自动更新一次，所以改命令查不到最变动过的文件。为了避免这种情况，可以在使用locate之前，先使用updatedb命令，手动更新数据库。</li>
<li>whereis —是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</li>
<li>which  作用是在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</li>
</ul>
<h3 id="select-poll和epoll的区别"><a href="#select-poll和epoll的区别" class="headerlink" title="select, poll和epoll的区别"></a>select, poll和epoll的区别</h3><ul>
<li>select<ul>
<li>select最早于1983年出现在4.2BSD中，它通过一个select()系统调用来监视多个文件描述符的数组，当select()返回后，该数组中就绪的文件描述符便会被内核修改标志位，使得进程可以获得这些文件描述符从而进行后续的读写操作。</li>
<li>select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点，事实上从现在看来，这也是它所剩不多的优点之一。</li>
<li>select的一个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，不过可以通过修改宏定义甚至重新编译内核的方式提升这一限制。</li>
<li>另外，select()所维护的存储大量文件描述符的数据结构，随着文件描述符数量的增大，其复制的开销也线性增长。同时，由于网络响应时间的延迟 使得大量TCP连接处于非活跃状态，但调用select()会对所有socket进行一次线性扫描，所以这也浪费了一定的开销。</li>
</ul>
</li>
<li>poll<ul>
<li>poll在1986年诞生于System V Release 3，它和select在本质上没有多大差别，但是poll没有最大文件描述符数量的限制。</li>
<li>poll和select同样存在一个缺点就是，包含大量文件描述符的数组被整体复制于用户态和内核的地址空间之间，而不论这些文件描述符是否就绪，它的开销随着文件描述符数量的增加而线性增大。</li>
<li>另外，select()和poll()将就绪的文件描述符告诉进程后，如果进程没有对其进行IO操作，那么下次调用select()和poll() 的时候将再次报告这些文件描述符，所以它们一般不会丢失就绪的消息，这种方式称为水平触发（Level Triggered）。</li>
</ul>
</li>
<li>epoll<ul>
<li>直到Linux2.6才出现了由内核直接支持的实现方法，那就是epoll，它几乎具备了之前所说的一切优点，被公认为Linux2.6下性能最好的多路I/O就绪通知方法。</li>
<li>epoll可以同时支持水平触发和边缘触发（Edge Triggered，只告诉进程哪些文件描述符刚刚变为就绪状态，它只说一遍，如果我们没有采取行动，那么它将不会再次告知，这种方式称为边缘触发），理论上边缘触发的性能要更高一些，但是代码实现相当复杂。</li>
<li>epoll同样只告知那些就绪的文件描述符，而且当我们调用epoll_wait()获得就绪文件描述符时，返回的不是实际的描述符，而是一个代表 就绪描述符数量的值，你只需要去epoll指定的一个数组中依次取得相应数量的文件描述符即可，这里也使用了内存映射（mmap）技术这样  彻底省掉了 这些文件描述符在系统调用时复制的开销。</li>
<li>另一个本质的改进在于epoll采用基于事件的就绪通知方式。在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描 述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，一旦基于某个文件描述符就绪时，内核会采用类似callbac的回调 机制，迅速激活这个文件描述符，当进程调用epoll_wait()时便得到通知。</li>
</ul>
</li>
</ul>
<h3 id="待处理"><a href="#待处理" class="headerlink" title="待处理"></a>待处理</h3><ul>
<li><ol>
<li>内存的页面置换算法</li>
</ol>
</li>
<li><ol start="2">
<li>进程调度算法</li>
</ol>
</li>
<li><ol start="3">
<li>进程间通信方式</li>
</ol>
</li>
<li><ol start="4">
<li>进程和线程定义，区别和联系</li>
</ol>
</li>
<li><ol start="5">
<li>进程之间的通信</li>
</ol>
</li>
<li><ol start="6">
<li>父子进程、孤儿进程</li>
</ol>
</li>
<li><ol start="7">
<li>fork进程时的操作，</li>
</ol>
</li>
<li><ol start="11">
<li>硬链接和软连接区别</li>
</ol>
</li>
<li><ol start="12">
<li>kill用法，某个进程杀不掉的原因（进入内核态，忽略kill信号）</li>
</ol>
</li>
<li><ol start="13">
<li>linux用过的命令</li>
</ol>
</li>
<li><ol start="14">
<li>系统管理命令（如查看内存使用、网络情况）</li>
</ol>
</li>
<li><ol start="15">
<li>管道的使用 |</li>
</ol>
</li>
<li><ol start="16">
<li>grep的使用，一定要掌握，每次都会问在文件中查找</li>
</ol>
</li>
<li><ol start="17">
<li>shell脚本</li>
</ol>
</li>
<li><ol start="19">
<li>awk使用</li>
</ol>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>js面试题</title>
    <url>/interview/frontend/js.html</url>
    <content><![CDATA[<ul>
<li>基本数据类型？<ul>
<li>Undefined、Null、Boolean、Number、String、ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 )</li>
</ul>
</li>
<li>介绍js有哪些内置对象？<ul>
<li>Object 是 JavaScript 中所有对象的父对象</li>
<li>数据封装类对象：Object、Array、Boolean、Number 和 String</li>
<li>其他对象：Function、Arguments、Math、Date、RegExp、Error</li>
</ul>
</li>
<li>null，undefined 的区别？<ul>
<li>null         表示一个对象是“没有值”的值，也就是值为“空”；</li>
<li>undefined     表示一个变量声明了没有初始化(赋值)；</li>
<li>undefined不是一个有效的JSON，而null是；</li>
<li>undefined的类型(typeof)是undefined；</li>
<li>null的类型(typeof)是object；</li>
<li>Javascript将未赋值的变量默认值设为undefined；</li>
<li>Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。</li>
<li>注意：<ul>
<li>在验证null时，一定要使用　=== ，因为 == 无法分别 null 和　undefined</li>
<li>null == undefined // true</li>
<li>null === undefined // false</li>
</ul>
</li>
</ul>
</li>
<li>使用 typeof bar === “object” 判断 bar 是不是一个对象有神马潜在的弊端？如何避免这种弊端？<br>//使用 typeof 的弊端是显而易见的(这种弊端同使用 instanceof)：<br>let obj = {};<br>let arr = [];<br>console.log(typeof obj === ‘object’);  //true<br>console.log(typeof arr === ‘object’);  //true<br>console.log(typeof null === ‘object’);  //true<br>//从上面的输出结果可知，typeof bar === “object” 并不能准确判断 bar 就是一个 Object。可以通过 Object.prototype.toString.call(bar) === “[object Object]” 来避免这种弊端：<br>let obj = {};<br>let arr = [];<br>console.log(Object.prototype.toString.call(obj));  //[object Object]<br>console.log(Object.prototype.toString.call(arr));  //[object Array]<br>console.log(Object.prototype.toString.call(null));  //[object Null]<br>//而 [] === false 是返回 false 的。</li>
<li></li>
</ul>
<ul>
<li><h4 id="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"><a href="#JavaScript有几种类型的值？，你能画一下他们的内存图吗？" class="headerlink" title="JavaScript有几种类型的值？，你能画一下他们的内存图吗？"></a>JavaScript有几种类型的值？，你能画一下他们的内存图吗？</h4><ul>
<li>栈：原始数据类型（Undefined，Null，Boolean，Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
<li>两种类型的区别是：存储位置不同；<ul>
<li>原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体</li>
</ul>
</li>
</ul>
</li>
<li><h4 id="如何将字符串转化为数字，例如’12-3b’"><a href="#如何将字符串转化为数字，例如’12-3b’" class="headerlink" title="如何将字符串转化为数字，例如’12.3b’?"></a>如何将字符串转化为数字，例如’12.3b’?</h4><ul>
<li>parseFloat(‘12.3b’);</li>
<li>正则表达式，’12.3b’.match(/(\d)+(.)?(\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。</li>
<li>如何验证非空</li>
</ul>
</li>
<li><h4 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h4></li>
<li><h4 id="异步与同步请求如何实现？"><a href="#异步与同步请求如何实现？" class="headerlink" title="异步与同步请求如何实现？"></a>异步与同步请求如何实现？</h4></li>
<li><h4 id="什么是window对象-什么是document对象"><a href="#什么是window对象-什么是document对象" class="headerlink" title="什么是window对象? 什么是document对象?"></a>什么是window对象? 什么是document对象?</h4><ul>
<li>window对象是指浏览器打开的窗口。</li>
<li>document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。</li>
</ul>
</li>
<li><h4 id="cookie-和session-的区别？"><a href="#cookie-和session-的区别？" class="headerlink" title="cookie 和session 的区别？"></a>cookie 和session 的区别？</h4><ul>
<li>1.cookie数据存放在客户的浏览器上，session数据放在服务器上。</li>
<li>2.cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗。考虑到安全应当使用session。</li>
<li>3.session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE。</li>
<li>4.单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。</li>
<li>5.所以个人建议：将登陆信息等重要信息存放为SESSION;其他信息如果需要保留，可以放在COOKIE中</li>
</ul>
</li>
<li><h4 id="cookie、sessionStorage、localStorage区别？"><a href="#cookie、sessionStorage、localStorage区别？" class="headerlink" title="cookie、sessionStorage、localStorage区别？"></a>cookie、sessionStorage、localStorage区别？</h4><ul>
<li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。</li>
<li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。</li>
<li>sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。</li>
<li>存储大小：<br>cookie数据大小不能超过4k。<br>sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。</li>
<li>有期时间：<br>localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据；<br>sessionStorage 数据在当前浏览器窗口关闭后自动删除。<br>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li>
</ul>
</li>
<li><h4 id="请解释一下-JavaScript-的同源策略。"><a href="#请解释一下-JavaScript-的同源策略。" class="headerlink" title="请解释一下 JavaScript 的同源策略。"></a>请解释一下 JavaScript 的同源策略。</h4><ul>
<li>概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。</li>
<li>这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。</li>
<li>指一段脚本只能读取来自同一来源的窗口和文档的属性。</li>
</ul>
</li>
<li><h4 id="如何判断在数组中是否存在"><a href="#如何判断在数组中是否存在" class="headerlink" title="如何判断在数组中是否存在"></a>如何判断在数组中是否存在</h4>indexOf</li>
<li><h4 id="如何判断一个对象是否属于某个类？"><a href="#如何判断一个对象是否属于某个类？" class="headerlink" title="如何判断一个对象是否属于某个类？"></a>如何判断一个对象是否属于某个类？</h4><ul>
<li>使用instanceof</li>
</ul>
</li>
<li><h4 id="for-in和for-of的区别"><a href="#for-in和for-of的区别" class="headerlink" title="for in和for of的区别"></a>for in和for of的区别</h4></li>
<li><h4 id="数组转字符串-join-；字符串转数组-split-‘’"><a href="#数组转字符串-join-；字符串转数组-split-‘’" class="headerlink" title="数组转字符串(join)；字符串转数组(split(‘’))"></a>数组转字符串(join)；字符串转数组(split(‘’))</h4></li>
<li><h4 id="你有用过哪些前端性能优化的方法？"><a href="#你有用过哪些前端性能优化的方法？" class="headerlink" title="你有用过哪些前端性能优化的方法？"></a>你有用过哪些前端性能优化的方法？</h4>*(1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。<br>*（2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数<br>*（3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。<br>*（4） 当需要设置的样式很多时设置className而不是直接操作style。<br>*（5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。<br>*（6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。<br>*（7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。<br>*（8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。<ul>
<li>对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。</li>
</ul>
</li>
<li><h4 id="jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？"><a href="#jQuery-的属性拷贝-extend-的实现原理是什么，如何实现深拷贝？" class="headerlink" title="jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？"></a>jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？</h4></li>
<li><h4 id="js延迟加载的方式有哪些？"><a href="#js延迟加载的方式有哪些？" class="headerlink" title="js延迟加载的方式有哪些？"></a>js延迟加载的方式有哪些？</h4><ul>
<li>defer和async、动态创建DOM方式（用得最多）、按需异步载入js</li>
</ul>
</li>
<li><h4 id="axios有哪些方法、参数？"><a href="#axios有哪些方法、参数？" class="headerlink" title="axios有哪些方法、参数？"></a>axios有哪些方法、参数？</h4></li>
<li><h4 id="ajax请求头部携带cookie"><a href="#ajax请求头部携带cookie" class="headerlink" title="ajax请求头部携带cookie"></a>ajax请求头部携带cookie</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import axios from &apos;axios&apos;</span><br><span class="line">axios.defaults.withCredentials=true;//让ajax携带cookie</span><br><span class="line">Vue.prototype.$axios = axios;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="react"><a href="#react" class="headerlink" title="react"></a>react</h2><ul>
<li><h4 id="React-中-Element-与-Component-的区别是？"><a href="#React-中-Element-与-Component-的区别是？" class="headerlink" title="React 中 Element 与 Component 的区别是？"></a>React 中 Element 与 Component 的区别是？</h4></li>
<li><h4 id="React-中-refs-的作用是什么？"><a href="#React-中-refs-的作用是什么？" class="headerlink" title="React 中 refs 的作用是什么？"></a>React 中 refs 的作用是什么？</h4><ul>
<li>Refs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。我们可以为元素添加ref属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回：</li>
</ul>
</li>
<li><h4 id="createElement-与-cloneElement-的区别是什么？"><a href="#createElement-与-cloneElement-的区别是什么？" class="headerlink" title="createElement 与 cloneElement 的区别是什么？"></a>createElement 与 cloneElement 的区别是什么？</h4><ul>
<li>createElement 函数是 JSX 编译之后使用的创建 React Element 的函数，而 cloneElement 则是用于复制某个元素并传入新的 Props。</li>
</ul>
</li>
<li><h4 id="组件的生命周期有哪些？"><a href="#组件的生命周期有哪些？" class="headerlink" title="组件的生命周期有哪些？"></a>组件的生命周期有哪些？</h4><ul>
<li>组件的声明周期有三种阶段，一种是初始化阶段（Mounting），一种是更新阶段（Updating）最后一种是析构阶段（Unmounting）。而这两个阶段的声明周期函数都是相似且有一一对应的关系的</li>
</ul>
</li>
<li><h4 id="什么时候使用-Class-Component-而非-Functional-Component"><a href="#什么时候使用-Class-Component-而非-Functional-Component" class="headerlink" title="什么时候使用 Class Component 而非 Functional Component?"></a>什么时候使用 Class Component 而非 Functional Component?</h4><ul>
<li>如果你的组件有state或者使用了生命周期函数，那么请使用Class component。 否则，使用Functional component。</li>
</ul>
</li>
<li>什么是keys 而且为什么他们很重要<ul>
<li>Keys负责帮助React跟踪列表中哪些元素被改变/添加/移除。</li>
</ul>
</li>
</ul>
<ul>
<li>DOM操作——怎样添加、移除、移动、复制、创建和查找节点。<ul>
<li>1）创建新节点<ul>
<li>createDocumentFragment() //创建一个DOM</li>
<li>createElement() //创建一个具体的</li>
<li>createTextNode() //创建一个文本节点</li>
</ul>
</li>
<li>2）添加、移除、替换、插入<ul>
<li>appendChild()</li>
<li>removeChild()</li>
<li>replaceChild()</li>
<li>insertBefore() //并没有insertAfter()</li>
</ul>
</li>
<li>3）查找<ul>
<li>getElementsByTagName() //通过标签名</li>
<li>getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的)</li>
<li>getElementById() //通过元素Id，唯一性</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python面试题</title>
    <url>/interview/backend/python.html</url>
    <content><![CDATA[<ul>
<li><p>装饰器的写法，并打印出方法名</p>
</li>
<li><p>定义一个字典，如果有动态的数据是不能够定义的，比如list. Tuple、字符串、数字是可以的</p>
</li>
<li><p>b树，b+树</p>
</li>
<li><p>深浅拷贝</p>
</li>
<li><p>redis数据类型，缓存失效方案</p>
</li>
<li><p>mysql存储引擎，索引方案</p>
</li>
<li><p>有序list合并成一个</p>
</li>
<li><p>协程</p>
</li>
<li><p>grpc</p>
</li>
<li><p><a href="https://github.com/leeguandong/Interview-code-practice-python" target="_blank" rel="noopener">https://github.com/leeguandong/Interview-code-practice-python</a></p>
</li>
<li><p><a href="https://github.com/princewen/leetcode_python" target="_blank" rel="noopener">https://github.com/princewen/leetcode_python</a></p>
</li>
<li><p><a href="http://bookshadow.com/leetcode/" target="_blank" rel="noopener">http://bookshadow.com/leetcode/</a></p>
</li>
<li><p>子类初始化父类</p>
<ul>
<li>子类必须显示的调用父类的构造方法赖初始化父类才行。</li>
</ul>
</li>
<li><p>python性能分析</p>
<ul>
<li>python -m cProfile -o profile.out main.py</li>
<li>brew install graphviz</li>
<li>pip install gprof2dot</li>
<li>gprof2dot -f pstats profile.out | dot -Tpng -o profile.png<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pstats</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Stats对象</span></span><br><span class="line">p = pstats.Stats(<span class="string">"profile/profile.out"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># strip_dirs(): 去掉无关的路径信息</span></span><br><span class="line"><span class="comment"># sort_stats(): 排序，支持的方式和上述的一致</span></span><br><span class="line"><span class="comment"># print_stats(): 打印分析结果，可以指定打印前几行</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 和直接运行cProfile.run("test()")的结果是一样的</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="number">-1</span>).print_stats()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照函数名排序，只打印前3行函数的信息, 参数还可为小数,表示前百分之几的函数信息</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"name"</span>).print_stats(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照运行时间和函数名进行排序</span></span><br><span class="line">p.strip_dirs().sort_stats(<span class="string">"cumulative"</span>, <span class="string">"name"</span>).print_stats(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果想知道有哪些函数调用了sum_num</span></span><br><span class="line">p.print_callers(<span class="number">0.5</span>, <span class="string">"sum_num"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看test()函数中调用了哪些函数</span></span><br><span class="line">p.print_callees(<span class="string">"topic"</span>)</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>语言特性<br>1.谈谈对 Python 和其他语言的区别<br>2.简述解释型和编译型编程语言<br>3.Python 的解释器种类以及相关特点？<br>4.说说你知道的Python3 和 Python2 之间的区别？<br>5.Python3 和 Python2 中 int 和 long 区别？<br>6.xrange 和 range 的区别？<br>编码规范<br>7.什么是 PEP8?<br>8.了解 Python 之禅么？<br>9.了解 dosctring 么？<br>10.了解类型注解么？<br>11.例举你知道 Python 对象的命名规范，例如方法或者类等<br>12.Python 中的注释有几种？<br>13.如何优雅的给一个函数加注释？<br>14.如何给变量加注释？<br>15.Python 代码缩进中是否支持 Tab 键和空格混用。<br>16.是否可以在一句 import 中导入多个库?<br>17.在给 Py 文件命名的时候需要注意什么?<br>18.例举几个规范 Python 代码风格的工具<br>数据类型<br>字符串<br>19.列举 Python 中的基本数据类型？<br>20.如何区别可变数据类型和不可变数据类型<br>21.将”hello world”转换为首字母大写”Hello World”<br>22.如何检测字符串中只含有数字?<br>23.将字符串”ilovechina”进行反转<br>24.Python 中的字符串格式化方式你知道哪些？<br>25.有一个字符串开头和末尾都有空格，比如“ adabdw ”,要求写一个函数把这个字符串的前后空格都去掉。<br>26.获取字符串”123456“最后的两个字符。<br>27.一个编码为 GBK 的字符串 S，要将其转成 UTF-8 编码的字符串，应如何操作？<br>28.s=”info:xiaoZhang 33 shandong”,用正则切分字符串输出[‘info’, ‘xiaoZhang’, ‘33’, ‘shandong’]<br>27.怎样将字符串转换为小写？<br>28.单引号、双引号、三引号的区别？<br>29.a = “你好     中国  “,去除多余空格只留一个空格。<br>列表<br>30.已知 AList = [1,2,3,1,2],对 AList 列表元素去重，写出具体过程。<br>31.如何实现 “1,2,3” 变成 [“1”,”2”,”3”]<br>32.给定两个 list，A 和 B，找出相同元素和不同元素<br>33.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]<br>34.合并列表[1,5,7,9]和[2,2,6,8]<br>35.如何打乱一个列表的元素？<br>字典<br>36.字典操作中 del 和 pop 有什么区别<br>37.按照字典的内的年龄排序<br>d1 = [<br>    {‘name’:’alice’, ‘age’:38},<br>    {‘name’:’bob’, ‘age’:18},<br>    {‘name’:’Carl’, ‘age’:28},<br>]<br>38.请合并下面两个字典 a = {“A”:1,”B”:2},b = {“C”:3,”D”:4}<br>39.如何使用生成式的方式生成一个字典，写一段功能代码。<br>40.如何把元组(“a”,”b”)和元组(1,2)，变为字典{“a”:1,”b”:2}<br>综合<br>41.Python 常用的数据结构的类型及其特性？<br>A：{1:0,2:0,3:0}<br>B：{“a”:0, “b”:0, “c”:0}<br>C: {(1,2):0, (2,3):0}<br>D: {[1,2]:0, [2,3]:0}<br>42.如何将元组(“A”,”B”)和元组(1,2),合并成字典{“A”:1,”B”:2}<br>43.Python 里面如何实现 tuple 和 list 的转换？<br>44.我们知道对于列表可以使用切片操作进行部分元素的选择，那么如何对生成器类型的对象实现相同的功能呢？<br>45.请将[i for i in range(3)]改成生成器<br>46.a=”hello”和 b=”你好”编码成 bytes 类型<br>47.下面的代码输出结果是什么？<br>a = (1,2,3,[4,5,6,7],8)<br>a[2] = 2<br>48.下面的代码输出的结果是什么?<br>a = (1,2,3,[4,5,6,7],8)<br>a[5] = 2<br>操作类题目<br>49.Python 交换两个变量的值<br>50.在读文件操作的时候会使用 read、readline 或者 readlines，简述它们各自的左右<br>51.json 序列化时，可以处理的数据类型有哪些？如何定制支持 datetime 类型？<br>52.json 序列化时，默认遇到中文会转换成 unicode，如果想要保留中文怎么办？<br>53.有两个磁盘文件 A 和 B，各存放一行字母，要求把这两个文件中的信息合并(按字母顺序排列)，输出到一个新文件 C 中。<br>54.如果当前的日期为 20190530，要求写一个函数输出 N 天后的日期，(比如 N 为 2，则输出 20190601)。<br>55.写一个函数，接收整数参数 n，返回一个函数，函数的功能是把函数的参数和 n 相乘并把结果返回。<br>56.下面代码会存在什么问题，如何改进？<br>def strappend(num):<br>    str=’first’<br>    for i in range(num):<br>        str+=str(i)<br>    return str<br>57.一行代码输出 1-100 之间的所有偶数。<br>58.with 语句的作用，写一段代码？<br>59.python 字典和 json 字符串相互转化方法<br>60.请写一个 Python 逻辑，计算一个文件中的大写字母数量<br>高级特效<br>70.函数装饰器有什么作用？请列举说明？<br>71.Python 垃圾回收机制？<br>72.魔法函数 <strong>call</strong>怎么使用?<br>73.如何判断一个对象是函数还是方法？<br>74.@classmethod 和@staticmethod 用法和区别<br>75.Python 中的接口如何实现？<br>76.Python 中的反射了解么?<br>77.metaclass 作用？以及应用场景？<br>78.hasattr() getattr() setattr()的用法<br>79.请列举你知道的 Python 的魔法方法及用途。<br>80.如何知道一个 Python 对象的类型？<br>81.Python 的传参是传值还是传址？</p>
<p>82.Python 中的元类(metaclass)使用举例 什么是元类(meta_class)?<br>元类就是用来创建类的“东西”</p>
<p>83.简述 any()和 all()方法<br>84.filter 方法求出列表所有奇数并构造新列表，a =  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>85.什么是猴子补丁？<br>86.在 Python 中是如何管理内存的？<br>87.当退出 Python 时是否释放所有内存分配？<br>正则表达式<br>88.使用正则表达式匹配出<html><h1><a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a></h1></html>中的地址<br>a=”张明 98 分”，用 re.sub，将 98 替换为 100<br>89.正则表达式匹配中(.<em>)和(.</em>?)匹配区别？<br>90.写一段匹配邮箱的正则表达式<br>其他内容<br>91.解释一下 python 中 pass 语句的作用？<br>92.简述你对 input()函数的理解<br>93.python 中的 is 和==<br>94.Python 中的作用域<br>95.三元运算写法和应用场景？<br>96.了解 enumerate 么？<br>97.列举 5 个 Python 中的标准模块<br>98.如何在函数中设置一个全局变量<br>99.pathlib 的用法举例<br>100.Python 中的异常处理，写一个简单的应用场景<br>101.Python 中递归的最大次数，那如何突破呢？<br>102.什么是面向对象的 mro<br>103.isinstance 作用以及应用场景？<br>104.什么是断言？应用场景？</p>
<p>105.lambda 表达式格式以及应用场景？<br>函数使用:</p>
<ol>
<li>代码块重复，这时候必须考虑到函数，降低程序的冗余度</li>
<li>代码块复杂，这时候必须考虑到函数，降低程序的复杂度<br>Python有两种函数,一种是def定义，一种是lambda函数()<br>当程序代码很短，且该函数只使用一次，为了程序的简洁，及节省变量内存占用空间，引入了匿名函数这个概念</li>
</ol>
<p>106.新式类和旧式类的区别<br>107.dir()是干什么用的？<br>108.一个包里有三个模块，demo1.py, demo2.py, demo3.py，但使用 from tools import *导入模块时，如何保证只有 demo1、demo3 被导入了。<br>109.列举 5 个 Python 中的异常类型以及其含义<br>110.copy 和 deepcopy 的区别是什么？<br>111.代码中经常遇到的*args, **kwargs 含义及用法。<br>112.Python 中会有函数或成员变量包含单下划线前缀和结尾，和双下划线前缀结尾，区别是什么?<br>113.w、a+、wb 文件写入模式的区别<br>114.举例 sort 和 sorted 的区别<br>115.什么是负索引？<br>116.pprint 模块是干什么的？<br>117.解释一下 Python 中的赋值运算符<br>118.解释一下 Python 中的逻辑运算符<br>119.讲讲 Python 中的位运算符<br>120.在 Python 中如何使用多进制数字？<br>121.怎样声明多个变量并赋值？<br>算法和数据结构<br>122.已知：<br>AList = [1,2,3]<br>BSet = {1,2,3}<br>(1) 从 AList 和 BSet 中 查找 4，最坏时间复杂度那个大？<br>(2) 从 AList 和 BSet 中 插入 4，最坏时间复杂度那个大？<br>123.用 Python 实现一个二分查找的函数</p>
<p>124.python 单例模式的实现方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- encoding=utf-8 -*-</span></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法1--------------------------'</span></span><br><span class="line"><span class="comment">#方法1,实现__new__方法</span></span><br><span class="line"><span class="comment">#并在将一个类的实例绑定到类变量_instance上,</span></span><br><span class="line"><span class="comment">#如果cls._instance为None说明该类还没有实例化过,实例化该类,并返回</span></span><br><span class="line"><span class="comment">#如果cls._instance不为None,直接返回cls._instance</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> hasattr(cls, <span class="string">'_instance'</span>):</span><br><span class="line">            orig = super(Singleton, cls)</span><br><span class="line">            cls._instance = orig.__new__(cls, *args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(Singleton)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass()</span><br><span class="line">two = MyClass()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="comment">#one和two完全相同,可以用id(), ==, is检测</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29097904</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法2--------------------------'</span></span><br><span class="line"><span class="comment">#方法2,共享属性;所谓单例就是所有引用(实例、对象)拥有相同的状态(属性)和行为(方法)</span></span><br><span class="line"><span class="comment">#同一个类的所有实例天然拥有相同的行为(方法),</span></span><br><span class="line"><span class="comment">#只需要保证同一个类的所有实例具有相同的状态(属性)即可</span></span><br><span class="line"><span class="comment">#所有实例共享属性的最简单最直接的方法就是__dict__属性指向(引用)同一个字典(dict)</span></span><br><span class="line"><span class="comment">#可参看:http://code.activestate.com/recipes/66531/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Borg</span><span class="params">(object)</span>:</span></span><br><span class="line">    _state = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        ob = super(Borg, cls).__new__(cls, *args, **kw)</span><br><span class="line">        ob.__dict__ = cls._state</span><br><span class="line">        <span class="keyword">return</span> ob</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass2</span><span class="params">(Borg)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">one = MyClass2()</span><br><span class="line">two = MyClass2()</span><br><span class="line"></span><br><span class="line"><span class="comment">#one和two是两个不同的对象,id, ==, is对比结果可看出</span></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#28873680</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#28873712</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#False</span></span><br><span class="line"><span class="comment">#但是one和two具有相同的（同一个__dict__属性）,见:</span></span><br><span class="line"><span class="keyword">print</span> id(one.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"><span class="keyword">print</span> id(two.__dict__)</span><br><span class="line"><span class="comment">#30104000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法3--------------------------'</span></span><br><span class="line"><span class="comment">#方法3:本质上是方法1的升级（或者说高级）版</span></span><br><span class="line"><span class="comment">#使用__metaclass__（元类）的高级python用法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span><span class="params">(type)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(cls, name, bases, dict)</span>:</span></span><br><span class="line">        super(Singleton2, cls).__init__(name, bases, dict)</span><br><span class="line">        cls._instance = <span class="literal">None</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls._instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            cls._instance = super(Singleton2, cls).__call__(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass3</span><span class="params">(object)</span>:</span></span><br><span class="line">    __metaclass__ = Singleton2</span><br><span class="line"></span><br><span class="line">one = MyClass3()</span><br><span class="line">two = MyClass3()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#31495472</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">print</span> <span class="string">'----------------------方法4--------------------------'</span></span><br><span class="line"><span class="comment">#方法4:也是方法1的升级（高级）版本,</span></span><br><span class="line"><span class="comment">#使用装饰器(decorator),</span></span><br><span class="line"><span class="comment">#这是一种更pythonic,更elegant的方法,</span></span><br><span class="line"><span class="comment">#单例类本身根本不知道自己是单例的,因为他本身(自己的代码)并不是单例的</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleton</span><span class="params">(cls, *args, **kw)</span>:</span></span><br><span class="line">    instances = &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_singleton</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">if</span> cls <span class="keyword">not</span> <span class="keyword">in</span> instances:</span><br><span class="line">            instances[cls] = cls(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> instances[cls]</span><br><span class="line">    <span class="keyword">return</span> _singleton</span><br><span class="line"></span><br><span class="line"><span class="meta">@singleton</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass4</span><span class="params">(object)</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x=<span class="number">0</span>)</span>:</span></span><br><span class="line">        self.x = x</span><br><span class="line"></span><br><span class="line">one = MyClass4()</span><br><span class="line">two = MyClass4()</span><br><span class="line"></span><br><span class="line">two.a = <span class="number">3</span></span><br><span class="line"><span class="keyword">print</span> one.a</span><br><span class="line"><span class="comment">#3</span></span><br><span class="line"><span class="keyword">print</span> id(one)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> id(two)</span><br><span class="line"><span class="comment">#29660784</span></span><br><span class="line"><span class="keyword">print</span> one == two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line"><span class="keyword">print</span> one <span class="keyword">is</span> two</span><br><span class="line"><span class="comment">#True</span></span><br><span class="line">one.x = <span class="number">1</span></span><br><span class="line"><span class="keyword">print</span> one.x</span><br><span class="line"><span class="comment">#1</span></span><br><span class="line"><span class="keyword">print</span> two.x</span><br><span class="line"><span class="comment">#1</span></span><br></pre></td></tr></table></figure>

<p>125.使用 Python 实现一个斐波那契数列<br>126.找出列表中的重复数字<br>127.找出列表中的单个数字<br>128.写一个冒泡排序<br>129.写一个快速排序<br>130.写一个拓扑排序<br>131.python 实现一个二进制计算<br>132.有一组“+”和“-”符号，要求将“+”排到左边，“-”排到右边，写出具体的实现方法。<br>133.单链表反转<br>134.交叉链表求交点<br>135.用队列实现栈<br>136.找出数据流的中位数<br>137.二叉搜索树中第 K 小的元素<br>爬虫相关<br>138.在 requests 模块中，requests.content 和 requests.text 什么区别<br>139.简要写一下 lxml 模块的使用方法框架<br>140.说一说 scrapy 的工作流程<br>141.scrapy 的去重原理<br>142.scrapy 中间件有几种类，你用过哪些中间件<br>143.你写爬虫的时候都遇到过什么？反爬虫措施，你是怎么解决的？<br>144.为什么会用到代理？<br>145.代理失效了怎么处理？<br>146.列出你知道 header 的内容以及信息<br>147.说一说打开浏览器访问 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 获取到结果，整个流程。<br>148.爬取速度过快出现了验证码怎么处理<br>149.scrapy 和 scrapy-redis 有什么区别？为什么选择 redis 数据库？<br>150.分布式爬虫主要解决什么问题<br>151.写爬虫是用多进程好？还是多线程好？为什么？<br>152.解析网页的解析器使用最多的是哪几个<br>153.需要登录的网页，如何解决同时限制 ip，cookie,session（其中有一些是动态生成的）在不使用动态爬取的情况下？<br>154.验证码的解决（简单的：对图像做处理后可以得到的，困难的：验证码是点击，拖动等动态进行的？）<br>155.使用最多的数据库（mysql，mongodb，redis 等），对他的理解？<br>网络编程<br>156.TCP 和 UDP 的区别？<br>157.简要介绍三次握手和四次挥手<br>158.什么是粘包？socket 中造成粘包的原因是什么？哪些情况会发生粘包现象？<br>并发<br>159.举例说明 conccurent.future 的中线程池的用法<br>160.说一说多线程，多进程和协程的区别。</p>
<p>161.简述 GIL.什么是GIL?<br>每一个interpreter进程,只能同时仅有一个线程来执行, 获得相关的锁, 存取相关的资源.<br>那么很容易就会发现,如果一个interpreter进程只能有一个线程来执行,<br>多线程的并发则成为不可能, 即使这几个线程之间不存在资源的竞争.<br>从理论上讲,我们要尽可能地使程序更加并行, 能够充分利用多核的功能</p>
<p>162.进程之间如何通信<br>163.IO 多路复用的作用？<br>164.select、poll、epoll 模型的区别？<br>165.什么是并发和并行？<br>167.解释什么是异步非阻塞？<br>168.threading.local 的作用？<br>Git 面试题<br>169.说说你知道的 git 命令<br>170.git 如何查看某次提交修改的内容x</p>
<p>180.说说你对zen of python的理解，你有什么办法看到它?<br>Python之禅,Python秉承一种独特的简洁和可读行高的语法，以及高度一致的编程模式，符合“大脑思维习惯”，使Python易于学习、理解和记忆。Python同时采用了一条极简主义的设计理念，了解完整的Python哲学理念，可以在任何一个Python交互解释器中键入import this命令，这是Python隐藏的一个彩蛋:描绘了一系列Python设计原则。如今已是Python社区内流行的行话”EIBTI”，明了胜于晦涩这条规则的简称. 在Python的思维方式中，明了胜于晦涩，简洁胜于复杂</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> this</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">The Zen of Python, by Tim Peters</span></span><br><span class="line"><span class="string">Beautiful is better than ugly.</span></span><br><span class="line"><span class="string">Explicit is better than implicit.</span></span><br><span class="line"><span class="string">Simple is better than complex.</span></span><br><span class="line"><span class="string">Complex is better than complicated.</span></span><br><span class="line"><span class="string">Flat is better than nested.</span></span><br><span class="line"><span class="string">Sparse is better than dense.</span></span><br><span class="line"><span class="string">Readability counts.</span></span><br><span class="line"><span class="string">Special cases aren't special enough to break the rules.</span></span><br><span class="line"><span class="string">Although practicality beats purity.</span></span><br><span class="line"><span class="string">Errors should never pass silently.</span></span><br><span class="line"><span class="string">Unless explicitly silenced.</span></span><br><span class="line"><span class="string">In the face of ambiguity, refuse the temptation to guess.</span></span><br><span class="line"><span class="string">There should be one-- and preferably only one --obvious way to do it.</span></span><br><span class="line"><span class="string">Although that way may not be obvious at first unless you're Dutch.</span></span><br><span class="line"><span class="string">Now is better than never.</span></span><br><span class="line"><span class="string">Although never is often better than *right* now.</span></span><br><span class="line"><span class="string">If the implementation is hard to explain, it's a bad idea.</span></span><br><span class="line"><span class="string">If the implementation is easy to explain, it may be a good idea.</span></span><br><span class="line"><span class="string">Namespaces are one honking great idea -- let's do more of those!</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>

<p>181.说说你对pythonic的看法，尝试解决下面的小问题<br>简洁，明了，严谨，灵活</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#交换两个变量值</span></span><br><span class="line">a,b = b,a</span><br><span class="line"><span class="comment">#去掉list中的重复元素</span></span><br><span class="line">old_list = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">new_list = list(set(old_list))</span><br><span class="line"><span class="comment">#翻转一个字符串</span></span><br><span class="line">s = <span class="string">'abcde'</span></span><br><span class="line">ss = s[::<span class="number">-1</span>]</span><br><span class="line"><span class="comment">#用两个元素之间有对应关系的list构造一个dict</span></span><br><span class="line">names = [<span class="string">'jianpx'</span>, <span class="string">'yue'</span>]</span><br><span class="line">ages = [<span class="number">23</span>, <span class="number">40</span>]</span><br><span class="line">m = dict(zip(names,ages))</span><br><span class="line"><span class="comment">#将数量较多的字符串相连，如何效率较高，为什么</span></span><br><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>]</span><br><span class="line">result = <span class="string">''</span>.join(fruits)</span><br></pre></td></tr></table></figure>

<p>182.你调试python代码的方法有哪些?<br>具体IDE都有调试，比如:IDLE, Eclipse+Pydev都可以设置断点调试。<br>pdb模块也可以做调试。<br>还有PyChecker和Pylint<br>PyChecker是一个python代码的静态分析工具，它可以帮助查找python代码的bug, 会对代码的复杂度和格式提出警告<br>Pylint   是另外一个工具可以进行coding standard检查。</p>
<p>Q: When will the else part of try-except-else be executed?<br>Q: What are metaclasses in Python?<br>Q: What is monkey patching? How to use in Python? Example?<br>Q: What are the tools that help to find bugs or perform static analysis? What static code analyzers do you know/used?<br>Q: Whenever Python exits, why isn’t all the memory de-allocated?<br>Q: Explain how can you access a module written in Python from C? Vise versa?<br>Q: What do these mean to you: @classmethod, @staticmethod, @property?<br>Q: Is Python a functional language?<br>Q: What is the attribute <strong>slots</strong>?<br>Q: Is it possible to use the construction True = False?<br>Q: How to create a class without the class statement?<br>Q: Give an example of filter and reduce over an iterable object<br>Q: Is it possible to have a producer thread reading from the network and a consumer thread writing to a file, really work in parallel? What about GIL?<br>Q: How do you create a dictionary which can preserve the order of pairs?<br>Q: What does the PYTHONOPTIMIZE flag do?<br>Q: What are descriptors? Code example?<br>Q: What is MRO in Python? How does it work?<br>Q: Mention what is the difference between Django, Pyramid, and Flask?<br>Q: Specify the requirements for code written in a functional style.<br>Q: Identify the pitfalls/limitations in the function code.<br>Q: How to package code in Python?<br>Q:What is wheels and eggs? What is the difference?<br>Q: How to package binary dependencies in Python?<br>Q: How can I reload a previously imported <code>module</code> module? (we assume that the module is a file with module.py)<br>Q: What advantages do NumPy arrays offer over (nested) Python lists?<br>Q: What is the process of compilation and linking in python?<br>Q: What id() function in Python is for?<br>Q: Is Python call-by-value or call-by-reference?<br>Q: Explain how you reverse a generator?<br>Q: Let A and B be objects of class Foo. What methods and in what order are called when “print (A + B)” is executed?<br>Q: Place the following functions below in order of their efficiency. How would you test your answer?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = sorted(lIn)</span><br><span class="line">    l2 = [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f2</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i <span class="keyword">for</span> i <span class="keyword">in</span> lIn <span class="keyword">if</span> i&lt;<span class="number">0.5</span>]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i*i <span class="keyword">for</span> i <span class="keyword">in</span> l2]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f3</span><span class="params">(lIn)</span>:</span></span><br><span class="line">    l1 = [i*i <span class="keyword">for</span> i <span class="keyword">in</span> lIn]</span><br><span class="line">    l2 = sorted(l1)</span><br><span class="line">    <span class="keyword">return</span> [i <span class="keyword">for</span> i <span class="keyword">in</span> l1 <span class="keyword">if</span> i&lt;(<span class="number">0.5</span>*<span class="number">0.5</span>)]</span><br></pre></td></tr></table></figure>

<p>Q: Write a one-liner that will count the number of capital letters in a file. Your code should work even if the file is too big to fit in memory.<br>Q: Output? Why? Is this inheritance?</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">type (C ())</span><br><span class="line">type (C)</span><br><span class="line">Q: What<span class="string">'s the output we get from running the following?</span></span><br><span class="line"><span class="string">big_num_1   = 1000</span></span><br><span class="line"><span class="string">big_num_2   = 1000</span></span><br><span class="line"><span class="string">small_num_1 = 1</span></span><br><span class="line"><span class="string">small_num_2 = 1</span></span><br><span class="line"><span class="string">big_num_1 is big_num_2</span></span><br><span class="line"><span class="string">small_num_1 is small_num_2</span></span><br><span class="line"><span class="string">Q: How is this possible?</span></span><br><span class="line"><span class="string">_MangledGlobal__mangled = 23</span></span><br><span class="line"><span class="string">class MangledGlobal:</span></span><br><span class="line"><span class="string">     def test(self):</span></span><br><span class="line"><span class="string">         return __mangled</span></span><br><span class="line"><span class="string">&gt;&gt;&gt; MangledGlobal().test()</span></span><br><span class="line"><span class="string">23</span></span><br></pre></td></tr></table></figure>

<p>1.Python这么好，说说它的特性吧<br>关键特性<br>Python是一种解释型语言，这意味着，与C，C++不同，Python不需要在运行之前进行编译。它是边运行边解释的。<br>Python是动态类型化的，这意味着当你声明它们或类似的东西时，你不需要声明变量的类型。你可以x=1 ，然后x=”abc”是没有错误。<br>Python非常适合面向对象编程，因为它允许定义类以及组合和继承。Python没有访问修饰符。<br>在Python中函数是一等对象，这意味着它们可以在运行时动态创建，能赋值给变量或者作为参数传给函数，还能作为函数的返回值。<br>Python代码容易上手，开发速度很快，但运行速度通常比编译语言慢。幸运的是，Python允许包含基于C的扩展，所以瓶颈可以被优化掉。</p>
<p>2.单引号、双引号和三引号之间的区别<br>关于怎么快速学python，可以加下小编的python学习群:611+530+101，不管你是小白还是大牛，小编我都欢迎，不定期分享干货<br>每天晚上20:00都会开直播给大家分享python学习知识和路线方法，群里会不定期更新最新的教程和学习方法，大家都是学习python的，或是转行，或是大学生，还有工作中想提升自己能力的，如果你是正在学习python的小伙伴可以加入学习。最后祝所有程序员都能够走上人生巅峰，让代码将梦想照进现实<br>单引号和双引号主要是用来表示字符串<br>比如:<br>单引号:’python’<br>双引号:”python”<br>区别:<br>若你的字符串里面本身包含单引号,必须用双引号包裹。<br>比如:”can’t find the log “<br>三引号<br>三单引号:’’’python ‘’’,也可以表示字符串一般用来输入多行文本,或者用于大段的注释。<br>三双引号：”””python”””，一般用在类里面,用来注释类,这样省的写文档,直接用类的对象doc访问获得文档。</p>
<p>3.Python里面如何拷贝一个对象？<br>标准库中的copy模块提供了两个方法来实现拷贝.一个方法是copy,它返回和参数包含内容一样的对象.<br>使用deepcopy方法,对象中的属性也被复制</p>
<p>4.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<p>5.什么是lambda函数？它的好处是什么?<br>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数。<br>lambda函数：首要用途是指点短小的回调函数。<br>lambda [arguments]:expression</p>
<blockquote>
<blockquote>
<blockquote>
<p>a=lambdax,y:x+y<br>a(3,11)<br>好处：<br>lambda能和def做同样种类的工作，特别是对于那些逻辑简单的函数，直接用lambda会更简洁，而且省去取函数名的麻烦。</p>
</blockquote>
</blockquote>
</blockquote>
<p>6.字符串格式化: %和 .format的区别是什么？<br>字符串的format函数非常灵活，很强大,可以接受的参数不限个数，并且位置可以不按顺序，而且有较为强大的格式限定符(比如:填充、对齐、精度等)。</p>
<p>7.Python是如何进行内存管理的？<br>Python引用了一个内存池(memory pool)机制，即Pymalloc机制(malloc:n.分配内存)，用于管理对小块内存的申请和释放<br>内存池（memory pool）的概念：<br>当创建大量消耗小内存的对象时，频繁调用new/malloc会导致大量的内存碎片，致使效率降低。内存池的概念就是预先在内存中申请一定数量的，大小相等 的内存块留作备用，当有新的内存需求时，就先从内存池中分配内存给这个需求，不够了之后再申请新的内存。这样做最显著的优势就是能够减少内存碎片，提升效率。<br>内存池的实现方式有很多，性能和适用范围也不一样。<br>python中的内存管理机制——Pymalloc：<br>python中的内存管理机制都有两套实现，一套是针对小对象，就是大小小于256bits时,pymalloc会在内存池中申请内存空间；当大于256bits，则会直接执行new/malloc的行为来申请内存空间。 关于释放内存方面，当一个对象的引用计数变为0时，python就会调用它的析构函数。在析构时，也采用了内存池机制，从内存池来的内存会被归还到内存池中，以避免频繁地释放动作。</p>
<p>8.如何用Python来进行查询和替换一个文本字符串？<br>可以使用sub()方法来进行查询和替换，sub方法的格式为：sub(replacement, string[, count=0])<br>replacement是被替换成的文本<br>string是需要被替换的文本<br>count是一个可选参数，指最大被替换的数量</p>
<p>9.Python里面search()和match()的区别？<br>match()函数只检测RE是不是在string的开始位置匹配，search()会扫描整个string查找匹配, 也就是说match()只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none 。</p>
<p>10.线程如何在Python中实现<br>Python有一个多线程包threading，可以使用多线程来加快你的代码。但是Python有一个叫做Global Interpreter Lock（GIL）的构造。GIL确保只有一个’线程’可以在任何时候执行。<br>线程获取GIL，做一些工作，然后将GIL传递到下一个线程。这种情况发生得非常快，所以对于人眼而言，它可能看起来像你的线程并行执行，但它们实际上只是轮流使用相同的CPU内核。因此GIL的存在使得Python中的多线程无法真正的利用多核的优势来提高性能。<br>对于IO密集型操作，在等待操作系统返回的时候会释放GIL；再比如爬虫因为有等待的服务器的响应时间，可以利用多线程来加速！但是对于CPU密集型操作，只能通过多进程Multiprocess来加速。</p>
<p>11.Python的参数传递，是值传递还是引用传递？<br>Python的参数传递有：<br>位置参数<br>默认参数<br>可变参数<br>关键字参数<br>函数的传值到底是值传递还是引用传递，要看情况<br>不可变参数用值传递：<br>比如像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象。<br>可变参数是用引用传递：<br>比如像列表，字典这样的对象是通过引用传递，和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变。</p>
<p>12.数据仓库是什么？<br>数据仓库是一个面向主题的、集成的、稳定的、反映历史变化的、随着时间的流逝发生变化的数据集合。它主要支持管理人员的决策分析。<br>数据仓库收集了企业相关内部和外部各个业务系统数据源、归档文件等一系列历史数据，最后转化成企业需要的战略决策信息。<br>特点：<br> 面向主题 ：根据业务的不同而进行的内容划分；<br> 集成特性 ：因为不同的业务源数据具有不同的数据特点，当业务源数据进入到数据仓库时，需要采用统一的编码格式进行数据加载，从而保证数据仓库中数据的唯一性；<br> 非易失性 ：数据仓库通过保存数据不同历史的各种状态，并不对数据进行任何更新操作。<br> 历史特性 ：数据保留时间戳字段，记录每个数据在不同时间内的各种状态。</p>
<p>1、一行代码实现1–100之和</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sum(range(<span class="number">0</span>,<span class="number">101</span>)</span><br></pre></td></tr></table></figure>

<p>2.如何在一个函数内部修改全局变量</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">fn()</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>3.字典如何删除键和合并两个字典</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">del</span></span><br><span class="line">update</span><br></pre></td></tr></table></figure>

<p>4.python实现列表去重的方法</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = []</span><br><span class="line">list(set(a))</span><br></pre></td></tr></table></figure>

<p>5.fun(<em>args,*</em>kwargs)中的<em>args,*</em>kwargs什么意思？</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>6.python2和python3的range（100）的区别<br>python2返回列表，python3返回迭代器，节约内存</p>
<p>7.一句话解释什么样的语言能够用装饰器?<br>函数可以作为参数传递的语言，可以使用装饰器</p>
<p>8.python内建数据类型有哪些<br>整型–int<br>布尔型–bool<br>字符串–str<br>列表–list<br>元组–tuple<br>字典–dict</p>
<p>9.简述面向对象中<strong>new</strong>和<strong>init</strong>区别<br><strong>init</strong>是初始化方法，创建对象后，就立刻被默认调用了，可接收参数<br>1、<strong>new</strong>至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别<br>2、<strong>new</strong>必须要有返回值，返回实例化出来的实例，这点在自己实现<strong>new</strong>时要特别注意，可以return父类（通过super(当前类名, cls)）<strong>new</strong>出来的实例，或者直接是object的<strong>new</strong>出来的实例<br>3、<strong>init</strong>有一个参数self，就是这个<strong>new</strong>返回的实例，<strong>init</strong>在<strong>new</strong>的基础上可以完成一些其它初始化的动作，<strong>init</strong>不需要返回值<br>4、如果<strong>new</strong>创建的是当前类的实例，会自动调用<strong>init</strong>函数，通过return语句里面调用的<strong>new</strong>函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的<strong>init</strong>函数，也不会调用其他类的<strong>init</strong>函数。</p>
<p>10.简述with方法打开处理文件帮我我们做了什么？<br>自带上下文管理器</p>
<p>11.列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fn</span><span class="params">(a)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a**<span class="number">2</span></span><br><span class="line">res = map(fn, a)</span><br><span class="line">res = [i <span class="keyword">for</span> i <span class="keyword">in</span> a <span class="keyword">if</span> i &gt; <span class="number">10</span>]</span><br></pre></td></tr></table></figure>

<p>12.python中生成随机整数、随机小数、0–1之间小数方法<br>随机整数：random.randint(a,b),生成区间内的整数<br>随机小数：习惯用numpy库，利用np.random.randn(5)生成5个随机小数<br>0-1随机小数：random.random(),括号中不传参</p>
<p>13.避免转义给字符串加哪个字母表示原始字符串？<br>r,表示需要原始字符串，不转义特殊字符</p>
<p>14.<div class="nam">中国</div>，用正则匹配出标签里面的内容（“中国”），其中class的类名是不确定的</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">str = <span class="string">'&lt;div class="nam"&gt;中国&lt;/div&gt;'</span></span><br><span class="line">res = re.findall(<span class="string">r'&lt;div class=".*"0&gt;(.*?)&lt;/div&gt;'</span>, str)</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure>

<p>15.python中断言方法举例<br>assert（）方法，断言成功，则程序继续执行，断言失败，则程序报错</p>
<p>16.列出python中可变数据类型和不可变数据类型，并简述原理<br>不可变数据类型：数值型、字符串型string和元组tuple<br>不允许变量的值发生变化，如果改变了变量的值，相当于是新建了一个对象，而对于相同的值的对象，在内存中则只有一个对象（一个地址），如下图用id()方法可以打印对象的id</p>
<p>可变数据类型：列表list和字典dict；<br>允许变量的值发生变化，即如果对变量进行append、+=等这种操作后，只是改变了变量的值，而不会新建一个对象，变量引用的对象的地址也不会变化，不过对于相同的值的不同对象，在内存中则会存在不同的对象，即每个对象都有自己的地址，相当于内存中对于同值的对象保存了多份，这里不存在引用计数，是实实在在的对象。</p>
<p>17.字典根据键从小到大排序</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = &#123;&#125;</span><br><span class="line"></span><br><span class="line">sorted(a.items(), key=<span class="keyword">lambda</span> x:x[<span class="number">0</span>], reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>18.正则re.complie作用<br>re.compile是将正则表达式编译成一个对象，加快速度，并重复使用</p>
<p>19.a=（1，）b=(1)，c=(“1”) 分别是什么类型的数据？<br>tuple,int,str</p>
<p>20.两个列表[1,5,7,9]和[2,2,6,8]合并为[1,2,2,3,6,7,8,9]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">a = [<span class="number">1</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line">b = [<span class="number">2</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line">a.extend(b)</span><br><span class="line">a + b</span><br><span class="line"></span><br><span class="line">a.sort()</span><br></pre></td></tr></table></figure>

<p>21.正则表达式匹配中，（.<em>）和（.</em>?）匹配区别？<br>（.<em>）是贪婪匹配，会把满足正则的尽可能多的往后匹配<br>（.</em>?）是非贪婪匹配，会把满足正则的尽可能少匹配</p>
<p>22.[[1,2],[3,4],[5,6]]一行代码展开该列表，得出[1,2,3,4,5,6]</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">b = np.array(a).flatten().tolist()</span><br></pre></td></tr></table></figure>

<p>23.提高python运行效率的方法<br>1、使用生成器，因为可以节约大量内存<br>2、循环代码优化，避免过多重复代码的执行<br>3、核心模块用Cython  PyPy等，提高效率<br>4、多进程、多线程、协程<br>5、多个if elif条件判断，可以把最有可能先发生的条件放到前面写，这样可以减少程序判断的次数，提高效率</p>
<p>24.写一个单列模式<br>因为创建对象时<strong>new</strong>方法执行，并且必须return 返回实例化出来的对象所cls.__instance是否存在，不存在的话就创建对象，存在的话就返回该对象，来保证只有一个实例对象存在（单列），打印ID，值一样，说明对象同一个</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Singleton</span><span class="params">(object)</span>:</span></span><br><span class="line">    _instance = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> _instance:</span><br><span class="line">            cls._instance = object.__new__(cls)</span><br><span class="line">        <span class="keyword">return</span> cls._instance</span><br></pre></td></tr></table></figure>

<p>25.保留两位小数</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">123.23423</span>,<span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<p>26.分别从前端、后端、数据库阐述web项目的性能优化<br>前端优化：<br>1、减少http请求、例如制作精灵图<br>2、html和CSS放在页面上部，javascript放在页面下面，因为js加载比HTML和Css加载慢，所以要优先加载html和css,以防页面显示不全，性能差，也影响用户体验差</p>
<p>后端优化：<br>1、缓存存储读写次数高，变化少的数据，比如网站首页的信息、商品的信息等。应用程序读取数据时，一般是先从缓存中读取，如果读取不到或数据已失效，再访问磁盘数据库，并将数据再次写入缓存。<br>2、异步方式，如果有耗时操作，可以采用异步，比如celery<br>3、代码优化，避免循环和判断次数太多，如果多个if else判断，优先判断最有可能先发生的情况</p>
<p>数据库优化：<br>1、如有条件，数据可以存放于redis，读取速度快<br>2、建立索引、外键等</p>
<p>27.列出常见MYSQL数据存储引擎<br>InnoDB：支持事务处理，支持外键，支持崩溃修复能力和并发控制。如果需要对事务的完整性要求比较高（比如银行），要求实现并发控制（比如售票），那选择InnoDB有很大的优势。如果需要频繁的更新、删除操作的数据库，也可以选择InnoDB，因为支持事务的提交（commit）和回滚（rollback）。<br>MyISAM：插入数据快，空间和内存使用比较低。如果表主要是用于插入新记录和读出记录，那么选择MyISAM能实现处理高效率。如果应用的完整性、并发性要求比 较低，也可以使用。<br>MEMORY：所有的数据都在内存中，数据的处理速度快，但是安全性不高。如果需要很快的读写速度，对数据的安全性要求较低，可以选择MEMOEY。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>
<p>29.简述多线程、多进程<br>进程：<br>1、操作系统进行资源分配和调度的基本单位，多个进程之间相互独立<br>2、稳定性好，如果一个进程崩溃，不影响其他进程，但是进程消耗资源大，开启的进程数量有限制</p>
<p>线程：<br>1、CPU进行资源分配和调度的基本单位，线程是进程的一部分，是比进程更小的能独立运行的基本单位，一个进程下的多个线程可以共享该进程的所有资源<br>2、如果IO操作密集，则可以多线程运行效率高，缺点是如果一个线程崩溃，都会造成进程的崩溃<br>应用：<br>IO密集的用多线程，在用户输入，sleep 时候，可以切换到其他线程执行，减少等待的时间<br>CPU密集的用多进程，因为假如IO操作少，用多线程的话，因为线程共享一个全局解释器锁，当前运行的线程会霸占GIL，其他线程没有GIL，就不能充分利用多核CPU的优势</p>
<p>30.IOError、AttributeError、ImportError、IndentationError、IndexError、KeyError、SyntaxError、NameError分别代表什么异常<br>IOError：输入输出异常<br>AttributeError：试图访问一个对象没有的属性<br>ImportError：无法引入模块或包，基本是路径问题<br>IndentationError：语法错误，代码没有正确的对齐<br>IndexError：下标索引超出序列边界<br>KeyError:试图访问你字典里不存在的键<br>SyntaxError:Python代码逻辑语法出错，不能执行<br>NameError:使用一个还未赋予对象的变量</p>
<p>31.python中copy和deepcopy区别<br>1、复制不可变数据类型，不管copy还是deepcopy,都是同一个地址当浅复制的值是不可变对象（数值，字符串，元组）时和=“赋值”的情况一样，对象的id值与浅复制原来的值相同<br>2、复制的值是可变对象（列表和字典）<br>浅拷贝copy有两种情况：<br>第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。<br>第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值  ，会影响浅复制的值。<br>深拷贝deepcopy：完全复制独立，包括内层列表和字典</p>
<p>32.请将[i for i in range(3)]改成生成器<br>生成器是特殊的迭代器，<br>1、列表表达式的[]改为（）即可变成生成器<br>2、函数在返回值得时候出现yield就变成生成器，而不是函数了；<br>中括号换成小括号即可，有没有惊呆了</p>
<p>33.int(“1.4”),int(1.4)输出结果？<br>int(“1.4”)报错，int(1.4)输出1</p>
<p>34.列举3条以上PEP8编码规范<br>1、顶级定义之间空两行，比如函数或者类定义。<br>2、方法定义、类定义与第一个方法之间，都应该空一行<br>3、三引号进行注释<br>4、使用Pycharm、Eclipse一般使用4个空格来缩进代码</p>
<p>35.简述乐观锁和悲观锁<br>悲观锁, 就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</p>
<p>乐观锁，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制，乐观锁适用于多读的应用类型，这样可以提高吞吐量</p>
<p>36.Linux命令重定向 &gt; 和 &gt;&gt;<br>Linux 允许将命令执行结果 重定向到一个 文件<br>将本应显示在终端上的内容 输出／追加 到指定文件中</p>
<blockquote>
<p>表示输出，会覆盖文件原有的内容</p>
<blockquote>
<p>表示追加，会将内容追加到已有文件的末尾</p>
</blockquote>
</blockquote>
<p>37.python传参数是传值还是传址？<br>Python中函数参数是引用传递（注意不是值传递）。对于不可变类型（数值型、字符串、元组），因变量不能修改，所以运算不会影响到变量自身；而对于可变类型（列表字典）来说，函数体运算可能会更改传入的参数变量。</p>
<p>38.求两个列表的交集、差集、并集</p>
<p>39.python正则中search和match</p>
]]></content>
  </entry>
  <entry>
    <title>资源</title>
    <url>/resource/index.html</url>
    <content><![CDATA[<h2 id="0x00、电子书"><a href="#0x00、电子书" class="headerlink" title="0x00、电子书"></a>0x00、电子书</h2><h3 id="1-操作系统"><a href="#1-操作系统" class="headerlink" title="1.操作系统"></a>1.操作系统</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E7%8E%B0%E4%BB%A3%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">现代操作系统_第三版.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf" target="_blank" rel="noopener">Red_Hat_Enterprise_Linux-7-System_Administrators_.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0_%E7%AC%AC%E4%B8%89%E7%89%88.pdf" target="_blank" rel="noopener">Linux内核设计与实现_第三版.pdf</a></li>
</ul>
<h3 id="2-后端"><a href="#2-后端" class="headerlink" title="2.后端"></a>2.后端</h3><h4 id="2-1-python"><a href="#2-1-python" class="headerlink" title="2.1 python"></a>2.1 python</h4><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/python%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">python核心编程.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Python%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86.pdf" target="_blank" rel="noopener">Python网络数据采集.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/OReilly.Web.Scraping.with.Python.2015.6.pdf" target="_blank" rel="noopener">OReilly.Web.Scraping.with.Python.2015.6.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/Machine%20Learning%20in%20Python.pdf" target="_blank" rel="noopener">Machine Learning in Python.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/The%20Django%20Book%202.0%E4%B8%AD%E6%96%87%E7%89%88.pdf" target="_blank" rel="noopener">The Django Book 2.0中文版.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/python/%E3%80%8APython%20Cookbook%E3%80%8B%E7%AC%AC%E4%B8%89%E7%89%88%E4%B8%AD%E6%96%87.pdf" target="_blank" rel="noopener">《Python Cookbook》第三版中文.pdf</a></li>
</ul>
<h4 id="2-2-golang"><a href="#2-2-golang" class="headerlink" title="2.2 golang"></a>2.2 golang</h4><ul>
<li><a href="http://www.gopl.io/" target="_blank" rel="noopener">go语言开发设计(原版)</a>, <a href="https://docs.hacknode.org/gopl-zh/" target="_blank" rel="noopener">go语言开发设计(中文版)</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/build-web-application-with-golang-en.pdf" target="_blank" rel="noopener">build-web-application-with-golang-en.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/effective-go-zh-en.pdf" target="_blank" rel="noopener">effective-go-zh-en.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/golang/go%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B.pdf" target="_blank" rel="noopener">go高级编程.pdf</a></li>
</ul>
<h4 id="2-3-c"><a href="#2-3-c" class="headerlink" title="2.3 c++"></a>2.3 c++</h4><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/C%2B%2B/C%2B%2BPrimer%E7%AC%AC%E4%BA%94%E7%89%88.pdf" target="_blank" rel="noopener">C++Primer第五版.pdf</a></li>
</ul>
<h3 id="3-数据库"><a href="#3-数据库" class="headerlink" title="3.数据库"></a>3.数据库</h3><h3 id="4-架构"><a href="#4-架构" class="headerlink" title="4.架构"></a>4.架构</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/%E5%A4%A7%E5%9E%8B%E7%BD%91%E7%AB%99%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%EF%BC%9A%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%88%86%E6%9E%90.pdf" target="_blank" rel="noopener">大型网站技术架构：核心原理与案例分析.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Web%E6%80%A7%E8%83%BD%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">Web性能权威指南.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%9E%B6%E6%9E%84/Recommender%2BSystems%2BHandbook.pdf" target="_blank" rel="noopener">Recommender+Systems+Handbook.pdf</a></li>
<li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念及设计(第五版)</a></li>
</ul>
<h3 id="5-前端"><a href="#5-前端" class="headerlink" title="5.前端"></a>5.前端</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E8%AF%AD%E8%A8%80%E7%9B%B8%E5%85%B3/javascript/%5BJavaScript%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97(%E7%AC%AC6%E7%89%88)%5D.(JavaScript%EF%BC%9AThe.Definitive.Guide).David.Flanagan.%E6%96%87%E5%AD%97%E7%89%88.pdf" target="_blank" rel="noopener">JavaScript权威指南(第6版)</a></li>
</ul>
<h3 id="6-大数据"><a href="#6-大数据" class="headerlink" title="6.大数据"></a>6.大数据</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E5%9F%BA%E7%A1%80.pdf" target="_blank" rel="noopener">数据仓库基础.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93_%E7%AC%AC%E5%9B%9B%E7%89%88.pdf" target="_blank" rel="noopener">数据仓库_第四版.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/DW2.0%E4%B8%8B%E4%B8%80%E4%BB%A3%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E7%9A%84%E6%9E%84%E6%9E%B6.pdf" target="_blank" rel="noopener">DW2.0下一代数据仓库的构架.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The%20Data%20Warehouse%20Toolkit%2C%203rd%20Edition.pdf" target="_blank" rel="noopener">The Data Warehouse Toolkit, 3rd Edition.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93/The_Data_Warehouse_Lifecycle_Toolkit(Second%20Edition).pdf" target="_blank" rel="noopener">The_Data_Warehouse_Lifecycle_Toolkit(Second Edition).pdf</a></li>
</ul>
<h3 id="7-人工智能"><a href="#7-人工智能" class="headerlink" title="7.人工智能"></a>7.人工智能</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%8E%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8E%9F%E4%B9%A6%E7%AC%AC3%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">神经网络与机器学习（原书第3版）.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86%E7%BB%BC%E8%AE%BA.pdf" target="_blank" rel="noopener">自然语言处理综论.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/AI/%E8%AF%AD%E4%B9%89%E7%BD%91%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B.pdf" target="_blank" rel="noopener">语义网基础教程.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/AI/PYTHON%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86.pdf" target="_blank" rel="noopener">PYTHON自然语言处理.pdf</a></li>
</ul>
<h3 id="8-网络"><a href="#8-网络" class="headerlink" title="8.网络"></a>8.网络</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97.pdf" target="_blank" rel="noopener">HTTP权威指南.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B71%EF%BC%9A%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷1：协议.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B72%EF%BC%9A%E5%AE%9E%E7%8E%B0.pdf" target="_blank" rel="noopener">TCP_IP详解卷2：实现.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/TCP_IP%E8%AF%A6%E8%A7%A3%E5%8D%B73%EF%BC%9ATCP%E4%BA%8B%E5%8A%A1%E5%8D%8F%E8%AE%AE%EF%BC%8CHTTP%EF%BC%8CNNTP%E5%92%8CUNIX%E5%9F%9F%E5%8D%8F%E8%AE%AE.pdf" target="_blank" rel="noopener">TCP_IP详解卷3：TCP事务协议，HTTP，NNTP和UNIX域协议.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E5%9B%BE%E8%A7%A3HTTP.pdf" target="_blank" rel="noopener">图解HTTP.pdf</a></li>
</ul>
<h3 id="9-算法"><a href="#9-算法" class="headerlink" title="9.算法"></a>9.算法</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/Algorithms%2C%204th%20Edition(%E7%AE%97%E6%B3%95%EF%BC%8C%E7%AC%AC%E5%9B%9B%E7%89%88%EF%BC%8C%E8%8B%B1%E6%96%87%E7%89%88).pdf" target="_blank" rel="noopener">Algorithms, 4th Edition(算法，第四版，英文版).pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%88%86%E6%9E%90%E5%9F%BA%E7%A1%80_%E7%AC%AC3%E7%89%88.pdf" target="_blank" rel="noopener">算法设计与分析基础_第3版.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%AE%97%E6%B3%95/leetcode-solution.pdf" target="_blank" rel="noopener">leetcode-solution.pdf</a></li>
</ul>
<h3 id="99-数学"><a href="#99-数学" class="headerlink" title="99.数学"></a>99.数学</h3><ul>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E7%BD%91%E7%BB%9C/%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6%20%E5%8E%9F%E4%B9%A6%E7%AC%AC5%E7%89%88.pdf" target="_blank" rel="noopener">组合数学 原书第5版.pdf</a></li>
<li><a href="https://github.com/xsoer/learn-files/raw/master/%E6%95%B0%E5%AD%A6/%5B%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8(%E8%8B%B1%E6%96%87%E7%AC%AC%E4%B8%83%E7%89%88)%5DDiscrete%20Mathematics%20and%20Its%20Applications%20(7th).pdf" target="_blank" rel="noopener">离散数学及其应用(英文第七版)</a></li>
</ul>
<h2 id="0x01、视频教程"><a href="#0x01、视频教程" class="headerlink" title="0x01、视频教程"></a>0x01、视频教程</h2><h2 id="0x02、论文"><a href="#0x02、论文" class="headerlink" title="0x02、论文"></a>0x02、论文</h2><ul>
<li><a href="https://github.com/papers-we-love/papers-we-love" target="_blank" rel="noopener">papers-we-love</a></li>
</ul>
<h3 id="1-分布式"><a href="#1-分布式" class="headerlink" title="1.分布式"></a>1.分布式</h3><ul>
<li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li>
</ul>
<h2 id="0x02、github图书库"><a href="#0x02、github图书库" class="headerlink" title="0x02、github图书库"></a>0x02、github图书库</h2><ul>
<li><a href="https://github.com/xsoer/learn-files" target="_blank" rel="noopener">https://github.com/xsoer/learn-files</a></li>
<li><a href="https://github.com/royeo/free-programming-books.pdf" target="_blank" rel="noopener">https://github.com/royeo/free-programming-books.pdf</a></li>
<li><a href="https://github.com/threerocks/studyFiles" target="_blank" rel="noopener">https://github.com/threerocks/studyFiles</a></li>
<li><a href="https://github.com/justjavac/free-programming-books-zh_CN" target="_blank" rel="noopener">https://github.com/justjavac/free-programming-books-zh_CN</a></li>
<li><a href="https://github.com/it-ebooks/it-ebooks-archive" target="_blank" rel="noopener">https://github.com/it-ebooks/it-ebooks-archive</a></li>
<li><a href="https://github.com/shivam-jha/DockerBooks" target="_blank" rel="noopener">https://github.com/shivam-jha/DockerBooks</a></li>
<li><a href="https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md" target="_blank" rel="noopener">https://github.com/EbookFoundation/free-programming-books/blob/master/free-programming-books-zh.md</a></li>
<li><a href="https://github.com/zhiwoeryi/eBook-3" target="_blank" rel="noopener">https://github.com/zhiwoeryi/eBook-3</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>go语言程序设计</title>
    <url>/books/gopl.html</url>
    <content><![CDATA[<blockquote>
<p><a href="http://www.gopl.io/" target="_blank" rel="noopener">图书地址</a>，<a href="https://docs.hacknode.org/gopl-zh/" target="_blank" rel="noopener">中文版地址</a></p>
</blockquote>
<h2 id="0x00、基础"><a href="#0x00、基础" class="headerlink" title="0x00、基础"></a>0x00、基础</h2><ul>
<li>如果是比较小的C语言库，我们完全可以用纯Go语言重新实现一遍。如果我们对性能也没有特殊要求的话，我们还可以用os/exec包的方法将C编写的应用程序作为一个子进程运行。只有当你需要使用复杂而且性能更高的底层C接口时，就是使用cgo的场景了</li>
<li>只有通过简洁的设计，才能让一个系统保持稳定、安全和持续的进化。</li>
<li>import声明必须跟在文件的package声明之后。随后，则是组成程序的函数、变量、常量、类型的声明语句（分别由关键字func、var、const、type定义）</li>
<li>一个函数的声明由func关键字、函数名、参数列表、返回值列表（这个例子里的main函数参数列表和返回值都是空的）以及包含在大括号里的函数体组成</li>
</ul>
<ol>
<li>%d 十进制整数</li>
<li>%x, %o, %b 十六进制，八进制，二进制整数。</li>
<li>%f, %g, %e 浮点数： 3.141593 3.141592653589793 3.141593e+00</li>
<li>%t 布尔：true或false</li>
<li>%c 字符（rune） (Unicode码点)</li>
<li>%s 字符串</li>
<li>%q 带双引号的字符串”abc”或带单引号的字符’c’</li>
<li>%v 变量的自然形式（natural format）</li>
<li>%T 变量的类型</li>
<li>%% 字面上的百分号标志（无操作数）</li>
</ol>
<ul>
<li><p>关键字</p>
<ol>
<li>break default func interface select</li>
<li>case defer go map struct</li>
<li>chan else goto package switch</li>
<li>const fallthrough if range type</li>
<li>continue for import return var</li>
</ol>
</li>
<li><p>预定义的名字</p>
<ol>
<li>内建常量: true false iota nil</li>
<li>内建类型: int int8 int16 int32 int64</li>
<li>uint uint8 uint16 uint32 uint64 uintptr</li>
<li>float32 float64 complex128 complex64</li>
<li>bool byte rune string error</li>
<li>内建函数: make len cap new append copy close delete</li>
<li>complex real imag</li>
<li>panic recover</li>
</ol>
</li>
<li><p>命令行</p>
<ul>
<li>get</li>
<li>run</li>
<li>clear</li>
<li>test</li>
<li>build</li>
<li>env</li>
<li>version</li>
<li>doc</li>
</ul>
</li>
<li><p>如果一个名字是在函数内部定义，那么它就只在函数内部有效。如果是在函数外部定义，那么将在当前包的所有文件中都可以访问。名字的开头字母的大小写决定了名字在包外的可见性。如果一个名字是大写字母开头的（译注：必须是在函数外部定义的包级名字；包级函数名本身也是包级名字），那么它将是导出的，也就是说可以被外部的包访问。包本身的名字一般总是用小写字母</p>
</li>
<li><p>Go语言程序员推荐使用 驼峰式 命名</p>
</li>
<li><p>主要有四种类型的声明语句：var、const、type和func，分别对应变量、常量、类型和函数实体对象的声明</p>
</li>
<li><p>一个Go语言编写的程序对应一个或多个以.go为文件后缀名的源文件。每个源文件中以包的声明语句开始，说明该源文件是属于哪个包。包声明语句之后是import语句导入依赖的其它包，然后是包一级的类型、变量、常量、函数的声明语句，包一级的各种类型的声明语句的顺序无关紧要（译注：函数内部的名字则必须先声明之后才能使用）</p>
</li>
<li><p>一个函数的声明由一个函数名字、参数列表（由函数的调用者提供参数变量的具体值）、一个可选的返回值列表和包含函数定义的函数体组成。如果函数没有返回值，那么返回值列表是省略的。执行函数从函数的第一个语句开始，依次顺序执行直到遇到return返回语句，如果没有返回语句则是执行到函数末尾，然后返回到函数调用者。</p>
</li>
<li><p>变量声明</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名字 类型 = 表达式</span><br></pre></td></tr></table></figure>
</li>
<li><p>其中“类型”或“= 表达式”两个部分可以省略其中的一个。如果省略的是类型信息，那么将根据初始化表达式来推导变量的类型信息。如果初始化表达式被省略，那么将用零值初始化该变量。 数值类型变量对应的零值是0，布尔类型变量对应的零值是false，字符串类型对应的零值是空字符串，接口或引用类型（包括slice、指针、map、chan和函数）变量对应的零值是nil。数组或结构体等聚合类型对应的零值是每个元素或字段都是对应该类型的零值。</p>
</li>
<li><p>零值初始化机制可以确保每个声明的变量总是有一个良好定义的值，因此在Go语言中不存在未初始化的变量。这个特性可以简化很多代码，而且可以在没有增加额外工作的前提下确保边界条件下的合理行为</p>
</li>
<li><p>也可以在一个声明语句中同时声明一组变量，或用一组初始化表达式声明并初始化一组变量。如果省略每个变量的类型，将可以声明多个类型不同的变量（类型由初始化表达式推导）：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> i, j, k <span class="keyword">int</span> <span class="comment">// int, int, int</span></span><br><span class="line"><span class="keyword">var</span> b, f, s = <span class="literal">true</span>, <span class="number">2.3</span>, <span class="string">"four"</span> <span class="comment">// bool, float64, string</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化表达式可以是字面量或任意的表达式。在包级别声明的变量会在main入口函数执行前完成初始化（§2.6.2），局部变量将在声明语句被执行到的时候完成初始化。</p>
</li>
<li><p>一组变量也可以通过调用一个函数，由函数返回的多个返回值初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f, err = os.Open(name) <span class="comment">// os.Open returns a file and an error</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>自增和自减是语句，而不是表达式，因此x = i++之类的表达式是错误的</p>
</li>
<li><p>元组赋值是另一种形式的赋值语句，它允许同时更新多个变量的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">x, y = y, x</span><br><span class="line">a[i], a[j] = a[j], a[i]</span><br></pre></td></tr></table></figure>
</li>
<li><p>map查找（§4.3）、类型断言（§7.10）或通道接收（§8.4.2）出现在赋值语句的右边时，并不一定是产生两个结果，也可能只产生一个结果。对于只产生一个结果的情形，map查找失败时会返回零值，类型断言失败时会发生运行时panic异常，通道接收失败时会返回零值（阻塞不算是失败）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">v = m[key] <span class="comment">// map查找，失败时返回零值</span></span><br><span class="line">v = x.(T) <span class="comment">// type断言，失败时panic异常</span></span><br><span class="line">v = &lt;-ch <span class="comment">// 管道接收，失败时返回零值（阻塞不算是失败）</span></span><br><span class="line">_, ok = m[key] <span class="comment">// map返回2个值</span></span><br><span class="line">_, ok = mm[<span class="string">""</span>], <span class="literal">false</span> <span class="comment">// map返回1个值</span></span><br><span class="line">_ = mm[<span class="string">""</span>] <span class="comment">// map返回1个值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>和变量声明一样，我们可以用下划线空白标识符_来丢弃不需要的值</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">_, err = io.Copy(dst, src) <span class="comment">// 丢弃字节数</span></span><br><span class="line">_, ok = x.(T) <span class="comment">// 只检测类型，忽略具体值</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>赋值语句是显式的赋值形式，但是程序中还有很多地方会发生隐式的赋值行为：函数调用会隐式地将调用参数的值赋值给函数的参数变量，一个返回语句会隐式地将返回操作的值赋值给结果变量，一个复合类型的字面量（§4.2）也会产生赋值行为</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">medals := []<span class="keyword">string</span>&#123;<span class="string">"gold"</span>, <span class="string">"silver"</span>, <span class="string">"bronze"</span>&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不管是隐式还是显式地赋值，在赋值语句左边的变量和右边最终的求到的值必须有相同的数据类型。更直白地说，只有右边的值对于左边的变量是可赋值的，赋值语句才是允许的</p>
</li>
<li><p>可赋值性的规则对于不同类型有着不同要求，对每个新类型特殊的地方我们会专门解释。对于目前我们已经讨论过的类型，它的规则是简单的：类型必须完全匹配，nil可以赋值给任何指针或引用类型的变量。常量（§3.6）则有更灵活的赋值规则，因为这样可以避免不必要的显式的类型转换。</p>
</li>
<li><p>对于两个值是否可以用==或!=进行相等比较的能力也和可赋值能力有关系：对于任何类型的值的相等比较，第二个值必须是对第一个值类型对应的变量是可赋值的，反之亦然。</p>
</li>
<li><p>一个类型声明语句创建了一个新的类型名称，和现有类型具有相同的底层结构。新命名的类型提供了一个方法，用来分隔不同概念的类型，这样即使它们底层类型相同也是不兼容的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名字 底层类型</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型声明语句一般出现在包一级，因此如果新创建的类型名字的首字符大写，则在包外部也可以使用</p>
</li>
<li><p>对于中文汉字，Unicode标志都作为小写字母处理，因此中文的命名默认不能导出；不过国内的用户针对该问题提出了不同的看法，根据RobPike的回复，在Go2中有可能会将中日韩等字符当作大写字母处理。</p>
</li>
<li><p>对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型.只有当两个类型的底层基础类型相同时，才允许这种转型操作，或者是两者都是指向相同底层结构的指针类型，这些转换只改变类型而不会影响值本身</p>
</li>
<li><p>数值类型之间的转型也是允许的，并且在字符串和一些特定类型的slice之间也是可以转换的</p>
</li>
<li><p>每个包都对应一个独立的名字空间</p>
</li>
<li><p>包还可以让我们通过控制哪些名字是外部可见的来隐藏内部实现信息。一个简单的规则是：如果一个名字是大写字母开头的，那么该名字是导出的（译注：因为汉字不区分大小写，因此汉字开头的名字是没有导出的）。</p>
</li>
<li><p>在每个源文件的包声明前紧跟着的注释是包注释（§10.7.4）。通常，包注释的第一句应该先是包的功能概要说明。一个包通常只有一个源文件有包注释（译注：如果有多个包注释，目前的文档工具会根据源文件名的先后顺序将它们链接为一个包注释）。如果包注释很大，通常会放到一个独立的doc.go文件中。</p>
</li>
<li><p>如果导入了一个包，但是又没有使用该包将被当作一个编译错误处理。</p>
</li>
<li><p>不过有更好的解决方案，我们可以使用golang.org/x/tools/cmd/goimports导入工具，它可以根据需要自动添加或删除导入的包；许多编辑器都可以集成goimports工具，然后在保存文件的时候自动运行。类似的还有gofmt工具，可以用来格式化Go源文件。</p>
</li>
<li><p>包的初始化首先是解决包级变量的依赖顺序，然后按照包级变量声明出现的顺序依次初始化：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = b + c <span class="comment">// a 第三个初始化, 为 3</span></span><br><span class="line"><span class="keyword">var</span> b = f() <span class="comment">// b 第二个初始化, 为 2, 通过调用 f (依赖c)</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="number">1</span> <span class="comment">// c 第一个初始化, 为 1</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> c + <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果包中含有多个.go源文件，它们将按照发给编译器的顺序进行初始化，Go语言的构建工具首先会将.go文件根据文件名排序，然后依次调用编译器编译。</p>
</li>
<li><p>对于在包级别声明的变量，如果有初始化表达式则用表达式初始化，还有一些没有初始化表达式的，例如某些表格数据初始化并不是一个简单的赋值过程。在这种情况下，我们可以用一个特殊的init初始化函数来简化初始化工作。每个文件都可以包含多个init初始化函数</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这样的init初始化函数除了不能被调用或引用外，其他行为和普通函数类似。在每个文件中的init初始化函数，在程序开始执行时按照它们声明的顺序被自动调用。</p>
</li>
<li><p>每个包在解决依赖的前提下，以导入声明的顺序初始化，每个包只会被初始化一次。因此，如果一个p包导入了q包，那么在p包初始化的时候可以认为q包必然已经初始化过了。初始化工作是自下而上进行的，main包最后被初始化。以这种方式，可以确保在main函数执行之前，所有依赖的包都已经完成初始化工作了。</p>
</li>
<li><p>声明语句的作用域是指源代码中可以有效使用这个名字的范围。</p>
</li>
<li><p>不要将作用域和生命周期混为一谈。声明语句的作用域对应的是一个源代码的文本区域；它是一个编译时的属性。一个变量的生命周期是指程序运行时变量存在的有效时间段，在此时间区域内它可以被程序的其他部分引用；是一个运行时的概念。</p>
</li>
<li><p>句法块是由花括弧所包含的一系列语句，就像函数体或循环体花括弧包裹的内容一样。句法块内部声明的名字是无法被外部块访问的</p>
</li>
<li><p>我们可以把块（block）的概念推广到包括其他声明的群组，这些声明在代码中并未显式地使用花括号包裹起来，我们称之为词法块。对全局的源代码来说，存在一个整体的词法块，称为全局词法块；对于每个包；每个for、if和switch语句，也都有对应词法块；每个switch或select的分支也有独立的词法块；当然也包括显式书写的词法块（花括弧包含的语句）。</p>
</li>
<li><p>声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问。</p>
</li>
<li><p>控制流标号，就是break、continue或goto语句后面跟着的那种标号，则是函数级的作用域。</p>
</li>
<li><p>一个程序可能包含多个同名的声明，只要它们在不同的词法域就没有关系.但是物极必反，如果滥用不同词法域可重名的特性的话，可能导致程序很难阅读。</p>
</li>
<li><p>当编译器遇到一个名字引用时，它会对其定义进行查找，查找过程从最内层的词法域向全局的作用域进行。如果查找失败，则报告“未声明的名字”这样的错误。如果该名字在内部和外部的块分别声明过，则内部块的声明首先被找到。在这种情况下，内部声明屏蔽了外部同名的声明，让外部的声明的名字无法被访问</p>
</li>
<li><p>在函数中词法域可以深度嵌套，因此内部的一个声明可能屏蔽外部的声明。还有许多语法块是if或for等控制流语句构造的。下面的代码有三个不同的变量x，因为它们是定义在不同的词法域（这个例子只是为了演示作用域规则，但不是好的编程风格）。</p>
</li>
<li><p>在包级别，声明的顺序并不会影响作用域范围，因此一个先声明的可以引用它自身或者是引用后面的一个声明，这可以让我们定义一些相互嵌套或递归的类型或函数。但是如果一个变量或常量递归引用了自身，则会产生编译错误。</p>
</li>
<li><p>Go语言的习惯是在if中处理错误然后直接返回，这样可以确保正常执行的语句不需要代码缩进。</p>
</li>
<li><p>将数据类型分为四类：基础类型、复合类型、引用类型和接口类型</p>
</li>
</ul>
<h2 id="0x01、函数"><a href="#0x01、函数" class="headerlink" title="0x01、函数"></a>0x01、函数</h2><ul>
<li><p>函数可以让我们将一个语句序列打包为一个单元，然后可以从程序中其它地方多次调用</p>
</li>
<li><p>函数的机制可以让我们将一个大的工作分解为小的任务，这样的小任务可以让不同程序员在不同时间、不同地方独立完成</p>
</li>
<li><p>一个函数同时对用户隐藏了其实现细节</p>
</li>
<li><p>函数声明包括函数名、形式参数列表、返回值列表（可省略）以及函数体</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">name</span><span class="params">(parameter-list)</span> <span class="params">(result-list)</span></span> &#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>形式参数列表描述了函数的参数名以及参数类型。</p>
</li>
<li><p>这些参数作为局部变量，其值由参数调用者提供</p>
</li>
<li><p>返回值列表描述了函数返回值的变量名以及类型。如果函数返回一个无名变量或者没有返回值，返回值列表的括号是可以省略的。如果一个函数声明不包括返回值列表，那么函数体执行完毕后，不会返回任何值</p>
</li>
<li><p>如果一个函数在声明时，包含返回值列表，该函数必须以 return语句结尾，除非函数明显无法运行到结尾处。</p>
</li>
<li><p>如果一组形参或返回值有相同的类型，我们不必为每个形参都写出参数类型</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i, j, k <span class="keyword">int</span>, s, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(i <span class="keyword">int</span>, j <span class="keyword">int</span>, k <span class="keyword">int</span>, s <span class="keyword">string</span>, t <span class="keyword">string</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数的类型被称为函数的签名。如果两个函数形式参数列表和返回值列表中的变量类型一一对应，那么这两个函数被认为有相同的类型或签名。形参和返回值的变量名不影响函数签名，也不影响它们是否可以以省略参数类型的形式表示。</p>
</li>
<li><p>每一次函数调用都必须按照声明顺序为所有参数提供实参（参数值）。在函数调用时，Go语言没有默认参数值，也没有任何方法可以通过参数名指定形参，因此形参和返回值的变量名对于函数调用者而言没有意义。</p>
</li>
<li><p>在函数体中，函数的形参作为局部变量，被初始化为调用者提供的值。函数的形参和有名返回值作为函数最外层的局部变量，被存储在相同的词法块中。</p>
</li>
<li><p>实参通过值的方式传递，因此函数的形参是实参的拷贝。对形参进行修改不会影响实参。但是，如果实参包括引用类型，如指针，slice(切片)、map、function、channel等类型，实参可能会由于函数的间接引用被修改。</p>
</li>
<li><p>你可能会偶尔遇到没有函数体的函数声明，这表示该函数不是以Go实现的。这样的声明定义了函数签名。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> math</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sin</span><span class="params">(x <span class="keyword">float64</span>)</span> <span class="title">float</span> //<span class="title">implemented</span> <span class="title">in</span> <span class="title">assembly</span> <span class="title">language</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数可以是递归的，这意味着函数可以直接或间接的调用自身.通过遍历二叉树来实现简单的插入排序.使用它来处理HTML文件。</p>
</li>
<li><p>golang.org/x/… 目录下存储了一些由Go团队设计、维护，对网络编程、国际化文件处理、移动平台、图像处理、加密解密、开发者工具提供支持的扩展包。未将这些扩展包加入到标准库原因有二，一是部分包仍在开发中，二是对大多数Go语言的开发者而言，扩展包提供的功能很少被使用。</p>
</li>
<li><p>大部分编程语言使用固定大小的函数调用栈，常见的大小从64KB到2MB不等。固定大小栈会限制递归的深度，当你用递归处理大量数据时，需要避免栈溢出；除此之外，还会导致安全性问题。与此相反，Go语言使用可变栈，栈的大小按需增加(初始时很小)。这使得我们使用递归时不必考虑溢出和安全问题。</p>
</li>
<li><p>一个函数可以返回多个值</p>
</li>
<li><p>如果某个值不被使用，可以将其分配给blank identifier:</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">links, _ := findLinks(url) <span class="comment">// errors ignored</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>虽然良好的命名很重要，但你也不必为每一个返回值都取一个适当的名字。比如，按照惯例，函数的最后一个bool类型的返回值表示函数是否运行成功，error类型的返回值代表函数的错误信息，对于这些类似的惯例，我们不必思考合适的命名，它们都无需解释。</p>
</li>
<li><p>如果一个函数所有的返回值都有显式的变量名，那么该函数的return语句可以省略操作数。这称之为bare return。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CountWordsAndImages does an HTTP GET request for the HTML</span></span><br><span class="line"><span class="comment">// document url and returns the number of words and images in it.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">CountWordsAndImages</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="params">(words, images <span class="keyword">int</span>, err error)</span></span> &#123;</span><br><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    err = fmt.Errorf(<span class="string">"parsing HTML: %s"</span>, err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">words, images = countWordsAndImages(doc)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countWordsAndImages</span><span class="params">(n *html.Node)</span> <span class="params">(words, images <span class="keyword">int</span>)</span></span> &#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当一个函数有多处return语句以及许多返回值时，bare return 可以减少代码的重复，但是使得代码难以被理解。举个例子，如果你没有仔细的审查代码，很难发现前2处return等价于 return 0,0,err（Go会将返回值 words和images在函数体的开始处，根据它们的类型，将其初始化为0），最后一处return等价于 return words, image, nil。基于以上原因，不宜过度使用bare return。</p>
</li>
<li><p>在Go中有一部分函数总是能成功的运行。比如strings.Contains和strconv.FormatBool函数，对各种可能的输入都做了良好的处理，使得运行时几乎不会失败，除非遇到灾难性的、不可预料的情况，比如运行时的内存溢出。</p>
</li>
<li><p>对于大部分函数而言，永远无法确保能否成功运行。这是因为错误的原因超出了程序员的控制。举个例子，任何进行I/O操作的函数都会面临出现错误的可能，只有没有经验的程序员才会相信读写操作不会失败，即使是简单的读写。因此，当本该可信的操作出乎意料的失败后，我们必须弄清楚导致失败的原因。</p>
</li>
<li><p>在Go的错误处理中，错误是软件包API和应用程序用户界面的一个重要组成部分，程序运行失败仅被认为是几个预期的结果之一。</p>
</li>
<li><p>对于那些将运行失败看作是预期结果的函数，它们会返回一个额外的返回值，通常是最后一个，来传递错误信息。如果导致失败的原因只有一个，额外的返回值可以是一个布尔值，通常被命名为ok。比如，cache.Lookup失败的唯一原因是key不存在，那么代码可以按照下面的方式组织：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">value, ok := cache.Lookup(key)</span><br><span class="line"><span class="keyword">if</span> !ok &#123;</span><br><span class="line">    <span class="comment">// ...cache[key] does not exist…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>内置的error是接口类型。我们将在第七章了解接口类型的含义，以及它对错误处理的影响。现在我们只需要明白error类型可能是nil或者non-nil。nil意味着函数运行成功，non-nil表示失败。对于non-nil的error类型，我们可以通过调用error的Error函数或者输出函数获得字符串类型的错误信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">fmt.Println(err)</span><br><span class="line">fmt.Printf(<span class="string">"%v"</span>, err)</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Go中，函数运行失败时会返回错误信息，这些错误信息被认为是一种预期的值而非异常（exception），这使得Go有别于那些将函数运行失败看作是异常的语言。虽然Go有各种异常机制，但这些机制仅被使用在处理那些未被预料到的错误，即bug，而不是那些在健壮程序中应该被避免的程序错误。</p>
</li>
<li><p>Go这样设计的原因是由于对于某个应该在控制流程中处理的错误而言，将这个错误以异常的形式抛出会混乱对错误的描述，这通常会导致一些糟糕的后果。当某个程序错误被当作异常处理后，这个错误会将堆栈跟踪信息返回给终端用户，这些信息复杂且无用，无法帮助定位错误。</p>
</li>
<li><p>最常用的方式是传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">resp, err := http.Get(url)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>当对html.Parse的调用失败时，findLinks不会直接返回html.Parse的错误，因为缺少两条重要信息：1、发生错误时的解析器（html parser）；2、发生错误的url。因此，findLinks构造了一个新的错误信息，既包含了这两项，也包括了底层的解析出错的信息</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">doc, err := html.Parse(resp.Body)</span><br><span class="line">resp.Body.Close()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, fmt.Errorf(<span class="string">"parsing %s as HTML: %v"</span>, url,err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>编写错误信息时，我们要确保错误信息对问题细节的描述是详尽的。尤其是要注意错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</p>
</li>
<li><p>函数内错误处理</p>
<ul>
<li>错误注意项<ul>
<li>确保错误信息对问题细节的描述是详尽的</li>
<li>错误信息表达的一致性，即相同的函数或同包内的同一组函数返回的错误在构成和处理方式上是相似的。</li>
</ul>
</li>
<li>处理逻辑<ul>
<li>检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</li>
</ul>
</li>
<li>五种错误处理方案<ul>
<li>传播错误。这意味着函数中某个子程序的失败，会变成该函数的失败。</li>
<li>重试逻辑。第二种是 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</li>
<li>输出错误并结束运行。如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</li>
<li>Log记录错误。 有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</li>
<li>忽略错误。我们可以直接忽略掉错误。</li>
</ul>
</li>
<li>panic异常</li>
<li>recover场景</li>
</ul>
</li>
<li><p>函数赋值</p>
<ul>
<li>函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</li>
<li>函数类型的零值是nil。调用值为nil的函数值会引起panic错误</li>
<li>函数值可以与nil比较</li>
<li>但是函数值之间是不可比较的，也不能用函数值作为map的key</li>
<li>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为</li>
</ul>
</li>
<li><p>匿名函数</p>
<ul>
<li>函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数</li>
<li>可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量</li>
<li>函数值不仅仅是一串代码，还记录了状态</li>
<li>函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</li>
</ul>
</li>
<li><p>一般而言，被调用函数f(x)会将调用信息和参数信息作为发生错误时的上下文放在错误信息中并返回给调用者，调用者需要添加一些错误信息中不包含的信息，比如添加url到html.Parse返回的错误中。</p>
</li>
<li><p>第二种是 如果错误的发生是偶然性的，或由不可预知的问题导致的。一个明智的选择是重新尝试失败的操作。在重试时，我们需要限制重试的时间间隔或重试的次数，防止无限制的重试。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// WaitForServer attempts to contact the server of a URL.</span></span><br><span class="line"><span class="comment">// It tries for one minute using exponential back-off.</span></span><br><span class="line"><span class="comment">// It reports an error if all attempts fail.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WaitForServer</span><span class="params">(url <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">const</span> timeout = <span class="number">1</span> * time.Minute</span><br><span class="line">deadline := time.Now().Add(timeout)</span><br><span class="line"><span class="keyword">for</span> tries := <span class="number">0</span>; time.Now().Before(deadline); tries++ &#123;</span><br><span class="line">    _, err := http.Head(url)</span><br><span class="line">    <span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// success</span></span><br><span class="line">    &#125;</span><br><span class="line">    log.Printf(<span class="string">"server not responding (%s);retrying…"</span>, err)</span><br><span class="line">    time.Sleep(time.Second &lt;&lt; <span class="keyword">uint</span>(tries)) <span class="comment">// exponential back-off</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> fmt.Errorf(<span class="string">"server %s failed to respond after %s"</span>, url, timeout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>如果错误发生后，程序无法继续运行，我们就可以采用第三种策略：输出错误信息并结束程序。需要注意的是，这种策略只应在main中执行。对库函数而言，应仅向上传播错误，除非该错误意味着程序内部包含不一致性，即遇到了bug，才能在库函数中结束程序。</p>
</li>
<li><p>第四种策略：有时，我们只需要输出错误信息就足够了，不需要中断程序的运行。我们可以通过log包提供函数</p>
</li>
<li><p>第五种，也是最后一种策略：我们可以直接忽略掉错误。</p>
</li>
<li><p>在Go中，错误处理有一套独特的编码风格。检查某个子函数是否失败后，我们通常将处理失败的逻辑代码放在处理成功的代码之前。如果某个错误会导致函数返回，那么成功时的逻辑代码不应放在else语句块中，而应直接放在函数体中。Go中大部分函数的代码结构几乎相同，首先是一系列的初始检查，防止错误发生，之后是函数的实际逻辑。</p>
</li>
<li><p>函数经常会返回多种错误，这对终端用户来说可能会很有趣，但对程序而言，这使得情况变得复杂。很多时候，程序必须根据错误类型，作出不同的响应。让我们考虑这样一个例子：从文件中读取n个字节。如果n等于文件的长度，读取过程的任何错误都表示失败。如果n小于文件的长度，调用者会重复的读取固定大小的数据直到文件结束。这会导致调用者必须分别处理由文件结束引起的各种错误。基于这样的原因，io包保证任何由文件结束引起的读取失败都返回同一个错误——io.EOF，该错误在io包中定义：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> io</span><br><span class="line"><span class="keyword">import</span> <span class="string">"errors"</span></span><br><span class="line"><span class="comment">// EOF is the error returned by Read when no more input is available.</span></span><br><span class="line"><span class="keyword">var</span> EOF = errors.New(<span class="string">"EOF"</span>)</span><br><span class="line">in := bufio.NewReader(os.Stdin)</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">    r, _, err := in.ReadRune()</span><br><span class="line">    <span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line">        <span class="keyword">break</span> <span class="comment">// finished reading</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"read failed:%v"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// ...use r…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数被看作第一类值（first-class values）：函数像其他值一样，拥有类型，可以被赋值给其他变量，传递给函数，从函数返回。对函数值（function value）的调用类似函数调用。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">square</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> n * n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">negative</span><span class="params">(n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> -n &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">product</span><span class="params">(m, n <span class="keyword">int</span>)</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> m * n &#125;</span><br><span class="line">f := square</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// "9"</span></span><br><span class="line">f = negative</span><br><span class="line">fmt.Println(f(<span class="number">3</span>)) <span class="comment">// "-3"</span></span><br><span class="line">fmt.Printf(<span class="string">"%T\n"</span>, f) <span class="comment">// "func(int) int"</span></span><br><span class="line">f = product <span class="comment">// compile error: can't assign func(int, int) int to func(int) int</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数类型的零值是nil。调用值为nil的函数值会引起panic错误：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(3)</span> // 此处<span class="title">f</span>的值为<span class="title">nil</span>, 会引起<span class="title">panic</span>错误</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数值可以与nil比较：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> f <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">int</span>)</span> <span class="title">int</span></span></span><br><span class="line"><span class="function"><span class="title">if</span> <span class="title">f</span> != <span class="title">nil</span></span> &#123;</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>但是函数值之间是不可比较的，也不能用函数值作为map的key。</p>
</li>
<li><p>函数值使得我们不仅仅可以通过数据来参数化函数，亦可通过行为。标准库中包含许多这样的例子。下面的代码展示了如何使用这个技巧。strings.Map对字符串中的每个字符调用add1函数，并将每个add1函数的返回值组成一个新的字符串返回给调用者。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add1</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;</span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"HAL-9000"</span>)) <span class="comment">// "IBM.:111"</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"VMS"</span>)) <span class="comment">// "WNT"</span></span><br><span class="line">fmt.Println(strings.Map(add1, <span class="string">"Admix"</span>)) <span class="comment">// "Benjy"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>拥有函数名的函数只能在包级语法块中被声明，通过函数字面量（function literal），我们可绕过这一限制，在任何表达式中表示一个函数值。函数字面量的语法和函数声明相似，区别在于func关键字后没有函数名。函数值字面量是一种表达式，它的值被称为匿名函数（anonymous function）</p>
</li>
<li><p>函数字面量允许我们在使用函数时，再定义它。通过这种技巧，我们可以改写之前对strings.Map的调用：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">strings.Map(<span class="function"><span class="keyword">func</span><span class="params">(r <span class="keyword">rune</span>)</span> <span class="title">rune</span></span> &#123; <span class="keyword">return</span> r + <span class="number">1</span> &#125;, <span class="string">"HAL-9000"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>更为重要的是，通过这种方式定义的函数可以访问完整的词法环境（lexical environment），这意味着在函数中定义的内部函数可以引用该函数的变量，如下例所示</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// squares返回一个匿名函数。</span></span><br><span class="line"><span class="comment">// 该匿名函数每次被调用时都会返回下一个数的平方。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squares</span><span class="params">()</span> <span class="title">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x <span class="keyword">int</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="title">int</span></span> &#123;</span><br><span class="line">    x++</span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f := squares()</span><br><span class="line">    fmt.Println(f()) <span class="comment">// "1"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "4"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "9"</span></span><br><span class="line">    fmt.Println(f()) <span class="comment">// "16"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>squares的例子证明，函数值不仅仅是一串代码，还记录了状态。在squares中定义的匿名内部函数可以访问和更新squares中的局部变量，这意味着匿名函数和squares中，存在变量引用。这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。</p>
</li>
<li><p>变量的生命周期不由它的作用域决定：squares返回后，变量x仍然隐式的存在于f中。</p>
</li>
<li><p>当匿名函数需要被递归调用时，我们必须首先声明一个变量（在上面的例子中，我们首先声明了 visitAll），再将匿名函数赋值给这个变量。如果不分成两部，函数字面量无法与visitAll绑定，我们也无法递归调用该匿名函数。</p>
</li>
<li><p>参数数量可变的函数称为可变参数函数。典型的例子就是fmt.Printf和类似函数。Printf首先接收一个必备的参数，之后接收任意个数的后续参数。</p>
</li>
<li><p>你只需要在调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法。当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束。你可以在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</p>
</li>
<li><p>defer语句经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁。通过defer机制，不论函数逻辑多复杂，都能保证在任何执行路径下，资源被释放。释放资源的defer应该直接跟在请求资源的语句后。在下面的代码中，一条defer语句替代了之前的所有resp.Body.Close</p>
</li>
<li><p>defer</p>
<ul>
<li>调用普通函数或方法前加上关键字defer，就完成了defer所需要的语法</li>
<li>当执行到该条语句时，函数和参数表达式得到计算，但直到包含该defer语句的函数执行完毕时，defer后的函数才会被执行，不论包含defer语句的函数是通过return正常结束，还是由于panic导致的异常结束</li>
<li>在一个函数中执行多条defer语句，它们的执行顺序与声明顺序相反。</li>
<li>经常被用于处理成对的操作，如打开、关闭、连接、断开连接、加锁、释放锁</li>
</ul>
</li>
<li><p>调试复杂程序时，defer机制也常被用于记录何时进入和退出函数。</p>
</li>
<li><p>被延迟执行的匿名函数甚至可以修改函数返回给调用者的返回值：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">triple</span><span class="params">(x <span class="keyword">int</span>)</span> <span class="params">(result <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; result += x &#125;()</span><br><span class="line">    <span class="keyword">return</span> double(x)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(triple(<span class="number">4</span>)) <span class="comment">// "12"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>在循环体中的defer语句需要特别注意，因为只有在函数执行完毕后，这些被延迟的函数才会执行。下面的代码会导致系统的文件描述符耗尽，因为在所有文件都被处理之前，没有文件会被关闭。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> f.Close() <span class="comment">// <span class="doctag">NOTE:</span> risky; could run out of file descriptors</span></span><br><span class="line">    <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>一种解决方法是将循环体中的defer语句移至另外一个函数。在每次循环时，调用这个函数。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> _, filename := <span class="keyword">range</span> filenames &#123;</span><br><span class="line">    <span class="keyword">if</span> err := doFile(filename); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doFile</span><span class="params">(filename <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    f, err := os.Open(filename)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">defer</span> f.Close()</span><br><span class="line">     <span class="comment">// ...process f…</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Go的类型系统会在编译时捕获很多错误，但有些错误只能在运行时检查，如数组访问越界、空指针引用等。这些运行时错误会引起painc异常。</p>
</li>
<li><p>一般而言，当panic异常发生时，程序会中断运行，并立即执行在该goroutine</p>
</li>
<li><p>不是所有的panic异常都来自运行时，直接调用内置的panic函数也会引发panic异常；panic函数接受任何值作为参数。当某些不应该发生的场景发生时，我们就应该调用panic。比如，当程序到达了某条逻辑上不可能到达的路径：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> s := suit(drawCard()); s &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Spades"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Hearts"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Diamonds"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">case</span> <span class="string">"Clubs"</span>: <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="built_in">panic</span>(fmt.Sprintf(<span class="string">"invalid suit %q"</span>, s)) <span class="comment">// Joker?</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>由于panic会引起程序的崩溃，因此panic一般用于严重错误，如程序内部的逻辑不一致。勤奋的程序员认为任何崩溃都表明代码中存在漏洞，所以对于大部分漏洞，我们应该使用Go提供的错误机制，而不是panic，尽量避免程序的崩溃。在健壮的程序中，任何可以预料到的错误，如不正确的输入、错误的配置或是失败的I/O操作都应该被优雅的处理，最好的处理方式，就是使用Go的错误机制</p>
</li>
<li><p>为了方便诊断问题，runtime包允许程序员输出堆栈信息。在下面的例子中，我们通过在main函数中延迟调用printStack输出堆栈信息。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> printStack()</span><br><span class="line">    f(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printStack</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> buf [<span class="number">4096</span>]<span class="keyword">byte</span></span><br><span class="line">    n := runtime.Stack(buf[:], <span class="literal">false</span>)</span><br><span class="line">    os.Stdout.Write(buf[:n])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将panic机制类比其他语言异常机制的读者可能会惊讶，runtime.Stack为何能输出已经被释放函数的信息？在Go的panic机制中，延迟函数的调用在释放堆栈信息之前。</p>
</li>
<li><p>通常来说，不应该对panic异常做任何处理，但有时，也许我们可以从异常中恢复，至少我们可以在程序崩溃前，做一些操作。举个例子，当web服务器遇到不可预料的严重问题时，在崩溃前应该将所有的连接关闭；如果不做任何处理，会使得客户端一直处于等待状态。如果web服务器还在开发阶段，服务器甚至可以将异常信息反馈到客户端，帮助调试。</p>
</li>
<li><p>让我们以语言解析器为例，说明recover的使用场景。考虑到语言解析器的复杂性，即使某个语言解析器目前工作正常，也无法肯定它没有漏洞。因此，当某个异常出现时，我们不会选择让解析器崩溃，而是会将panic异常当作普通的解析错误，并附加额外信息提醒用户报告此错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Parse</span><span class="params">(input <span class="keyword">string</span>)</span> <span class="params">(s *Syntax, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> p := <span class="built_in">recover</span>(); p != <span class="literal">nil</span> &#123;</span><br><span class="line">            err = fmt.Errorf(<span class="string">"internal error: %v"</span>, p)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// ...parser...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不加区分的恢复所有的panic异常，不是可取的做法；因为在panic之后，无法保证包级变量的状态仍然和我们预期一致。比如，对数据结构的一次重要更新没有被完整完成、文件或者网络连接没有被关闭、获得的锁没有被释放。此外，如果写日志时产生的panic被不加区分的恢复，可能会导致漏洞被忽略。</p>
</li>
<li><p>虽然把对panic的处理都集中在一个包下，有助于简化对复杂和不可以预料问题的处理，但作为被广泛遵守的规范，你不应该试图去恢复其他包引起的panic。公有的API应该将函数的运行失败作为error返回，而不是panic。同样的，你也不应该恢复一个由他人开发的函数引起的panic，比如说调用者传入的回调函数，因为你无法确保这样做是安全的。</p>
</li>
<li><p>有时我们很难完全遵循规范，举个例子，net/http包中提供了一个web服务器，将收到的请求分发给用户提供的处理函数。很显然，我们不能因为某个处理函数引发的panic异常，杀掉整个进程；web服务器遇到处理函数导致的panic时会调用recover，输出堆栈信息，继续运行。这样的做法在实践中很便捷，但也会引起资源泄漏，或是因为recover操作，导致其他问题。</p>
</li>
<li><p>为了标识某个panic是否应该被恢复，我们可以将panic value设置成特殊类型。在recover时对panic value进行检查，如果发现panic value是特殊类型，就将这个panic作为errror处理，如果不是，则按照正常的panic进行处理（在下面的例子中，我们会看到这种方式）。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// soleTitle returns the text of the first non-empty title element</span></span><br><span class="line"><span class="comment">// in doc, and an error if there was not exactly one.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">soleTitle</span><span class="params">(doc *html.Node)</span> <span class="params">(title <span class="keyword">string</span>, err error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">type</span> bailout <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> p := <span class="built_in">recover</span>(); p &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="literal">nil</span>: <span class="comment">// no panic</span></span><br><span class="line">            <span class="keyword">case</span> bailout&#123;&#125;: <span class="comment">// "expected" panic</span></span><br><span class="line">                err = fmt.Errorf(<span class="string">"multiple title elements"</span>)</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="built_in">panic</span>(p) <span class="comment">// unexpected panic; carry on panicking</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;()</span><br><span class="line">     <span class="comment">// Bail out of recursion if we find more than one nonempty title.</span></span><br><span class="line">     forEachNode(doc, <span class="function"><span class="keyword">func</span><span class="params">(n *html.Node)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n.Type == html.ElementNode &amp;&amp; n.Data == <span class="string">"title"</span> &amp;&amp;</span><br><span class="line">        n.FirstChild != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> title != <span class="string">""</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(bailout&#123;&#125;) <span class="comment">// multiple titleelements</span></span><br><span class="line">        &#125;</span><br><span class="line">        title = n.FirstChild.Data</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;, <span class="literal">nil</span>)</span><br><span class="line">     <span class="keyword">if</span> title == <span class="string">""</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>, fmt.Errorf(<span class="string">"no title element"</span>)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> title, <span class="literal">nil</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="0x02、方法"><a href="#0x02、方法" class="headerlink" title="0x02、方法"></a>0x02、方法</h2><ul>
<li><p>一个对象其实也就是一个简单的值或者一个变量，在这个对象中会包含一些方法，而一个方法则是一个一个和特殊类型关联的函数。一个面向对象的程序会用方法来表达其属性和对应的操作，这样使用这个对象的用户就不需要直接去操作对象，而是借助方法来做这些事情。</p>
</li>
<li><p>在函数声明时，在其名字之前放上一个变量，即是一个方法。这个附加的参数会将该函数附加到这种类型上，即相当于为这种类型定义了一个独占的方法。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> geometry</span><br><span class="line"><span class="keyword">import</span> <span class="string">"math"</span></span><br><span class="line"><span class="keyword">type</span> Point <span class="keyword">struct</span>&#123; X, Y <span class="keyword">float64</span> &#125;</span><br><span class="line"><span class="comment">// traditional function</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distance</span><span class="params">(p, q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// same thing, but as a method of the Point type</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p Point)</span> <span class="title">Distance</span><span class="params">(q Point)</span> <span class="title">float64</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> math.Hypot(q.X-p.X, q.Y-p.Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Go语言中，我们并不会像其它语言那样用this或者self作为接收器；我们可以任意的选择接收器的名字。由于接收器的名字经常会被使用到，所以保持其在方法间传递时的一致性和简短性是不错的主意。这里的建议是可以使用其类型的第一个字母，比如这里使用了Point的首字母p。</p>
</li>
<li><p>在方法调用过程中，接收器参数一般会在方法名之前出现。这和方法声明是一样的，都是接收器参数在方法名字之前。下面是例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">q := Point&#123;<span class="number">4</span>, <span class="number">6</span>&#125;</span><br><span class="line">fmt.Println(Distance(p, q)) <span class="comment">// "5", function call</span></span><br><span class="line">fmt.Println(p.Distance(q)) <span class="comment">// "5", method call</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>这种p.Distance的表达式叫做选择器，因为他会选择合适的对应p这个对象的Distance方法来执行。选择器也会被用来选择一个struct类型的字段，比如p.X。由于方法和字段都是在同一命名空间，所以如果我们在这里声明一个X方法的话，编译器会报错，因为在调用p.X时会有歧义</p>
</li>
<li><p>在能够给任意类型定义方法这一点上，Go和很多其它的面向对象的语言不太一样。因此在Go语言里，我们为一些简单的数值、字符串、slice、map来定义一些附加行为很方便。我们可以给同一个包内的任意命名类型定义方法，只要这个命名类型的底层类型(译注：这个例子里，底层类型是指[]Point这个slice，Path就是命名类型)不是指针或者interface。</p>
</li>
<li><p>对于一个给定的类型，其内部的方法都必须有唯一的方法名，但是不同的类型却可以有同样的方法名，比如我们这里Point和Path就都有Distance这个名字的方法；所以我们没有必要非在方法名之前加类型名来消除歧义，比如PathDistance。这里我们已经看到了方法比之函数的一些好处：方法名可以简短。当我们在包外调用的时候这种好处就会被放大，因为我们可以使用这个短名字，而可以省略掉包的名字，下面是例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"gopl.io/ch6/geometry"</span></span><br><span class="line">perim := geometry.Path&#123;&#123;<span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">1</span>&#125;, &#123;<span class="number">5</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;</span><br><span class="line">fmt.Println(geometry.PathDistance(perim)) <span class="comment">// "12", standalone function</span></span><br><span class="line">fmt.Println(perim.Distance()) <span class="comment">// "12", method of geometry.Path</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>当调用一个函数时，会对其每一个参数值进行拷贝，如果一个函数需要更新一个变量，或者函数的其中一个参数实在太大我们希望能够避免进行这种默认的拷贝，这种情况下我们就需要用到指针了。对应到我们这里用来更新接收器的对象的方法，当这个接受者变量本身比较大时，我们就可以用其指针而不是对象来声明方法，如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Point)</span> <span class="title">ScaleBy</span><span class="params">(factor <span class="keyword">float64</span>)</span></span> &#123;</span><br><span class="line">    p.X *= factor</span><br><span class="line">    p.Y *= factor</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>这个方法的名字是(Point).ScaleBy。这里的括号是必须的；没有括号的话这个表达式可能会被理解为(Point.ScaleBy)。</p>
</li>
<li><p>在现实的程序里，一般会约定如果Point这个类有一个指针作为接收器的方法，那么所有Point的方法都必须有一个指针接收器，即使是那些并不需要这个指针接收器的函数。我们在这里打破了这个约定只是为了展示一下两种方法的异同而已</p>
</li>
<li><p>只有类型(Point)和指向他们的指针(*Point)，才可能是出现在接收器声明里的两种接收器。此外，为了避免歧义，在声明方法时，如果一个类型名本身是一个指针的话，是不允许其出现在接收器中的，比如下面这个例子：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> P *<span class="keyword">int</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(P)</span> <span class="title">f</span><span class="params">()</span></span> &#123; <span class="comment">/* ... */</span> &#125; <span class="comment">// compile error: invalid receiver type</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>想要调用指针类型方法(*Point).ScaleBy，只要提供一个Point类型的指针即可，像下面这样。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">r := &amp;Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">r.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(*r) <span class="comment">// "&#123;2, 4&#125;"</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">pptr := &amp;p</span><br><span class="line">pptr.ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line">p := Point&#123;<span class="number">1</span>, <span class="number">2</span>&#125;</span><br><span class="line">(&amp;p).ScaleBy(<span class="number">2</span>)</span><br><span class="line">fmt.Println(p) <span class="comment">// "&#123;2, 4&#125;"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>编译器会隐式地帮我们用&amp;p去调用ScaleBy这个方法。这种简写方法只适用于“变量”，包括struct里的字段比如p.X，以及array和slice内的元素比如perim[0]。我们不能通过一个无法取到地址的接收器来调用指针方法，比如临时变量的内存地址就无法获取得到：</p>
</li>
</ul>
<h2 id="0x03、接口"><a href="#0x03、接口" class="headerlink" title="0x03、接口"></a>0x03、接口</h2><ul>
<li><p>一个具体的类型可以准确的描述它所代表的值，并且展示出对类型本身的一些操作方式：就像数字类型的算术操作，切片类型的取下标、添加元素和范围获取操作。具体的类型还可以通过它的内置方法提供额外的行为操作。总的来说，当你拿到一个具体的类型时你就知道它的本身是什么和你可以用它来做什么。</p>
</li>
<li><p>接口类型是一种抽象的类型。它不会暴露出它所代表的对象的内部值的结构和这个对象支持的基础操作的集合；它们只会表现出它们自己的方法。也就是说当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么。</p>
</li>
<li><p>fmt.Printf，它会把结果写到标准输出，和fmt.Sprintf，它会把结果以字符串的形式返回。这两个函数都使用了另一个函数fmt.Fprintf来进行封装，fmt.Fprintf这个函数对它的计算结果会被怎么使用是完全不知道的。Fprintf函数可能没有假定写入的是一个文件或是一段内存，而是写入一个可以调用Write函数的值</p>
</li>
<li><p>因为fmt.Fprintf函数没有对具体操作的值做任何假设，而是仅仅通过io.Writer接口的约定来保证行为，所以第一个参数可以安全地传入一个只需要满足io.Writer接口的任意具体类型的值。一个类型可以自由地被另一个满足相同接口的类型替换，被称作可替换性(LSP里氏替换)。这是一个面向对象的特征。</p>
</li>
<li><p>一个类型如果拥有一个接口需要的所有方法，那么这个类型就实现了这个接口。接口指定的规则非常简单：表达一个类型属于某个接口只要这个类型实现这个接口</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 多实现的接口可以赋值给少实现的接口;但是反过来就不行</span></span><br><span class="line">w = rwc <span class="comment">// OK: io.ReadWriteCloser has Write method</span></span><br><span class="line">rwc = w <span class="comment">// compile error: io.Writer lacks Close method</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>抽象对于go来说是非常适合的，只有抽象的恰当，才是好语言。go的接口抽象的非常好。</p>
</li>
<li><p>每一个具体类型的组基于它们相同的行为可以表示成一个接口类型。不像基于类的语言，他们一个类实现的接口集合需要进行显式的定义，在Go语言中我们可以在需要的时候定义一个新的抽象或者特定特点的组，而不需要修改具体类型的定义。当具体的类型来自不同的作者时这种方式会特别有用。当然也确实没有必要在具体的类型中指出这些共性。</p>
</li>
<li><p>一个不包含任何值的nil接口值和一个刚好包含nil指针的接口值是不同的。这个细微区别产生了一个容易绊倒每个Go程序员的陷阱。</p>
</li>
<li><p>在进行框架该进行，go的接口抽象特别重要</p>
</li>
<li><p>你可以使用导出机制(§6.6)来限制一个类型的方法或一个结构体的字段是否在包外可见。接口只有当有两个或两个以上的具体类型必须以相同的方式进行处理时才需要。</p>
</li>
<li><p>当一个接口只被一个单一的具体类型实现时有一个例外，就是由于它的依赖，这个具体类型不能和这个接口存在在一个相同的包中。这种情况下，一个接口是解耦这两个包的一个好方式。</p>
</li>
<li><p>interface是一组method的组合，我们通过interface来定义对象的一组行为。</p>
</li>
<li><p>interface类型定义了一组方法，如果某个对象实现了某个接口的所有方法，则此对象就实现了此接口</p>
</li>
<li><p>空interface(interface{})不包含任何的method，正因为如此，所有的类型都实现了空interface。空interface对于描述起不到任何的作用(因为它不包含任何的method），但是空interface在我们需要存储任意类型的数值的时候相当有用，因为它可以存储任意类型的数值。它有点类似于C语言的void*类型。</p>
</li>
<li><p>一个函数把interface{}作为参数，那么他可以接受任意类型的值作为参数，如果一个函数返回interface{},那么也就可以返回任意类型的值。</p>
</li>
<li><p>反射就是能检查程序在运行时的状态</p>
</li>
<li><p>接口相当于是一份契约，它规定了一个对象所能提供的一组操作</p>
</li>
</ul>
<h2 id="0x04、并发"><a href="#0x04、并发" class="headerlink" title="0x04、并发"></a>0x04、并发</h2><ul>
<li><p>两种手段来实现，goroutine和channe</p>
</li>
<li><p>当一个程序启动时，其主函数即在一个单独的goroutine中运行，我们叫它main goroutine。新的goroutine会用go语句来创建。在语法上，go语句是一个普通的函数或方法调用前加上关键字go。go语句会使其语句中的函数在一个新创建的goroutine中运行。而go语句本身会迅速地完成。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">f() <span class="comment">// call f(); wait for it to return</span></span><br><span class="line"><span class="keyword">go</span> f() <span class="comment">// create a new goroutine that calls f(); don't wait</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>主函数返回时，所有的goroutine都会被直接打断，程序退出</p>
</li>
<li><p>除了从主函数退出或者直接终止程序之外，没有其它的编程方法能够让一个goroutine来打断另一个的执行，但是之后可以看到一种方式来实现这个目的，通过goroutine之间的通信来让一个goroutine请求其它的goroutine，并让被请求的goroutine自行结束执行。</p>
</li>
<li><p>如果说goroutine是Go语言程序的并发体的话，那么channels则是它们之间的通信机制。一个channel是一个通信机制，它可以让一个goroutine通过它给另一个goroutine发送值信息。每个channel都有一个特殊的类型，也就是channels可发送数据的类型。一个可以发送int类型数据的channel一般写为chan int。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// ch has type 'chan int'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个channel有发送和接受两个主要操作，都是通信行为。一个发送语句将一个值从一个goroutine通过channel发送到另一个执行接收操作的goroutine。发送和接收两个操作都使用&lt;-运算符。在发送语句中，&lt;-运算符分割channel和要发送的值。在接收语句中，&lt;-运算符写在channel对象之前。一个不使用接收结果的接收操作也是合法的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch &lt;- x <span class="comment">// a send statement</span></span><br><span class="line">x = &lt;-ch <span class="comment">// a receive expression in an assignment statement</span></span><br><span class="line">&lt;-ch <span class="comment">// a receive statement; result is discarded</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Channel还支持close操作，用于关闭channel，随后对基于该channel的任何发送操作都将导致panic异常。对一个已经被close过的channel进行接收操作依然可以接受到之前已经成功发送的数据；如果channel中已经没有数据的话将产生一个零值的数据。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">\\ 使用内置的<span class="built_in">close</span>函数就可以关闭一个channel：</span><br><span class="line"><span class="built_in">close</span>(ch)</span><br></pre></td></tr></table></figure>
</li>
<li><p>以最简单方式调用make函数创建的是一个无缓存的channel，但是我们也可以指定第二个整型参数，对应channel的容量。如果channel的容量大于零，那么该channel就是带缓存的channel。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">0</span>) <span class="comment">// unbuffered channel</span></span><br><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, <span class="number">3</span>) <span class="comment">// buffered channel with capacity 3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>一个基于无缓存Channels的发送操作将导致发送者goroutine阻塞，直到另一个goroutine在相同的Channels上执行接收操作，当发送的值通过Channels成功传输之后，两个goroutine可以继续执行后面的语句。反之，如果接收操作先发生，那么接收者goroutine也将阻塞，直到有另一个goroutine在相同的Channels上执行发送操作。基于无缓存Channels的发送和接收操作将导致两个goroutine做一次同步操作</p>
</li>
</ul>
<ol>
<li>在讨论并发编程时，当我们说x事件在y事件之前发生（happens before），我们并不是说x事件在时间上比y时间更早；我们要表达的意思是要保证在此之前的事件都已经完成了，例如在此之前的更新某些变量的操作已经完成，你可以放心依赖这些已完成的事件了。</li>
<li>当我们说x事件既不是在y事件之前发生也不是在y事件之后发生，我们就说x事件和y事件是并发的。这并不是意味着x事件和y事件就一定是同时发生的，我们只是不能确定这两个事件发生的先后顺序。在下一章中我们将看到，当两个goroutine并发访问了相同的变量时，我们有必要保证某些事件的执行顺序，以避免出现某些并发问题。</li>
</ol>
<ul>
<li><p>首先每个消息都有一个值，但是有时候通讯的事实和发生的时刻也同样重要。当我们更希望强调通讯发生的时刻时，我们将它称为消息事件。有些消息事件并不携带额外的信息，它仅仅是用作两个goroutine之间的同步，这时候我们可以用struct{}空结构体作为channels元素的类型，虽然也可以使用bool或int类型实现同样的功能，done &lt;- 1语句也比done &lt;- struct{}{}更短。</p>
</li>
<li><p>Channels也可以用于将多个goroutine连接在一起，一个Channel的输出作为下一个Channel的输入。这种串联的Channels就是所谓的管道（pipeline）</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="comment">// Counter</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> x := <span class="number">0</span>; ; x++ &#123;</span><br><span class="line">            naturals &lt;- x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Squarer</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> &#123;</span><br><span class="line">            x := &lt;-naturals</span><br><span class="line">            squares &lt;- x * x</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;()</span><br><span class="line">    <span class="comment">// Printer (in main goroutine)</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        fmt.Println(&lt;-squares)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>类型chan&lt;- int表示一个只发送int的channel，只能发送不能接收。相反，类型&lt;-chan int表示一个只接收int的channel，只能接收不能发送。（箭头&lt;-和关键字chan的相对位置表明了channel的方向。）这种限制将在编译期检测。</p>
</li>
<li><p>因为关闭操作只用于断言不再向channel发送新的数据，所以只有在发送者所在的goroutine才会调用close函数，因此对一个只接收的channel调用close将是一个编译错误。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">counter</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> x := <span class="number">0</span>; x &lt; <span class="number">100</span>; x++ &#123;</span><br><span class="line">        out &lt;- x</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">squarer</span><span class="params">(out <span class="keyword">chan</span>&lt;- <span class="keyword">int</span>, in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        out &lt;- v * v</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(out)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printer</span><span class="params">(in &lt;-<span class="keyword">chan</span> <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> v := <span class="keyword">range</span> in &#123;</span><br><span class="line">        fmt.Println(v)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    naturals := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    squares := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>)</span><br><span class="line">    <span class="keyword">go</span> counter(naturals)</span><br><span class="line">    <span class="keyword">go</span> squarer(squares, naturals)</span><br><span class="line">    printer(squares)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>带缓存的Channel内部持有一个元素队列。队列的最大容量是在调用make函数创建channel时通过第二个参数指定的。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>, <span class="number">3</span>)</span><br><span class="line">fmt.Println(<span class="built_in">cap</span>(ch)) <span class="comment">// "3"</span></span><br><span class="line">fmt.Println(<span class="built_in">len</span>(ch)) <span class="comment">// "2" 有效元素数</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>向缓存Channel的发送操作就是向内部缓存队列的尾部插入元素，接收操作则是从队列的头部删除元素。如果内部缓存队列是满的，那么发送操作将阻塞直到因另一个goroutine执行接收操作而释放了新的队列空间。相反，如果channel是空的，接收操作将阻塞直到有另一个goroutine执行发送操作而向队列插入元素。</p>
</li>
<li><p>Go语言新手有时候会将一个带缓存的channel当作同一个goroutine中的队列使用，虽然语法看似简单，但实际上这是一个错误。Channel和goroutine的调度器机制是紧密相连的，如果没有其他goroutine从channel接收，发送者——或许是整个程序——将会面临永远阻塞的风险。如果你只是需要一个简单的队列，使用slice就可以了</p>
</li>
<li><p>如果我们使用了无缓存的channel，那么两个慢的goroutines将会因为没有人接收而被永远卡住。这种情况，称为goroutines泄漏，这将是一个BUG。和垃圾变量不同，泄漏的goroutines并不会被自动回收，因此确保每个不再需要的goroutine能正常退出是重要的。</p>
</li>
<li><p>关于无缓存或带缓存channels之间的选择，或者是带缓存channels的容量大小的选择，都可能影响程序的正确性。无缓存channel更强地保证了每个发送操作与相应的同步接收操作；但是对于带缓存channel，这些操作是解耦的。同样，即使我们知道将要发送到一个channel的信息的数量上限，创建一个对应容量大小的带缓存channel也是不现实的，因为这要求在执行任何接收操作之前缓存所有已经发送的值。如果未能分配足够的缓存将导致程序死锁。</p>
</li>
<li><p>另一方面，如果生产线的前期阶段一直快于后续阶段，那么它们之间的缓存在大部分时间都将是满的。相反，如果后续阶段比前期阶段更快，那么它们之间的缓存在大部分时间都将是空的。对于这类场景，额外的缓存并没有带来任何好处。</p>
</li>
<li><p>一个只能为1和0的信号量叫做二元信号量(binary semaphore)。</p>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>python常用库</title>
    <url>/man/python/lib.html</url>
    <content><![CDATA[<h2 id="random"><a href="#random" class="headerlink" title="random"></a>random</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">random.random()</span><br><span class="line"></span><br><span class="line">random.randrange(<span class="number">0</span>, <span class="number">101</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">random.uniform(<span class="number">2.5</span>, <span class="number">10.0</span>)</span><br><span class="line"></span><br><span class="line">random.choice()</span><br><span class="line"></span><br><span class="line">random.shuffle()</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>python基础</title>
    <url>/man/python/basic.html</url>
    <content><![CDATA[<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul>
<li>大小写转化<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">str = <span class="string">"www.abc.com"</span></span><br><span class="line">print(str.upper())          <span class="comment"># 把所有字符中的小写字母转换成大写字母</span></span><br><span class="line">print(str.lower())          <span class="comment"># 把所有字符中的大写字母转换成小写字母</span></span><br><span class="line">print(str.capitalize())     <span class="comment"># 把第一个字母转化为大写字母，其余小写</span></span><br><span class="line">print(str.title())          <span class="comment"># 把每个单词的第一个字母转化为大写，其余小写</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul>
<li>round<ul>
<li>保留几位小数<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">round(<span class="number">1.245</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 1.24</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>《深入分布式缓存:从原理到实践》读书笔记</title>
    <url>/books/deep-analysis-distributed-cache.html</url>
    <content><![CDATA[<h2 id="第1章-缓存为王"><a href="#第1章-缓存为王" class="headerlink" title="第1章 缓存为王"></a>第1章 缓存为王</h2><h3 id="1-1-什么是缓存？"><a href="#1-1-什么是缓存？" class="headerlink" title="1.1 什么是缓存？"></a>1.1 什么是缓存？</h3><p>我们平时在编程的时候，接触到的都是虚拟地址而不是真实的物理地址，这是虚拟内存的主要功能之一。假如请求一个页的地址，需要将页的虚拟地址转化为页的物理地址。页表（pagetable）和内存管理单元（MMU）就负责将页的虚拟地址映射到物理地址。页表负责记录哪些是物理页，哪些是虚拟页，以及这些页的页表条目（PTE）。而MMU是一个物理硬件，MMU负责进行虚拟地址到物理地址的翻译，翻译过程中需要从页表获取页的PTE, MMU也会使用翻译后备缓存器（TLB）的缓存页号。可见，在操作系统层面都有缓存。</p>
<ul>
<li>根据在软件系统中所处位置的不同，缓存大体可以分为三类：<ul>
<li>客户端缓存；</li>
<li>服务端缓存；</li>
<li>网络中的缓存。</li>
</ul>
</li>
<li>根据规模和部署方式缓存也可以分为：<ul>
<li>单体缓存；</li>
<li>缓存集群；</li>
<li>分布式缓存。</li>
</ul>
</li>
</ul>
<h3 id="1-2-为什么使用缓存？"><a href="#1-2-为什么使用缓存？" class="headerlink" title="1.2 为什么使用缓存？"></a>1.2 为什么使用缓存？</h3><blockquote>
<p> 关于系统的性能</p>
</blockquote>
<ul>
<li>系统性能的指标一般包括响应时间、延迟时间、吞吐量，并发用户数和资源利用率等几个方面。<ul>
<li>响应时间是指系统对用户请求做出响应的时间</li>
<li>吞吐量是指系统在单位时间内处理请求的数量。</li>
<li>并发用户数是指系统可以同时承载的正常使用系统功能的用户数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。而资源利用率反映的是在一段时间内资源平均被占用的情况。</li>
</ul>
</li>
</ul>
<p>从浏览器到网络，再到应用服务器，甚至到数据库，通过在各个层面应用缓存技术，整个系统的性能将大幅提高</p>
<p>使用缓存技术，可以降低系统的响应时间，减少网络传输时间和应用延迟时间，进而提高了系统的吞吐量，增加了系统的并发用户数。</p>
<h3 id="1-3-从网站的架构发展看缓存"><a href="#1-3-从网站的架构发展看缓存" class="headerlink" title="1.3 从网站的架构发展看缓存"></a>1.3 从网站的架构发展看缓存</h3><p><img data-src="assets/img/dadc/web-architecture.png" alt="架构图"></p>
<h3 id="1-4-客户端缓存"><a href="#1-4-客户端缓存" class="headerlink" title="1.4 客户端缓存"></a>1.4 客户端缓存</h3><h4 id="1-4-1-页面缓存"><a href="#1-4-1-页面缓存" class="headerlink" title="1.4.1 页面缓存"></a>1.4.1 页面缓存</h4><p>页面缓存有两层含义：一个是页面自身对某些元素或全部元素进行缓存；另一层意思是服务端将静态页面或动态页面的元素进行缓存，然后给客户端使用。</p>
<p>HTML5中使用本地缓存的方法也很简单，示例代码如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">localStorage.setItem()</span><br><span class="line">localStorage.getItem()</span><br></pre></td></tr></table></figure>

<p>HTML5提供的离线应用缓存机制，使得网页应用可以离线使用，这种机制在浏览器上支持度非常广，可以放心地使用该特性来加速页面的访问。开启离线缓存的步骤如下：</p>
<ul>
<li>1）准备用于描述页面需要缓存的资源列表清单文件（manifest text/cache-manifest）。</li>
<li>2）在需要离线使用的页面中添加manifest属性，指定缓存清单文件的路径。</li>
</ul>
<h4 id="1-4-2-浏览器缓存"><a href="#1-4-2-浏览器缓存" class="headerlink" title="1.4.2 浏览器缓存"></a>1.4.2 浏览器缓存</h4><p>浏览器缓存是根据一套与服务器约定的规则进行工作的，工作规则很简单：检查以确保副本是最新的，通常只要一次会话。</p>
<p>HTTP1.0提供了一些很基本的缓存特性。服务器侧设置Expires的HTTP头来告诉客户端在重新请求文件之前缓存多久是安全的，可以通过if-modified-since的条件请求来使用缓存。其中，发送的时间是文件最初被下载的时间，而不是即将过期的时间，如果文件没有改变，服务器可以用304-Not Modified来应答。客户端收到304代码，就可以使用缓存的文件版本了。</p>
<p>HTTP 1.1有了较大的增强，缓存系统被形式化了，引入了实体标签e-tag。e-tag是文件或对象的唯一标识，这意味着可以请求一个资源，以及提供所持有的文件，然后询问服务器这个文件是否有变化。如果某一个文件的e-tag是有效的，那么服务器会生成304-Not Modified应答，并提供正确文件的e-tag，否则，发送200-OK应答</p>
<p>Last-Modified/ETag与Cache-Control/Expires的作用是不一样的，如果检测到本地的缓存还在有效的时间范围内，浏览器则直接使用本地缓存，不会发送任何请求。两者一起使用时，Cache-Control/Expires的优先级要高于Last-Modified/ETag。即当本地副本根据Cache-Control/Expires发现还在有效期内时，则不会再次发送请求去服务器询问修改时间（Last-Modified）或实体标识（e-tag）了。</p>
<p>Cache-Control与Expires的功能一致，都是指明当前资源的有效期，控制浏览器是直接从浏览器缓存取数据还是重新发请求到服务器取数据。只不过Cache-Control的选择更多，设置更细致，如果同时设置的话，其优先级高于Expires。</p>
<p>一般情况下，使用Cache-Control/Expires会配合Last-Modified/ETag一起使用，因为即使服务器设置缓存时间，当用户点击“刷新”按钮时，浏览器会忽略缓存继续向服务器发送请求，这时Last-Modified/ETag将能够很好利用服务端的返回码304，从而减少响应开销。</p>
<h4 id="1-4-3-APP上的缓存"><a href="#1-4-3-APP上的缓存" class="headerlink" title="1.4.3 APP上的缓存"></a>1.4.3 APP上的缓存</h4><p>APP可以将内容缓存在内存、文件或本地数据库（例如SQLite）中，但基于内存的缓存要谨慎使用。</p>
<h3 id="1-5-网络中的缓存"><a href="#1-5-网络中的缓存" class="headerlink" title="1.5 网络中的缓存"></a>1.5 网络中的缓存</h3><p>网络中的缓存位于客户端和服务端之间，代理或响应客户端的网络请求，从而对重复的请求返回缓存中的数据资源。同时，接受服务端的请求，更新缓存中的内容。</p>
<h4 id="1-5-1-Web代理缓存"><a href="#1-5-1-Web代理缓存" class="headerlink" title="1.5.1 Web代理缓存"></a>1.5.1 Web代理缓存</h4><p>Web代理几乎是伴随着互联网诞生的，常用的Web代理分为正向代理、反向代理和透明代理。Web代理缓存是将Web代理作为缓存的一种技术。</p>
<p>反向代理与正向代理相反，对于客户端而言代理服务器就像是源服务器，并且客户端不需要进行设置。客户端向反向代理发送普通请求，接着反向代理将判断向何处转发请求，并将从源服务器获得的内容返回给客户端。</p>
<p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，由代理服务器改变客户端请求的报文字段，并会传送真实的IP地址。<br>加密的透明代理属于匿名代理，不用设置就可以使用代理了。透明代理的例子就是时下很多公司使用的行为管理软件。</p>
<p>对于Web代理缓存而言，较流行的是Squid，它支持建立复杂的缓存层级结构，拥有详细的日志、高性能缓存以及用户认证支持</p>
<h4 id="1-5-2-边缘缓存"><a href="#1-5-2-边缘缓存" class="headerlink" title="1.5.2 边缘缓存"></a>1.5.2 边缘缓存</h4><p>如果这些反向代理服务器能够做到和用户来自同一个网络，那么用户访问反向代理服务器，就会得到很高质量的响应速度，所以可以将这样的反向代理缓存称为边缘缓存。</p>
<p>边缘缓存在网络上位于靠近用户的一侧，可以处理来自不同用户的请求，主要用于向用户提供静态的内容，以减少应用服务器的介入</p>
<p>边缘缓存中典型的商业化服务就是CDN了</p>
<p>CDN边缘节点的缓存策略因服务商不同而有所变化，但一般都会遵循HTTP标准协议，通过HTTP响应头中的Cache-control: max-age的字段来设置CDN边缘节点的数据缓存时间</p>
<p>一般地，CDN边缘节点对开发者来说是透明的，开发者可以通过CDN服务商提供的“刷新缓存”接口来清理位于CDN边缘节点上的缓存数据</p>
<h3 id="1-6-服务端缓存"><a href="#1-6-服务端缓存" class="headerlink" title="1.6 服务端缓存"></a>1.6 服务端缓存</h3><h4 id="1-6-1-数据库缓存"><a href="#1-6-1-数据库缓存" class="headerlink" title="1.6.1 数据库缓存"></a>1.6.1 数据库缓存</h4><p>数据库缓存是一类特殊的缓存，是数据库自身的缓存机制。</p>
<p>大多数数据库不需要配置就可以快速运行，但并没有为特定的需求进行优化。在数据库调优的时候，缓存优化是一项很重要的工作。</p>
<blockquote>
<ol>
<li>MySQL的查询缓存</li>
</ol>
</blockquote>
<p>Query cache作用于整个MySQL实例，主要用于缓存MySQL中的ResultSet，也就是一条SQL语句执行的结果集，所以仅仅只能针对select语句。</p>
<ul>
<li>Query Cache的使用需要多个参数配合，其中最为关键的是query_cache_size和query_cache_type，前者设置用于缓存ResultSet的内存大小，后者设置在何种场景下使用Query Cache。这可以通过计算Query Cache的命中率来进行调整。query_cache_type可以设置为0（OFF）,1（ON）或者2（DEMAND），分别表示完全不使用Query Cache，除显式要求不使用Query Cache之外的所有select都使用Query Cache，以及只有显式要求才使用Query Cache。</li>
</ul>
<blockquote>
<p>2．检验Query Cache的合理性</p>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">variables</span> <span class="keyword">like</span> <span class="string">'%query_cache%'</span>;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">status</span> <span class="keyword">like</span> <span class="string">'Qcache%'</span>;</span><br></pre></td></tr></table></figure>

<p>通过调节以下几个参数可以知道query_cache_size设置得是否合理：</p>
<ul>
<li>Qcache inserts</li>
<li>Qcache hits<ul>
<li>如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓存；</li>
</ul>
</li>
<li>Qcache lowmem prunes<ul>
<li>如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况</li>
</ul>
</li>
<li>Qcache free blocks<ul>
<li>Qcache_free_blocks值非常大，则表明缓存区中的碎片很多，可能需要寻找合适的机会进行整理。</li>
</ul>
</li>
</ul>
<p>其中Qcache_hits表示多少次命中，通过这个参数我们可以查看到Query Cache的基本效果；而Qcache_inserts表示多少次未命中然后插入。通过“Qcache_hits”和“Qcache_inserts”两个参数可以算出Query Cache的命中率：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Query Cache 命中率=Qcache_hits/(Qcache_hits + Qcache_inserts)</span><br></pre></td></tr></table></figure>

<p>Qcache_lowmem_prunes表示多少条Query因为内存不足而被清除出Query Cache。通过Qcache_lowmem_prunes和Qcache_free_memory相互结合，能够更清楚地了解到系统中Query Cache的内存大小是否真的足够，是否频繁的出现因为内存不足而有Query被换出的情况。</p>
<blockquote>
<ol start="3">
<li>InnoDB的缓存性能</li>
</ol>
</blockquote>
<p>当使用InnoDB存储引擎的时候，innodb_buffer_pool_size参数可能是影响性能的最为关键的一个参数了，用来设置用于缓存InnoDB索引及数据块的内存区域大小，更像是Oracle数据库的db_cache_size</p>
<p>可以通过<code>(Innodb_buffer_pool_read_requests - Innodb_buffer_pool_reads) /Innodb_buffer_pool_read_requests*100%</code>计算缓存命中率，并根据命中率来调整<code>innodb_buffer_pool_size</code>参数大小进行优化</p>
<p>table_cache是一个非常重要的MySQL性能参数，主要用于设置table高速缓存的数量。由于每个客户端连接都会至少访问一个表，因此该参数与max_connections有关。</p>
<p>在执行缓存操作之前，table_cache参数用于限制缓存表的最大数目：如果当前已经缓存的表未达到table_cache数目，则会将新表添加进来；若已经达到此值，MySQL将根据缓存表的最后查询时间、查询率等规则释放之前的缓存。</p>
<h4 id="1-6-2-平台级缓存"><a href="#1-6-2-平台级缓存" class="headerlink" title="1.6.2 平台级缓存"></a>1.6.2 平台级缓存</h4><p>平台级缓存在这里指的是用来写带有缓存特性的应用框架，或者可用于缓存功能的专用库（如PHP中的Smarty模板库）。</p>
<p>在Java语言中，缓存框架更多，例如Ehcache, Cacheonix, Voldemort, JBoss Cache,OSCache等等。</p>
<h4 id="1-6-3-应用级缓存"><a href="#1-6-3-应用级缓存" class="headerlink" title="1.6.3 应用级缓存"></a>1.6.3 应用级缓存</h4><p>应用级缓存，需要开发者通过代码来实现缓存机制。这里是NoSQL的胜场，不论是Redis还是MongoDB，以及Memcached都可以作为应用级缓存的重要技术。一种典型的方式是每分钟或一段时间后统一生成某类页面存储在缓存中，或者可以在热数据变化时更新缓存。</p>
<blockquote>
<p>1．面向Redis的缓存应用</p>
</blockquote>
<p>Redis集群采用无中心节点方式实现，无需proxy代理，客户端直接与Redis集群的每个节点连接，根据同样的哈希算法计算出key对应的slot，然后直接在slot对应的Redis上执行命令。在Redis看来，响应时间是最苛刻的条件，增加一层带来的开销是不能接受的。因此，Redis实现了客户端对节点的直接访问，为了去中心化，节点之间通过Gossip协议交换相互的状态，以及探测新加入的节点信息</p>
<p>所有的Redis节点通过PING-PONG机制彼此互联，内部使用二进制协议优化传输速度和带宽。节点故障是通过集群中超过半数的节点检测失效时才会生效。</p>
<blockquote>
<p>2．多级缓存实例</p>
</blockquote>
<p>多级缓存示例<br><img data-src="assets/img/dadc/mulit_level_cache.png" alt="多级缓存"></p>
<blockquote>
<p>3．缓存算法</p>
</blockquote>
<p>在实现缓存应用的时候，需要了解缓存技术中的几个术语。</p>
<ul>
<li>缓存命中：当客户发起一个请求时，系统接收到这个请求，如果该请求的数据是在缓存中，这一数据就会被使用，这一行为叫作缓存命中。</li>
<li>没有命中：cache miss是没有命中。如果缓存中还有存储空间，那么没有命中的对象会被存储到缓存中来。</li>
<li>存储成本：当没有缓存命中时，系统会从数据库或其他数据源取出数据，然后放入缓存。而把这个数据放入缓存所需要的时间和空间，就是存储成本。</li>
<li>缓存失效：当存储在缓存中的数据需要更新时，就意味着缓存中的这一数据失效了。❑ 替代策略：当缓存没有命中时，并且缓存容量已经满了，就需要在缓存中去除一条旧数据，然后加入一条新数据，而到底应该去除哪些数据，就是由替代策略决定的。</li>
</ul>
<p>替代策略的具体实现就是缓存算法，这里简要介绍一下主流的缓存算法：</p>
<ul>
<li>（1）Least-Recently-Used（LRU）<ul>
<li>替换掉最近被请求最少的对象，这种传统策略在实际中应用最广。</li>
<li>在CPU缓存淘汰和虚拟内存系统中效果很好。然而在直接应用与代理缓存中效果欠佳，因为Web访问的时间局部性常常变化很大。</li>
<li>浏览器就一般使用了LRU作为缓存算法。新的对象会被放在缓存的顶部，</li>
</ul>
</li>
<li>（2）Least-Frequently-Used（LFU）<ul>
<li>替换掉访问次数最少的缓存，这一策略意图是保留最常用的、最流行的对象，替换掉很少使用的那些数据。</li>
</ul>
</li>
<li>（3）Least Recently Used 2（LRU2）<ul>
<li>LRU的变种，把被两次访问过的对象放入缓存池，当缓存池满了之后，会把有两次最少使用的缓存对象去除。因为需要跟踪对象2次，访问负载就会随着缓存池的增加而增加。</li>
</ul>
</li>
<li>（4）Two Queues（2Q）<ul>
<li>Two Queues是LRU的另一个变种，把被访问的数据放到LRU的缓存中，如果这个对象再一次被访问，就把他转移到第二个、更大的LRU缓存，使用了多级缓存的方式。去除缓存对象是为了保持第一个缓存池是第二个缓存池的1/3。当缓存的访问负载是固定的时候，把LRU换成LRU2，就比增加缓存的容量更好。</li>
</ul>
</li>
<li>（5）SIZE<ul>
<li>替换占用空间最大的对象，这一策略通过淘汰一个大对象而不是多个小对象来提高命中率。不过，可能有些进入缓存的小对象永远不会再被访问。SIZE策略没有提供淘汰这类对象的机制，也会导致“缓存污染”。</li>
</ul>
</li>
<li>（6）LRU-Threshold<ul>
<li>不缓存超过某一size的对象，其他与LRU相同。</li>
</ul>
</li>
<li>（7）Log(Size)+LRU<ul>
<li>替换size最大的对象，当size相同时，按LRU进行替换。</li>
</ul>
</li>
<li>（8）Hyper-G<ul>
<li>LFU的改进版，同时考虑上次访问时间和对象size。</li>
</ul>
</li>
<li>（9）Pitkow/Recker<ul>
<li>替换最近最少使用的对象，除非所有对象都是今天访问过的。如果是这样，则替换掉最大的对象。这一策略试图符合每日访问Web网页的特定模式。这一策略也被建议在每天结束时运行，以释放被“旧的”、最近最少使用的对象占用的空间。</li>
</ul>
</li>
<li>（10）Lowest-Latency-First<ul>
<li>替换下载时间最少的文档。显然它的目标是最小化平均延迟。</li>
</ul>
</li>
<li>（11）Hybrid Hybrid<ul>
<li>有一个目标是减少平均延迟。对缓存中的每个文档都会计算一个保留效用，保留效用最低的对象会被替换掉</li>
</ul>
</li>
<li>（12）Lowest Relative Value（LRV）<ul>
<li>LRV也是基于计算缓存中文档的保留效用，然后替换保留效用最低的文档。</li>
</ul>
</li>
<li>（13）Adaptive Replacement Cache（ARC）<ul>
<li>ARC介于LRU和LFU之间，为了提高效果，由2个LRU组成，第一个包含的条目是最近只被使用过一次的，而第二个LRU包含的是最近被使用过两次的条目，因此，得到了新的对象和常用的对象。ARC能够自我调节，并且是低负载的。</li>
</ul>
</li>
<li>（14）Most Recently Used（MRU）<ul>
<li>MRU与LRU是相对，移除最近最多被使用的对象。当一次访问过来的时候，有些事情是无法预测的，并且在缓存系统中找出最少最近使用的对象是一项时间复杂度非常高的运算，这时会考虑MRU，在数据库内存缓存中比较常见。</li>
</ul>
</li>
<li>（15）First in First out（FIFO）<ul>
<li>FIFO通过一个队列去跟踪所有的缓存对象，最近最常用的缓存对象放在后面，而更早的缓存对象放在前面，当缓存容量满时，排在前面的缓存对象会被踢走，然后把新的缓存对象加进去。</li>
</ul>
</li>
<li>（16）Random Cache<ul>
<li>随机缓存就是随意的替换缓存数据，比FIFO机制好，在某些情况下，甚至比LRU好，但是通常LRU都会比随机缓存更好些。</li>
</ul>
</li>
</ul>
<blockquote>
<p>4．使用公有云的缓存服务</p>
</blockquote>
<p>基于Redis的云存储服务</p>
<ul>
<li>动态扩容</li>
<li>数据多备</li>
<li>自动容灾</li>
<li>成本较低</li>
</ul>
<h2 id="第2章-分布式系统理论"><a href="#第2章-分布式系统理论" class="headerlink" title="第2章 分布式系统理论"></a>第2章 分布式系统理论</h2><p>分布式理论体系宏大精深，先从分布式系统理论，比如Paxos、分布式系统设计策略、心跳检测、分布式系统设计实践、全局ID生成几个方面讲。</p>
<h3 id="2-1-分布式系统概论"><a href="#2-1-分布式系统概论" class="headerlink" title="2.1 分布式系统概论"></a>2.1 分布式系统概论</h3><p>深入地讨论了以下几个方面：</p>
<ul>
<li>分布式程序设计语言：基本结构。</li>
<li>理论基础：全局状态和事件排序；逻辑时钟和物理时钟。</li>
<li>分布式操作系统：互斥和选举；死锁的检测和解决方法；自稳定；任务调度和负载平衡。</li>
<li>分布式通信：一对一通信；组（collective）通信。</li>
<li>可靠性：一致性；错误恢复；可靠通信。</li>
<li>分布式数据管理：复制数据的一致性；分布式并发控制。</li>
<li>应用：分布式操作系统；分布式文件系统；分布式数据库系统；分布式共享存储器；异型处理。</li>
</ul>
<p>综上所述，分布式系统是一个内涵极度丰富的领域，单就应用层次而言就涉及分布式缓存、分布式存储、分布式文件系统、分布式锁、分布式事务、分布式调度任务、分布式调度计算、分布式消息、分布式采集等等，</p>
<h3 id="2-2-分布式系统概念"><a href="#2-2-分布式系统概念" class="headerlink" title="2.2 分布式系统概念"></a>2.2 分布式系统概念</h3><h4 id="2-2-1-进程与线程"><a href="#2-2-1-进程与线程" class="headerlink" title="2.2.1 进程与线程"></a>2.2.1 进程与线程</h4><p>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。</p>
<p>线程是进程的一个实体，是CPU调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器、一组寄存器和栈），但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p>
<h4 id="2-2-2-并发"><a href="#2-2-2-并发" class="headerlink" title="2.2.2 并发"></a>2.2.2 并发</h4><p>当有多个线程在操作时，如果系统只有一个CPU，则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段，再将时间段分配给各个线程执行，在一个时间段的线程代码运行时，其他线程处于挂起状态。这种方式我们称之为并发（Concurrent）。</p>
<p>应用层的并发：定义为单位时间内对于共享资源的访问。</p>
<h4 id="2-2-3-锁"><a href="#2-2-3-锁" class="headerlink" title="2.2.3 锁"></a>2.2.3 锁</h4><p>锁（lock）作为用于保护临界区（critical section）的一种机制，被广泛应用在多线程程序中</p>
<p>减少或规避锁争用的几种策略：</p>
<ul>
<li>分拆锁；</li>
<li>分离锁；</li>
<li>避免共享变量缓存；</li>
<li>使用并发容器如Amino；</li>
<li>使用Immutable数据和ThreadLocal中的数据</li>
</ul>
<h4 id="2-2-4-并行"><a href="#2-2-4-并行" class="headerlink" title="2.2.4 并行"></a>2.2.4 并行</h4><p>当系统有一个以上的CPU时，则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行（Parallel）。</p>
<p>并发与并行的区别</p>
<ul>
<li>并行是指两个或者多个事件在同一时刻发生；</li>
<li>并发是指两个或多个事件在同一时间间隔内发生。</li>
</ul>
<h4 id="2-2-5-集群"><a href="#2-2-5-集群" class="headerlink" title="2.2.5 集群"></a>2.2.5 集群</h4><p>集群是一组相互独立的、通过高速网络互联的计算机，它们构成了一个组，并以单一系统的模式加以管理。</p>
<p>分布式系统可以表达为很多机器组成的集群，靠彼此之间的网络通信，担当的角色可能不同，共同完成同一件事情的系统</p>
<p>可以划分为以下几种类型：</p>
<ul>
<li>节点：系统中按照协议完成计算工作的一个逻辑实体，可能是执行某些工作的进程或机器。</li>
<li>网络：系统的数据传输通道，用来彼此通信。通信是具有方向性的。</li>
<li>存储：系统中持久化数据的数据库或者文件存储。</li>
</ul>
<p>根据典型的集群体系结构，集群中涉及的关键技术可以归属于四个层次：</p>
<ul>
<li>网络层：网络互联结构、通信协议、信号技术等。</li>
<li>节点机及操作系统层高性能客户机、分层或基于微内核的操作系统等。</li>
<li>集群系统管理层：资源管理、资源调度、负载平衡、并行IPO、安全等。</li>
<li>应用层：并行程序开发环境、串行应用、并行应用等</li>
</ul>
<h4 id="2-2-6-状态特性"><a href="#2-2-6-状态特性" class="headerlink" title="2.2.6 状态特性"></a>2.2.6 状态特性</h4><p>分布式环境中的任何节点（Node）也是无状态的。无状态是指不保存存储状态，则可以随意重启和替代，便于做扩展。</p>
<h4 id="2-2-7-系统重发与幂等性"><a href="#2-2-7-系统重发与幂等性" class="headerlink" title="2.2.7 系统重发与幂等性"></a>2.2.7 系统重发与幂等性</h4><p>系统重发示例<br><img data-src="assets/img/dadc/net-service-retry.jpeg" alt="系统重发"></p>
<p>所谓幂等性就是调用1次和调用N次要返回一样的结果。<br>比如一次转账动作，A账户转账1000到B账户，由于网络调用超时，客户端client基于上述保障成功率的原因发起了retry，那么最终应该转账1000还是2000呢，客户的意愿是1000。只需要在设计上加上调用订单号就可以规避这个问题，多次重发，调用的订单号一样，则在服务提供方内部只做一次真实转账动作就行了。</p>
<h4 id="2-2-8-硬件异常"><a href="#2-2-8-硬件异常" class="headerlink" title="2.2.8 硬件异常"></a>2.2.8 硬件异常</h4><blockquote>
<p>1．服务器宕机</p>
</blockquote>
<p>引发服务器宕机的原因可能是服务器停电、内存错误等等故障，换言之，服务器故障是大概率事件。</p>
<p>在分布式环境下，采用低廉的PC Server代替高大上的服务器已是常态。我们把宕机时不能提供服务的节点，称为不可用。</p>
<p>服务器宕机时，节点将丢失所有内部信息，因此设计时需要考虑存储系统的持久化，在重启系统后，可以进行相关存储内容的恢复</p>
<blockquote>
<p>2．网络异常</p>
</blockquote>
<p>网络异常的原因可能是消息丢失、网络包数据错误。</p>
<p>设计容错系统的一个方案是，任何消息只有收到对方回复才可以认为发送成功。</p>
<blockquote>
<p>3．磁盘故障</p>
</blockquote>
<p>在分布式环境中，需要把数据存储在多台服务器，一旦一台出现故障，也能从其他服务器恢复。</p>
<blockquote>
<p>4．机房级异常</p>
</blockquote>
<p>对容灾而言也有同城灾备和异地机房的做法。当发生机房级异常比如光纤出了问题，异地机房可以继续提供服务</p>
<h3 id="2-3-分布式系统理论"><a href="#2-3-分布式系统理论" class="headerlink" title="2.3 分布式系统理论"></a>2.3 分布式系统理论</h3><p>CAP理论提出了一致性、可用性、分区容忍性的取舍问题；<br>Paxos、Raft、2PC、3PC分别给出了一致性的解决方案；<br>Lease机制主要针对网络拥塞或瞬断的情况下，出现双主情况的解法；<br>Quorum NWR和MVCC主要解决分布式存储领域的一致性问题；<br>Gossip是一种去中心化、容错而又最终一致性的算法</p>
<h4 id="2-3-1-CAP理论"><a href="#2-3-1-CAP理论" class="headerlink" title="2.3.1 CAP理论"></a>2.3.1 CAP理论</h4><p>分布式系统的CAP理论：首先将分布式系统中的三个特性进行如下归纳：</p>
<ul>
<li>一致性（C）：在分布式系统中的所有数据备份，在同一时刻是否有同样的值。（等同于所有节点访问同一份最新的数据副本）</li>
<li>可用性（A）：在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li>
<li>分区容忍性（P）：以实际效果而言，分区相当于对通信的时限要求。系统如果不能在一定时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。</li>
</ul>
<blockquote>
<p>（1）CA without P</p>
</blockquote>
<p>如果不要求P（不允许分区），则C（强一致性）和A（可用性）是可以保证的。</p>
<p>CA的系统更多的是允许分区后各子系统依然保持CA。</p>
<p>典型放弃分区容忍性的例子有关系型数据库、LDAP等。</p>
<blockquote>
<p>（2）CP without A</p>
</blockquote>
<p>如果不要求A（可用性），相当于每个请求都需要在Server之间强一致，而P（分区）会导致同步时间无限延长，如此CP也是可以保证的</p>
<blockquote>
<p>（3）AP wihtout C</p>
</blockquote>
<p>要高可用并允许分区，则需放弃一致性。一旦分区发生，节点之间可能会失去联系，为了高可用，每个节点只能用本地数据提供服务，而这样会导致全局数据的不一致性</p>
<p>现在众多的NoSQL都属于此类</p>
<h4 id="2-3-3-Paxos"><a href="#2-3-3-Paxos" class="headerlink" title="2.3.3 Paxos"></a>2.3.3 Paxos</h4><blockquote>
<ol>
<li>Paxos是什么</li>
</ol>
</blockquote>
<p>一言以蔽之，Paxos协议是一个解决分布式系统中，多个节点之间就某个值（提案）达成一致（决议）的通信协议。它能够处理在少数节点离线的情况下，剩余的多数节点仍然能够达成一致。</p>
<blockquote>
<ol start="2">
<li>Paxos协议简介</li>
</ol>
</blockquote>
<p>Paxos协议是一个两阶段协议，分为Prepare阶段和Accept阶段</p>
<p>Proposer是提议提案的服务器，而Acceptor是批准提案的服务器。二者在物理上可以是同一台机器。</p>
<ul>
<li>Prepare阶段（1）Prepare阶段1:Proposer发送Prepare</li>
</ul>
<h4 id="2-3-4-2PC"><a href="#2-3-4-2PC" class="headerlink" title="2.3.4 2PC"></a>2.3.4 2PC</h4><p>在事务处理、关系型数据库及计算机网络中，2阶段提交协议（2PC）是一种典型的原子提交协议（atomic commitment protocol）。它是一种由协调器来处理分布式原子参与者是提交或者回滚事务的分布式算法。</p>
<p>该协议包括2个阶段：</p>
<ul>
<li>（1）提交请求阶段或者叫投票阶段该阶段的任务是确定相关参与者对于事务处理是否准备就绪，YES代表可以commit, NO则反之。</li>
<li>（2）提交阶段基于投票结果，由协调器决定提交事务抑或是退出事务处理；各事务参与者遵循指示，对本地事务资源做需要的动作。</li>
</ul>
<h4 id="2-3-5-3PC"><a href="#2-3-5-3PC" class="headerlink" title="2.3.5 3PC"></a>2.3.5 3PC</h4><p>第一阶段，投票，事务协调器询问参与者是否能提交（canCommit），都得到肯定回答后，继续第二阶段。<br>第二阶段是预提交，都确认预提交成功后，进行第三阶段。<br>第三阶段就是真实的提交，成功则完成事务；失败则继续重试</p>
<h4 id="2-3-6-Raft"><a href="#2-3-6-Raft" class="headerlink" title="2.3.6 Raft"></a>2.3.6 Raft</h4><p>在Raft中，任何时候一个服务器可以扮演下面角色之一：</p>
<ul>
<li>领导者：处理所有客户端交互、日志复制等动作，一般一次只有一个领导者。</li>
<li>选民：类似选民，完全被动的角色，这样的服务器等待被通知投票。</li>
<li>候选人：候选人就是在选举过程中提名自己的实体，一旦选举成功，则成为领导者。</li>
</ul>
<h4 id="2-3-7-Lease机制"><a href="#2-3-7-Lease机制" class="headerlink" title="2.3.7 Lease机制"></a>2.3.7 Lease机制</h4><p>Lease英文含义是“租期”、“承诺”</p>
<h4 id="2-3-8-解决“脑裂”问题"><a href="#2-3-8-解决“脑裂”问题" class="headerlink" title="2.3.8 解决“脑裂”问题"></a>2.3.8 解决“脑裂”问题</h4><p>主备是实现高可用的有效方式，但存在一个脑裂问题。脑裂（split-brain），指在一个高可用（HA）系统中，当联系着的两个节点断开联系时，本来为一个整体的系统，分裂为两个独立节点，这时两个节点开始争抢共享资源，结果会导致系统混乱，数据损坏</p>
<p>有一种做法称为设置仲裁机制，例如设置第三方检测服务器（Monitor），当Slave确定准备接管Master时，让Monitor也ping一下Master，如果没有通讯，则判断其“死亡”；同时Master在对外提供服务时，每隔一段时间比如10s由Master服务器ping Slave服务器和Monitor，如果均出现异常，则暂定业务操作，重试。重试多次之后则退出程序执行或者执行服务器重启操作。</p>
<h4 id="2-3-9-Quorum-NWR"><a href="#2-3-9-Quorum-NWR" class="headerlink" title="2.3.9 Quorum NWR"></a>2.3.9 Quorum NWR</h4><p>NWR是一种在分布式存储系统中用于控制一致性级别的一种策略。在Amazon的Dynamo云存储系统中，就应用NWR来控制一致性</p>
<ul>
<li>N：同一份数据的拷贝份数；</li>
<li>W：是更新一个数据对象的时候需要确保成功更新的份数；</li>
<li>R：读取一个数据需要读取的拷贝的份数。</li>
</ul>
<h4 id="2-3-10-MVCC"><a href="#2-3-10-MVCC" class="headerlink" title="2.3.10 MVCC"></a>2.3.10 MVCC</h4><p>MVCC，全称Multiversion concurrency control，翻译为基于多版本并发控制。人们一般把基于锁（比如行级锁）的并发控制机制称成为悲观机制，而把MVCC机制称为乐观机制.</p>
<p>由于MVCC是一种宽松的设计，读写相互不阻塞，可以获得较好的并发性能。</p>
<h4 id="2-3-11-Gossip"><a href="#2-3-11-Gossip" class="headerlink" title="2.3.11 Gossip"></a>2.3.11 Gossip</h4><p>Gossip就是一种去中心化思路的分布式协议，解决状态在集群中的传播和状态一致性的保证两个问题</p>
<p>Gossip的核心是在去中心化结构下，通过信息的部分传递，达到全集群的状态信息传播，传播的时间收敛在O(Log(N))以内，其中N是节点的数量。同时基于Gossip协议，可以构建出状态一致的各种解决方案。</p>
<h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h4 id="A-后续阅读"><a href="#A-后续阅读" class="headerlink" title="A.后续阅读"></a>A.后续阅读</h4><ul>
<li><a href="https://kdocs.cn/l/sPP91WsQL" target="_blank" rel="noopener">分布式系统概念与设计(原书第5版).pdf</a></li>
<li><a href="https://kdocs.cn/l/sh1n1Y1aL" target="_blank" rel="noopener">paxos-made-simple.pdf</a></li>
<li><a href="https://kdocs.cn/l/sVgDvD5mY" target="_blank" rel="noopener">从PAXOS到ZOOKEEPER分布式一致性原理与实践.pdf</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/chip/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/cs/basic.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/cs/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/man/rust/lib.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>python常用库</title>
    <url>/man/python/lib-redis.html</url>
    <content><![CDATA[<ul>
<li>批量删除Keys</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">keys = redis_conn.keys(<span class="string">'iproxy:*'</span>)</span><br><span class="line">redis_conn.delete(*keys)</span><br></pre></td></tr></table></figure>]]></content>
  </entry>
  <entry>
    <title>rust手册</title>
    <url>/man/python/index.html</url>
    <content><![CDATA[<ul>
<li><a href="basic.html">基础</a></li>
<li><a href="lib.html">库</a></li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>llvm</title>
    <url>/man/cs/llvm.html</url>
    <content><![CDATA[<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><ul>
<li><p><a href="https://llvm.org/" target="_blank" rel="noopener">官网</a></p>
</li>
<li><p><a href="https://github.com/llvm/llvm-project" target="_blank" rel="noopener">github</a></p>
</li>
<li><p><a href="https://www.infoworld.com/article/3247799/what-is-llvm-the-power-behind-swift-rust-clang-and-more.html" target="_blank" rel="noopener">What is LLVM? </a></p>
</li>
</ul>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>LLVM 全称是 Low Level Virtual Machine，它是源自 the University of Illinois 的一个研究项目，该项目旨在提供一个现代化的编译机制，使得对任何编程语言既可以做到静态编译也可以动态编译，而且非常高效。后来 LLVM 项目逐渐发展，并孵化了许多子项目，比如 Clang，LLDB， OpenMP 等。</p>
<p>一般来说，编译器会将源语言翻译为一种“中间语言(IR)”，之后再由 中间语言 利用后端程序和设备翻译为目标平台的汇编语言。不同编译器的中间语言IR是不一样的，IR集中体现了编译器的主要特征——算法，优化方式，汇编流程等等。</p>
]]></content>
  </entry>
  <entry>
    <title>nameko使用</title>
    <url>/man/python/lib-nameko.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>rust手册</title>
    <url>/man/rust/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>rust的基础</title>
    <url>/man/rust/basic.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>rust与llvm</title>
    <url>/man/rust/llvm.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>rust的ffi使用</title>
    <url>/man/rust/ffi.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>芯片简介</title>
    <url>/man/chip/basic.html</url>
    <content><![CDATA[<h3 id="芯片分类"><a href="#芯片分类" class="headerlink" title="芯片分类"></a>芯片分类</h3><ul>
<li><p>按照功能分类</p>
<ul>
<li>计算的</li>
<li>控制的</li>
<li>存储的</li>
</ul>
</li>
<li><p>按照集成电路规模</p>
<ul>
<li>有超大规模</li>
<li>大规模</li>
<li>中规模</li>
<li>小规模</li>
</ul>
</li>
<li><p>具体到了类型</p>
<ul>
<li>CPU</li>
<li>SoC</li>
<li>DSP</li>
</ul>
</li>
</ul>
<h3 id="CPU结构和功能"><a href="#CPU结构和功能" class="headerlink" title="CPU结构和功能"></a>CPU结构和功能</h3><p>结构：</p>
<ul>
<li>1) 控制器：完成指令的读入、寄存、译码和执行。</li>
<li>2) 寄存器：暂存用于寻址和计算过程的产生的地址和数据。</li>
<li>3) I/O控制逻辑：负责CPU中与输入/输出操作有关的逻辑。</li>
<li>4) 算数逻辑运算单元（Arithmetic &amp; Logic Unit, ALU）：运算器核心，负责进行算术运算、逻辑运算和移位操作，用来进行数值计算和产生存储器访问地址。</li>
</ul>
<p>功能：</p>
<ul>
<li>1) 与存储器之间交换信息。</li>
<li>2) 和I/O设备之间交换信息。</li>
<li>3) 为了使系统正常工作而接收和输出必要的信号，如复位信号、电源、输入时钟脉冲等。</li>
</ul>
<h3 id="微处理系统"><a href="#微处理系统" class="headerlink" title="微处理系统"></a>微处理系统</h3><p>1) CPU的外部特征就是数量有限的输入输出引脚。<br>2) 数据总线：用于CPU和存储器或I/O接口之间传送数据，双向通信；数据总线的条数决定了CPU和存储器或I/O设备一次最多能交换数据的位数，是微处理器的位数的判据，例如：Intel 386DX、ARM Cortex-M3是32位微处理器；Intel采用了IA-64架构的处理器、PowerPC 970是64位处理器；类似地，还有更加古老的8位、16位处理器等。<br>3) 地址总线：CPU通过地址总线输出地址码用以选择某一存储单元或某一成为I/O端口的寄存器，单向通信；地址总线的条数决定了地址码的位数，进而决定了存储空间的大小，例如：地址总线宽度（条数）为8，则可以标记2^8 = 256个存储单元，若每个存储单元的字长为8 bit，则最大可以接入系统的存储空间为256kB。<br>4) 控制总线：用来传送自CPU发出的控制信息或外设送到CPU的状态信息，双向通信；</p>
<h3 id="专用集成电路"><a href="#专用集成电路" class="headerlink" title="专用集成电路"></a>专用集成电路</h3><p>专用的集成电路（Application Specific Integrated Circuit, ASIC）是一种为专门目的而设计的集成电路。是指应特定用户要求和特定电子系统的需要而设计、制造的集成电路<br>ASIC的特点是面向特定用户的需求，ASIC在批量生产时与通用集成电路相比具有体积更小、功耗更低、可靠性提高、性能提高、保密性增强、成本降低等优点</p>
<h3 id="可编程逻辑器件"><a href="#可编程逻辑器件" class="headerlink" title="可编程逻辑器件"></a>可编程逻辑器件</h3><p>可编程逻辑器件（Programmable Logic Device, PLD）是一种通用集成电路，它是ASIC的一个子集，逻辑功能可以按照用户对器件编程来确定。<br>PLD与一般数字芯片不同的是：PLD内部的数字电路可以在出厂后才规划决定，甚至可以无限制改变，而一般数字芯片在出厂前就已经决定其内部电路，无法在出厂后再次改变，事实上一般的模拟芯片、通信芯片、微控制器也都一样，出厂后就无法再对其内部电路进行更改。</p>
<blockquote>
<p>可编程逻辑器件的发展历程</p>
</blockquote>
<ul>
<li>最早的可编程逻辑器件（PLD）是1970年制成的可编程只读存储器（PROM），它由固定的与阵列和可编程的或阵列组成</li>
<li>可编程逻辑阵列（PLA）于20世纪70年代中期出现，它是由可编程的与阵列和可编程的或阵列组成，但由于器件的价格比较贵、编程复杂、资源利用率低，因而没有得到广泛应用。</li>
<li>可编程阵列逻辑（PAL）是1977年美国MMI公司率先推出的，它采用熔丝编程方式，由可编程的与阵列和固定的或阵列组成，采用双极性工艺制造，器件的工作速度很高。由于它的设计很灵活，输出结构种类很多，因而成为第一个得到普遍应用的可编程逻辑器件</li>
<li>通用阵列逻辑（GAL）是1985年Lattice公司最先发明的可电擦写、可重复编程、可设置加密位的PLD。GAL在PAL的基础上，采用了输出逻辑宏单元形式（EECMOS）工艺结构。在实际应用中，GAL对PAL仿真具有百分之百的兼容性，所以GAL几乎完全代替了PAL，并可以取代大部分标准SSI、MSI集成芯片，因而获得广泛应用</li>
<li>可擦除可编程逻辑器件（EPLD）是20世纪80年代中期Altera公司推出的基于UVEPROM和CMOS技术的PLD，后来发展到采用EECMOS工艺制作的PLD，EPLD的基本逻辑单元是宏单元，宏单元是由可编程的与阵列、可编程寄存器和可编程I/O三部分组成的</li>
<li>复杂可编程逻辑器件（CPLD）是20世纪80年代末Lattice公司提出了在线可编程技术（SP）以后于20世纪90年代初推出的。CPLD至少包含三种结构：可编程逻辑宏单元可编程I/O单元和可编程内部连线，它是在EPLD的基础上发展起来的，采用EECMOS工艺制作，与EPLD相比，增加了内部连线，对逻辑宏单元和I/O单元也有很大改进。</li>
<li>现场可编程门阵列（FPGA）器件是Xilinx公司1985年首家推出的，它是一种新型的高密度PLD，采用CMOS-SRAM工艺制作。FPGA的结构与门阵列PLD不同，其内部由许多独立的可编程逻辑模块（CLB）组成，逻辑块之间可以灵活地相互连接，CLB的功能很强，不仅能够实现逻辑函数，还可以配置成RAM等复杂的形式。配置数据存放在芯片内的SRAM中，设计人员可现场修改器件的逻辑功能，即所谓的现场可编程。FPGA出现后受到电子设计工程师的普遍欢迎，发展十分迅速。</li>
</ul>
<h3 id="硬件描述语言"><a href="#硬件描述语言" class="headerlink" title="硬件描述语言"></a>硬件描述语言</h3><p>硬件描述语言（Hardware Deion Language, HDL）是一种用形式化方法描述逻辑电路和系统的语言。利用这种语言，逻辑电路系统的设计可以从上层到下层（从抽象到具体）逐层描述自己的设计思想，用一系列分层次的模块来表示极其复杂的逻辑系统。然后，利用电子设计自动化（EDA）工具，逐层进行仿真验证，再把其中需要变为实际电路的模块组合，经过自动综合工具转换到门级电路网表。接下来，再用专用集成电路（ASIC）或现场可编程门阵列（FPGA）自动布局布线工具，把网表转换为要实现的具体电路布线结构。</p>
<ul>
<li>VHDL</li>
<li>Verilog HDL</li>
<li>System C</li>
</ul>
<h3 id="常见的数据处理芯片"><a href="#常见的数据处理芯片" class="headerlink" title="常见的数据处理芯片"></a>常见的数据处理芯片</h3><h4 id="MCU"><a href="#MCU" class="headerlink" title="MCU"></a>MCU</h4><p>日常生活中最常见得到的微处理器系统就是我们身边的微型计算机，也就是个人电脑<br>MCU是应用最广泛的一种电子控制芯片，其控制程序可以由特殊的烧录工具下载到ROM中，行使系统的功能。这些ROM可以使以是PROM、UVEPROM、EEPROM等，若MCU上没有集成ROM，也可以外接ROM。按照系统结构，微处理器系统可以分为冯·诺依曼结构（也称普雷斯顿结构）和哈佛结构，其区别是程序与数据的存放方式不同，同样地，MCU芯片也可以分为这两种结构，灵活地满足需要。</p>
<h4 id="MPU"><a href="#MPU" class="headerlink" title="MPU"></a>MPU</h4><p>微处理器单元（Micro Processor Unit, MPU），就是把很多CPU集成在一起并行处理数据的芯片。通俗来说，MCU集成了RAM，ROM等设备；MPU则不集成这些设备，是高度集成的通用结构的中央处理器矩阵，也可以认为是去除了集成外设的MCU。</p>
<h4 id="PLD（CPLD-FPGA）"><a href="#PLD（CPLD-FPGA）" class="headerlink" title="PLD（CPLD/FPGA）"></a>PLD（CPLD/FPGA）</h4><p>因为目前广泛使用的PLD是CPLD和FPGA。<br>CPLD/FPGA的内部结构和CPU完全不同，内部电路可以被多次修改，可以按照用户的编程形成不同的组合逻辑电路、时序逻辑电路结构，是一种“万能”的芯片，CPLD/FPGA看起来像一个CPU，其实不然，因为使用CPLD/FPGA实现控制是纯硬件实现，实质上和使用成千上万基本逻辑门搭建的数字逻辑电路没有区别。</p>
<h4 id="ADC、DAC"><a href="#ADC、DAC" class="headerlink" title="ADC、DAC"></a>ADC、DAC</h4><p>这就是模数转换电路（Analog Digital Circuit, ADC）,相应的也有数模转换（D/A）和数模转换电路（Digital Analog Circuit, DAC）芯片，进行D/A的时候同样要在数学和信息论上满足相关定理。</p>
<h4 id="DSP"><a href="#DSP" class="headerlink" title="DSP"></a>DSP</h4><p>数字信号处理器（Digital Signal Processor, DSP）是用来高速处理数字信号的专用芯片。<br>常常采用专用的电路来处理数字信号，如数字滤波、快速傅里叶变换、时频分析、语音信号和图像信号的处理加工等。这些运算往往很复杂，很多涉及复数的累加、累乘运算，举个例子：离散傅里叶变换的计算就十分复杂，但是运用时域抽取或频域抽取的快速傅里叶变换算法后就可以大大减少运算量，但是电路较为复杂。将能完成这些复杂运算的电路集成在一块芯片上，能在一个时钟周期完成一次乘加运算，使其能完成如基2-FFT蝶形运算、音频滤波、图像处理等复杂运算，这样的芯片叫做DSP。DSP也是一种特殊的CPU，特别适合信号的处理</p>
<h4 id="SoC"><a href="#SoC" class="headerlink" title="SoC"></a>SoC</h4><p>SoC的全称是System on a Chip，顾名思义，就是在一块芯片上集成一整个信息处理系统，称为片上系统或系统级芯片。<br>SoC也代表着一种技术，是一种以确定系统功能为目标，各个模块的软硬件协同开发，最后把开发成果集成为一块芯片的技术。由于功能丰富，又要求有不俗的性能发挥，SoC已然是功能最为丰富的硬件，其上集成了CPU、GPU、RAM、ADC/DAC、Modem、高速DSP等各种芯片，有的SoC上还必须集成电源管理模块，各种外部设备的控制模块，充分考虑各总线的分布利用……现如今，智能手机里的SoC上就集成了以上的部件和基带处理器等很多相关的通信模块。<br>SoC在无人机技术、自动驾驶，深度学习等行业也有越来越多的应用，用一块单芯片就能实现完整的电子系统，是半导体行业、IC产业未来的发展方向</p>
<h3 id="半导体IP核"><a href="#半导体IP核" class="headerlink" title="半导体IP核"></a>半导体IP核</h3><p>IP核，全称知识产权核（英语：intellectual property core），是在集成电路的可重用设计方法学中，指某一方提供的、形式为逻辑单元、芯片设计的可重用模组。IP核通常已经通过了设计验证，设计人员以IP核为基础进行设计，可以缩短设计所需的周期。[1]IP核可以通过协议由一方提供给另一方，或由一方独自占有。IP核的概念源于产品设计的专利证书和源代码的版权等。设计人员能够以IP核为基础进行专用集成电路或现场可编程逻辑门阵列的逻辑设计，以减少设计周期。</p>
<p>IP核分为软核、硬核和固核。</p>
<ul>
<li>软核通常是与工艺无关、具有寄存器传输级硬件描述语言描述的设计代码，可以进行后续设计；</li>
<li>硬核是前者通过逻辑综合、布局、布线之后的一系列表征文件，具有特定的工艺形式、物理实现方式；</li>
<li>固核则通常介于上面两者之间，它已经通过功能验证、时序分析等过程，设计人员可以以逻辑门级网表的形式获取。</li>
</ul>
]]></content>
  </entry>
</search>
