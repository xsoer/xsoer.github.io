<!doctype html>
<html lang="zh-CN">
<head>

    <meta charset="utf-8">
    <meta name="generator" content="Hugo 0.58.1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <title>hackfox | </title>
    <meta property="og:title" content="hackfox | ">
    <meta property="og:type" content="website">
    <meta name="Keywords" content="">
    <meta name="description" content="">
    <meta property="og:url" content="https://xsoer.github.io/">
    <link rel="shortcut icon" href="https://xsoer.github.io/favicon.ico" type="image/x-icon">

    <link rel="stylesheet" href="https://xsoer.github.io/css/normalize.css">
    
    <link rel="stylesheet" href="https://xsoer.github.io/css/style.css">
    <link rel="alternate" type="application/rss+xml+xml" href="https://xsoer.github.io/index.xml" title="hackfox" />
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

    


    
    
</head>


<body>
<header id="header" class="clearfix">
    <div class="container">
        <div class="col-group">
            <div class="site-name ">
                
                    <h1>
                        <a id="logo" href="https://xsoer.github.io/">
                            hackfox
                        </a>
                    </h1>
                
                
            </div>
            <div>
                <nav id="nav-menu" class="clearfix">
                    <a class="current" href="https://xsoer.github.io/">首页</a>
                    
                    <a  href="https://xsoer.github.io/books/" title="新书">新书</a>
                    
                    <a  href="https://xsoer.github.io/archives/" title="归档">归档</a>
                    
                    <a  href="https://xsoer.github.io/about/" title="关于">关于</a>
                    
                </nav>
            </div>
        </div>
    </div>
</header>


<div id="body">
    <div class="container">
        <div class="col-group">

            <div class="col-8" id="main">
                <div class="res-cons">
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2016/05-23-url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2016/05-23-url%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2016/12-24-git%E5%91%BD%E4%BB%A4/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                Git常用命令  作者：codehackfox@gmail.com 时间：2016-12-24 19:08:57   0x00、常用命令   git init #git 初始化仓库 git clone remote_url #git 克隆远程库 git add . #git 添加所有文件 git commit -m &quot;批注&quot; #git 提交 git push &lt;remoteName&gt; &lt;localName&gt; #git推送至远程 git remote add origin &lt;server&gt; #远程没有创建仓库，将本地推送到远程仓库 git checkout -b branch_name #创建分支，并切换到分支 git checkout master #切换到主分支 git branch -d &lt;branch_name&gt; #删除分支 git pull &lt;remoteName&gt; &lt;localName&gt; #将本地仓库更新至最新 git merge branch_name #将其他分支合并到本地主分支 git diff &lt;sourch_branch&gt; &lt;target_branch&gt; #比对分支 git tag &lt;tag_name&gt; #创建标签 git show # git status #查看当前状态 git fetch #合并 git config --list #查看配置信息 git rm &lt;file_name&gt; #删除文件 git mv &lt;old_name&gt; &lt;new_name&gt; #重命名文件 git log #查看日志 git rebase HEAD &lt;file_name&gt; #重置 git remote -v #查看远程仓库 git remote rm &lt;file_name&gt; #删除远程仓库 git branch #查看本地分支 git branch -r #查看远程分支 git branch &lt;branch_name&gt; #创建本地分支 git config --global user.……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2016/12-24-git%E5%91%BD%E4%BB%A4/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2017/03-12-vim%E5%91%BD%E4%BB%A4/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 VIM使用文档总结  作者:codehackfox@gmail.com 时间: 2017-03-02 13:10:12   0x00、快捷键   向下添加一行 &gt; o 向下翻页 &gt; ctrl+f 向上翻页 &gt; ctrl+b 下一个词 &gt; w 行尾 &gt; $ 第一个字符行首 &gt; ^ 行首 &gt; 0 撤销 &gt; u 文件首 &gt; gg 文件尾 &gt; G 屏首 &gt; ctrl+h 屏中 &gt; ctrl+m 屏尾 &gt; ctrl+l  ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2017/03-12-vim%E5%91%BD%E4%BB%A4/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2017/07-06-mysql%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 mysql编码问题  作者：codehackfox@gamil.com 时间：2019-09-06 09:12:43  ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2017/07-06-mysql%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2017/09-28-%E5%BC%80%E6%9C%BA%E8%87%AA%E6%A3%80/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 系统开机自检  作者：codehackfox@gmail.com 时间：2017-09-28 15:24:23   0x00、关于开机自动检测硬盘的原因   第一种：是你非法关机造成的，比如直接断电的情况。 第二种：是和硬盘的分区格式有关，FAT32格式在非法关机后会在开机时要求检测硬盘，而且必须检测完毕才不会在下次启动时重新检测。系统有一个文件中记录了检测是否结束的信息，有时即使检测完成了也会因为这个文件没有更新而在下次开机时重新检测。 第三种：当硬盘出现坏道也会出现开机自动检测硬盘。   0x01、关于取消开机自动检测硬盘的方法   方法一： 如果分区是FAT32格式，将其转换成NTFS，方法是在命令提示符下输入：convert X: /fs:ntfs 方法二： 如果是非正常的关机，然后开机检测时又跳过了，每一次都会运行的。如果不是这个原因的话，您就要检查一下D盘状态是否正常，修正一下硬盘的错误。方法为 &ldquo;开始&rdquo;→&rdquo;运行&rdquo;，在窗口中输入&rdquo;chkdskX:/f&rdquo;(x为盘符)，这个命令可以检查文件系统中的逻辑错误，并进行修复；然后启动&rdquo;磁盘碎片整理&rdquo; 对相应的磁盘进行碎片整理，可以消除再次的磁盘扫描。如果还是不行，就可能是硬盘出现了坏道，最简单的方法是把D盘的数据备份一下，然后格式化D盘，就可 以正常使用了。 方法三：打开&rdquo;我的电脑&rdquo;－右键点击X盘选择&rdquo;属性&rdquo;－选择&rdquo;工具&rdquo;－&rdquo;查错&rdquo;中点&rdquo;开始检查&rdquo;－选中&rdquo;自动修复文件系统错误&rdquo;和&rdquo;扫描并试图恢复坏扇区&rdquo;，然后点&rdquo;开始&rdquo;。 方法四：我们知道系统之所以要对磁盘进行扫描是因为在注册表中设置了&rdquo;脏&rdquo;字节。在注册表中找到以下分支: 方法五：如果是硬盘出现坏道，请使用磁盘修复工具进行修复，如使用HDDRegenerate等。 方法六：一定是你在BIOS设置中选择了每次开机都要检测硬盘,所以才这样,和你的电脑配置是没有关系的。解决方法在开机后按DEL进入BIOS选 择Quick Power On Self Test（快速加电自检测），你的一定设为了Enabled了,选择Disabled，将其关闭就行了。  ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2017/09-28-%E5%BC%80%E6%9C%BA%E8%87%AA%E6%A3%80/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/03-02-php%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                PHP知识体系  作者：codehackfox@gmail.com 时间：2018-03-02 11:53:29   0x00、关键字   $ 、echo、 print、null、global、GLOBALS[&lsquo;y&rsquo;]、static、function、public、private、protected 对象(class)：String、Integer、Float、Boolean、Object、NULL、Resource、Closure() 函数(function)：  通用：die()、var_dump()、for()、foreach()、define()、echo 函数：function_exists() 数组：array()、sort()、count()、 implode($arr,&lsquo;,&rsquo;)、is_array()、unset()、 字符串：strlen()、mb_substr()、strpos()、str_replace()、str_word_count()、sprintf()、explode(&lsquo;,&rsquo;,$string)、substr()、iconv_substr 数据库：query()、mysql()、close()、 文件：file_exist()、is_file()、is_dir() 对象： serialize()、unserialize() 回话：session_start()、setcookie()、session_destroy()、session_unset()、 日期：date()、strtotime()、date_default_timezone_set() socket：  超级全局变量:  $GLOBALS $_SERVER $_REQUEST $_POST $_GET $_FILES $_ENV $_COOKIE $_SESSION  魔术方法：  contract()、decontract、get()、set()、 _invoke()    0x01、字符串  //字符串定义方式 // ''只转译 ' / 但是“”转译的比较多 // &quot;&quot;可以解析变量 // ''速度比较快，不用分析变量，转译内用少。我们优先使用 '' $str1 = 'hello'; $str2 = &quot;hello&quot;; //写大段文本 //heredoc &lt;&lt;&lt;HTML .……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/03-02-php%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/05-18-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 docker常用命令  作者：codehackfox@gmail.com 时间：2018-05-18 14:29:58   0x00、常用命令   查看容器重启次数  docker inspect -f &ldquo;{{ .RestartCount }}&rdquo; container_id  查看容器最后一次的启动时间  docker inspect -f &ldquo;{{ .State.StartedAt }}” container_id  commit一个镜像  docker run &ndash;name=&ldquo;python_env_l&rdquo; -it image_name /bin/bash docker commit -m=&ldquo;msg&rdquo; -a=&ldquo;user_name&rdquo; 4631e1627784 image_name:2.1 docker tag image_name:2.1 image_name:latest docker push image_name  Docker构建镜像  docker build -t imageName .  打标签  Docker tag image user/newName:tag  批量删除无用镜像  docker image rm docker images|grep none|awk {'print $3'}  批量删除无用容器  sudo docker rm sudo docker ps -a |grep Exited| awk {'print $1'}   ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/05-18-docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/08-10-%E8%A1%8C%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 行与列式数据库  作者：codehackfox@gmail.com 时间：2018-08-10 13:23:49   0x00、简介  行式数据库  平常用的结构化关系型数据库，比如mysql、sqlserver等 一行为一条数据，进行记录存储 可以进行join查询，可以进行笛卡尔积运算  列式数据库  列式数据库是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。 特点  因为硬盘寻址时间相较于计算机上其他部件的运行速度来说不是一般的慢，所以常用相同工作负载下的硬盘访问性能来比较行数据库和列数据库。通常，顺序读取数据要比随机访问更快。而且，硬盘寻址时间的提升比起CPU速度的进步要慢得多 (参看 摩尔定律)，在使用硬盘作为存储媒介的系统上这种情况很可能还会持续一段时间。下面简单罗列了一些选择行数据库还是列数据库的权衡依据。当然，如果能够把数据全放在内存中，那么使用内存数据库性能会更好。  1.在只需要根据某几列来聚合数据的时候按列的数据组织方式更有效。因为这样只需要读取一部分数据，要比读取全部数据更快。 2.当只需要修改某一列值的时候按列的数据组织方式更有效。因为可以直接找到某列数据并修改，而与行中的其他列无关。 3.当需要某行的多列数据的时候按行的数据组织方式更有效。当行中数据不是太多的情况下一次硬盘寻址就可以获得该行的所有数据。 4.在新增行数据的时候，如果各列都有值，那么按行的数据组织方式会更有效，因为只需要一次硬盘寻址就可以写入整行的全部数据。    应用  面向行的数据存储架构更适用于OLTP-频繁交互事务的场景。 面向列的数据存储架构更适用于OLAP-(如数据仓库)这样在海量数据（(可能达到 terabyte规模)）中进行有限复杂查询的场景。   0x01、比较     底层存储实例      随机读与顺序读      0x02、优缺点  列数据库  优点：  极高的装载速度（最高可以等于所有硬盘IO 的总和，基本是极限了） 适合大量的数据而不是小数据 实时加载数据仅限于增加（删除和更新需要解压缩Block 然后计算然后重新压缩储存 高效的压缩率，不仅节省储存空间也节省计算内存和CPU。 非常适合做聚合操作。  缺点：  不适合扫描小量数据 不适合随机的更新 批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。 不适合做含有删除和更新的实时操作   行数据库  优点  适合频繁的增删改数据 小量数据的频繁维护和简单统计  缺点  不适合做统计类操作   ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/08-10-%E8%A1%8C%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/08-12-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                数据建模  作者：codehackfox@gmail.com 时间：2018-08-12 12:12:23   0x00、数据模型   为什么要建模
 定义如何存储信息，如何操作信息，以及信息的完整性等约束功能 影响了数据的形态和使用方式 需要满足不同的业务场景需要 联机事务处理(OLTP):满足业务线需要，频繁的维护更新数据，强一致性 联机分析处理(OLAP):满足决策层需要，更多纬度的视角查询，满足统计决策   定义数据如何存储
 数据模型是定义数据如何输入和输出的一种模型。其主要作用是为信息系统提供数据的定义和格式。
 数据模型是数据库系统的核心和基础，现有的数据库系统都是基于某种数据模型而建立起来的。
 三要素
 数据结构：储存在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。 比如结构化存储、非结构化存储 关联关系型，KV型 数据操作：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。 关系操作的select及其join、 group by、order by,insert,update, delete等 关系型数据库：oracle,SQLServer,DB2,Mysql。面向对象化 键值数据库：redis,mongodb,hbase等。存储非结构化，缓存等 时间序列数据库:InfluxDB，confluenceDB，Elasticsearch等。 存储日志类型，便于分析 流式数据库:MQ，Spark，Kafka。存储消息类型，不做永久性存储。发布-订阅型、消息队列、消息中间件 数据完整性约束条件：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。[1]    0x01、数据建模   建模过程中的主要活动包括：  确定数据及其相关过程（如实地销售人员需要查看在线产品目录并提交新客户订单）。 定义数据（如数据类型、大小和默认值）。 确保数据的完整性（使用业务规则和验证检查）。 定义操作过程（如安全检查和备份）。 选择数据存储技术（如关系、分层或索引存储技术）。  数据建模大致分为三个阶段，概念建模阶段，逻辑建模阶段和物理建模阶段。其中概念建模和逻辑建模阶段与数据库厂商毫无关系，换言之，与MySQL，SQL Server，Oracle没有关系。物理建模阶段和数据库厂商存在很大的联系，因为不同厂商对同一功能的支持方式不同，如高可用性，读写分离，甚至是索引，分区等。   0x02、数据存储历史   历史发展  无库时代 ：没有专门的数据库，数据大多以文件形式存放 层次状数据库 ：使用层次状模型进行数据库设计和存放 网状数据库 ：使用网状模型进行数据库设计和存放 关系型数据库 ：使用关系型模型进行数据库设计和存放 非关系型数据库：为适应水平扩展性和处理超大量的数据环境，近几年发展非常迅速的发展，衍生类型非常多。 数据集市 数据仓库    0x03、层次模型    一种用树形结构描述实体及其之间关系的数据模型。在这种结构中，每一个记录类型都是用节点表示，记录类型之间的联系则用结点之间的有向线段来表示。每一个双亲结点可以有多个子节点但是每一个子节点只能有一个双亲结点。这种结构决定了采用层次模型作为数系组织方式的层次数据库系统只能处理一对多的实体联系。 层次模型是最早用于商品数据库管理系统的数据模型。 层次数据模型中最基本的数据关系是基本层次关系，它代表两个记录型之间一对多的关系，也叫做双亲子女关系（PCR）。 举例   一个教师学生层次模型。该层次模型有4个记录类型，即实体。分别是： （1）记录型（实体）系是根结点，由系编号、系名、地点3个属性（字段）组成。它有两个子结点，分别是教研室实体和学生实体。 （2）记录型（实体）教研室是系的子结点，同时又是教师实体的双亲结点。它由教研室编号和教研室名两个属性（字段）组成。 （3）记录型（实体）学生由学号、姓名、成绩3个属性（字段）组成。 （4）记录型（实体）教师由教师号、姓名、研究方向3个属性（字段）组成。学生与教师是叶子结点，他们没有子结点。由系到教研室、教研室到教师、系到学生都是一对多的联系。  特征。在一个层次模型中的限制条件是：  （1）有且仅有一个节点，无父节点，它为树的根；（有且仅有一个结点没有双亲，该节点就是根结点。） （2）其他节点有且仅有一个父节点。（根以外的其他结点有且仅有一个双亲结点 ）这就使得层次数据库系统只能直接处理一对多的实体关系。 （3）任何一个给定的记录值只有按照其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离双亲记录值而独立存在。 因而层次模型只能表示“1一M”关系，而不能直接表示“M—M”关系。在层次模型中，一个结点称为一个记录型，用来描述实体集。每个记录型可以有一个或多个记录值，上层一个记录值对应下层一个或多个记录值，而下层每个记录值只能对应上层一个记录值。例如，系记录型有：计算机系、电信系等记录值。而计算机系的下层记录值有软件、结构、应用等研究室和数据结构、操作系统、数据库等课程，软件研究室下层又有员工和项目记录值，如图所示:  关于层次模型中实体集之间多对多的联系的处理，解决的方法是引入冗余结点。例如，学生和课程之间的多对多的联系，引入学生和课程的冗余结点，转换为两棵树：一棵树的根是学生，子结点是课程，它表现了一个学生可以选多门课程；一棵树的根是课程，子结点是学生，它反映了一门课程可以被多个学生选。至于冗余结点可以用虚拟结点实现：在冗余结点处仅存放一个指针，指向实际结点。  数据完整性约束。层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。具体如下：  （1）进行插入数据时，如果没有相应的双亲结点值就不能插入它的子结点值。例如，在上图层次数据库中，如果新调入一名教师，但尚未分配到某个教研室，这时就不能将新的教师插入到数据库中。 （2）进行删除数据时，如果删除双亲结点值，则相应的子结点值也被同时删除。例如，在上图中的层次数据库中，如果删除网络教研室，则该教研室的所有教师的数据将全部丢失。 （3）进行修改数据时，进行更新操作时，应更新所有相应记录，以保证数据的一致性。 [2]  优缺点  优点:  层次模型的数据结构比较简单，只需要几条命令就能操纵数据库，比较容易使用。 结构清晰，结点间联系简单，只要知道每个结点的双亲结点，就可以知道整个模型结构。现实世界中许多实体间联系本来就是呈现出一种很自然的层次关系，如表示行政层次，家族关系很关系  缺点:  （1）现实世界中很多联系是非层次性的，如多对多联系、一个结点具有多个双亲等。层次模型表示这类联系的方法很不灵活，不能直接表示两个以上的实体型间的的复杂的联系和实体型间的多对多联系。只能通过引入冗余数据或建非自然的数据组织如创建虚拟节点的方法来解决，易产生不一致性。 （2）对数据的插入和删除的操作限制太多。 （3）查询子女结点必须通过双亲结点，因为层次模型对任一结点的所有子树都规定了先后次序，这一限制隐含了对数据库存取路径的控制。树中父子结点之间只存在一种联系，因此，对树中的任一结点，只有一条自根结点到达它的路径。 （4）树结点中任何记录的属性只能是不可再分的简单数据类型。 （5）由于结构严密，层次命令趋于程序化。   层次模型的物理存储有两种实现方法：  顺序法：按照层次顺序把所有的记录邻接存放，即通过物理空间的位置相邻来实现层次顺序。 指针法：各个记录存放时不是按层次顺序，而是用指针按层次顺序把它们链接起来。  1969由IBM公司的IMS（Information Management System），这是IBM公司研制的最早的大型数据库系统程序产品   0x04、网状模型   定义  用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型（Network Model）。 网状模型取消了层次模型的不能表示非树状结构的限制，两个或两个以上的结点都可以有多个双亲结点，则此时有向树变成了有向图，该有向图描述了网状模型。  特征。网状模型的数据结构主要有以下两个特征:  (1)允许有一个以上的节点无双亲。 (2)至少有一个节点可以有多于一个的双亲。 网状模型中每个结点表示一个记录型（实体），每个记录型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）间的父子关系。  示例   课程（实体）的父节点由专业、教研室、学生。以课程和学生之间的关系来说，他们是一种m:n的关系，也就是说一个学生能够选修多门课程，一门课程也可以被多个学生同时选修。  网状与层级数据库的区别  层次模型中子结点与双亲结点的联系是唯一的，在网状模型中这种联系可以不唯一。 层次模型可以看作网状模型的特例 因此，在网状模型中要为每个联系命名，并指出与该联系有关的双亲记录和子记录。  数据操作与完整性约束  网状模型的数据操作主要包括查询、插入、删除和更新。具体如下：  (1)进行插入操作时，允许插入尚未确定双亲结点值的子结点值。如可增加一名尚未分配到某个教研室的新老师，也可增加一些刚来报到还未分配宿舍的学生。 (2)进行删除操作时，只允许删除双亲结点值。如可删除一个教研室，而该科研室所有教师的信息仍保留在数据库中。 (3)修改数据时，可直接表示非树状结构，而无须像层次模型那样增加冗余结点，因此修改操作时只需要指定更新记录即可。  进行更新操作时只需更新指定记录即可。因此，一般来说，网状模型没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统(如DBTG)对数据操作都加了一些限制，提供了一定的完整性约束。 [3] DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句，主要有：  (1)支持记录码的概念，码是唯一标识记录的数据项的集合。 (2)保证一个联系中双亲记录和子记录之间是一对多的联系。 (3)可以支持双亲记录和子记录之间某些约束条件。如有些子记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。   优缺点  优点  能够更为直接地描述现实客观世界。可表示实体间的多种复杂联系。 修改网状数据模型时，没有层次状数据模型的那么多的严格限制，可以删除一个节点的父节点而依旧保留该节点；也允许插入一个没有任何父节点的节点，这样的插入在层次状数据模型中是不被允许的，除非是首先插入的是根节点； 实体之间的关系在底层中可以借由指针指针实现。具有良好的性能，存取效率较高。  缺点  结构比较复杂，其数据定义语言(DDL)、数据操作语言(DML)复杂，用户不容易使用。而且应用环境越大，数据库的结构就变得越复杂，不利于最终用户掌握。 数据独立性差，由于实体间的联系本质上是通过存取路径表示的，因此应用程序在访问数据时要指定存取路径。 网状数据模型数据之间的彼此关联比较大，该模型其实一种导航式的数据模型结构，不仅要说明要对数据做些什么，还说明操作的记录的路径；     0x05、关系模型   网状数据库和层次数据库已经很好地解决了数据的集中和共享问题 但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。 1970年，IBM的研究员E.……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/08-12-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/10-26-python%E7%9A%84format%E4%BD%BF%E7%94%A8/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                python的format使用  作者：codehackfox@gmail.com 时间：2018-10-26 17:15:23  0x00、介绍  format优点
 1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型 2.单个参数可以多次输出，参数顺序可以不相同 3.填充方式十分灵活，对齐方式十分强大 4.官方推荐用的方式，%方式将会在后面的版本被淘汰
print('hello {0}'.format('world')) // hello world   format格式
#format的格式 replacement_field ::= &quot;{&quot; [field_name] [&quot;!&quot; conversion] [&quot;:&quot; format_spec] &quot;}&quot; field_name ::= arg_name (&quot;.&quot; attribute_name | &quot;[&quot; element_index &quot;]&quot;)* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= &lt;any source character except &quot;]&quot;&gt; + conversion ::= &quot;r&quot; | &quot;s&quot; | &quot;a&quot; format_spec ::= &lt;described in the next section&gt;  format_spec 的格式……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/10-26-python%E7%9A%84format%E4%BD%BF%E7%94%A8/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2018/12-02-python%E6%80%BB%E7%BB%93/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                python总结  作者：codehackfox@gmail.com 时间：2018-12-02 09:23:23   0x00、基本概念 0x01、基本类型   1.数字:numbers  int,double,float,bool,complex 1)可同时为多个变量赋值 2)一个变量可以通过赋值指向不同类型的对象 3)数值的除法(/)总时返回浮点数，要获得整数用(//)  2.字符串:string  1)可以用&rdquo;或&rdquo;&rdquo; 2)可以使用()转义 3)不想转义需要字符串前加r 4)可以使用(+)号连接，用(*)可以重复 5)可以使用()连接上下行，也可以用&rdquo;&lsquo;&hellip;&ldquo;&lsquo;或&rdquo;&ldquo;&rdquo;&hellip;&ldquo;&rdquo;&rdquo; 6)没有单独的字符，一个字符就是长度为1的字符串 7)可对字符串切片，用冒号切割，形式为：变量[头下标:尾下标]，从左向右以0开始，从右向左以-1开始 8)字符串不能改变  3.列表:list-&gt;[]  1)写在方括号内，并用逗号隔开 2)元素类型可以不同 3)可以被索引和切片 4)支持串联操作，用(+)操作符 5)列表元素可以改变 6)内置很多方法：如append(i),pop(i),len(),insert(i,x),remove(x),index(i),count(i),sort(),reverse(),copy()  4.元组:tuple-&gt;()  1)写在圆括号内，用逗号隔开 2)元素类型可以不同 3)可以被索引和切片 4)支持串联操作，用(+)操作符 5)元素不可改变  5.集合：set-&gt;{}  1)无序不重复元素集 2)基本功能是进行成员关系测试和消除重复元素 3)可以使用大括号或set()函数创建集合；但创建空集合必须用set()函数，因为{}是用来创建字典的  6.字典：Dictionary-&gt;{&rdquo;:&ldquo;,&hellip;}  1)一种映射类型，一个无序的键:值对的集合 2)dict()函数直接从键值对序列中构造，也可以进行推导 3)内置很多方法：如clear(),keys(),values()等 4)字典的关键字必须是不可变类型，且不能重复  list,string和tuple都属于sequence(序列)   0x02、注释   1.#号单行注释 2.&ldquo;&lsquo;或&rdquo;&ldquo;&ldquo;多行注释   0x03、格式   1.……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2018/12-02-python%E6%80%BB%E7%BB%93/">阅读全文</a></p>
                        </article>
                    
                        <article class="post">
                            <header>
                                <h1 class="post-title">
                                    <a href="https://xsoer.github.io/posts/2019/03-08-python%E8%A3%85%E9%A5%B0%E5%99%A8/" title="" ></a>
                                </h1>
                            </header>
                            <date class="post-meta meta-date">
                                1年1月1日
                            </date>
                            
                            <div class="post-content">
                                 python装饰器  作者：codehackfox@gmail.com 时间：2019-03-08 10:56:37   0x00、装饰器   在函数调用前后想添加功能，但又不希望修改原函数的定义，这种在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。 本质上，decorator就是一个返回函数的高阶函数。
def deco1(func): print(&quot;func before&quot;) start = datetime.datetime.now() ret = func() print(&quot;func after&quot;) end = datetime.datetime.now() return ret def func(): print(&quot;my name is func&quot;)  带了装饰器的函数会自动运行。
   0x01、复杂的装饰器  ……
                            </div>
                            <p class="readmore"><a href="https://xsoer.github.io/posts/2019/03-08-python%E8%A3%85%E9%A5%B0%E5%99%A8/">阅读全文</a></p>
                        </article>
                    
                    



<ol class="page-navigator">
    
    <li class="prev">
        <a href="https://xsoer.github.io/">上一页</a>
    </li>
    

    
    <li >
        <a href="https://xsoer.github.io/">1</a>
    </li>
    
    <li  class="current">
        <a href="https://xsoer.github.io/page/2/">2</a>
    </li>
    
    <li >
        <a href="https://xsoer.github.io/page/3/">3</a>
    </li>
    
    <li >
        <a href="https://xsoer.github.io/page/4/">4</a>
    </li>
    

    
    <li class="next">
        <a href="https://xsoer.github.io/page/3/">下一页</a>
    </li>
    
</ol>



                </div>
            </div>

            <div id="secondary">
    <section class="widget">
        <form id="search" action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" _lpchecked="1">
      
      <input type="text" name="q" maxlength="20" placeholder="Search">
      <input type="hidden" name="sitesearch" value="https://xsoer.github.io/">
      <button type="submit" class="submit icon-search"></button>
</form>
    </section>
    
    <section class="widget">
        <h3 class="widget-title">最近文章</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://xsoer.github.io/posts/2019/09-06-%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E5%B7%A5%E5%85%B7/" title="数据同步工具">数据同步工具</a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2019/02-10-python%E9%9D%A2%E8%AF%95/" title="python面试总结">python面试总结</a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2019/01-01-2019%E6%8A%80%E6%9C%AF%E5%8A%A8%E5%90%91/" title="2019技术动向">2019技术动向</a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/03-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/06-12-php%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/07-05-php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/10-01-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/10-12-mysql%E6%8A%80%E6%9C%AF/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2015/12-28-mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/" title=""></a>
    </li>
    
    <li>
        <a href="https://xsoer.github.io/posts/2016/03-10-mysql%E7%B4%A2%E5%BC%95/" title=""></a>
    </li>
    
</ul>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">分类</h3>
<ul class="widget-list">
    
    <li>
        <a href="https://xsoer.github.io/categories/development/">development(3)</a>
    </li>
    
</ul>
    </section>

    <section class="widget">
        <h3 class="widget-title">标签</h3>
<div class="tagcloud">
    
    <a href="https://xsoer.github.io/tags/%E6%96%B0%E6%8A%80%E6%9C%AF/">新技术</a>
    
    <a href="https://xsoer.github.io/tags/%E9%9D%A2%E8%AF%95/">面试</a>
    
</div>
    </section>

    

    <section class="widget">
        <h3 class="widget-title">其它</h3>
        <ul class="widget-list">
            <li><a href="https://xsoer.github.io/index.xml">文章 RSS</a></li>
        </ul>
    </section>
</div>
        </div>
    </div>
</div>
<footer id="footer">
    <div class="container">
        &copy; 2019 <a href="https://xsoer.github.io/">hackfox By </a>.
        Powered by <a rel="nofollow noreferer noopener" href="https://gohugo.io" target="_blank">Hugo</a>.
        <a href="https://www.flysnow.org/" target="_blank">Theme</a> based on <a href="https://github.com/rujews/maupassant-hugo" target="_blank">maupassant</a>.
        
    </div>
</footer>



<a id="rocket" href="#top"></a>
<script type="text/javascript" src="https://xsoer.github.io/js/totop.js?v=0.0.0" async=""></script>

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-114671402-1', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>







</body>
</html>
