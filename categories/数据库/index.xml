<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>数据库 on hackfox</title>
    <link>https://xsoer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
    <description>Recent content in 数据库 on hackfox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Sun, 01 Sep 2019 10:01:57 +0000</lastBuildDate>
    
	<atom:link href="https://xsoer.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>kudu简介</title>
      <link>https://xsoer.github.io/posts/2019/09-01-%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 01 Sep 2019 10:01:57 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2019/09-01-%E6%95%B0%E5%AD%A6%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80/</guid>
      <description> 0x00、整体简介  向量 矩阵 导数 数值计算 概率分布 参数估计 回归分析 判断问题  0x01、向量 0x02、矩阵 0x03、导数 0x04、数值计算 0x05、概率分布 0x06、参数估计 0x07、回归分析 0x08、判断问题 </description>
    </item>
    
    <item>
      <title>Impala操作手册</title>
      <link>https://xsoer.github.io/posts/2019/04-22-impala%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%96%87%E6%A1%A3/</link>
      <pubDate>Mon, 22 Apr 2019 20:08:24 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2019/04-22-impala%E7%B3%BB%E7%BB%9F%E6%80%A7%E6%96%87%E6%A1%A3/</guid>
      <description>[TOC]
 简介   支持的查询存储  关系型数据库 数据仓库 Kudu Hive Hbase HDFS  可以单独部署一个集群，读取远程数据源。 支持的操作  运行impala-shell进入交互模式  /usr/bin/impala-shell  ODBC、JDBC Hue web-based user interface.    数据表   分为外部表和内部表 内部表  通过impala创建的表都是内部表(internal) 修改表结构对应的底层表也会进行变动  外部表  不同过impala创建的表都是外部表(external) 要操作这些表，需要在impala建立表的映射关系 通过sql修改表结构或者删除表不会删除底层表，删除的只是表的映射关系    SQL语法   sql示例
-- This line is a comment about a table. create table ...; /* This is a multi-line comment about a query. */ select ...; select * from t /* This is an embedded comment about a query. */ where ...; select * from t -- This is a trailing comment within a multi-line command. where ...;  外部表映射
CREATE EXTERNAL TABLE my_mapping_table STORED AS KUDU TBLPROPERTIES ( &#39;kudu.table_name&#39; = &#39;my_kudu_table&#39; );  创建内部表
CREATE TABLE my_first_table ( id BIGINT, name STRING, PRIMARY KEY(id) ) PARTITION BY HASH PARTITIONS 16 STORED AS KUDU;  用select来建表</description>
    </item>
    
    <item>
      <title>数据库基础</title>
      <link>https://xsoer.github.io/posts/2019/03-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 10 Mar 2019 18:19:34 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2019/03-10-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9F%BA%E7%A1%80/</guid>
      <description>  1.数据库中的事务是什么?事务的隔离级别?脏读、幻读、不可重复读是什么意思？   数据库事务  将一组相关操作组合为一个要么全部成功要么全部失败的单元 具有ACID（原子性、一致性、隔离性和持久性）属性  原子性(Atomicity)：原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚 一致性(Consistent)：一致性是指事务必须使数据库从一个一致性状态变换到另一个一致性状态，也就是说一个事务执行之前和执行之后都必须于一致性状态 隔离性(Isolation)：隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所扰，多个并发事务之间要相互隔离。 持久性(Duration)：持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。   事物隔离级别  Serializable (串行化)：可避免脏读、不可重复读、幻读的发生。 Repeatable read (可重复读)：可避免脏读、不可重复读的发生。 Read committed (读已提交)：可避免脏读的发生。 Read uncommitted (读未提交)：最低级别，任何情况都无法保证。  脏读、幻读、不可重复读  脏读：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据 不可重复读：不可重复读是指在对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。 幻读：是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。  备注：  不可重复读和脏读的区别是，脏读是某一事务读取了另一个事务未提交的脏数据，而不可重复读则是读取了前一事务提交的数据。 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数） 当前事务的隔离级别：select @@tx_isolation;    2.优化数据库的方法。说说 SQL 优化之道   主机性能 内存使用性能 网络传输性能 SQL语句执行性能   3.唯一索引和普通索引的区别，索引类别（B+树索引、全文索引、哈希索引），索引的区别   为什么要用 B+tree 作为 MySql 索引的数据结构   聚集索引与非聚集索引的区别   Mysql存储引擎有哪些？有什么区别？存储引擎的 InnoDB 与 MyISAM区别、优缺点、使用场景？   varchar和char有什么区别   DDL、DML、DCL 分别指什么   explain 命令   数据库的几大范式   说说分库与分表设计，分库与分表带来的分布式困境与对应之策   什么是自适应哈希索引（AHI）   limit 20000 加载很慢怎么解决   常见的几种分布式 ID 的设计方案  </description>
    </item>
    
    <item>
      <title>python的format使用</title>
      <link>https://xsoer.github.io/posts/2018/10-26-python%E7%9A%84format%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Fri, 26 Oct 2018 17:15:23 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2018/10-26-python%E7%9A%84format%E4%BD%BF%E7%94%A8/</guid>
      <description>0x00、介绍  format优点
 1.不需要理会数据类型的问题，在%方法中%s只能替代字符串类型 2.单个参数可以多次输出，参数顺序可以不相同 3.填充方式十分灵活，对齐方式十分强大 4.官方推荐用的方式，%方式将会在后面的版本被淘汰
print(&#39;hello {0}&#39;.format(&#39;world&#39;)) // hello world   format格式
#format的格式 replacement_field ::= &amp;quot;{&amp;quot; [field_name] [&amp;quot;!&amp;quot; conversion] [&amp;quot;:&amp;quot; format_spec] &amp;quot;}&amp;quot; field_name ::= arg_name (&amp;quot;.&amp;quot; attribute_name | &amp;quot;[&amp;quot; element_index &amp;quot;]&amp;quot;)* arg_name ::= [identifier | integer] attribute_name ::= identifier element_index ::= integer | index_string index_string ::= &amp;lt;any source character except &amp;quot;]&amp;quot;&amp;gt; + conversion ::= &amp;quot;r&amp;quot; | &amp;quot;s&amp;quot; | &amp;quot;a&amp;quot; format_spec ::= &amp;lt;described in the next section&amp;gt;  format_spec 的格式
format_spec ::= [[fill]align][sign][#][0][width][,][.precision][type] fill ::= &amp;lt;any character&amp;gt; align ::= &amp;quot;&amp;lt;&amp;quot; | &amp;quot;&amp;gt;&amp;quot; | &amp;quot;=&amp;quot; | &amp;quot;^&amp;quot; sign ::= &amp;quot;+&amp;quot; | &amp;quot;-&amp;quot; | &amp;quot; &amp;quot; width ::= integer precision ::= integer type ::= &amp;quot;b&amp;quot; | &amp;quot;c&amp;quot; | &amp;quot;d&amp;quot; | &amp;quot;e&amp;quot; | &amp;quot;E&amp;quot; | &amp;quot;f&amp;quot; | &amp;quot;F&amp;quot; | &amp;quot;g&amp;quot; | &amp;quot;G&amp;quot; | &amp;quot;n&amp;quot; | &amp;quot;o&amp;quot; | &amp;quot;s&amp;quot; | &amp;quot;x&amp;quot; | &amp;quot;X&amp;quot; | &amp;quot;%&amp;quot;   0x01、应用 一、填充  1.</description>
    </item>
    
    <item>
      <title>数据建模</title>
      <link>https://xsoer.github.io/posts/2018/08-12-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</link>
      <pubDate>Sun, 12 Aug 2018 12:12:23 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2018/08-12-%E6%95%B0%E6%8D%AE%E5%BB%BA%E6%A8%A1/</guid>
      <description>0x00、数据模型   为什么要建模
 定义如何存储信息，如何操作信息，以及信息的完整性等约束功能 影响了数据的形态和使用方式 需要满足不同的业务场景需要 联机事务处理(OLTP):满足业务线需要，频繁的维护更新数据，强一致性 联机分析处理(OLAP):满足决策层需要，更多纬度的视角查询，满足统计决策   定义数据如何存储
 数据模型是定义数据如何输入和输出的一种模型。其主要作用是为信息系统提供数据的定义和格式。
 数据模型是数据库系统的核心和基础，现有的数据库系统都是基于某种数据模型而建立起来的。
 三要素
 数据结构：储存在数据库中对象类型的集合，作用是描述数据库组成对象以及对象之间的联系。 比如结构化存储、非结构化存储 关联关系型，KV型 数据操作：指对数据库中各种对象实例允许执行的操作的集合，包括操作及其相关的操作规则。 关系操作的select及其join、 group by、order by,insert,update, delete等 关系型数据库：oracle,SQLServer,DB2,Mysql。面向对象化 键值数据库：redis,mongodb,hbase等。存储非结构化，缓存等 时间序列数据库:InfluxDB，confluenceDB，Elasticsearch等。 存储日志类型，便于分析 流式数据库:MQ，Spark，Kafka。存储消息类型，不做永久性存储。发布-订阅型、消息队列、消息中间件 数据完整性约束条件：指在给定的数据模型中，数据及其联系所遵守的一组通用的完整性规则，它能保证数据的正确性和一致性。[1]    0x01、数据建模   建模过程中的主要活动包括：  确定数据及其相关过程（如实地销售人员需要查看在线产品目录并提交新客户订单）。 定义数据（如数据类型、大小和默认值）。 确保数据的完整性（使用业务规则和验证检查）。 定义操作过程（如安全检查和备份）。 选择数据存储技术（如关系、分层或索引存储技术）。  数据建模大致分为三个阶段，概念建模阶段，逻辑建模阶段和物理建模阶段。其中概念建模和逻辑建模阶段与数据库厂商毫无关系，换言之，与MySQL，SQL Server，Oracle没有关系。物理建模阶段和数据库厂商存在很大的联系，因为不同厂商对同一功能的支持方式不同，如高可用性，读写分离，甚至是索引，分区等。   0x02、数据存储历史   历史发展  无库时代 ：没有专门的数据库，数据大多以文件形式存放 层次状数据库 ：使用层次状模型进行数据库设计和存放 网状数据库 ：使用网状模型进行数据库设计和存放 关系型数据库 ：使用关系型模型进行数据库设计和存放 非关系型数据库：为适应水平扩展性和处理超大量的数据环境，近几年发展非常迅速的发展，衍生类型非常多。 数据集市 数据仓库    0x03、层次模型    一种用树形结构描述实体及其之间关系的数据模型。在这种结构中，每一个记录类型都是用节点表示，记录类型之间的联系则用结点之间的有向线段来表示。每一个双亲结点可以有多个子节点但是每一个子节点只能有一个双亲结点。这种结构决定了采用层次模型作为数系组织方式的层次数据库系统只能处理一对多的实体联系。 层次模型是最早用于商品数据库管理系统的数据模型。 层次数据模型中最基本的数据关系是基本层次关系，它代表两个记录型之间一对多的关系，也叫做双亲子女关系（PCR）。 举例   一个教师学生层次模型。该层次模型有4个记录类型，即实体。分别是： （1）记录型（实体）系是根结点，由系编号、系名、地点3个属性（字段）组成。它有两个子结点，分别是教研室实体和学生实体。 （2）记录型（实体）教研室是系的子结点，同时又是教师实体的双亲结点。它由教研室编号和教研室名两个属性（字段）组成。 （3）记录型（实体）学生由学号、姓名、成绩3个属性（字段）组成。 （4）记录型（实体）教师由教师号、姓名、研究方向3个属性（字段）组成。学生与教师是叶子结点，他们没有子结点。由系到教研室、教研室到教师、系到学生都是一对多的联系。  特征。在一个层次模型中的限制条件是：  （1）有且仅有一个节点，无父节点，它为树的根；（有且仅有一个结点没有双亲，该节点就是根结点。） （2）其他节点有且仅有一个父节点。（根以外的其他结点有且仅有一个双亲结点 ）这就使得层次数据库系统只能直接处理一对多的实体关系。 （3）任何一个给定的记录值只有按照其路径查看时，才能显出它的全部意义，没有一个子女记录值能够脱离双亲记录值而独立存在。 因而层次模型只能表示“1一M”关系，而不能直接表示“M—M”关系。在层次模型中，一个结点称为一个记录型，用来描述实体集。每个记录型可以有一个或多个记录值，上层一个记录值对应下层一个或多个记录值，而下层每个记录值只能对应上层一个记录值。例如，系记录型有：计算机系、电信系等记录值。而计算机系的下层记录值有软件、结构、应用等研究室和数据结构、操作系统、数据库等课程，软件研究室下层又有员工和项目记录值，如图所示:  关于层次模型中实体集之间多对多的联系的处理，解决的方法是引入冗余结点。例如，学生和课程之间的多对多的联系，引入学生和课程的冗余结点，转换为两棵树：一棵树的根是学生，子结点是课程，它表现了一个学生可以选多门课程；一棵树的根是课程，子结点是学生，它反映了一门课程可以被多个学生选。至于冗余结点可以用虚拟结点实现：在冗余结点处仅存放一个指针，指向实际结点。  数据完整性约束。层次模型的数据操纵主要有查询、插入、删除和更新。进行插入、删除、更新操作时要满足层次模型的完整性约束条件。具体如下：  （1）进行插入数据时，如果没有相应的双亲结点值就不能插入它的子结点值。例如，在上图层次数据库中，如果新调入一名教师，但尚未分配到某个教研室，这时就不能将新的教师插入到数据库中。 （2）进行删除数据时，如果删除双亲结点值，则相应的子结点值也被同时删除。例如，在上图中的层次数据库中，如果删除网络教研室，则该教研室的所有教师的数据将全部丢失。 （3）进行修改数据时，进行更新操作时，应更新所有相应记录，以保证数据的一致性。 [2]  优缺点  优点:  层次模型的数据结构比较简单，只需要几条命令就能操纵数据库，比较容易使用。 结构清晰，结点间联系简单，只要知道每个结点的双亲结点，就可以知道整个模型结构。现实世界中许多实体间联系本来就是呈现出一种很自然的层次关系，如表示行政层次，家族关系很关系  缺点:  （1）现实世界中很多联系是非层次性的，如多对多联系、一个结点具有多个双亲等。层次模型表示这类联系的方法很不灵活，不能直接表示两个以上的实体型间的的复杂的联系和实体型间的多对多联系。只能通过引入冗余数据或建非自然的数据组织如创建虚拟节点的方法来解决，易产生不一致性。 （2）对数据的插入和删除的操作限制太多。 （3）查询子女结点必须通过双亲结点，因为层次模型对任一结点的所有子树都规定了先后次序，这一限制隐含了对数据库存取路径的控制。树中父子结点之间只存在一种联系，因此，对树中的任一结点，只有一条自根结点到达它的路径。 （4）树结点中任何记录的属性只能是不可再分的简单数据类型。 （5）由于结构严密，层次命令趋于程序化。   层次模型的物理存储有两种实现方法：  顺序法：按照层次顺序把所有的记录邻接存放，即通过物理空间的位置相邻来实现层次顺序。 指针法：各个记录存放时不是按层次顺序，而是用指针按层次顺序把它们链接起来。  1969由IBM公司的IMS（Information Management System），这是IBM公司研制的最早的大型数据库系统程序产品   0x04、网状模型   定义  用有向图结构表示实体类型及实体间联系的数据结构模型称为网状模型（Network Model）。 网状模型取消了层次模型的不能表示非树状结构的限制，两个或两个以上的结点都可以有多个双亲结点，则此时有向树变成了有向图，该有向图描述了网状模型。  特征。网状模型的数据结构主要有以下两个特征:  (1)允许有一个以上的节点无双亲。 (2)至少有一个节点可以有多于一个的双亲。 网状模型中每个结点表示一个记录型（实体），每个记录型可包含若干个字段（实体的属性），结点间的连线表示记录类型（实体）间的父子关系。  示例   课程（实体）的父节点由专业、教研室、学生。以课程和学生之间的关系来说，他们是一种m:n的关系，也就是说一个学生能够选修多门课程，一门课程也可以被多个学生同时选修。  网状与层级数据库的区别  层次模型中子结点与双亲结点的联系是唯一的，在网状模型中这种联系可以不唯一。 层次模型可以看作网状模型的特例 因此，在网状模型中要为每个联系命名，并指出与该联系有关的双亲记录和子记录。  数据操作与完整性约束  网状模型的数据操作主要包括查询、插入、删除和更新。具体如下：  (1)进行插入操作时，允许插入尚未确定双亲结点值的子结点值。如可增加一名尚未分配到某个教研室的新老师，也可增加一些刚来报到还未分配宿舍的学生。 (2)进行删除操作时，只允许删除双亲结点值。如可删除一个教研室，而该科研室所有教师的信息仍保留在数据库中。 (3)修改数据时，可直接表示非树状结构，而无须像层次模型那样增加冗余结点，因此修改操作时只需要指定更新记录即可。  进行更新操作时只需更新指定记录即可。因此，一般来说，网状模型没有层次模型那样严格的完整性约束条件，但具体的网状数据库系统(如DBTG)对数据操作都加了一些限制，提供了一定的完整性约束。 [3] DBTG在模式DDL中提供了定义DBTG数据库完整性的若干概念和语句，主要有：  (1)支持记录码的概念，码是唯一标识记录的数据项的集合。 (2)保证一个联系中双亲记录和子记录之间是一对多的联系。 (3)可以支持双亲记录和子记录之间某些约束条件。如有些子记录要求双亲记录存在才能插入，双亲记录删除时也连同删除。   优缺点  优点  能够更为直接地描述现实客观世界。可表示实体间的多种复杂联系。 修改网状数据模型时，没有层次状数据模型的那么多的严格限制，可以删除一个节点的父节点而依旧保留该节点；也允许插入一个没有任何父节点的节点，这样的插入在层次状数据模型中是不被允许的，除非是首先插入的是根节点； 实体之间的关系在底层中可以借由指针指针实现。具有良好的性能，存取效率较高。  缺点  结构比较复杂，其数据定义语言(DDL)、数据操作语言(DML)复杂，用户不容易使用。而且应用环境越大，数据库的结构就变得越复杂，不利于最终用户掌握。 数据独立性差，由于实体间的联系本质上是通过存取路径表示的，因此应用程序在访问数据时要指定存取路径。 网状数据模型数据之间的彼此关联比较大，该模型其实一种导航式的数据模型结构，不仅要说明要对数据做些什么，还说明操作的记录的路径；     0x05、关系模型   网状数据库和层次数据库已经很好地解决了数据的集中和共享问题 但是在数据独立性和抽象级别上仍有很大欠缺。用户在对这两种数据库进行存取时，仍然需要明确数据的存储结构，指出存取路径。 1970年，IBM的研究员E.</description>
    </item>
    
    <item>
      <title>行与列式数据库</title>
      <link>https://xsoer.github.io/posts/2018/08-10-%E8%A1%8C%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <pubDate>Fri, 10 Aug 2018 13:23:49 +0000</pubDate>
      
      <guid>https://xsoer.github.io/posts/2018/08-10-%E8%A1%8C%E4%B8%8E%E5%88%97%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <description> 行与列式数据库  作者：codehackfox@gmail.com 时间：2018-08-10 13:23:49   0x00、简介  行式数据库  平常用的结构化关系型数据库，比如mysql、sqlserver等 一行为一条数据，进行记录存储 可以进行join查询，可以进行笛卡尔积运算  列式数据库  列式数据库是以列相关存储架构进行数据存储的数据库，主要适合于批量数据处理和即时查询。相对应的是行式数据库，数据以行相关的存储体系架构进行空间分配，主要适合于小批量的数据处理，常用于联机事务型数据处理。 特点  因为硬盘寻址时间相较于计算机上其他部件的运行速度来说不是一般的慢，所以常用相同工作负载下的硬盘访问性能来比较行数据库和列数据库。通常，顺序读取数据要比随机访问更快。而且，硬盘寻址时间的提升比起CPU速度的进步要慢得多 (参看 摩尔定律)，在使用硬盘作为存储媒介的系统上这种情况很可能还会持续一段时间。下面简单罗列了一些选择行数据库还是列数据库的权衡依据。当然，如果能够把数据全放在内存中，那么使用内存数据库性能会更好。  1.在只需要根据某几列来聚合数据的时候按列的数据组织方式更有效。因为这样只需要读取一部分数据，要比读取全部数据更快。 2.当只需要修改某一列值的时候按列的数据组织方式更有效。因为可以直接找到某列数据并修改，而与行中的其他列无关。 3.当需要某行的多列数据的时候按行的数据组织方式更有效。当行中数据不是太多的情况下一次硬盘寻址就可以获得该行的所有数据。 4.在新增行数据的时候，如果各列都有值，那么按行的数据组织方式会更有效，因为只需要一次硬盘寻址就可以写入整行的全部数据。    应用  面向行的数据存储架构更适用于OLTP-频繁交互事务的场景。 面向列的数据存储架构更适用于OLAP-(如数据仓库)这样在海量数据（(可能达到 terabyte规模)）中进行有限复杂查询的场景。   0x01、比较     底层存储实例      随机读与顺序读      0x02、优缺点  列数据库  优点：  极高的装载速度（最高可以等于所有硬盘IO 的总和，基本是极限了） 适合大量的数据而不是小数据 实时加载数据仅限于增加（删除和更新需要解压缩Block 然后计算然后重新压缩储存 高效的压缩率，不仅节省储存空间也节省计算内存和CPU。 非常适合做聚合操作。  缺点：  不适合扫描小量数据 不适合随机的更新 批量更新情况各异，有的优化的比较好的列式数据库（比如Vertica）表现比较好，有些没有针对更新的数据库表现比较差。 不适合做含有删除和更新的实时操作   行数据库  优点  适合频繁的增删改数据 小量数据的频繁维护和简单统计  缺点  不适合做统计类操作   </description>
    </item>
    
  </channel>
</rss>