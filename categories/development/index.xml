<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Development on hackfox</title>
    <link>http://xsoer.github.io/categories/development/</link>
    <description>Recent content in Development on hackfox</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Wed, 28 Feb 2018 18:30:10 +0000</lastBuildDate>
    
	<atom:link href="http://xsoer.github.io/categories/development/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Laravel的异常处理</title>
      <link>http://xsoer.github.io/post/180228-laravel%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</link>
      <pubDate>Wed, 28 Feb 2018 18:30:10 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180228-laravel%E7%9A%84%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</guid>
      <description>在进行项目操作时，
// class A文件 public function a() { try{ logger(111); (new \App\Business\B)-&amp;gt;b(); }catch(BusinessException $e) { logger(444) $this-&amp;gt;rollBackOrder(); throw new BusinessException($e-&amp;gt;getMessage().&#39;请联系管理员处理&#39;, 21000); } } public function rollBackOrder() { // some code } // class B文件 public function b() { try{ $i = 1; if ($i != 0) { logger(222) throw new KrException(&#39;错误了，回滚回滚&#39;, 500); } }catch (KrException $e) { logger(333) throw new KrException($e-&amp;gt;getMessage(), 500); } }  以上代码打印结果为:
111 222 333  可以看到最后A内的rollBackOrder方法未执行</description>
    </item>
    
    <item>
      <title>Laravel的拼接sql问题</title>
      <link>http://xsoer.github.io/post/180226-laravel%E7%9A%84%E6%8B%BC%E6%8E%A5sql%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 26 Feb 2018 17:46:28 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180226-laravel%E7%9A%84%E6%8B%BC%E6%8E%A5sql%E9%97%AE%E9%A2%98/</guid>
      <description>laravel的原始sql语句在输入数据查询时，需要注意传入的字符，否则很容易出问题。例如：
$query-&amp;gt;whereRaw(&amp;quot;(fund_name like %{$wd}% or fund_fullname like %{$wd}%)&amp;quot;);  在传入：siggi&amp;rsquo;s,或者siggi&amp;rdquo;s时，在sql执行时会报错。 需要修改为一下
$query-&amp;gt;where( function ($q) use ($wd) { $q-&amp;gt;where(&#39;fund_name&#39;, &#39;like&#39;, &amp;quot;%{$wd}%&amp;quot;); $q-&amp;gt;orWhere(&#39;fund_fullname&#39;, &#39;like&#39;, &amp;quot;%{$wd}%&amp;quot;); } );  利用larvel自带的ORM进行转义就没有问题。</description>
    </item>
    
    <item>
      <title>Atom原理</title>
      <link>http://xsoer.github.io/post/180224-atom%E5%8E%9F%E7%90%86/</link>
      <pubDate>Sat, 24 Feb 2018 16:42:41 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180224-atom%E5%8E%9F%E7%90%86/</guid>
      <description>atom基于electron来构建，可以跨平台、开源。 什么是electron呢？  a framework for building cross platform apps using web technologies   Electron  简介
  一个基于Node、chromium、V8集成的跨平台的用web技术开发桌面程序的工具。   如何集成的？
  分为一个主进程和渲染进程。 主进程。package.json里的main函数就是主进程， 运行在主进程中的脚本将以创建 web 页面的方式显示一个 GUI。 渲染进程。由于 Electron 使用 Chromium 来显示 web 页面，所以 Chromium 的多进程架构也是可用的。 每个 Electron 中的 web 页面运行在它的叫渲染进程的进程中。在通常的浏览器内，网页通常运行在一个沙盒的环境挡住并且不能够使用原生的资源。 然而 Electron 的用户在 Node.js 的 API 支持下可以在页面中和操作系统进行一些低级别的交互。 两者区别。  主进程使用 BrowserWindow 实例创建页面。 每个 BrowserWindow 实例都在自己的渲染进程里运行页面。 当一个 BrowserWindow 实例被销毁后，相应的渲染进程也会被终止。 主进程管理所有页面和与之对应的渲染进程。每个渲染进程都是相互独立的，并且只关心他们自己的页面。 由于在页面里管理原生 GUI 资源是非常危险而且容易造成资源泄露，所以在页面调用 GUI 相关的 APIs 是不被允许的。 如果你想在网页里使用 GUI 操作，其对应的渲染进程必须与主进程进行通讯，请求主进程进行相关的 GUI 操作。 在 Electron，我们提供几种方法用于主进程和渲染进程之间的通讯。 像 ipcRenderer 和 ipcMain 模块用于发送消息， remote 模块用于 RPC 方式通讯。 这些内容都可以在一个 FAQ 中查看 如何在两个页面之间共享数据。    如何涉及API？有哪些方面的API？使用了chromium的哪些技术?</description>
    </item>
    
    <item>
      <title>Vue项目升级打包工具</title>
      <link>http://xsoer.github.io/post/180224-vue%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 24 Feb 2018 16:27:30 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180224-vue%E9%A1%B9%E7%9B%AE%E5%8D%87%E7%BA%A7%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/</guid>
      <description> 原因
  由于早起的项目是一年前用vue-cli工具生成的，当时的打包工具是webpack1.0版本的，现在的项目越来越大，打包速度越来越慢；并且配套的校验、压缩等工具也已老旧，所以打算升级。   步骤
  1.用最新版的vue-cli脚手架工具来安装一个项目。 升级vue-cli工具  nmp update vue-cli -g   2.执行一下命令来生成最新的vue项目  vue init webpack my-project  3.把原项目内的src文件保留，其余的全部替换为新项目的文件。此处应该把老项目内引用的相关依赖加入新项目的package.json内，然后执行安装。
 注意
  1.新升级后的项目安装的eslint校验比较严格，此处可以先不安装eslint.当把所有的文件都升级到最新项目并且运行无误后，在单独安装eslint. 2.安装最新的eslint后，需要添加.eslintrc.js和.eslintignore两个文件，并且需要修改webpack.basic.conf.js文件来添加eslint功能。 3.添加后，在package.json内添加执行eslint的命令。执行一下命令来查看项目的校验情况。  npm run lint   4.如果有问题，可以执行一下命令来自动修复文件。  eslint --fix file-name   5.如果不能自动修复的，那就根据提示来做调整。如果不想要校验规则，可以在.eslintre.js内做修改。
 6.校验规则分为三级：
 off或0 表示关闭； warn或1 表示开启并使用警告级别（触发后程序不会退出 error或2 表示开启并使用错误级别（触发后程序会退出）。   </description>
    </item>
    
    <item>
      <title>CSRF TOKEN原理</title>
      <link>http://xsoer.github.io/post/180112-csrf-token%E5%8E%9F%E7%90%86/</link>
      <pubDate>Fri, 12 Jan 2018 19:28:21 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180112-csrf-token%E5%8E%9F%E7%90%86/</guid>
      <description>用处  在Kernel文件内引入的VerifyCsrfToken文件，如果不需要就注释掉 传统Form表单提交，在form表单内添加  &amp;lt;input name=&amp;quot;_token&amp;quot; type=&amp;quot;hidden&amp;quot; value=&amp;quot;{{ csrf_token() }}&amp;quot; /&amp;gt;   在Ajax，用 X-CSRF-TOKEN或者X-XSRF-TOKEN.在公共父页面添加  &amp;lt;meta name=&amp;quot;csrf-token&amp;quot; content=&amp;quot;{{csrf_token()}}&amp;quot; /&amp;gt; $.ajaxSetup({ headers: { &#39;X-CSRF-TOKEN&#39;: $(&#39;meta[name=&amp;quot;csrf-token&amp;quot;]&#39;).attr(&#39;content&#39;) } });   判断及添加token源码,在Illuminate\Foundation\Http\Middleware\VerifyCsrfToken文件内  public function handle($request, Closure $next) { if ( $this-&amp;gt;isReading($request) || $this-&amp;gt;runningUnitTests() || $this-&amp;gt;shouldPassThrough($request) || $this-&amp;gt;tokensMatch($request) ) { return $this-&amp;gt;addCookieToResponse($request, $next($request)); } throw new TokenMismatchException; } protected function tokensMatch($request) { $sessionToken = $request-&amp;gt;session()-&amp;gt;token(); $token = $request-&amp;gt;input(&#39;_token&#39;) ?: $request-&amp;gt;header(&#39;X-CSRF-TOKEN&#39;); if (!</description>
    </item>
    
    <item>
      <title>Laravel定时任务</title>
      <link>http://xsoer.github.io/post/180110-laravel%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</link>
      <pubDate>Wed, 10 Jan 2018 19:31:08 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/180110-laravel%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/</guid>
      <description>定时任务传入参数和选择值方法  param为必填 option为可选项·   &amp;lt;?php namespace App\Console\Commands; use Illuminate\Console\Command; class TestDemo extends Command { /** * 控制台命令名称 * * @var string */ protected $signature = &#39;test {param1} {--param2=}&#39;; /** * 控制台命令描述 * * @var string */ protected $description = &#39;test&#39;; /** * 创建新的命令实例 * * @param DripEmailer $drip * @return void */ public function __construct(DripEmailer $drip) { parent::__construct(); } /** * 执行控制台命令 * * @return mixed */ public function handle() { //参数调用方法 $param1 = $this-&amp;gt;argument(&#39;param1&#39;); $param2 = $this-&amp;gt;option(&#39;param2&#39;); $this-&amp;gt;info($param1); $this-&amp;gt;info($param2); } }   依赖的服务要注入  &amp;lt;?</description>
    </item>
    
    <item>
      <title>Docker基础</title>
      <link>http://xsoer.github.io/post/171224-docker%E5%9F%BA%E7%A1%80/</link>
      <pubDate>Sun, 24 Dec 2017 19:24:45 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/171224-docker%E5%9F%BA%E7%A1%80/</guid>
      <description>命令  Management Commands:
 config Manage Docker configs container Manage containers image Manage images network Manage networks node Manage Swarm nodes plugin Manage plugins secret Manage Docker secrets service Manage services stack Manage Docker stacks swarm Manage Swarm system Manage Docker volume Manage volumes  Commands:
 attach Attach local standard input, output, and error streams to a running container build Build an image from a Dockerfile commit Create a new image from a container&amp;rsquo;s changes cp Copy files/folders between a container and the local filesystem create Create a new container diff Inspect changes to files or directories on a container&amp;rsquo;s filesystem events Get real time events from the server exec Run a command in a running container export Export a container&amp;rsquo;s filesystem as a tar archive history Show the history of an image images List images import Import the contents from a tarball to create a filesystem image info Display system-wide information inspect Return low-level information on Docker objects kill Kill one or more running containers load Load an image from a tar archive or STDIN login Log in to a Docker registry logout Log out from a Docker registry logs Fetch the logs of a container pause Pause all processes within one or more containers port List port mappings or a specific mapping for the container ps List containers pull Pull an image or a repository from a registry push Push an image or a repository to a registry rename Rename a container restart Restart one or more containers rm Remove one or more containers rmi Remove one or more images run Run a command in a new container save Save one or more images to a tar archive (streamed to STDOUT by default) search Search the Docker Hub for images start Start one or more stopped containers stats Display a live stream of container(s) resource usage statistics stop Stop one or more running containers tag Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE top Display the running processes of a container unpause Unpause all processes within one or more containers update Update configuration of one or more containers version Show the Docker version information wait Block until one or more containers stop, then print their exit codes  docker images // 查看存在多少镜像</description>
    </item>
    
    <item>
      <title>ES6标准预览</title>
      <link>http://xsoer.github.io/post/171001-es6%E6%A0%87%E5%87%86%E6%A6%82%E8%A7%88/</link>
      <pubDate>Sun, 01 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/171001-es6%E6%A0%87%E5%87%86%E6%A6%82%E8%A7%88/</guid>
      <description>一、变量  新增两个关键字：let、const
  let与var的区别
 作用域不同() 变量是否可以提升不  contst：只读不可改，声明即赋值 其所声明的对象的属性是可以改变的。
  二、箭头函数 三、字符串  模版字符串(``) 新增几个方法  &#39;my string&#39;.startsWith(&#39;my&#39;); //true &#39;my string&#39;.endsWith(&#39;my&#39;); // false &#39;my string&#39;.includes(&#39;str&#39;); // true &#39;my &#39;.repeat(3); // &#39;my my my &#39;  四、数组  Array 对象增加了一些新的静态方法，Array 原型上也增加了一些新方法
  from 从类数组和可遍历对象中创建 Array 的实例 find 返回回调返回 true 的第一个元素。  [9, 2, 10, 8].find(n =&amp;gt; n === 10) // 10   findIndex 返回回调函数返回 true的第一个元素的下标。  [5, 1, 10, 8].</description>
    </item>
    
    <item>
      <title>开机自检</title>
      <link>http://xsoer.github.io/post/170928-%E5%BC%80%E6%9C%BA%E8%87%AA%E6%A3%80/</link>
      <pubDate>Thu, 28 Sep 2017 00:00:00 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/170928-%E5%BC%80%E6%9C%BA%E8%87%AA%E6%A3%80/</guid>
      <description> 关于开机自动检测硬盘的原因：
  第一种：是你非法关机造成的，比如直接断电的情况。
 第二种：是和硬盘的分区格式有关，FAT32格式在非法关机后会在开机时要求检测硬盘，而且必须检测完毕才不会在下次启动时重新检测。系统有一个文件中记录了检测是否结束的信息，有时即使检测完成了也会因为这个文件没有更新而在下次开机时重新检测。
 第三种：当硬盘出现坏道也会出现开机自动检测硬盘。
   关于取消开机自动检测硬盘的方法：
  方法一： 如果分区是FAT32格式，将其转换成NTFS，方法是在命令提示符下输入：convert X: /fs:ntfs
 方法二： 如果是非正常的关机，然后开机检测时又跳过了，每一次都会运行的。如果不是这个原因的话，您就要检查一下D盘状态是否正常，修正一下硬盘的错误。方法为 &amp;ldquo;开始&amp;rdquo;→&amp;rdquo;运行&amp;rdquo;，在窗口中输入&amp;rdquo;chkdskX:/f&amp;rdquo;(x为盘符)，这个命令可以检查文件系统中的逻辑错误，并进行修复；然后启动&amp;rdquo;磁盘碎片整理&amp;rdquo; 对相应的磁盘进行碎片整理，可以消除再次的磁盘扫描。如果还是不行，就可能是硬盘出现了坏道，最简单的方法是把D盘的数据备份一下，然后格式化D盘，就可 以正常使用了。
 方法三：打开&amp;rdquo;我的电脑&amp;rdquo;－右键点击X盘选择&amp;rdquo;属性&amp;rdquo;－选择&amp;rdquo;工具&amp;rdquo;－&amp;rdquo;查错&amp;rdquo;中点&amp;rdquo;开始检查&amp;rdquo;－选中&amp;rdquo;自动修复文件系统错误&amp;rdquo;和&amp;rdquo;扫描并试图恢复坏扇区&amp;rdquo;，然后点&amp;rdquo;开始&amp;rdquo;。
 方法四：我们知道系统之所以要对磁盘进行扫描是因为在注册表中设置了&amp;rdquo;脏&amp;rdquo;字节。在注册表中找到以下分支:
 方法五：如果是硬盘出现坏道，请使用磁盘修复工具进行修复，如使用HDDRegenerate等。
 方法六：一定是你在BIOS设置中选择了每次开机都要检测硬盘,所以才这样,和你的电脑配置是没有关系的。解决方法在开机后按DEL进入BIOS选 择Quick Power On Self Test（快速加电自检测），你的一定设为了Enabled了,选择Disabled，将其关闭就行了。
  </description>
    </item>
    
    <item>
      <title>Git常用命令</title>
      <link>http://xsoer.github.io/post/161224-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Sat, 24 Dec 2016 19:08:57 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/161224-git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</guid>
      <description>git init #git 初始化仓库 git clone remote_url #git 克隆远程库 git add * #git 添加所有文件 git commit -m &amp;quot;批注&amp;quot; #git 提交 git push &amp;lt;remoteName&amp;gt; &amp;lt;localName&amp;gt; #git推送至远程 git remote add origin &amp;lt;server&amp;gt; #远程没有创建仓库，将本地推送到远程仓库 git checkout -b branch_name #创建分支，并切换到分支 git checkout master #切换到主分支 git branch -d &amp;lt;branch_name&amp;gt; #删除分支 git pull &amp;lt;remoteName&amp;gt; &amp;lt;localName&amp;gt; #将本地仓库更新至最新 git merge branch_name #将其他分支合并到本地主分支 git diff &amp;lt;sourch_branch&amp;gt; &amp;lt;target_branch&amp;gt; #比对分支 git tag &amp;lt;tag_name&amp;gt; #创建标签 git show # git status #查看当前状态 git fetch #合并 git config --list #查看配置信息 git rm &amp;lt;file_name&amp;gt; #删除文件 git mv &amp;lt;old_name&amp;gt; &amp;lt;new_name&amp;gt; #重命名文件 git log #查看日志 git rebase HEAD &amp;lt;file_name&amp;gt; #重置 git remote -v #查看远程仓库 git remote rm &amp;lt;file_name&amp;gt; #删除远程仓库 git branch #查看本地分支 git branch -r #查看远程分支 git branch &amp;lt;branch_name&amp;gt; #创建本地分支 git config --global user.</description>
    </item>
    
    <item>
      <title>Mysql优化建议</title>
      <link>http://xsoer.github.io/post/161024-mysql%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</link>
      <pubDate>Mon, 24 Oct 2016 19:21:22 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/161024-mysql%E4%BC%98%E5%8C%96%E5%BB%BA%E8%AE%AE/</guid>
      <description> 1.为查询缓存优化你的查询(curdata(),rand(),no()无法进行优化)； 2.explain你的查询； 3.当只要一行数据时使用limit 1； 4.为搜索字段建立索引； 5.在join表的时候使用相当类型的列，并将其索引 6.千万不要order by rand(); 7.避免select *； 8.用于为每张表设置一个id，尽量为unsigned int类型； 9.使用enum而不是varchar; 10.从procedure analyse()取得建议； 11.尽可能的使用not null; 12.Prepared Statements; 13.把ip地址存成UNSIGNED INT 14.固定长度表会更快； 15.垂直分割； 16.拆分大的delete或insert语句； 17.越小的列会越快； 18.选择正确的存储引擎； 19.使用一个对象关系映射器（ORM）； 20.小心“永久链接”；  </description>
    </item>
    
    <item>
      <title>Centos7下转移mysql目录</title>
      <link>http://xsoer.github.io/post/161024-centos7%E4%B8%8B%E8%BD%AC%E7%A7%BBmysql%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 24 Oct 2016 19:03:05 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/161024-centos7%E4%B8%8B%E8%BD%AC%E7%A7%BBmysql%E7%9B%AE%E5%BD%95/</guid>
      <description> 1.停止mysql systemctl stop mysqld  2.假设转移的目标目录为/mnt下 cp -arp /var/lib/mysql /mnt  3.修改mysql配置文件 vim /etc/my.cnf #datadir=/var/lib/mysql #旧路径 datadir=/mnt/mysql	#新路径 #socket=/var/lib/mysql/mysql.sock #旧路径 socket=/data/mysql/mysql.sock #新路径  4.修改apache配置文件 vim /etc/php.ini [mysql] mysql.default_socket = /mnt/mysql/mysql.sock [mysqli] mysql.default_socket = /mnt/mysql/mysql.sock  5.创建连接 ln -s /mnt/mysql/mysql.sock /var/lib/mysql/mysql.sock  6.启动mysql,大功告成 systemctl start mysqld  </description>
    </item>
    
    <item>
      <title>Mysql常用操作</title>
      <link>http://xsoer.github.io/post/160724-mysql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 24 Jul 2016 19:12:57 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/160724-mysql%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</guid>
      <description>1.授权用户 mysql&amp;gt;GRANT ALL PRIVILEGES ON *.* TO &#39;zxc&#39;@&#39;%&#39; IDENTIFIED BY &#39;ydp#2015$Z!!!&#39; WITH GRANT OPTION; mysql&amp;gt;FLUSH PRIVILEGES;  2.远程连接 shell&amp;gt;mysql -h127.0.0.1 -P3306 -uroot -p  3.导出数据库 shell&amp;gt;mysqldump -h127.0.0.1 -P3306 -uroot -p sqsx &amp;gt; sqsx.sql  -4.导入数据库
shell&amp;gt;mysql -uroot -p sqsx &amp;lt; sqsx.sql  5.分析查询 shell&amp;gt; explain `select * from user`  6.查询所有的进程 mysql&amp;gt;show procelist;  7.建数据库语句 mysql&amp;gt;create database dbname default character set utf8 collate utf8_general_ci;  8.创建数据表语句 mysql&amp;gt;create table dbname.tablename () engine=Innodb charset=utf8;  9.</description>
    </item>
    
    <item>
      <title>运维技能</title>
      <link>http://xsoer.github.io/post/160224-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/</link>
      <pubDate>Wed, 24 Feb 2016 19:01:13 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/160224-%E8%BF%90%E7%BB%B4%E6%8A%80%E8%83%BD/</guid>
      <description>初级运维：  1.CPU、内存、磁盘、IO、文件系统 2.系统安装：设备选择、规划磁盘分区、定制化安装 3.基础知识：基本命令、文本编辑器、用户与组、权限管理 4.磁盘管理：磁盘分区和文件系统、磁盘阵列管理、逻辑卷管理 5.软件管理：软件安装、服务管理、进程管理  中级运维：  1.开源、GNU、GPL、POSIX、Linux内核、RAID、RAID等级、磁盘、磁盘原理、块、超级块、文件系统、i节点 2.shell  1.基础入门 1)shell的基本组成与参数 2)执行跟踪和调优排错 2.shell脚本 1)输入输出重定向 2)分割和管道 3)增强管道能力：find、grep等 4)shell变量和返回值 5)字符串操作 6)条件判断、循环 7)分支、函数、块输入 8)shell文件处理 3.正则表达式 1)基本概念 2)基本元字符 3)正则表达式总的分组 4.sed与awk 1)sed与awk的概念 2)sed工作模式 3)sed中的正则 4)awk中的模式与动作 5)awk的域和记录 6)awk中的正则 7)awk管道与重定向 8)awk格式化输出 9)awk变量与函数  3.LAMP  1.APACHE  1)APACHE安装与配置 2)profork与workert 3)apache模块  2.mysql  1)mysql安装与配置 2)SQL语句与管理工具 3)存储引擎与索引 4)单机运行多实例 5)mysql主从复制 6)mysql cluster  3.php  1)php安装与配置 2)phpize 3)session与cookie 4)php操作数据库  4.lamp整合  1)编译整合 2)FASTCGI  5.</description>
    </item>
    
    <item>
      <title>mysql主从同步</title>
      <link>http://xsoer.github.io/post/151110-mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 10 Nov 2015 13:08:25 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/151110-mysql%E4%B8%BB%E4%BB%8E%E5%90%8C%E6%AD%A5/</guid>
      <description>1.主库和从库创建同步账户  mysql&amp;gt; grant replication slave, replication client on *.* to repl@&#39;192.168.1.%&#39; identified by &#39;123456&#39;;   2.主库配置  /etc/my.cnf server-id=130 #保证唯一值 log-bin=mysql-bin binlog_format=mixed binlog-do-db=test2 binlog-ignore-db=mysql log-error=/var/lib/mysql/mysql.err   3.重启主库
 4.查看主库状态
  mysql&amp;gt;show master status; +-------------------------+-----------------+--------------------+-------------------------+ | File | Position | Binlog_Do_DB | Binlog_Ignore_DB | +-------------------------+----------------+--------------------+--------------------------+ | mysql-bin.000002 | 120 | test2 | mysql | +-------------------------+----------------+---------------------+------------------------+ 1 row in set (0.00 sec)   5.从库配置  /etc/my.cnf server-id=131 #保证唯一值 log-bin=mysql-bin binlog_format=mixed replicate-do-db=test2 replicate-ignore-db=mysql relay_log=/var/lib/mysql/mysql-relay-bin log_slave_updates=1 read_only=1   6.</description>
    </item>
    
    <item>
      <title>PHP字符串操作</title>
      <link>http://xsoer.github.io/post/150705-php%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Sun, 05 Jul 2015 08:32:19 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/150705-php%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C/</guid>
      <description> 1.print 有返回值、只能输出一个、可以用在表达式中
 echo 无返回值、能输出多个、不能用于表达式中  2.trim($strs) //去除两边的空格
 rtrim($strs) //去除右边的空格 ltrim($strs) //去除左边的空格  3.点链接字符串(.)
 4.strlen($strs) //求字符串长度
 5.explode(&amp;lsquo;,&amp;rsquo;,$strs) //分割字符串为数组
 6.implode(&amp;lsquo;,&amp;rsquo;,$arr) //分割数组为字符串
 7.strtoupper($strs),strtolower($strs) //转换字符串大小写
 8.!=、== //比较两个对象是否相等
 9.!== 、=== //比较两个对象及值是否相等
 10.strcmp($str1,$str2) //区分大小写比较字符串，前者大于后者返回大于零的数，小于返回小于零的数，相等则返回零
 11.strcasecmp($str1,$str2) //不区分大小写比较字符串
 12.strncmp($str1,$str2,n) //区分大小写比较前n个字符串
 13.strncasecmp($str1,$str2,n) //不区分大小写比较前n个字符串
 14.str_replace($oldstr,$newstr,$strs) //区分大小写替换字符串内的字符
 15.strstr($strs,$findstr) //字符串查找
 16.htmlspecialchars($str) //将字符串内特殊的字符转换为html内的字符
 17.md5($str) //md5加密
 18.strrev($str) //反转字符串
  </description>
    </item>
    
    <item>
      <title>PHP数组函数</title>
      <link>http://xsoer.github.io/post/150705-php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sun, 05 Jul 2015 01:53:37 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/150705-php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0/</guid>
      <description>1.array() [] //生成数组
 2.isset($arr[$i])//判断该值是否存在
 3.is_array($arr) //判断是否是数组
 4.array_push($arr,$a) //从尾部往数组内添加值
 5.array_unshift //从头部往数组内插入
 6.array_pop //弹出数组最后一个
 7.array_shift //弹出数组第一个
 8.range(0,6) //产生一个从0到6的数组
 9.in_array($a,$arr) //检验是否在数组内
 10.array_keys() //返回数组的所有键值
 11.array_change_key_case($arr1,CASE_UPPER) //改变键值为大写 或者CASE_LOWER 小写
 12.array_merge() //合并两个或多个数组
 13.sort($arr) //给数组排序，升序
 14.count() //查询数组内元素的个数
 15.array_filter($arr,$fun) //用一个函数过滤数组
 16.print_r() //输出数组
 17.foreach($arr as $k) //遍历数组
 18.while(list($key,$value)==each($arr)) //list遍历数组
 19.explode(&amp;lsquo;,&amp;rsquo;,$arr) //去除字符串中的逗号，转为数组
 20.implode(&amp;lsquo;,&amp;rsquo;,$arr) //将数组转为字符串
 21.ksort() //按键排序
 22.asort() //按值排序</description>
    </item>
    
    <item>
      <title>JS字符串转换为数字</title>
      <link>http://xsoer.github.io/post/150702-js%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/</link>
      <pubDate>Thu, 02 Jul 2015 04:05:40 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/150702-js%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%95%B0%E5%AD%97/</guid>
      <description>  字符串在做运算时，一定要转换为数字后在做运算，否则会出现各种奇葩现象。
 转换的函数：  1.js提供了parseInt()和parseFloat()两个转换函数。前者把值转换成整数，后者把值转换成浮点数。只有对String类型调用这些方法，这两个函数才能正确运行；对其他类型返回的都是NaN(Not a Number)。
 2.还可使用强制类型转换（type casting）处理转换值的类型。使用强制类型转换可以访问特定的值，即使它是另一种类型的。
 ECMAScript中可用的3种强制类型转换如下： Boolean(value)——把给定的值转换成Boolean型； Number(value)——把给定的值转换成数字（可以是整数或浮点数）； String(value)——把给定的值转换成字符串。 用这三个函数之一转换值，将创建一个新值，存放由原始值直接转换成的值。这会造成意想不到的后果。 当要转换的值是至少有一个字符的字符串、非0数字或对象时，Boolean()函数将返回true。如果该值是空字符串、数字0、undefined或null，它将返回false。  3.利用js变量弱类型转换。例：
  &amp;lt;script&amp;gt; var str= &#39;234.56 &#39;; var x = str-0; x = x*10; &amp;lt;/script&amp;gt;  </description>
    </item>
    
    <item>
      <title>JDBC对sqlserver的操作</title>
      <link>http://xsoer.github.io/post/140604-jdbc%E5%AF%B9sqlserver%E7%9A%84%E6%93%8D%E4%BD%9C/</link>
      <pubDate>Wed, 04 Jun 2014 09:41:26 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/140604-jdbc%E5%AF%B9sqlserver%E7%9A%84%E6%93%8D%E4%BD%9C/</guid>
      <description>过程：  1.注册驱动器类：Class.forName() 2.连接数据库：  String url = &amp;quot;jdbc:sqlserver://localhost:1433;DatabaseName=DataBaseName&amp;quot;; String uername = &amp;quot;dbuser&amp;quot;; String password = &amp;quot;secret&amp;quot;; Connection conn = DriverManager.getConnection(url,username,password);   3.执行sql语句：  Statement stat = conn.createStatement(); String command = &amp;quot;UPDATE BOOKS&amp;quot;; stat.executeUpdate(command);  java.sql.Statement()(三种执行方式)  第一种: execute();void 可执行任何sql语句 第二种：executeUpdate();int  可以执行：INSERT UPDATE DELETE CREATE TABLE;DROP TABLE 返回：受影响的行数  第三种：executeQuery(); ResultSet  执行：SELECT 返回：一个ResultSet对象，每次一行迭代例：   ResultSet rs = stat.executeQuery(&amp;quot;SELECT * FORM BOOKS&amp;quot;)； while(rs.next()){ look at a row of the result set } rs.</description>
    </item>
    
    <item>
      <title>基础数据结构</title>
      <link>http://xsoer.github.io/post/140224-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</link>
      <pubDate>Mon, 24 Feb 2014 19:34:10 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/140224-%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</guid>
      <description>数据结构往往同高效的检索算法和索引技术有关，是介于数学、计算机硬件和计算机软件三者之间的一门核心课程
基本结构：集合、线性结构、树形结构、图状结构  集合结构:除了同属于一种类型外，别无其它关系 线性结构:元素之间存在一对一关系常见类型有:数组,链表,队列,栈,它们之间在操作上有所区别。例如:链表可在任意位置插入或删除元素,而队列在队尾插入元素,队头删除元素,栈只能在栈顶进行插入,删除操作. 树形结构:元素之间存在一对多的关系,常见类型有:树(有许多特例:二叉树、平衡二叉树、查找树等) 图形结构:元素之间存在多对多的关系,图形结构中每个结点的前驱结点数和后续结点多个数可以任意  常用数据结构  数组（静态数组、动态数组） 线性表 链表（单向链表、双向链表、循环链表） 队栈 散列表 树（二叉树、查找树、平衡树、线索、堆） 图等的定义、存储和操作  数组  PHP的数组和其他语言不同之处是键可以为字符串，而且语言都是整型值 关于数组的问题及解法   - 数组的循环移动 - 最长递增子序列 - 和最大的子数组 - 寻找最大的前K个元素 - 数组分裂 - 乘积最大的子数组 - 最快速度求两个数组之交集算法 - 查找第二大数的算法 - 蛇形输出数组  线性表 -</description>
    </item>
    
    <item>
      <title>基础数据结构</title>
      <link>http://xsoer.github.io/post/php/laravel/cookie%E4%B8%8Esession/</link>
      <pubDate>Mon, 24 Feb 2014 19:34:10 +0000</pubDate>
      
      <guid>http://xsoer.github.io/post/php/laravel/cookie%E4%B8%8Esession/</guid>
      <description> Laravel 并没有使用 PHP 内置的 Session 功能，而且自己实现了一套更加灵活更加强大的 Session 机制，核心逻辑请参考 Illuminate\Session\Middleware\StartSession 这个中间件，因此在 Laravel 应用中不要试图通过 $_SESSION 方式去获取应用的 Session 值，这是徒劳的 在 Laravel 的控制器构造函数中是无法获取应用 Session 数据的，这是因为 Laravel 的 Session 通过 StartSession 中间件启动，既然是中间件就会在服务容器注册所有服务之后执行，而控制器们的构造函数都是在容器注册服务的时候执行的，所以这个时候 Session 尚未启动，又何来的获取数据呢？解决办法是将获取 Session 数据逻辑后置或者在构造函数中引入在 StartSession 之后执行的中间件。 记住我 的功能就是通过cookie来实现的  </description>
    </item>
    
  </channel>
</rss>